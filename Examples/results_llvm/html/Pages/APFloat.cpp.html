<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>APFloat.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Support/APFloat.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- APFloat.cpp - Implement APFloat class -----------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file implements a class to represent arbitrary precision floating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// point values and provide a variety of arithmetic operations on them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/ADT/APFloat.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/ADT/APSInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/FloatingPointMode.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/FoldingSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/Hashing.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/ADT/StringExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/ADT/StringRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/Config/llvm-config.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Support/Error.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include <cstring></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include <limits.h></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">  do {                                                                         \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">    if (usesLayout<IEEEFloat>(getSemantics()))                                 \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">      return U.IEEE.METHOD_CALL;                                               \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">      return U.Double.METHOD_CALL;                                             \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">    llvm_unreachable("Unexpected semantics");                                  \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">  } while (false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">/// A macro used to combine two fcCategory enums into one key which can be used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">/// in a switch statement to classify how the interaction of two APFloat's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">/// categories affects an operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">/// TODO: If clang source code is ever allowed to use constexpr in its own</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">/// codebase, change this into a static inline function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#define PackCategoriesIntoKey(_lhs, _rhs) ((_lhs) * 4 + (_rhs))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">/* Assumed in hexadecimal significand parsing, and conversion to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">   hexadecimal strings.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">static_assert(APFloatBase::integerPartWidth % 4 == 0, "Part width must be divisible by 4!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">// How the nonfinite values Inf and NaN are represented.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">enum class fltNonfiniteBehavior {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">  // Represents standard IEEE 754 behavior. A value is nonfinite if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">  // exponent field is all 1s. In such cases, a value is Inf if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">  // significand bits are all zero, and NaN otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">  IEEE754,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">  // This behavior is present in the Float8ExMyFN* types (Float8E4M3FN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">  // Float8E5M2FNUZ, Float8E4M3FNUZ, and Float8E4M3B11FNUZ). There is no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">  // representation for Inf, and operations that would ordinarily produce Inf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">  // produce NaN instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">  // The details of the NaN representation(s) in this form are determined by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">  // `fltNanEncoding` enum. We treat all NaNs as quiet, as the available</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">  // encodings do not distinguish between signalling and quiet NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">  NanOnly,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">// How NaN values are represented. This is curently only used in combination</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">// with fltNonfiniteBehavior::NanOnly, and using a variant other than IEEE</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">// while having IEEE non-finite behavior is liable to lead to unexpected</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">// results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">enum class fltNanEncoding {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">  // Represents the standard IEEE behavior where a value is NaN if its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  // exponent is all 1s and the significand is non-zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  IEEE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  // Represents the behavior in the Float8E4M3 floating point type where NaN is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">  // represented by having the exponent and mantissa set to all 1s.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  // This behavior matches the FP8 E4M3 type described in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  // https://arxiv.org/abs/2209.05433. We treat both signed and unsigned NaNs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  // as non-signalling, although the paper does not state whether the NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  // values are signalling or not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  AllOnes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  // Represents the behavior in Float8E{5,4}E{2,3}FNUZ floating point types</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">  // where NaN is represented by a sign bit of 1 and all 0s in the exponent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  // and mantissa (i.e. the negative zero encoding in a IEEE float). Since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  // there is only one NaN value, it is treated as quiet NaN. This matches the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">  // behavior described in https://arxiv.org/abs/2206.02915 .</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  NegativeZero,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">/* Represents floating point arithmetic semantics.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">struct fltSemantics {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  /* The largest E such that 2^E is representable; this matches the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">     definition of IEEE 754.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  APFloatBase::ExponentType maxExponent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  /* The smallest E such that 2^E is a normalized number; this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">     matches the definition of IEEE 754.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  APFloatBase::ExponentType minExponent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">  /* Number of bits in the significand.  This includes the integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">     bit.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  unsigned int precision;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  /* Number of bits actually used in the semantics. */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">  unsigned int sizeInBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">  fltNonfiniteBehavior nonFiniteBehavior = fltNonfiniteBehavior::IEEE754;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  fltNanEncoding nanEncoding = fltNanEncoding::IEEE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  // Returns true if any number described by this semantics can be precisely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  // represented by the specified semantics. Does not take into account</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  // the value of fltNonfiniteBehavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="uncoveredLine">  bool isRepresentableBy(const fltSemantics &S) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">    return maxExponent <= S.maxExponent && minExponent >= S.minExponent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">           precision <= S.precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">static constexpr fltSemantics semIEEEhalf = {15, -14, 11, 16};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">static constexpr fltSemantics semBFloat = {127, -126, 8, 16};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">static constexpr fltSemantics semIEEEsingle = {127, -126, 24, 32};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">static constexpr fltSemantics semIEEEdouble = {1023, -1022, 53, 64};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">static constexpr fltSemantics semIEEEquad = {16383, -16382, 113, 128};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">static constexpr fltSemantics semFloat8E5M2 = {15, -14, 3, 8};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">static constexpr fltSemantics semFloat8E5M2FNUZ = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">    15, -15, 3, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">static constexpr fltSemantics semFloat8E4M3FN = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">    8, -6, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::AllOnes};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">static constexpr fltSemantics semFloat8E4M3FNUZ = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">    7, -7, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">static constexpr fltSemantics semFloat8E4M3B11FNUZ = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">    4, -10, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">static constexpr fltSemantics semFloatTF32 = {127, -126, 11, 19};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">static constexpr fltSemantics semX87DoubleExtended = {16383, -16382, 64, 80};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">static constexpr fltSemantics semBogus = {0, 0, 0, 0};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">/* The IBM double-double semantics. Such a number consists of a pair of IEEE</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">   64-bit doubles (Hi, Lo), where |Hi| > |Lo|, and if normal,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">   (double)(Hi + Lo) == Hi. The numeric value it's modeling is Hi + Lo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">   Therefore it has two 53-bit mantissa parts that aren't necessarily adjacent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">   to each other, and two 11-bit exponents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">   Note: we need to make the value different from semBogus as otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">   an unsafe optimization may collapse both values to a single address,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">   and we heavily rely on them having distinct addresses.             */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">static constexpr fltSemantics semPPCDoubleDouble = {-1, 0, 0, 128};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">/* These are legacy semantics for the fallback, inaccrurate implementation of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">   IBM double-double, if the accurate semPPCDoubleDouble doesn't handle the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">   operation. It's equivalent to having an IEEE number with consecutive 106</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">   bits of mantissa and 11 bits of exponent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">   It's not equivalent to IBM double-double. For example, a legit IBM</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">   double-double, 1 + epsilon:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">     1 + epsilon = 1 + (1 >> 1076)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">   is not representable by a consecutive 106 bits of mantissa.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">   Currently, these semantics are used in the following way:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">     semPPCDoubleDouble -> (IEEEdouble, IEEEdouble) -></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">     (64-bit APInt, 64-bit APInt) -> (128-bit APInt) -></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">     semPPCDoubleDoubleLegacy -> IEEE operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">   We use bitcastToAPInt() to get the bit representation (in APInt) of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">   underlying IEEEdouble, then use the APInt constructor to construct the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">   legacy IEEE float.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">   TODO: Implement all operations in semPPCDoubleDouble, and delete these</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">   semantics.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">static constexpr fltSemantics semPPCDoubleDoubleLegacy = {1023, -1022 + 53,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">                                                          53 + 53, 128};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">const llvm::fltSemantics &APFloatBase::EnumToSemantics(Semantics S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="uncoveredLine">  switch (S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">  case S_IEEEhalf:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">    return IEEEhalf();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">  case S_BFloat:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">    return BFloat();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="uncoveredLine">  case S_IEEEsingle:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">    return IEEEsingle();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  case S_IEEEdouble:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">    return IEEEdouble();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">  case S_IEEEquad:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">    return IEEEquad();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">  case S_PPCDoubleDouble:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">    return PPCDoubleDouble();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">  case S_Float8E5M2:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">    return Float8E5M2();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">  case S_Float8E5M2FNUZ:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">    return Float8E5M2FNUZ();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">  case S_Float8E4M3FN:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">    return Float8E4M3FN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">  case S_Float8E4M3FNUZ:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">    return Float8E4M3FNUZ();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="uncoveredLine">  case S_Float8E4M3B11FNUZ:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">    return Float8E4M3B11FNUZ();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="uncoveredLine">  case S_FloatTF32:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">    return FloatTF32();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">  case S_x87DoubleExtended:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">    return x87DoubleExtended();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">  llvm_unreachable("Unrecognised floating semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">APFloatBase::Semantics</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="uncoveredLine">APFloatBase::SemanticsToEnum(const llvm::fltSemantics &Sem) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">  if (&Sem == &llvm::APFloat::IEEEhalf())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">    return S_IEEEhalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::BFloat())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="uncoveredLine">    return S_BFloat;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::IEEEsingle())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">    return S_IEEEsingle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::IEEEdouble())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">    return S_IEEEdouble;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::IEEEquad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">    return S_IEEEquad;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::PPCDoubleDouble())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">    return S_PPCDoubleDouble;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::Float8E5M2())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">    return S_Float8E5M2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::Float8E5M2FNUZ())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">    return S_Float8E5M2FNUZ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::Float8E4M3FN())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">    return S_Float8E4M3FN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::Float8E4M3FNUZ())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">    return S_Float8E4M3FNUZ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::Float8E4M3B11FNUZ())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">    return S_Float8E4M3B11FNUZ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::FloatTF32())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">    return S_FloatTF32;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  else if (&Sem == &llvm::APFloat::x87DoubleExtended())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">    return S_x87DoubleExtended;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">    llvm_unreachable("Unknown floating semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::IEEEhalf() { return semIEEEhalf; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::BFloat() { return semBFloat; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::IEEEsingle() { return semIEEEsingle; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="coveredLine">const fltSemantics &APFloatBase::IEEEdouble() { return semIEEEdouble; }</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::IEEEquad() { return semIEEEquad; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="coveredLine">const fltSemantics &APFloatBase::PPCDoubleDouble() {</td>
    <td>134</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="coveredLine">  return semPPCDoubleDouble;</td>
    <td>134</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::Float8E5M2() { return semFloat8E5M2; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::Float8E5M2FNUZ() { return semFloat8E5M2FNUZ; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::Float8E4M3FN() { return semFloat8E4M3FN; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::Float8E4M3FNUZ() { return semFloat8E4M3FNUZ; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::Float8E4M3B11FNUZ() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">  return semFloat8E4M3B11FNUZ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::FloatTF32() { return semFloatTF32; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::x87DoubleExtended() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">  return semX87DoubleExtended;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">const fltSemantics &APFloatBase::Bogus() { return semBogus; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">constexpr RoundingMode APFloatBase::rmNearestTiesToEven;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">constexpr RoundingMode APFloatBase::rmTowardPositive;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">constexpr RoundingMode APFloatBase::rmTowardNegative;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">constexpr RoundingMode APFloatBase::rmTowardZero;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">constexpr RoundingMode APFloatBase::rmNearestTiesToAway;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">/* A tight upper bound on number of parts required to hold the value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">   pow(5, power) is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">     power * 815 / (351 * integerPartWidth) + 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">   However, whilst the result may require only this many parts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">   because we are multiplying two values to get it, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">   multiplication may require an extra part with the excess part</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">   being zero (consider the trivial case of 1 * 1, tcFullMultiply</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">   requires two parts to hold the single-part result).  So we add an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">   extra one to guarantee enough space whilst multiplying.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">const unsigned int maxExponent = 16383;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">const unsigned int maxPrecision = 113;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">const unsigned int maxPowerOfFiveExponent = maxExponent + maxPrecision - 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">const unsigned int maxPowerOfFiveParts =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">    2 +</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">    ((maxPowerOfFiveExponent * 815) / (351 * APFloatBase::integerPartWidth));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">unsigned int APFloatBase::semanticsPrecision(const fltSemantics &semantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">  return semantics.precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">APFloatBase::ExponentType</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">APFloatBase::semanticsMaxExponent(const fltSemantics &semantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">  return semantics.maxExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">APFloatBase::ExponentType</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">APFloatBase::semanticsMinExponent(const fltSemantics &semantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">  return semantics.minExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">unsigned int APFloatBase::semanticsSizeInBits(const fltSemantics &semantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">  return semantics.sizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">unsigned int APFloatBase::semanticsIntSizeInBits(const fltSemantics &semantics,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">                                                 bool isSigned) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  // The max FP value is pow(2, MaxExponent) * (1 + MaxFraction), so we need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  // at least one more bit than the MaxExponent to hold the max FP value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">  unsigned int MinBitWidth = semanticsMaxExponent(semantics) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  // Extra sign bit needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">  if (isSigned)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">    ++MinBitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="uncoveredLine">  return MinBitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">bool APFloatBase::isRepresentableAsNormalIn(const fltSemantics &Src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">                                            const fltSemantics &Dst) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">  // Exponent range must be larger.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">  if (Src.maxExponent >= Dst.maxExponent || Src.minExponent <= Dst.minExponent)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  // If the mantissa is long enough, the result value could still be denormal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">  // with a larger exponent range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">  // FIXME: This condition is probably not accurate but also shouldn't be a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  // practical concern with existing types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="uncoveredLine">  return Dst.precision >= Src.precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">unsigned APFloatBase::getSizeInBits(const fltSemantics &Sem) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">  return Sem.sizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">static constexpr APFloatBase::ExponentType</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="coveredLine">exponentZero(const fltSemantics &semantics) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="coveredLine">  return semantics.minExponent - 1;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">static constexpr APFloatBase::ExponentType</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="coveredLine">exponentInf(const fltSemantics &semantics) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="coveredLine">  return semantics.maxExponent + 1;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">static constexpr APFloatBase::ExponentType</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="coveredLine">exponentNaN(const fltSemantics &semantics) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="coveredLine">  if (semantics.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">    if (semantics.nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">      return exponentZero(semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">    return semantics.maxExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="coveredLine">  return semantics.maxExponent + 1;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">/* A bunch of private, handy routines.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">static inline Error createError(const Twine &Err) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">  return make_error<StringError>(Err, inconvertibleErrorCode());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="coveredLine">static constexpr inline unsigned int partCountForBits(unsigned int bits) {</td>
    <td>469</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="coveredLine">  return ((bits) + APFloatBase::integerPartWidth - 1) / APFloatBase::integerPartWidth;</td>
    <td>469</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">/* Returns 0U-9U.  Return values >= 10U are not digits.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">static inline unsigned int</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">decDigitValue(unsigned int c)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">  return c - '0';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">/* Return the value of a decimal exponent of the form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">   [+-]ddddddd.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">   If the exponent overflows, returns a large exponent with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">   appropriate sign.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">static Expected<int> readExponent(StringRef::iterator begin,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">                                  StringRef::iterator end) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  bool isNegative;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">  unsigned int absExponent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">  const unsigned int overlargeExponent = 24000;  /* FIXME.  */</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">  StringRef::iterator p = begin;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  // Treat no exponent as 0 to match binutils</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">  if (p == end || ((*p == '-' || *p == '+') && (p + 1) == end)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">  isNegative = (*p == '-');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">  if (*p == '-' || *p == '+') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">    if (p == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">      return createError("Exponent has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">  absExponent = decDigitValue(*p++);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">  if (absExponent >= 10U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">    return createError("Invalid character in exponent");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">  for (; p != end; ++p) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">    unsigned int value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">    value = decDigitValue(*p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">    if (value >= 10U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">      return createError("Invalid character in exponent");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">    absExponent = absExponent * 10U + value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">    if (absExponent >= overlargeExponent) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">      absExponent = overlargeExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">  if (isNegative)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">    return -(int) absExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">    return (int) absExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">/* This is ugly and needs cleaning up, but I don't immediately see</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">   how whilst remaining safe.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">static Expected<int> totalExponent(StringRef::iterator p,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">                                   StringRef::iterator end,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">                                   int exponentAdjustment) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  int unsignedExponent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  bool negative, overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">  int exponent = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">  if (p == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">    return createError("Exponent has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">  negative = *p == '-';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">  if (*p == '-' || *p == '+') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">    if (p == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">      return createError("Exponent has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">  unsignedExponent = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">  overflow = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">  for (; p != end; ++p) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">    unsigned int value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">    value = decDigitValue(*p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">    if (value >= 10U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">      return createError("Invalid character in exponent");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="uncoveredLine">    unsignedExponent = unsignedExponent * 10 + value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">    if (unsignedExponent > 32767) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">      overflow = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">  if (exponentAdjustment > 32767 || exponentAdjustment < -32768)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">    overflow = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">  if (!overflow) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">    exponent = unsignedExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">    if (negative)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">      exponent = -exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">    exponent += exponentAdjustment;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">    if (exponent > 32767 || exponent < -32768)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">      overflow = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">  if (overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="uncoveredLine">    exponent = negative ? -32768: 32767;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">  return exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">static Expected<StringRef::iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">skipLeadingZeroesAndAnyDot(StringRef::iterator begin, StringRef::iterator end,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">                           StringRef::iterator *dot) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">  StringRef::iterator p = begin;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">  *dot = end;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="uncoveredLine">  while (p != end && *p == '0')</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">  if (p != end && *p == '.') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">    *dot = p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">    if (end - begin == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">      return createError("Significand has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">    while (p != end && *p == '0')</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">      p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="uncoveredLine">  return p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">/* Given a normal decimal floating point number of the form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">     dddd.dddd[eE][+-]ddd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">   where the decimal point and exponent are optional, fill out the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">   structure D.  Exponent is appropriate if the significand is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">   treated as an integer, and normalizedExponent if the significand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">   is taken to have the decimal point after a single leading</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">   non-zero digit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">   If the value is zero, V->firstSigDigit points to a non-digit, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">   the return exponent is zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">*/</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">struct decimalInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  const char *firstSigDigit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  const char *lastSigDigit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  int exponent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  int normalizedExponent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">static Error interpretDecimal(StringRef::iterator begin,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">                              StringRef::iterator end, decimalInfo *D) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">  StringRef::iterator dot = end;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">  if (!PtrOrErr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">    return PtrOrErr.takeError();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">  StringRef::iterator p = *PtrOrErr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">  D->firstSigDigit = p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="uncoveredLine">  D->exponent = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">  D->normalizedExponent = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">  for (; p != end; ++p) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">    if (*p == '.') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">      if (dot != end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">        return createError("String contains multiple dots");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">      dot = p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">      if (p == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">    if (decDigitValue(*p) >= 10U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">  if (p != end) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">    if (*p != 'e' && *p != 'E')</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">      return createError("Invalid character in significand");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">    if (p == begin)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="uncoveredLine">      return createError("Significand has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">    if (dot != end && p - begin == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">      return createError("Significand has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">    /* p points to the first non-digit in the string */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">    auto ExpOrErr = readExponent(p + 1, end);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">    if (!ExpOrErr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">      return ExpOrErr.takeError();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="uncoveredLine">    D->exponent = *ExpOrErr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">    /* Implied decimal point?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">    if (dot == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="uncoveredLine">      dot = p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">  /* If number is all zeroes accept any exponent.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="uncoveredLine">  if (p != D->firstSigDigit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">    /* Drop insignificant trailing zeroes.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">    if (p != begin) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">      do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">        do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">          p--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="uncoveredLine">        while (p != begin && *p == '0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">      while (p != begin && *p == '.');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">    /* Adjust the exponents for any decimal point.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="uncoveredLine">    D->exponent += static_cast<APFloat::ExponentType>((dot - p) - (dot > p));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">    D->normalizedExponent = (D->exponent +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">              static_cast<APFloat::ExponentType>((p - D->firstSigDigit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="uncoveredLine">                                      - (dot > D->firstSigDigit && dot < p)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">  D->lastSigDigit = p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  return Error::success();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">/* Return the trailing fraction of a hexadecimal number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">   DIGITVALUE is the first hex digit of the fraction, P points to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">   the next digit.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">static Expected<lostFraction></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">trailingHexadecimalFraction(StringRef::iterator p, StringRef::iterator end,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">                            unsigned int digitValue) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">  unsigned int hexDigit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">  /* If the first trailing digit isn't 0 or 8 we can work out the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">     fraction immediately.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">  if (digitValue > 8)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">    return lfMoreThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">  else if (digitValue < 8 && digitValue > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    return lfLessThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  // Otherwise we need to find the first non-zero digit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">  while (p != end && (*p == '0' || *p == '.'))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  if (p == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">    return createError("Invalid trailing hexadecimal fraction!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">  hexDigit = hexDigitValue(*p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  /* If we ran off the end it is exactly zero or one-half, otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">     a little more.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">  if (hexDigit == UINT_MAX)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    return digitValue == 0 ? lfExactlyZero: lfExactlyHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">    return digitValue == 0 ? lfLessThanHalf: lfMoreThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">/* Return the fraction lost were a bignum truncated losing the least</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">   significant BITS bits.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">static lostFraction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">lostFractionThroughTruncation(const APFloatBase::integerPart *parts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">                              unsigned int partCount,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">                              unsigned int bits)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">  unsigned int lsb;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">  lsb = APInt::tcLSB(parts, partCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  /* Note this is guaranteed true if bits == 0, or LSB == UINT_MAX.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">  if (bits <= lsb)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">    return lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  if (bits == lsb + 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">    return lfExactlyHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">  if (bits <= partCount * APFloatBase::integerPartWidth &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">      APInt::tcExtractBit(parts, bits - 1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">    return lfMoreThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">  return lfLessThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">/* Shift DST right BITS bits noting lost fraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">static lostFraction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">shiftRight(APFloatBase::integerPart *dst, unsigned int parts, unsigned int bits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">  lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">  lost_fraction = lostFractionThroughTruncation(dst, parts, bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  APInt::tcShiftRight(dst, parts, bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">  return lost_fraction;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">/* Combine the effect of two lost fractions.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">static lostFraction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">combineLostFractions(lostFraction moreSignificant,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">                     lostFraction lessSignificant)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">  if (lessSignificant != lfExactlyZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">    if (moreSignificant == lfExactlyZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">      moreSignificant = lfLessThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">    else if (moreSignificant == lfExactlyHalf)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">      moreSignificant = lfMoreThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">  return moreSignificant;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">/* The error from the true value, in half-ulps, on multiplying two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">   floating point numbers, which differ from the value they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">   approximate by at most HUE1 and HUE2 half-ulps, is strictly less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">   than the returned value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">   See "How to Read Floating Point Numbers Accurately" by William D</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">   Clinger.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">static unsigned int</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">HUerrBound(bool inexactMultiply, unsigned int HUerr1, unsigned int HUerr2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">  assert(HUerr1 < 2 || HUerr2 < 2 || (HUerr1 + HUerr2 < 8));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">  if (HUerr1 + HUerr2 == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">    return inexactMultiply * 2;  /* <= inexactMultiply half-ulps.  */</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">    return inexactMultiply + 2 * (HUerr1 + HUerr2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">/* The number of ulps from the boundary (zero, or half if ISNEAREST)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">   when the least significant BITS are truncated.  BITS cannot be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">   zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">static APFloatBase::integerPart</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">ulpsFromBoundary(const APFloatBase::integerPart *parts, unsigned int bits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">                 bool isNearest) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">  unsigned int count, partBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  APFloatBase::integerPart part, boundary;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">  assert(bits != 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">  bits--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">  count = bits / APFloatBase::integerPartWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">  partBits = bits % APFloatBase::integerPartWidth + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">  part = parts[count] & (~(APFloatBase::integerPart) 0 >> (APFloatBase::integerPartWidth - partBits));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">  if (isNearest)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">    boundary = (APFloatBase::integerPart) 1 << (partBits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    boundary = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">  if (count == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">    if (part - boundary <= boundary - part)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">      return part - boundary;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">      return boundary - part;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">  if (part == boundary) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">    while (--count)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">      if (parts[count])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">    return parts[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">  } else if (part == boundary - 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">    while (--count)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">      if (~parts[count])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">    return -parts[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">  return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">/* Place pow(5, power) in DST, and return the number of parts used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">   DST must be at least one part larger than size of the answer.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">static unsigned int</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">powerOf5(APFloatBase::integerPart *dst, unsigned int power) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  static const APFloatBase::integerPart firstEightPowers[] = { 1, 5, 25, 125, 625, 3125, 15625, 78125 };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">  APFloatBase::integerPart pow5s[maxPowerOfFiveParts * 2 + 5];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">  pow5s[0] = 78125 * 5;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">  unsigned int partsCount[16] = { 1 };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">  APFloatBase::integerPart scratch[maxPowerOfFiveParts], *p1, *p2, *pow5;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">  unsigned int result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">  assert(power <= maxExponent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">  p1 = dst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">  p2 = scratch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">  *p1 = firstEightPowers[power & 7];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">  power >>= 3;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">  result = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">  pow5 = pow5s;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">  for (unsigned int n = 0; power; power >>= 1, n++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">    unsigned int pc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">    pc = partsCount[n];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">    /* Calculate pow(5,pow(2,n+3)) if we haven't yet.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">    if (pc == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">      pc = partsCount[n - 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">      APInt::tcFullMultiply(pow5, pow5 - pc, pow5 - pc, pc, pc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">      pc *= 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">      if (pow5[pc - 1] == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">        pc--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">      partsCount[n] = pc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">    if (power & 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">      APFloatBase::integerPart *tmp;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">      APInt::tcFullMultiply(p2, p1, pow5, result, pc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">      result += pc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">      if (p2[result - 1] == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">        result--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">      /* Now result is in p1 with partsCount parts and p2 is scratch</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">         space.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">      tmp = p1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">      p1 = p2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">      p2 = tmp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">    pow5 += pc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">  if (p1 != dst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">    APInt::tcAssign(dst, p1, result);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">  return result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">/* Zero at the end to avoid modular arithmetic when adding one; used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">   when rounding up during hexadecimal output.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">static const char hexDigitsLower[] = "0123456789abcdef0";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">static const char hexDigitsUpper[] = "0123456789ABCDEF0";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">static const char infinityL[] = "infinity";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">static const char infinityU[] = "INFINITY";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">static const char NaNL[] = "nan";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">static const char NaNU[] = "NAN";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">/* Write out an integerPart in hexadecimal, starting with the most</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">   significant nibble.  Write out exactly COUNT hexdigits, return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">   COUNT.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">static unsigned int</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">partAsHex (char *dst, APFloatBase::integerPart part, unsigned int count,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">           const char *hexDigitChars)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">  unsigned int result = count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">  assert(count != 0 && count <= APFloatBase::integerPartWidth / 4);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">  part >>= (APFloatBase::integerPartWidth - 4 * count);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">  while (count--) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">    dst[count] = hexDigitChars[part & 0xf];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">    part >>= 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">  return result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">/* Write out an unsigned decimal integer.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">static char *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">writeUnsignedDecimal (char *dst, unsigned int n)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  char buff[40], *p;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">  p = buff;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">  do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">    *p++ = '0' + n % 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">  while (n /= 10);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">    *dst++ = *--p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">  while (p != buff);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">  return dst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">/* Write out a signed decimal integer.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">static char *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">writeSignedDecimal (char *dst, int value)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">  if (value < 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">    *dst++ = '-';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">    dst = writeUnsignedDecimal(dst, -(unsigned) value);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">    dst = writeUnsignedDecimal(dst, value);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">  return dst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">/* Constructors.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="coveredLine">void IEEEFloat::initialize(const fltSemantics *ourSemantics) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">  unsigned int count;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="coveredLine">  semantics = ourSemantics;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="coveredLine">  count = partCount();</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="coveredLine">  if (count > 1)</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">    significand.parts = new integerPart[count];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="coveredLine">}</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="coveredLine">void IEEEFloat::freeSignificand() {</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="coveredLine">  if (needsCleanup())</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">    delete [] significand.parts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="coveredLine">}</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">void IEEEFloat::assign(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">  assert(semantics == rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">  sign = rhs.sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">  category = rhs.category;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">  exponent = rhs.exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">  if (isFiniteNonZero() || category == fcNaN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">    copySignificand(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">void IEEEFloat::copySignificand(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">  assert(isFiniteNonZero() || category == fcNaN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">  assert(rhs.partCount() >= partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">  APInt::tcAssign(significandParts(), rhs.significandParts(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">                  partCount());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">/* Make this number a NaN, with an arbitrary but deterministic value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">   for the significand.  If double or longer, this is a signalling NaN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">   which may not be ideal.  If float, this is QNaN(0).  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="uncoveredLine">void IEEEFloat::makeNaN(bool SNaN, bool Negative, const APInt *fill) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">  category = fcNaN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">  sign = Negative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">  exponent = exponentNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">  integerPart *significand = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">  unsigned numParts = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">  APInt fill_storage;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">    // Finite-only types do not distinguish signalling and quiet NaN, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">    // make them all signalling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">    SNaN = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">      sign = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">      fill_storage = APInt::getZero(semantics->precision - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">      fill_storage = APInt::getAllOnes(semantics->precision - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">    fill = &fill_storage;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">  // Set the significand bits to the fill.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">  if (!fill || fill->getNumWords() < numParts)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="uncoveredLine">    APInt::tcSet(significand, 0, numParts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="uncoveredLine">  if (fill) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">    APInt::tcAssign(significand, fill->getRawData(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">                    std::min(fill->getNumWords(), numParts));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">    // Zero out the excess bits of the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">    unsigned bitsToPreserve = semantics->precision - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">    unsigned part = bitsToPreserve / 64;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">    bitsToPreserve %= 64;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">    significand[part] &= ((1ULL << bitsToPreserve) - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">    for (part++; part != numParts; ++part)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">      significand[part] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">  unsigned QNaNBit = semantics->precision - 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">  if (SNaN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">    // We always have to clear the QNaN bit to make it an SNaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">    APInt::tcClearBit(significand, QNaNBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">    // If there are no bits set in the payload, we have to set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">    // *something* to make it a NaN instead of an infinity;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">    // conventionally, this is the next bit down from the QNaN bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">    if (APInt::tcIsZero(significand, numParts))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="uncoveredLine">      APInt::tcSetBit(significand, QNaNBit - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">  } else if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">    // The only NaN is a quiet NaN, and it has no bits sets in the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">    // Do nothing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">    // We always have to set the QNaN bit to make it a QNaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">    APInt::tcSetBit(significand, QNaNBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">  // For x87 extended precision, we want to make a NaN, not a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">  // pseudo-NaN.  Maybe we should expose the ability to make</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  // pseudo-NaNs?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">  if (semantics == &semX87DoubleExtended)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">    APInt::tcSetBit(significand, QNaNBit + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">IEEEFloat &IEEEFloat::operator=(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">  if (this != &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">    if (semantics != rhs.semantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">      freeSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">      initialize(rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">    assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="coveredLine">IEEEFloat &IEEEFloat::operator=(IEEEFloat &&rhs) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="coveredLine">  freeSignificand();</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="coveredLine">  semantics = rhs.semantics;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="coveredLine">  significand = rhs.significand;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="coveredLine">  exponent = rhs.exponent;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="coveredLine">  category = rhs.category;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="coveredLine">  sign = rhs.sign;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="coveredLine">  rhs.semantics = &semBogus;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="coveredLine">  return *this;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">bool IEEEFloat::isDenormal() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">  return isFiniteNonZero() && (exponent == semantics->minExponent) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">         (APInt::tcExtractBit(significandParts(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">                              semantics->precision - 1) == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">bool IEEEFloat::isSmallest() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  // The smallest number by magnitude in our format will be the smallest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">  // denormal, i.e. the floating point number with exponent being minimum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  // exponent and significand bitwise equal to 1 (i.e. with MSB equal to 0).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">  return isFiniteNonZero() && exponent == semantics->minExponent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="uncoveredLine">    significandMSB() == 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="uncoveredLine">bool IEEEFloat::isSmallestNormalized() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">  return getCategory() == fcNormal && exponent == semantics->minExponent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">         isSignificandAllZerosExceptMSB();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">bool IEEEFloat::isSignificandAllOnes() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">  // Test if the significand excluding the integral bit is all ones. This allows</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  // us to test for binade boundaries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">  const integerPart *Parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">    if (~Parts[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">  // Set the unused high bits to all ones when we compare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="uncoveredLine">  const unsigned NumHighBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">  const integerPart HighBitFill =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">    ~integerPart(0) << (integerPartWidth - NumHighBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">  if (~(Parts[PartCount - 1] | HighBitFill))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">bool IEEEFloat::isSignificandAllOnesExceptLSB() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  // Test if the significand excluding the integral bit is all ones except for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  // the least significant bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">  const integerPart *Parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">  if (Parts[0] & 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">    if (~Parts[i] & ~unsigned{!i})</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">  // Set the unused high bits to all ones when we compare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">  const unsigned NumHighBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">  const integerPart HighBitFill = ~integerPart(0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">                                  << (integerPartWidth - NumHighBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">  if (~(Parts[PartCount - 1] | HighBitFill | 0x1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">bool IEEEFloat::isSignificandAllZeros() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  // Test if the significand excluding the integral bit is all zeros. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  // allows us to test for binade boundaries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">  const integerPart *Parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">    if (Parts[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  // Compute how many bits are used in the final word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">  const unsigned NumHighBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">  assert(NumHighBits < integerPartWidth && "Can not have more high bits to "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">         "clear than integerPartWidth");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">  const integerPart HighBitMask = ~integerPart(0) >> NumHighBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">  if (Parts[PartCount - 1] & HighBitMask)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">bool IEEEFloat::isSignificandAllZerosExceptMSB() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">  const integerPart *Parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">    if (Parts[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">  const unsigned NumHighBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">  return Parts[PartCount - 1] == integerPart(1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">                                     << (integerPartWidth - NumHighBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">bool IEEEFloat::isLargest() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">      semantics->nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">    // The largest number by magnitude in our format will be the floating point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">    // number with maximum exponent and with significand that is all ones except</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">    // the LSB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">           isSignificandAllOnesExceptLSB();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">    // The largest number by magnitude in our format will be the floating point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">    // number with maximum exponent and with significand that is all ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">           isSignificandAllOnes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">bool IEEEFloat::isInteger() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">  // This could be made more efficient; I'm going for obviously correct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">  if (!isFinite()) return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">  IEEEFloat truncated = *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">  truncated.roundToIntegral(rmTowardZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">  return compare(truncated) == cmpEqual;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">bool IEEEFloat::bitwiseIsEqual(const IEEEFloat &rhs) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">  if (this == &rhs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">  if (semantics != rhs.semantics ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">      category != rhs.category ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">      sign != rhs.sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">  if (category==fcZero || category==fcInfinity)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">  if (isFiniteNonZero() && exponent != rhs.exponent)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">  return std::equal(significandParts(), significandParts() + partCount(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">                    rhs.significandParts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, integerPart value) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">  initialize(&ourSemantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">  sign = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">  zeroSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">  exponent = ourSemantics.precision - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">  significandParts()[0] = value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">  normalize(rmNearestTiesToEven, lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">  initialize(&ourSemantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">  makeZero(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">// Delegate to the previous constructor, because later copy constructor may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">// actually inspects category, which can't be garbage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, uninitializedTag tag)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">    : IEEEFloat(ourSemantics) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">IEEEFloat::IEEEFloat(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">  initialize(rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">  assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="coveredLine">IEEEFloat::IEEEFloat(IEEEFloat &&rhs) : semantics(&semBogus) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="coveredLine">  *this = std::move(rhs);</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="coveredLine">}</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="coveredLine">IEEEFloat::~IEEEFloat() { freeSignificand(); }</td>
    <td>134</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="coveredLine">unsigned int IEEEFloat::partCount() const {</td>
    <td>469</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="coveredLine">  return partCountForBits(semantics->precision + 1);</td>
    <td>469</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">const IEEEFloat::integerPart *IEEEFloat::significandParts() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">  return const_cast<IEEEFloat *>(this)->significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="coveredLine">IEEEFloat::integerPart *IEEEFloat::significandParts() {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="coveredLine">  if (partCount() > 1)</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">    return significand.parts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="coveredLine">    return &significand.part;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">void IEEEFloat::zeroSignificand() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">/* Increment an fcNormal floating point number's significand.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">void IEEEFloat::incrementSignificand() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">  integerPart carry;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">  carry = APInt::tcIncrement(significandParts(), partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">  /* Our callers should never cause us to overflow.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">  assert(carry == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">  (void)carry;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">/* Add the significand of the RHS.  Returns the carry flag.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">IEEEFloat::integerPart IEEEFloat::addSignificand(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">  integerPart *parts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">  parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">  assert(semantics == rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">  assert(exponent == rhs.exponent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="uncoveredLine">  return APInt::tcAdd(parts, rhs.significandParts(), 0, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">/* Subtract the significand of the RHS with a borrow flag.  Returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">   the borrow flag.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">IEEEFloat::integerPart IEEEFloat::subtractSignificand(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">                                                      integerPart borrow) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">  integerPart *parts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">  parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">  assert(semantics == rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">  assert(exponent == rhs.exponent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">  return APInt::tcSubtract(parts, rhs.significandParts(), borrow,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">                           partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">/* Multiply the significand of the RHS.  If ADDEND is non-NULL, add it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">   on to the full-precision result of the multiplication.  Returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">   lost fraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">                                            IEEEFloat addend) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  unsigned int omsb;        // One, not zero, based MSB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">  unsigned int partsCount, newPartsCount, precision;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">  integerPart *lhsSignificand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  integerPart scratch[4];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  integerPart *fullSignificand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">  lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">  bool ignored;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">  assert(semantics == rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">  precision = semantics->precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  // Allocate space for twice as many bits as the original significand, plus one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  // extra bit for the addition to overflow into.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">  newPartsCount = partCountForBits(precision * 2 + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">  if (newPartsCount > 4)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">    fullSignificand = new integerPart[newPartsCount];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">    fullSignificand = scratch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">  lhsSignificand = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="uncoveredLine">  partsCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">  APInt::tcFullMultiply(fullSignificand, lhsSignificand,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">                        rhs.significandParts(), partsCount, partsCount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">  lost_fraction = lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">  omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">  exponent += rhs.exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">  // Assume the operands involved in the multiplication are single-precision</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">  // FP, and the two multiplicants are:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  //   *this = a23 . a22 ... a0 * 2^e1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  //     rhs = b23 . b22 ... b0 * 2^e2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">  // the result of multiplication is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">  //   *this = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">  // Note that there are three significant bits at the left-hand side of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  // radix point: two for the multiplication, and an overflow bit for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  // addition (that will always be zero at this point). Move the radix point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  // toward left by two bits, and adjust exponent accordingly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">  exponent += 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">  if (addend.isNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">    // The intermediate result of the multiplication has "2 * precision"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">    // signicant bit; adjust the addend to be consistent with mul result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">    Significand savedSignificand = significand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">    const fltSemantics *savedSemantics = semantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">    fltSemantics extendedSemantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">    opStatus status;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">    unsigned int extendedPrecision;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">    // Normalize our MSB to one below the top bit to allow for overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">    extendedPrecision = 2 * precision + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="uncoveredLine">    if (omsb != extendedPrecision - 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">      assert(extendedPrecision > omsb);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">      APInt::tcShiftLeft(fullSignificand, newPartsCount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">                         (extendedPrecision - 1) - omsb);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">      exponent -= (extendedPrecision - 1) - omsb;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">    /* Create new semantics.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="uncoveredLine">    extendedSemantics = *semantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">    extendedSemantics.precision = extendedPrecision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">    if (newPartsCount == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="uncoveredLine">      significand.part = fullSignificand[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">      significand.parts = fullSignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">    semantics = &extendedSemantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">    // Make a copy so we can convert it to the extended semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">    // Note that we cannot convert the addend directly, as the extendedSemantics</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">    // is a local variable (which we take a reference to).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">    IEEEFloat extendedAddend(addend);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">    status = extendedAddend.convert(extendedSemantics, rmTowardZero, &ignored);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">    assert(status == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">    (void)status;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">    // Shift the significand of the addend right by one bit. This guarantees</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">    // that the high bit of the significand is zero (same as fullSignificand),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">    // so the addition will overflow (if it does overflow at all) into the top bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="uncoveredLine">    lost_fraction = extendedAddend.shiftSignificandRight(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">    assert(lost_fraction == lfExactlyZero &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">           "Lost precision while shifting addend for fused-multiply-add.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">    lost_fraction = addOrSubtractSignificand(extendedAddend, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">    /* Restore our state.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">    if (newPartsCount == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">      fullSignificand[0] = significand.part;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="uncoveredLine">    significand = savedSignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="uncoveredLine">    semantics = savedSemantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">    omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">  // Convert the result having "2 * precision" significant-bits back to the one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  // having "precision" significant-bits. First, move the radix point from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">  // poision "2*precision - 1" to "precision - 1". The exponent need to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">  // adjusted by "2*precision - 1" - "precision - 1" = "precision".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="uncoveredLine">  exponent -= precision + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  // In case MSB resides at the left-hand side of radix point, shift the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">  // mantissa right by some amount to make sure the MSB reside right before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  // the radix point (i.e. "MSB . rest-significant-bits").</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">  // Note that the result is not normalized when "omsb < precision". So, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">  // caller needs to call IEEEFloat::normalize() if normalized value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">  // expected.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="uncoveredLine">  if (omsb > precision) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">    unsigned int bits, significantParts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">    lostFraction lf;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">    bits = omsb - precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">    significantParts = partCountForBits(omsb);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">    lf = shiftRight(fullSignificand, significantParts, bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="uncoveredLine">    lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="uncoveredLine">    exponent += bits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">  APInt::tcAssign(lhsSignificand, fullSignificand, partsCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">  if (newPartsCount > 4)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">    delete [] fullSignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">  return lost_fraction;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">  return multiplySignificand(rhs, IEEEFloat(*semantics));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">/* Multiply the significands of LHS and RHS to DST.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">lostFraction IEEEFloat::divideSignificand(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">  unsigned int bit, i, partsCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">  const integerPart *rhsSignificand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">  integerPart *lhsSignificand, *dividend, *divisor;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">  integerPart scratch[4];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">  lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">  assert(semantics == rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">  lhsSignificand = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">  rhsSignificand = rhs.significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">  partsCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">  if (partsCount > 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="uncoveredLine">    dividend = new integerPart[partsCount * 2];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">    dividend = scratch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">  divisor = dividend + partsCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">  /* Copy the dividend and divisor as they will be modified in-place.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">  for (i = 0; i < partsCount; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">    dividend[i] = lhsSignificand[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">    divisor[i] = rhsSignificand[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">    lhsSignificand[i] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">  exponent -= rhs.exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="uncoveredLine">  unsigned int precision = semantics->precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">  /* Normalize the divisor.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">  bit = precision - APInt::tcMSB(divisor, partsCount) - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="uncoveredLine">  if (bit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">    exponent += bit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">    APInt::tcShiftLeft(divisor, partsCount, bit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">  /* Normalize the dividend.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">  bit = precision - APInt::tcMSB(dividend, partsCount) - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">  if (bit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="uncoveredLine">    exponent -= bit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">    APInt::tcShiftLeft(dividend, partsCount, bit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">  /* Ensure the dividend >= divisor initially for the loop below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">     Incidentally, this means that the division loop below is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">     guaranteed to set the integer bit to one.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">  if (APInt::tcCompare(dividend, divisor, partsCount) < 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="uncoveredLine">    exponent--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">    assert(APInt::tcCompare(dividend, divisor, partsCount) >= 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">  /* Long division.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">  for (bit = precision; bit; bit -= 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">    if (APInt::tcCompare(dividend, divisor, partsCount) >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">      APInt::tcSubtract(dividend, divisor, 0, partsCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">      APInt::tcSetBit(lhsSignificand, bit - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="uncoveredLine">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">  /* Figure out the lost fraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">  int cmp = APInt::tcCompare(dividend, divisor, partsCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">  if (cmp > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">    lost_fraction = lfMoreThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="uncoveredLine">  else if (cmp == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">    lost_fraction = lfExactlyHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">  else if (APInt::tcIsZero(dividend, partsCount))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">    lost_fraction = lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">    lost_fraction = lfLessThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">  if (partsCount > 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">    delete [] dividend;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="uncoveredLine">  return lost_fraction;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="uncoveredLine">unsigned int IEEEFloat::significandMSB() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">  return APInt::tcMSB(significandParts(), partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">unsigned int IEEEFloat::significandLSB() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">  return APInt::tcLSB(significandParts(), partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">/* Note that a zero result is NOT normalized to fcZero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">lostFraction IEEEFloat::shiftSignificandRight(unsigned int bits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">  /* Our exponent should not overflow.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="uncoveredLine">  assert((ExponentType) (exponent + bits) >= exponent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">  exponent += bits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">  return shiftRight(significandParts(), partCount(), bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">/* Shift the significand left BITS bits, subtract BITS from its exponent.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="uncoveredLine">void IEEEFloat::shiftSignificandLeft(unsigned int bits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="uncoveredLine">  assert(bits < semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">  if (bits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">    unsigned int partsCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">    APInt::tcShiftLeft(significandParts(), partsCount, bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="uncoveredLine">    exponent -= bits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">    assert(!APInt::tcIsZero(significandParts(), partsCount));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">IEEEFloat::cmpResult</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="uncoveredLine">IEEEFloat::compareAbsoluteValue(const IEEEFloat &rhs) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">  int compare;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="uncoveredLine">  assert(semantics == rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">  assert(isFiniteNonZero());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">  assert(rhs.isFiniteNonZero());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">  compare = exponent - rhs.exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="">  /* If exponents are equal, do an unsigned bignum comparison of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">     significands.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">  if (compare == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="uncoveredLine">    compare = APInt::tcCompare(significandParts(), rhs.significandParts(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">                               partCount());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">  if (compare > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">    return cmpGreaterThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">  else if (compare < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">    return cmpLessThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="uncoveredLine">    return cmpEqual;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">/* Set the least significant BITS bits of a bignum, clear the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">   rest.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="uncoveredLine">static void tcSetLeastSignificantBits(APInt::WordType *dst, unsigned parts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">                                      unsigned bits) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">  unsigned i = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">  while (bits > APInt::APINT_BITS_PER_WORD) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="uncoveredLine">    dst[i++] = ~(APInt::WordType)0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">    bits -= APInt::APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  if (bits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">    dst[i++] = ~(APInt::WordType)0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">  while (i < parts)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">    dst[i++] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">/* Handle overflow.  Sign is preserved.  We either become infinity or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">   the largest finite number.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::handleOverflow(roundingMode rounding_mode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  /* Infinity?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="uncoveredLine">  if (rounding_mode == rmNearestTiesToEven ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">      rounding_mode == rmNearestTiesToAway ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">      (rounding_mode == rmTowardPositive && !sign) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">      (rounding_mode == rmTowardNegative && sign)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">      makeNaN(false, sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="uncoveredLine">      category = fcInfinity;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">    return (opStatus) (opOverflow | opInexact);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">  /* Otherwise we become the largest finite number.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">  exponent = semantics->maxExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">  tcSetLeastSignificantBits(significandParts(), partCount(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">                            semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">    APInt::tcClearBit(significandParts(), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="uncoveredLine">  return opInexact;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">/* Returns TRUE if, when truncating the current number, with BIT the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">   new LSB, with the given lost fraction and rounding mode, the result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">   would need to be rounded away from zero (i.e., by increasing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">   signficand).  This routine must work for fcZero of both signs, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">   fcNormal numbers.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="uncoveredLine">bool IEEEFloat::roundAwayFromZero(roundingMode rounding_mode,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">                                  lostFraction lost_fraction,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">                                  unsigned int bit) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">  /* NaNs and infinities should not have lost fractions.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">  assert(isFiniteNonZero() || category == fcZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="">  /* Current callers never pass this so we don't handle it.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">  assert(lost_fraction != lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">  switch (rounding_mode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">  case rmNearestTiesToAway:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">    return lost_fraction == lfExactlyHalf || lost_fraction == lfMoreThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">  case rmNearestTiesToEven:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">    if (lost_fraction == lfMoreThanHalf)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">    /* Our zeroes don't have a significand to test.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">    if (lost_fraction == lfExactlyHalf && category != fcZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">      return APInt::tcExtractBit(significandParts(), bit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">  case rmTowardZero:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="uncoveredLine">  case rmTowardPositive:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">    return !sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">  case rmTowardNegative:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">    return sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">  llvm_unreachable("Invalid rounding mode found");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::normalize(roundingMode rounding_mode,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">                                         lostFraction lost_fraction) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">  unsigned int omsb;                /* One, not zero, based MSB.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">  int exponentChange;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">  if (!isFiniteNonZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">  /* Before rounding normalize the exponent of fcNormal numbers.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="uncoveredLine">  omsb = significandMSB() + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">  if (omsb) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">    /* OMSB is numbered from 1.  We want to place it in the integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">       bit numbered PRECISION if possible, with a compensating change in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">       the exponent.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">    exponentChange = omsb - semantics->precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">    /* If the resulting exponent is too high, overflow according to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">       the rounding mode.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">    if (exponent + exponentChange > semantics->maxExponent)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">      return handleOverflow(rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">    /* Subnormal numbers have exponent minExponent, and their MSB</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">       is forced based on that.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">    if (exponent + exponentChange < semantics->minExponent)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">      exponentChange = semantics->minExponent - exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">    /* Shifting left is easy as we don't lose precision.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="uncoveredLine">    if (exponentChange < 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">      assert(lost_fraction == lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">      shiftSignificandLeft(-exponentChange);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">      return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">    if (exponentChange > 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">      lostFraction lf;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">      /* Shift right and capture any new lost fraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">      lf = shiftSignificandRight(exponentChange);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="uncoveredLine">      lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">      /* Keep OMSB up-to-date.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">      if (omsb > (unsigned) exponentChange)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">        omsb -= exponentChange;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="uncoveredLine">        omsb = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">  // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">  // represented by negative zero, then it is a valid finite value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">      semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="uncoveredLine">      exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">    return handleOverflow(rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="">  /* Now round the number according to rounding_mode given the lost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">     fraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">  /* As specified in IEEE 754, since we do not trap we do not report</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">     underflow for exact results.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="uncoveredLine">  if (lost_fraction == lfExactlyZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">    /* Canonicalize zeroes.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">    if (omsb == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="uncoveredLine">      category = fcZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">        sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">  /* Increment the significand if we're rounding away from zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">  if (roundAwayFromZero(rounding_mode, lost_fraction, 0)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">    if (omsb == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">      exponent = semantics->minExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">    incrementSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">    omsb = significandMSB() + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">    /* Did the significand increment overflow?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="uncoveredLine">    if (omsb == (unsigned) semantics->precision + 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">      /* Renormalize by incrementing the exponent and shifting our</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">         significand right one.  However if we already have the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="">         maximum exponent we overflow to infinity.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">      if (exponent == semantics->maxExponent)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="">        // Invoke overflow handling with a rounding mode that will guarantee</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">        // that the result gets turned into the correct infinity representation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">        // This is needed instead of just setting the category to infinity to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="">        // account for 8-bit floating point types that have no inf, only NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">        return handleOverflow(sign ? rmTowardNegative : rmTowardPositive);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">      shiftSignificandRight(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="uncoveredLine">      return opInexact;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">    // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="">    // represented by negative zero, then it is a valid finite value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">        semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="uncoveredLine">        exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">      return handleOverflow(rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">  /* The normal case - we were and are not denormal, and any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">     significand increment above didn't overflow.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">  if (omsb == semantics->precision)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">    return opInexact;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">  /* We have a non-zero denormal.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">  assert(omsb < semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">  /* Canonicalize zeroes.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">  if (omsb == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="uncoveredLine">    category = fcZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">      sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">  /* The fcZero case is a denormal that underflowed to zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">  return (opStatus) (opUnderflow | opInexact);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::addOrSubtractSpecials(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">                                                     bool subtract) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">    llvm_unreachable(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">    assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="">    [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="uncoveredLine">    if (isSignaling()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">      makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="uncoveredLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">    category = fcInfinity;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">    sign = rhs.sign ^ subtract;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="uncoveredLine">    assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="uncoveredLine">    sign = rhs.sign ^ subtract;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">    /* Sign depends on rounding mode; handled by caller.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">    /* Differently signed infinities can only be validly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">       subtracted.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">    if (((sign ^ rhs.sign)!=0) != subtract) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">      makeNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">    return opDivByZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">/* Add or subtract two normal numbers.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="uncoveredLine">lostFraction IEEEFloat::addOrSubtractSignificand(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">                                                 bool subtract) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">  integerPart carry;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">  lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">  int bits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">  /* Determine if the operation on the absolute values is effectively</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">     an addition or subtraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">  subtract ^= static_cast<bool>(sign ^ rhs.sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">  /* Are we bigger exponent-wise than the RHS?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="uncoveredLine">  bits = exponent - rhs.exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">  /* Subtraction is more subtle than one might naively expect.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">  if (subtract) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">    IEEEFloat temp_rhs(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="uncoveredLine">    if (bits == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">      lost_fraction = lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">    else if (bits > 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="uncoveredLine">      lost_fraction = temp_rhs.shiftSignificandRight(bits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="uncoveredLine">      shiftSignificandLeft(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">      lost_fraction = shiftSignificandRight(-bits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="uncoveredLine">      temp_rhs.shiftSignificandLeft(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">    // Should we reverse the subtraction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">    if (compareAbsoluteValue(temp_rhs) == cmpLessThan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">      carry = temp_rhs.subtractSignificand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">        (*this, lost_fraction != lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">      copySignificand(temp_rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">      sign = !sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">      carry = subtractSignificand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">        (temp_rhs, lost_fraction != lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">    /* Invert the lost fraction - it was on the RHS and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="">       subtracted.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">    if (lost_fraction == lfLessThanHalf)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">      lost_fraction = lfMoreThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="uncoveredLine">    else if (lost_fraction == lfMoreThanHalf)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">      lost_fraction = lfLessThanHalf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="">    /* The code above is intended to ensure that no borrow is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">       necessary.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">    assert(!carry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="">    (void)carry;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="uncoveredLine">    if (bits > 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="uncoveredLine">      IEEEFloat temp_rhs(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">      lost_fraction = temp_rhs.shiftSignificandRight(bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="uncoveredLine">      carry = addSignificand(temp_rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">    } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="uncoveredLine">      lost_fraction = shiftSignificandRight(-bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">      carry = addSignificand(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">    /* We have a guard bit; generating a carry cannot happen.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">    assert(!carry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="">    (void)carry;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">  return lost_fraction;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::multiplySpecials(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">    llvm_unreachable(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="uncoveredLine">    assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">    sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">    [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">    sign ^= rhs.sign; // restore the original sign</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="uncoveredLine">    if (isSignaling()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">      makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="uncoveredLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="uncoveredLine">    category = fcInfinity;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="uncoveredLine">    category = fcZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="uncoveredLine">    makeNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">    return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::divideSpecials(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">    llvm_unreachable(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">    assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">    sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">    [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">    sign ^= rhs.sign; // restore the original sign</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">    if (isSignaling()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">      makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="uncoveredLine">    category = fcZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="uncoveredLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="uncoveredLine">      makeNaN(false, sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">      category = fcInfinity;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">    return opDivByZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">    makeNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">    return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::modSpecials(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">    llvm_unreachable(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">    assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">    [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">    if (isSignaling()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">      makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="uncoveredLine">    makeNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">    return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::remainderSpecials(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="uncoveredLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">    llvm_unreachable(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">    assign(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">    [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">    if (isSignaling()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">      makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="uncoveredLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">    makeNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">    return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="uncoveredLine">    return opDivByZero; // fake status, indicating this is not a special case</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">/* Change sign.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="uncoveredLine">void IEEEFloat::changeSign() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">  // With NaN-as-negative-zero, neither NaN or negative zero can change</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">  // their signs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="uncoveredLine">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="uncoveredLine">      (isZero() || isNaN()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">  /* Look mummy, this one's easy.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="uncoveredLine">  sign = !sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">/* Normalized addition or subtraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::addOrSubtract(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">                                             roundingMode rounding_mode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">                                             bool subtract) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">  fs = addOrSubtractSpecials(rhs, subtract);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">  /* This return code means it was not a simple case.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="uncoveredLine">  if (fs == opDivByZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="">    lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">    lost_fraction = addOrSubtractSignificand(rhs, subtract);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">    /* Can only be zero if we lost no fraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="uncoveredLine">    assert(category != fcZero || lost_fraction == lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">  /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">     positive zero unless rounding to minus infinity, except that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">     adding two like-signed zeroes gives that zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">  if (category == fcZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">    if (rhs.category != fcZero || (sign == rhs.sign) == subtract)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">      sign = (rounding_mode == rmTowardNegative);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">    // NaN-in-negative-zero means zeros need to be normalized to +0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">      sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="">/* Normalized addition.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::add(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">                                   roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="uncoveredLine">  return addOrSubtract(rhs, rounding_mode, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">/* Normalized subtraction.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::subtract(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="">                                        roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">  return addOrSubtract(rhs, rounding_mode, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">/* Normalized multiply.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::multiply(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">                                        roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">  sign ^= rhs.sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">  fs = multiplySpecials(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">    sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">  if (isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">    lostFraction lost_fraction = multiplySignificand(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">    if (lost_fraction != lfExactlyZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">      fs = (opStatus) (fs | opInexact);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">/* Normalized divide.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::divide(const IEEEFloat &rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">                                      roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">  sign ^= rhs.sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="uncoveredLine">  fs = divideSpecials(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">    sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="uncoveredLine">  if (isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">    lostFraction lost_fraction = divideSignificand(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="uncoveredLine">    if (lost_fraction != lfExactlyZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="uncoveredLine">      fs = (opStatus) (fs | opInexact);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">/* Normalized remainder.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::remainder(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">  unsigned int origSign = sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">  // First handle the special cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">  fs = remainderSpecials(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">  if (fs != opDivByZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">    return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">  fs = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  // Make sure the current value is less than twice the denom. If the addition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">  // did not succeed (an overflow has happened), which means that the finite</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">  // value we currently posses must be less than twice the denom (as we are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="">  // using the same semantics).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="uncoveredLine">  IEEEFloat P2 = rhs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">  if (P2.add(rhs, rmNearestTiesToEven) == opOK) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">    fs = mod(P2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">    assert(fs == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">  // Lets work with absolute numbers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="uncoveredLine">  IEEEFloat P = rhs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">  P.sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="uncoveredLine">  sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">  // To calculate the remainder we use the following scheme.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">  // The remainder is defained as follows:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">  // remainder = numer - rquot * denom = x - r * p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">  // Where r is the result of: x/p, rounded toward the nearest integral value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">  // (with halfway cases rounded toward the even number).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="">  // Currently, (after x mod 2p):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">  // r is the number of 2p's present inside x, which is inherently, an even</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">  // number of p's.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">  // We may split the remaining calculation into 4 options:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">  // - if x == 0.5p then we round to the nearest even number which is 0, and we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">  //   are done as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">  // - if 0.5p < x < p then we round to nearest number which is 1, and we have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">  //   to subtract 1p at least once.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">  // - if x >= p then we must subtract p at least once, as x must be a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">  //   remainder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">  // By now, we were done, or we added 1 to r, which in turn, now an odd number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">  // We can now split the remaining calculation to the following 3 options:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">  // - if x == 0.5p then we round to the nearest even number. As r is odd, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">  //   must round up to the next even number. so we must subtract p once more.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">  // - if x > 0.5p (and inherently x < p) then we must round r up to the next</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="">  //   integral, and subtract p once more.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">  // Extend the semantics to prevent an overflow/underflow or inexact result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="">  bool losesInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="uncoveredLine">  fltSemantics extendedSemantics = *semantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">  extendedSemantics.maxExponent++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="uncoveredLine">  extendedSemantics.minExponent--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">  extendedSemantics.precision += 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">  IEEEFloat VEx = *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="uncoveredLine">  fs = VEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">  assert(fs == opOK && !losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">  IEEEFloat PEx = P;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">  fs = PEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">  assert(fs == opOK && !losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">  // It is simpler to work with 2x instead of 0.5p, and we do not need to lose</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="">  // any fraction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="uncoveredLine">  fs = VEx.add(VEx, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="uncoveredLine">  assert(fs == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">  if (VEx.compare(PEx) == cmpGreaterThan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">    fs = subtract(P, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="uncoveredLine">    assert(fs == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">    // Make VEx = this.add(this), but because we have different semantics, we do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">    // not want to `convert` again, so we just subtract PEx twice (which equals</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">    // to the desired value).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">    assert(fs == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">    assert(fs == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="uncoveredLine">    cmpResult result = VEx.compare(PEx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="uncoveredLine">    if (result == cmpGreaterThan || result == cmpEqual) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">      fs = subtract(P, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">      assert(fs == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="uncoveredLine">  if (isZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">    sign = origSign;    // IEEE754 requires this</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">      // But some 8-bit floats only have positive 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">      sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">    sign ^= origSign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="">/* Normalized llvm frem (C fmod). */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::mod(const IEEEFloat &rhs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">  fs = modSpecials(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="uncoveredLine">  unsigned int origSign = sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="uncoveredLine">  while (isFiniteNonZero() && rhs.isFiniteNonZero() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="uncoveredLine">         compareAbsoluteValue(rhs) != cmpLessThan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">    int Exp = ilogb(*this) - ilogb(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="uncoveredLine">    IEEEFloat V = scalbn(rhs, Exp, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">    // V can overflow to NaN with fltNonfiniteBehavior::NanOnly, so explicitly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="">    // check for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">    if (V.isNaN() || compareAbsoluteValue(V) == cmpLessThan)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">      V = scalbn(rhs, Exp - 1, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="uncoveredLine">    V.sign = sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">    fs = subtract(V, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="uncoveredLine">    assert(fs==opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="uncoveredLine">  if (isZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">    sign = origSign; // fmod requires this</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="uncoveredLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">      sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">/* Normalized fused-multiply-add.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::fusedMultiplyAdd(const IEEEFloat &multiplicand,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="">                                                const IEEEFloat &addend,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="">                                                roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="">  /* Post-multiplication sign, before addition.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="uncoveredLine">  sign ^= multiplicand.sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">  /* If and only if all arguments are normal do we need to do an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="">     extended-precision calculation.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="uncoveredLine">  if (isFiniteNonZero() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="uncoveredLine">      multiplicand.isFiniteNonZero() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">      addend.isFinite()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">    lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="uncoveredLine">    lost_fraction = multiplySignificand(multiplicand, addend);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">    if (lost_fraction != lfExactlyZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="uncoveredLine">      fs = (opStatus) (fs | opInexact);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">    /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">       positive zero unless rounding to minus infinity, except that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">       adding two like-signed zeroes gives that zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="uncoveredLine">    if (category == fcZero && !(fs & opUnderflow) && sign != addend.sign) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="uncoveredLine">      sign = (rounding_mode == rmTowardNegative);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="uncoveredLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">        sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="uncoveredLine">    fs = multiplySpecials(multiplicand);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="">    /* FS can only be opOK or opInvalidOp.  There is no more work</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">       to do in the latter case.  The IEEE-754R standard says it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">       implementation-defined in this case whether, if ADDEND is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">       quiet NaN, we raise invalid op; this implementation does so.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">       If we need to do the addition we can do so with normal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">       precision.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">    if (fs == opOK)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">      fs = addOrSubtract(addend, rounding_mode, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">/* Rounding-mode correct round to integral value.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::roundToIntegral(roundingMode rounding_mode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="uncoveredLine">  if (isInfinity())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="">    // [IEEE Std 754-2008 6.1]:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">    // The behavior of infinity in floating-point arithmetic is derived from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="">    // limiting cases of real arithmetic with operands of arbitrarily</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="">    // large magnitude, when such a limit exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="">    // ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">    // Operations on infinite operands are usually exact and therefore signal no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="">    // exceptions ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="uncoveredLine">  if (isNaN()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="uncoveredLine">    if (isSignaling()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="">      // [IEEE Std 754-2008 6.2]:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="">      // Under default exception handling, any operation signaling an invalid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">      // operation exception and for which a floating-point result is to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="">      // delivered shall deliver a quiet NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="uncoveredLine">      makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="">      // [IEEE Std 754-2008 6.2]:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">      // Signaling NaNs shall be reserved operands that, under default exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">      // handling, signal the invalid operation exception(see 7.2) for every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">      // general-computational and signaling-computational operation except for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="">      // the conversions described in 5.12.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">      // [IEEE Std 754-2008 6.2]:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="">      // For an operation with quiet NaN inputs, other than maximum and minimum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="">      // operations, if a floating-point result is to be delivered the result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">      // shall be a quiet NaN which should be one of the input NaNs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">      // ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">      // Every general-computational and quiet-computational operation involving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">      // one or more input NaNs, none of them signaling, shall signal no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="">      // exception, except fusedMultiplyAdd might signal the invalid operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="">      // exception(see 7.2).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="uncoveredLine">      return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">  if (isZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">    // [IEEE Std 754-2008 6.3]:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">    // ... the sign of the result of conversions, the quantize operation, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="">    // roundToIntegral operations, and the roundToIntegralExact(see 5.3.1) is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">    // the sign of the first or only operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">  // If the exponent is large enough, we know that this value is already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">  // integral, and the arithmetic below would potentially cause it to saturate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">  // to +/-Inf.  Bail out early instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">  if (exponent+1 >= (int)semanticsPrecision(*semantics))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">  // The algorithm here is quite simple: we add 2^(p-1), where p is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">  // precision of our format, and then subtract it back off again.  The choice</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="">  // of rounding modes for the addition/subtraction determines the rounding mode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">  // for our integral rounding as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">  // NOTE: When the input value is negative, we do subtraction followed by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="">  // addition instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="uncoveredLine">  APInt IntegerConstant(NextPowerOf2(semanticsPrecision(*semantics)), 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="uncoveredLine">  IntegerConstant <<= semanticsPrecision(*semantics)-1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="uncoveredLine">  IEEEFloat MagicConstant(*semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">  fs = MagicConstant.convertFromAPInt(IntegerConstant, false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="">                                      rmNearestTiesToEven);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">  assert(fs == opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="uncoveredLine">  MagicConstant.sign = sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">  // Preserve the input sign so that we can handle the case of zero result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="">  // correctly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">  bool inputSign = isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="uncoveredLine">  fs = add(MagicConstant, rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="">  // Current value and 'MagicConstant' are both integers, so the result of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">  // subtraction is always exact according to Sterbenz' lemma.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="uncoveredLine">  subtract(MagicConstant, rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="">  // Restore the input sign.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">  if (inputSign != isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">    changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="">/* Comparison requires normalized numbers.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="uncoveredLine">IEEEFloat::cmpResult IEEEFloat::compare(const IEEEFloat &rhs) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">  cmpResult result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="uncoveredLine">  assert(semantics == rhs.semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="uncoveredLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="uncoveredLine">    llvm_unreachable(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="uncoveredLine">    return cmpUnordered;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">    if (sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">      return cmpLessThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="uncoveredLine">      return cmpGreaterThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">    if (rhs.sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">      return cmpGreaterThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">      return cmpLessThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">    if (sign == rhs.sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">      return cmpEqual;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="uncoveredLine">    else if (sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="uncoveredLine">      return cmpLessThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">      return cmpGreaterThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="uncoveredLine">    return cmpEqual;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">  /* Two normal numbers.  Do they have the same sign?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">  if (sign != rhs.sign) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="uncoveredLine">    if (sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="uncoveredLine">      result = cmpLessThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="uncoveredLine">      result = cmpGreaterThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="">    /* Compare absolute values; invert result if negative.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="uncoveredLine">    result = compareAbsoluteValue(rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="uncoveredLine">    if (sign) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="uncoveredLine">      if (result == cmpLessThan)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">        result = cmpGreaterThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="uncoveredLine">      else if (result == cmpGreaterThan)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="uncoveredLine">        result = cmpLessThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="uncoveredLine">  return result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="">/// IEEEFloat::convert - convert a value of one floating point type to another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="">/// The return value corresponds to the IEEE754 exceptions.  *losesInfo</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="">/// records whether the transformation lost information, i.e. whether</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="">/// converting the result back to the original type will produce the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="">/// original value (this is almost the same as return value==fsOK, but there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="">/// are edge cases where this is not so).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::convert(const fltSemantics &toSemantics,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="">                                       roundingMode rounding_mode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="">                                       bool *losesInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="">  lostFraction lostFraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="">  unsigned int newPartCount, oldPartCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="">  int shift;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">  const fltSemantics &fromSemantics = *semantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">  bool is_signaling = isSignaling();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">  lostFraction = lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="uncoveredLine">  newPartCount = partCountForBits(toSemantics.precision + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="uncoveredLine">  oldPartCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="uncoveredLine">  shift = toSemantics.precision - fromSemantics.precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="uncoveredLine">  bool X86SpecialNan = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="uncoveredLine">  if (&fromSemantics == &semX87DoubleExtended &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="uncoveredLine">      &toSemantics != &semX87DoubleExtended && category == fcNaN &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">      (!(*significandParts() & 0x8000000000000000ULL) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">       !(*significandParts() & 0x4000000000000000ULL))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">    // x86 has some unusual NaNs which cannot be represented in any other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="">    // format; note them here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="uncoveredLine">    X86SpecialNan = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">  // If this is a truncation of a denormal number, and the target semantics</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="">  // has larger exponent range than the source semantics (this can happen</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="">  // when truncating from PowerPC double-double to double format), the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">  // right shift could lose result mantissa bits.  Adjust exponent instead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">  // of performing excessive shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">  // Also do a similar trick in case shifting denormal would produce zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="">  // significand as this case isn't handled correctly by normalize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="uncoveredLine">  if (shift < 0 && isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="uncoveredLine">    int omsb = significandMSB() + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="uncoveredLine">    int exponentChange = omsb - fromSemantics.precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="uncoveredLine">    if (exponent + exponentChange < toSemantics.minExponent)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="uncoveredLine">      exponentChange = toSemantics.minExponent - exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="uncoveredLine">    if (exponentChange < shift)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="uncoveredLine">      exponentChange = shift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="uncoveredLine">    if (exponentChange < 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="uncoveredLine">      shift -= exponentChange;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="uncoveredLine">      exponent += exponentChange;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="uncoveredLine">    } else if (omsb <= -shift) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="uncoveredLine">      exponentChange = omsb + shift - 1; // leave at least one bit set</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="uncoveredLine">      shift -= exponentChange;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="uncoveredLine">      exponent += exponentChange;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="">  // If this is a truncation, perform the shift before we narrow the storage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="uncoveredLine">  if (shift < 0 && (isFiniteNonZero() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="uncoveredLine">                    (category == fcNaN && semantics->nonFiniteBehavior !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">                                              fltNonfiniteBehavior::NanOnly)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="uncoveredLine">    lostFraction = shiftRight(significandParts(), oldPartCount, -shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="">  // Fix the storage so it can hold to new value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="uncoveredLine">  if (newPartCount > oldPartCount) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="">    // The new type requires more storage; make it available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="">    integerPart *newParts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="uncoveredLine">    newParts = new integerPart[newPartCount];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">    APInt::tcSet(newParts, 0, newPartCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="uncoveredLine">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="uncoveredLine">      APInt::tcAssign(newParts, significandParts(), oldPartCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="uncoveredLine">    freeSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="uncoveredLine">    significand.parts = newParts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="uncoveredLine">  } else if (newPartCount == 1 && oldPartCount != 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="">    // Switch to built-in storage for a single part.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="uncoveredLine">    integerPart newPart = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="uncoveredLine">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="uncoveredLine">      newPart = significandParts()[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="uncoveredLine">    freeSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="uncoveredLine">    significand.part = newPart;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="">  // Now that we have the right storage, switch the semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="uncoveredLine">  semantics = &toSemantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="">  // If this is an extension, perform the shift now that the storage is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="">  // available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">  if (shift > 0 && (isFiniteNonZero() || category==fcNaN))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="uncoveredLine">    APInt::tcShiftLeft(significandParts(), newPartCount, shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="uncoveredLine">  if (isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="uncoveredLine">    fs = normalize(rounding_mode, lostFraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="uncoveredLine">    *losesInfo = (fs != opOK);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="uncoveredLine">  } else if (category == fcNaN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="uncoveredLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="uncoveredLine">      *losesInfo =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">          fromSemantics.nonFiniteBehavior != fltNonfiniteBehavior::NanOnly;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">      makeNaN(false, sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">      return is_signaling ? opInvalidOp : opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="">    // If NaN is negative zero, we need to create a new NaN to avoid converting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="">    // NaN to -Inf.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="uncoveredLine">    if (fromSemantics.nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">        semantics->nanEncoding != fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="uncoveredLine">      makeNaN(false, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="uncoveredLine">    *losesInfo = lostFraction != lfExactlyZero || X86SpecialNan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="">    // For x87 extended precision, we want to make a NaN, not a special NaN if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="">    // the input wasn't special either.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="uncoveredLine">    if (!X86SpecialNan && semantics == &semX87DoubleExtended)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="uncoveredLine">      APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="">    // Convert of sNaN creates qNaN and raises an exception (invalid op).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="">    // This also guarantees that a sNaN does not become Inf on a truncation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="">    // that loses all payload bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="uncoveredLine">    if (is_signaling) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="uncoveredLine">      makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="uncoveredLine">      fs = opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">      fs = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="uncoveredLine">  } else if (category == fcInfinity &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="uncoveredLine">             semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="uncoveredLine">    makeNaN(false, sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">    *losesInfo = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">    fs = opInexact;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="uncoveredLine">  } else if (category == fcZero &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="uncoveredLine">             semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="">    // Negative zero loses info, but positive zero doesn't.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="uncoveredLine">    *losesInfo =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">        fromSemantics.nanEncoding != fltNanEncoding::NegativeZero && sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">    fs = *losesInfo ? opInexact : opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="">    // NaN is negative zero means -0 -> +0, which can lose information</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="uncoveredLine">    sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">    *losesInfo = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="uncoveredLine">    fs = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="">/* Convert a floating point number to an integer according to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="">   rounding mode.  If the rounded integer value is out of range this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="">   returns an invalid operation exception and the contents of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="">   destination parts are unspecified.  If the rounded value is in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="">   range but the floating point number is not the exact integer, the C</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="">   standard doesn't require an inexact exception to be raised.  IEEE</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="">   854 does require it so we do that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="">   Note that for conversions to integer type the C standard requires</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="">   round-to-zero to always be used.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::convertToSignExtendedInteger(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="">    MutableArrayRef<integerPart> parts, unsigned int width, bool isSigned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="">    roundingMode rounding_mode, bool *isExact) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="">  lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="">  const integerPart *src;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="">  unsigned int dstPartsCount, truncatedBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="uncoveredLine">  *isExact = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="">  /* Handle the three special cases first.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">  if (category == fcInfinity || category == fcNaN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="uncoveredLine">    return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="uncoveredLine">  dstPartsCount = partCountForBits(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="uncoveredLine">  assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">  if (category == fcZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="uncoveredLine">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="">    // Negative zero can't be represented as an int.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="uncoveredLine">    *isExact = !sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="uncoveredLine">  src = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="">  /* Step 1: place our absolute value, with any fraction truncated, in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="">     the destination.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="uncoveredLine">  if (exponent < 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="">    /* Our absolute value is less than one; truncate everything.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="uncoveredLine">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="">    /* For exponent -1 the integer bit represents .5, look at that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="">       For smaller exponents leftmost truncated bit is 0. */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="uncoveredLine">    truncatedBits = semantics->precision -1U - exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="">    /* We want the most significant (exponent + 1) bits; the rest are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="">       truncated.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="uncoveredLine">    unsigned int bits = exponent + 1U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="">    /* Hopelessly large in magnitude?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="uncoveredLine">    if (bits > width)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="uncoveredLine">    if (bits < semantics->precision) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="">      /* We truncate (semantics->precision - bits) bits.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="uncoveredLine">      truncatedBits = semantics->precision - bits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="uncoveredLine">      APInt::tcExtract(parts.data(), dstPartsCount, src, bits, truncatedBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="">      /* We want at least as many bits as are available.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="uncoveredLine">      APInt::tcExtract(parts.data(), dstPartsCount, src, semantics->precision,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="">                       0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="uncoveredLine">      APInt::tcShiftLeft(parts.data(), dstPartsCount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="uncoveredLine">                         bits - semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="uncoveredLine">      truncatedBits = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="">  /* Step 2: work out any lost fraction, and increment the absolute</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="">     value if we would round away from zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="uncoveredLine">  if (truncatedBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="uncoveredLine">    lost_fraction = lostFractionThroughTruncation(src, partCount(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="">                                                  truncatedBits);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="uncoveredLine">    if (lost_fraction != lfExactlyZero &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="uncoveredLine">        roundAwayFromZero(rounding_mode, lost_fraction, truncatedBits)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="uncoveredLine">      if (APInt::tcIncrement(parts.data(), dstPartsCount))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="uncoveredLine">        return opInvalidOp;     /* Overflow.  */</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="uncoveredLine">    lost_fraction = lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="">  /* Step 3: check if we fit in the destination.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="uncoveredLine">  unsigned int omsb = APInt::tcMSB(parts.data(), dstPartsCount) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="uncoveredLine">  if (sign) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="uncoveredLine">    if (!isSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="">      /* Negative numbers cannot be represented as unsigned.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="uncoveredLine">      if (omsb != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="uncoveredLine">        return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="">      /* It takes omsb bits to represent the unsigned integer value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="">         We lose a bit for the sign, but care is needed as the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="">         maximally negative integer is a special case.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="uncoveredLine">      if (omsb == width &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="uncoveredLine">          APInt::tcLSB(parts.data(), dstPartsCount) + 1 != omsb)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="uncoveredLine">        return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="">      /* This case can happen because of rounding.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="uncoveredLine">      if (omsb > width)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="uncoveredLine">        return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="uncoveredLine">    APInt::tcNegate (parts.data(), dstPartsCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="uncoveredLine">    if (omsb >= width + !isSigned)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="uncoveredLine">      return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="uncoveredLine">  if (lost_fraction == lfExactlyZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="uncoveredLine">    *isExact = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="uncoveredLine">    return opInexact;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="">/* Same as convertToSignExtendedInteger, except we provide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="">   deterministic values in case of an invalid operation exception,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="">   namely zero for NaNs and the minimal or maximal value respectively</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="">   for underflow or overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="">   The *isExact output tells whether the result is exact, in the sense</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="">   that converting it back to the original floating point type produces</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="">   the original value.  This is almost equivalent to result==opOK,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="">   except for negative zeroes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="">*/</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="">IEEEFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="uncoveredLine">IEEEFloat::convertToInteger(MutableArrayRef<integerPart> parts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="">                            unsigned int width, bool isSigned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="">                            roundingMode rounding_mode, bool *isExact) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="uncoveredLine">  fs = convertToSignExtendedInteger(parts, width, isSigned, rounding_mode,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="">                                    isExact);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="uncoveredLine">  if (fs == opInvalidOp) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="">    unsigned int bits, dstPartsCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="uncoveredLine">    dstPartsCount = partCountForBits(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="uncoveredLine">    assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="uncoveredLine">    if (category == fcNaN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="uncoveredLine">      bits = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="uncoveredLine">    else if (sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="uncoveredLine">      bits = isSigned;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="uncoveredLine">      bits = width - isSigned;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="uncoveredLine">    tcSetLeastSignificantBits(parts.data(), dstPartsCount, bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="uncoveredLine">    if (sign && isSigned)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="uncoveredLine">      APInt::tcShiftLeft(parts.data(), dstPartsCount, width - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="">/* Convert an unsigned integer SRC to a floating point number,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="">   rounding according to ROUNDING_MODE.  The sign of the floating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="">   point number is not modified.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::convertFromUnsignedParts(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="">    const integerPart *src, unsigned int srcCount, roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="">  unsigned int omsb, precision, dstCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="">  integerPart *dst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="">  lostFraction lost_fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="uncoveredLine">  omsb = APInt::tcMSB(src, srcCount) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="uncoveredLine">  dst = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="uncoveredLine">  dstCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="uncoveredLine">  precision = semantics->precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="">  /* We want the most significant PRECISION bits of SRC.  There may not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="">     be that many; extract what we can.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="uncoveredLine">  if (precision <= omsb) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="uncoveredLine">    exponent = omsb - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="uncoveredLine">    lost_fraction = lostFractionThroughTruncation(src, srcCount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="">                                                  omsb - precision);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="uncoveredLine">    APInt::tcExtract(dst, dstCount, src, precision, omsb - precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="uncoveredLine">    exponent = precision - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="uncoveredLine">    lost_fraction = lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="uncoveredLine">    APInt::tcExtract(dst, dstCount, src, omsb, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="uncoveredLine">  return normalize(rounding_mode, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::convertFromAPInt(const APInt &Val, bool isSigned,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="">                                                roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="uncoveredLine">  unsigned int partCount = Val.getNumWords();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="uncoveredLine">  APInt api = Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="uncoveredLine">  sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="uncoveredLine">  if (isSigned && api.isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="uncoveredLine">    sign = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="uncoveredLine">    api = -api;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="uncoveredLine">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="">/* Convert a two's complement integer SRC to a floating point number,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="">   rounding according to ROUNDING_MODE.  ISSIGNED is true if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="">   integer is signed, in which case it must be sign-extended.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="">IEEEFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="uncoveredLine">IEEEFloat::convertFromSignExtendedInteger(const integerPart *src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="">                                          unsigned int srcCount, bool isSigned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="">                                          roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="">  opStatus status;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="uncoveredLine">  if (isSigned &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="uncoveredLine">      APInt::tcExtractBit(src, srcCount * integerPartWidth - 1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="">    integerPart *copy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="">    /* If we're signed and negative negate a copy.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="uncoveredLine">    sign = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="uncoveredLine">    copy = new integerPart[srcCount];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="uncoveredLine">    APInt::tcAssign(copy, src, srcCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="uncoveredLine">    APInt::tcNegate(copy, srcCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="uncoveredLine">    status = convertFromUnsignedParts(copy, srcCount, rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="uncoveredLine">    delete [] copy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="uncoveredLine">    sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="uncoveredLine">    status = convertFromUnsignedParts(src, srcCount, rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="uncoveredLine">  return status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="">/* FIXME: should this just take a const APInt reference?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="">IEEEFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="uncoveredLine">IEEEFloat::convertFromZeroExtendedInteger(const integerPart *parts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="">                                          unsigned int width, bool isSigned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="">                                          roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="uncoveredLine">  unsigned int partCount = partCountForBits(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="uncoveredLine">  APInt api = APInt(width, ArrayRef(parts, partCount));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="uncoveredLine">  sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="uncoveredLine">  if (isSigned && APInt::tcExtractBit(parts, width - 1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="uncoveredLine">    sign = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="uncoveredLine">    api = -api;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="uncoveredLine">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="">Expected<IEEEFloat::opStatus></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="uncoveredLine">IEEEFloat::convertFromHexadecimalString(StringRef s,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="">                                        roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="uncoveredLine">  lostFraction lost_fraction = lfExactlyZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="uncoveredLine">  zeroSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="uncoveredLine">  exponent = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="uncoveredLine">  integerPart *significand = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="uncoveredLine">  unsigned partsCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="uncoveredLine">  unsigned bitPos = partsCount * integerPartWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="uncoveredLine">  bool computedTrailingFraction = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="">  // Skip leading zeroes and any (hexa)decimal point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="uncoveredLine">  StringRef::iterator begin = s.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="uncoveredLine">  StringRef::iterator end = s.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="">  StringRef::iterator dot;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="uncoveredLine">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="uncoveredLine">  if (!PtrOrErr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="uncoveredLine">    return PtrOrErr.takeError();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="uncoveredLine">  StringRef::iterator p = *PtrOrErr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="uncoveredLine">  StringRef::iterator firstSignificantDigit = p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="uncoveredLine">  while (p != end) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="">    integerPart hex_value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="uncoveredLine">    if (*p == '.') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="uncoveredLine">      if (dot != end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="uncoveredLine">        return createError("String contains multiple dots");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="uncoveredLine">      dot = p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="uncoveredLine">    hex_value = hexDigitValue(*p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="uncoveredLine">    if (hex_value == UINT_MAX)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="">    // Store the number while we have space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="uncoveredLine">    if (bitPos) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="uncoveredLine">      bitPos -= 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="uncoveredLine">      hex_value <<= bitPos % integerPartWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="uncoveredLine">      significand[bitPos / integerPartWidth] |= hex_value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="uncoveredLine">    } else if (!computedTrailingFraction) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="uncoveredLine">      auto FractOrErr = trailingHexadecimalFraction(p, end, hex_value);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="uncoveredLine">      if (!FractOrErr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="uncoveredLine">        return FractOrErr.takeError();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="uncoveredLine">      lost_fraction = *FractOrErr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="uncoveredLine">      computedTrailingFraction = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="">  /* Hex floats require an exponent but not a hexadecimal point.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="uncoveredLine">  if (p == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="uncoveredLine">    return createError("Hex strings require an exponent");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="uncoveredLine">  if (*p != 'p' && *p != 'P')</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="uncoveredLine">    return createError("Invalid character in significand");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="uncoveredLine">  if (p == begin)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="uncoveredLine">    return createError("Significand has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="uncoveredLine">  if (dot != end && p - begin == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="uncoveredLine">    return createError("Significand has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="">  /* Ignore the exponent if we are zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="uncoveredLine">  if (p != firstSignificantDigit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="">    int expAdjustment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="">    /* Implicit hexadecimal point?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="uncoveredLine">    if (dot == end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="uncoveredLine">      dot = p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="">    /* Calculate the exponent adjustment implicit in the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="">       significant digits.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="uncoveredLine">    expAdjustment = static_cast<int>(dot - firstSignificantDigit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="uncoveredLine">    if (expAdjustment < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="uncoveredLine">      expAdjustment++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="uncoveredLine">    expAdjustment = expAdjustment * 4 - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="">    /* Adjust for writing the significand starting at the most</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="">       significant nibble.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="uncoveredLine">    expAdjustment += semantics->precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="uncoveredLine">    expAdjustment -= partsCount * integerPartWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="">    /* Adjust for the given exponent.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="uncoveredLine">    auto ExpOrErr = totalExponent(p + 1, end, expAdjustment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="uncoveredLine">    if (!ExpOrErr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="uncoveredLine">      return ExpOrErr.takeError();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="uncoveredLine">    exponent = *ExpOrErr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="uncoveredLine">  return normalize(rounding_mode, lost_fraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="">IEEEFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="uncoveredLine">IEEEFloat::roundSignificandWithExponent(const integerPart *decSigParts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="">                                        unsigned sigPartCount, int exp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="">                                        roundingMode rounding_mode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="">  unsigned int parts, pow5PartCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="uncoveredLine">  fltSemantics calcSemantics = { 32767, -32767, 0, 0 };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="">  integerPart pow5Parts[maxPowerOfFiveParts];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="">  bool isNearest;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="uncoveredLine">  isNearest = (rounding_mode == rmNearestTiesToEven ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="">               rounding_mode == rmNearestTiesToAway);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="uncoveredLine">  parts = partCountForBits(semantics->precision + 11);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="">  /* Calculate pow(5, abs(exp)).  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="uncoveredLine">  pow5PartCount = powerOf5(pow5Parts, exp >= 0 ? exp: -exp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="uncoveredLine">  for (;; parts *= 2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="">    opStatus sigStatus, powStatus;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="">    unsigned int excessPrecision, truncatedBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="uncoveredLine">    calcSemantics.precision = parts * integerPartWidth - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="uncoveredLine">    excessPrecision = calcSemantics.precision - semantics->precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="uncoveredLine">    truncatedBits = excessPrecision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="uncoveredLine">    IEEEFloat decSig(calcSemantics, uninitialized);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="uncoveredLine">    decSig.makeZero(sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="uncoveredLine">    IEEEFloat pow5(calcSemantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="uncoveredLine">    sigStatus = decSig.convertFromUnsignedParts(decSigParts, sigPartCount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="">                                                rmNearestTiesToEven);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="uncoveredLine">    powStatus = pow5.convertFromUnsignedParts(pow5Parts, pow5PartCount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="">                                              rmNearestTiesToEven);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="">    /* Add exp, as 10^n = 5^n * 2^n.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="uncoveredLine">    decSig.exponent += exp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="">    lostFraction calcLostFraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="">    integerPart HUerr, HUdistance;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="">    unsigned int powHUerr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="uncoveredLine">    if (exp >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="">      /* multiplySignificand leaves the precision-th bit set to 1.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="uncoveredLine">      calcLostFraction = decSig.multiplySignificand(pow5);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="uncoveredLine">      powHUerr = powStatus != opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="uncoveredLine">      calcLostFraction = decSig.divideSignificand(pow5);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="">      /* Denormal numbers have less precision.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="uncoveredLine">      if (decSig.exponent < semantics->minExponent) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="uncoveredLine">        excessPrecision += (semantics->minExponent - decSig.exponent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="uncoveredLine">        truncatedBits = excessPrecision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="uncoveredLine">        if (excessPrecision > calcSemantics.precision)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="uncoveredLine">          excessPrecision = calcSemantics.precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="">      /* Extra half-ulp lost in reciprocal of exponent.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="uncoveredLine">      powHUerr = (powStatus == opOK && calcLostFraction == lfExactlyZero) ? 0:2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="">    /* Both multiplySignificand and divideSignificand return the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="">       result with the integer bit set.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="uncoveredLine">    assert(APInt::tcExtractBit</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="">           (decSig.significandParts(), calcSemantics.precision - 1) == 1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="uncoveredLine">    HUerr = HUerrBound(calcLostFraction != lfExactlyZero, sigStatus != opOK,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="">                       powHUerr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="uncoveredLine">    HUdistance = 2 * ulpsFromBoundary(decSig.significandParts(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="">                                      excessPrecision, isNearest);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="">    /* Are we guaranteed to round correctly if we truncate?  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="uncoveredLine">    if (HUdistance >= HUerr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="uncoveredLine">      APInt::tcExtract(significandParts(), partCount(), decSig.significandParts(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="uncoveredLine">                       calcSemantics.precision - excessPrecision,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="">                       excessPrecision);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="">      /* Take the exponent of decSig.  If we tcExtract-ed less bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="">         above we must adjust our exponent to compensate for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="">         implicit right shift.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="uncoveredLine">      exponent = (decSig.exponent + semantics->precision</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="uncoveredLine">                  - (calcSemantics.precision - excessPrecision));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="uncoveredLine">      calcLostFraction = lostFractionThroughTruncation(decSig.significandParts(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="">                                                       decSig.partCount(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="">                                                       truncatedBits);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="uncoveredLine">      return normalize(rounding_mode, calcLostFraction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="">Expected<IEEEFloat::opStatus></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="uncoveredLine">IEEEFloat::convertFromDecimalString(StringRef str, roundingMode rounding_mode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="">  decimalInfo D;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="">  /* Scan the text.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="uncoveredLine">  StringRef::iterator p = str.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="uncoveredLine">  if (Error Err = interpretDecimal(p, str.end(), &D))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="uncoveredLine">    return std::move(Err);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="">  /* Handle the quick cases.  First the case of no significant digits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="">     i.e. zero, and then exponents that are obviously too large or too</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="">     small.  Writing L for log 10 / log 2, a number d.ddddd*10^exp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="">     definitely overflows if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="">           (exp - 1) * L >= maxExponent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="">     and definitely underflows to zero where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="">           (exp + 1) * L <= minExponent - precision</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="">     With integer arithmetic the tightest bounds for L are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="">           93/28 < L < 196/59            [ numerator <= 256 ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="">           42039/12655 < L < 28738/8651  [ numerator <= 65536 ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="">  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="">  // Test if we have a zero number allowing for strings with no null terminators</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="">  // and zero decimals with non-zero exponents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="">  // We computed firstSigDigit by ignoring all zeros and dots. Thus if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="">  // D->firstSigDigit equals str.end(), every digit must be a zero and there can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="">  // be at most one dot. On the other hand, if we have a zero with a non-zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="">  // exponent, then we know that D.firstSigDigit will be non-numeric.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="uncoveredLine">  if (D.firstSigDigit == str.end() || decDigitValue(*D.firstSigDigit) >= 10U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="uncoveredLine">    category = fcZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="uncoveredLine">    fs = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="uncoveredLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="uncoveredLine">      sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="">    /* Check whether the normalized exponent is high enough to overflow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="">       max during the log-rebasing in the max-exponent check below. */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="uncoveredLine">  } else if (D.normalizedExponent - 1 > INT_MAX / 42039) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="uncoveredLine">    fs = handleOverflow(rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="">  /* If it wasn't, then it also wasn't high enough to overflow max</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="">     during the log-rebasing in the min-exponent check.  Check that it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="">     won't overflow min in either check, then perform the min-exponent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="">     check. */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="uncoveredLine">  } else if (D.normalizedExponent - 1 < INT_MIN / 42039 ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="uncoveredLine">             (D.normalizedExponent + 1) * 28738 <=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="uncoveredLine">               8651 * (semantics->minExponent - (int) semantics->precision)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="">    /* Underflow to zero and round.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="uncoveredLine">    category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="uncoveredLine">    zeroSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="uncoveredLine">    fs = normalize(rounding_mode, lfLessThanHalf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="">  /* We can finally safely perform the max-exponent check. */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="uncoveredLine">  } else if ((D.normalizedExponent - 1) * 42039</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="uncoveredLine">             >= 12655 * semantics->maxExponent) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="">    /* Overflow and round.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="uncoveredLine">    fs = handleOverflow(rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="">    integerPart *decSignificand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="">    unsigned int partCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="">    /* A tight upper bound on number of bits required to hold an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="">       N-digit decimal integer is N * 196 / 59.  Allocate enough space</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="">       to hold the full significand, and an extra part required by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="">       tcMultiplyPart.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="uncoveredLine">    partCount = static_cast<unsigned int>(D.lastSigDigit - D.firstSigDigit) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="uncoveredLine">    partCount = partCountForBits(1 + 196 * partCount / 59);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="uncoveredLine">    decSignificand = new integerPart[partCount + 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="uncoveredLine">    partCount = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="">    /* Convert to binary efficiently - we do almost all multiplication</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="">       in an integerPart.  When this would overflow do we do a single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="">       bignum multiplication, and then revert again to multiplication</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="">       in an integerPart.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="">      integerPart decValue, val, multiplier;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="uncoveredLine">      val = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="uncoveredLine">      multiplier = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="">      do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="uncoveredLine">        if (*p == '.') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="uncoveredLine">          p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="uncoveredLine">          if (p == str.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="uncoveredLine">            break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="uncoveredLine">        decValue = decDigitValue(*p++);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="uncoveredLine">        if (decValue >= 10U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="uncoveredLine">          delete[] decSignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="uncoveredLine">          return createError("Invalid character in significand");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="uncoveredLine">        multiplier *= 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="uncoveredLine">        val = val * 10 + decValue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="">        /* The maximum number that can be multiplied by ten with any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="">           digit added without overflowing an integerPart.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="uncoveredLine">      } while (p <= D.lastSigDigit && multiplier <= (~ (integerPart) 0 - 9) / 10);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="">      /* Multiply out the current part.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="uncoveredLine">      APInt::tcMultiplyPart(decSignificand, decSignificand, multiplier, val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="">                            partCount, partCount + 1, false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="">      /* If we used another part (likely but not guaranteed), increase</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="">         the count.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="uncoveredLine">      if (decSignificand[partCount])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="uncoveredLine">        partCount++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="uncoveredLine">    } while (p <= D.lastSigDigit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="uncoveredLine">    category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="uncoveredLine">    fs = roundSignificandWithExponent(decSignificand, partCount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="">                                      D.exponent, rounding_mode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="uncoveredLine">    delete [] decSignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="uncoveredLine">  return fs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="uncoveredLine">bool IEEEFloat::convertFromStringSpecials(StringRef str) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="uncoveredLine">  const size_t MIN_NAME_SIZE = 3;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="uncoveredLine">  if (str.size() < MIN_NAME_SIZE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="uncoveredLine">  if (str.equals("inf") || str.equals("INFINITY") || str.equals("+Inf")) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="uncoveredLine">    makeInf(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="uncoveredLine">  bool IsNegative = str.front() == '-';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="uncoveredLine">  if (IsNegative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="uncoveredLine">    str = str.drop_front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="uncoveredLine">    if (str.size() < MIN_NAME_SIZE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="uncoveredLine">    if (str.equals("inf") || str.equals("INFINITY") || str.equals("Inf")) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="uncoveredLine">      makeInf(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="">  // If we have a 's' (or 'S') prefix, then this is a Signaling NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="uncoveredLine">  bool IsSignaling = str.front() == 's' || str.front() == 'S';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="uncoveredLine">  if (IsSignaling) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="uncoveredLine">    str = str.drop_front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="uncoveredLine">    if (str.size() < MIN_NAME_SIZE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="uncoveredLine">  if (str.startswith("nan") || str.startswith("NaN")) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="uncoveredLine">    str = str.drop_front(3);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="">    // A NaN without payload.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="uncoveredLine">    if (str.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="uncoveredLine">      makeNaN(IsSignaling, IsNegative);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="">    // Allow the payload to be inside parentheses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="uncoveredLine">    if (str.front() == '(') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="">      // Parentheses should be balanced (and not empty).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="uncoveredLine">      if (str.size() <= 2 || str.back() != ')')</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="uncoveredLine">      str = str.slice(1, str.size() - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="">    // Determine the payload number's radix.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="uncoveredLine">    unsigned Radix = 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="uncoveredLine">    if (str[0] == '0') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="uncoveredLine">      if (str.size() > 1 && tolower(str[1]) == 'x') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="uncoveredLine">        str = str.drop_front(2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="uncoveredLine">        Radix = 16;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="">      } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="uncoveredLine">        Radix = 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="">    // Parse the payload and make the NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="uncoveredLine">    APInt Payload;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="uncoveredLine">    if (!str.getAsInteger(Radix, Payload)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="uncoveredLine">      makeNaN(IsSignaling, IsNegative, &Payload);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="">Expected<IEEEFloat::opStatus></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="uncoveredLine">IEEEFloat::convertFromString(StringRef str, roundingMode rounding_mode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="uncoveredLine">  if (str.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="uncoveredLine">    return createError("Invalid string length");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="">  // Handle special cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="uncoveredLine">  if (convertFromStringSpecials(str))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="">  /* Handle a leading minus sign.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="uncoveredLine">  StringRef::iterator p = str.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="uncoveredLine">  size_t slen = str.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="uncoveredLine">  sign = *p == '-' ? 1 : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="uncoveredLine">  if (*p == '-' || *p == '+') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="uncoveredLine">    slen--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="uncoveredLine">    if (!slen)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="uncoveredLine">      return createError("String has no digits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="uncoveredLine">  if (slen >= 2 && p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="uncoveredLine">    if (slen == 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="uncoveredLine">      return createError("Invalid string");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="">    return convertFromHexadecimalString(StringRef(p + 2, slen - 2),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="uncoveredLine">                                        rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="uncoveredLine">  return convertFromDecimalString(StringRef(p, slen), rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="">/* Write out a hexadecimal representation of the floating point value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="">   to DST, which must be of sufficient size, in the C99 form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="">   [-]0xh.hhhhp[+-]d.  Return the number of characters written,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="">   excluding the terminating NUL.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="">   If UPPERCASE, the output is in upper case, otherwise in lower case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="">   HEXDIGITS digits appear altogether, rounding the value if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="">   necessary.  If HEXDIGITS is 0, the minimal precision to display the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="">   number precisely is used instead.  If nothing would appear after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="">   the decimal point it is suppressed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="">   The decimal exponent is always printed and has at least one digit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="">   Zero values display an exponent of zero.  Infinities and NaNs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="">   appear as "infinity" or "nan" respectively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="">   The above rules are as specified by C99.  There is ambiguity about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="">   what the leading hexadecimal digit should be.  This implementation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="">   uses whatever is necessary so that the exponent is displayed as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="">   stored.  This implies the exponent will fall within the IEEE format</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="">   range, and the leading hexadecimal digit will be 0 (for denormals),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="">   1 (normal numbers) or 2 (normal numbers rounded-away-from-zero with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="">   any other digits zero).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="">*/</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="uncoveredLine">unsigned int IEEEFloat::convertToHexString(char *dst, unsigned int hexDigits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="">                                           bool upperCase,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="">                                           roundingMode rounding_mode) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="">  char *p;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="uncoveredLine">  p = dst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="uncoveredLine">  if (sign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="uncoveredLine">    *dst++ = '-';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="uncoveredLine">  switch (category) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="uncoveredLine">  case fcInfinity:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="uncoveredLine">    memcpy (dst, upperCase ? infinityU: infinityL, sizeof infinityU - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="uncoveredLine">    dst += sizeof infinityL - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="uncoveredLine">  case fcNaN:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="uncoveredLine">    memcpy (dst, upperCase ? NaNU: NaNL, sizeof NaNU - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="uncoveredLine">    dst += sizeof NaNU - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="uncoveredLine">  case fcZero:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="uncoveredLine">    *dst++ = '0';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="uncoveredLine">    *dst++ = upperCase ? 'X': 'x';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="uncoveredLine">    *dst++ = '0';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="uncoveredLine">    if (hexDigits > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="uncoveredLine">      *dst++ = '.';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="uncoveredLine">      memset (dst, '0', hexDigits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="uncoveredLine">      dst += hexDigits - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="uncoveredLine">    *dst++ = upperCase ? 'P': 'p';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="uncoveredLine">    *dst++ = '0';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="uncoveredLine">  case fcNormal:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="uncoveredLine">    dst = convertNormalToHexString (dst, hexDigits, upperCase, rounding_mode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="uncoveredLine">  *dst = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="uncoveredLine">  return static_cast<unsigned int>(dst - p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="">/* Does the hard work of outputting the correctly rounded hexadecimal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="">   form of a normal floating point number with the specified number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="">   hexadecimal digits.  If HEXDIGITS is zero the minimum number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="">   digits necessary to print the value precisely is output.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="uncoveredLine">char *IEEEFloat::convertNormalToHexString(char *dst, unsigned int hexDigits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="">                                          bool upperCase,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="">                                          roundingMode rounding_mode) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="">  unsigned int count, valueBits, shift, partsCount, outputDigits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="">  const char *hexDigitChars;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="">  const integerPart *significand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="">  char *p;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="">  bool roundUp;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="uncoveredLine">  *dst++ = '0';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="uncoveredLine">  *dst++ = upperCase ? 'X': 'x';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="uncoveredLine">  roundUp = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="uncoveredLine">  hexDigitChars = upperCase ? hexDigitsUpper: hexDigitsLower;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="uncoveredLine">  significand = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="uncoveredLine">  partsCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="">  /* +3 because the first digit only uses the single integer bit, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="">     we have 3 virtual zero most-significant-bits.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="uncoveredLine">  valueBits = semantics->precision + 3;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="uncoveredLine">  shift = integerPartWidth - valueBits % integerPartWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="">  /* The natural number of digits required ignoring trailing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="">     insignificant zeroes.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="uncoveredLine">  outputDigits = (valueBits - significandLSB () + 3) / 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="">  /* hexDigits of zero means use the required number for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="">     precision.  Otherwise, see if we are truncating.  If we are,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="">     find out if we need to round away from zero.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="uncoveredLine">  if (hexDigits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="uncoveredLine">    if (hexDigits < outputDigits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="">      /* We are dropping non-zero bits, so need to check how to round.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="">         "bits" is the number of dropped bits.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="">      unsigned int bits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="">      lostFraction fraction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="uncoveredLine">      bits = valueBits - hexDigits * 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="uncoveredLine">      fraction = lostFractionThroughTruncation (significand, partsCount, bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="uncoveredLine">      roundUp = roundAwayFromZero(rounding_mode, fraction, bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="uncoveredLine">    outputDigits = hexDigits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="">  /* Write the digits consecutively, and start writing in the location</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="">     of the hexadecimal point.  We move the most significant digit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="">     left and add the hexadecimal point later.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="uncoveredLine">  p = ++dst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="uncoveredLine">  count = (valueBits + integerPartWidth - 1) / integerPartWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="uncoveredLine">  while (outputDigits && count) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="">    integerPart part;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="">    /* Put the most significant integerPartWidth bits in "part".  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="uncoveredLine">    if (--count == partsCount)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="uncoveredLine">      part = 0;  /* An imaginary higher zero part.  */</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="uncoveredLine">      part = significand[count] << shift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="uncoveredLine">    if (count && shift)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="uncoveredLine">      part |= significand[count - 1] >> (integerPartWidth - shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="">    /* Convert as much of "part" to hexdigits as we can.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="uncoveredLine">    unsigned int curDigits = integerPartWidth / 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="uncoveredLine">    if (curDigits > outputDigits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="uncoveredLine">      curDigits = outputDigits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="uncoveredLine">    dst += partAsHex (dst, part, curDigits, hexDigitChars);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="uncoveredLine">    outputDigits -= curDigits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="uncoveredLine">  if (roundUp) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="uncoveredLine">    char *q = dst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="">    /* Note that hexDigitChars has a trailing '0'.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="uncoveredLine">      q--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="uncoveredLine">      *q = hexDigitChars[hexDigitValue (*q) + 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="uncoveredLine">    } while (*q == '0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="uncoveredLine">    assert(q >= p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="">    /* Add trailing zeroes.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="uncoveredLine">    memset (dst, '0', outputDigits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="uncoveredLine">    dst += outputDigits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="">  /* Move the most significant digit to before the point, and if there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="">     is something after the decimal point add it.  This must come</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="">     after rounding above.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="uncoveredLine">  p[-1] = p[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="uncoveredLine">  if (dst -1 == p)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="uncoveredLine">    dst--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="uncoveredLine">    p[0] = '.';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="">  /* Finally output the exponent.  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="uncoveredLine">  *dst++ = upperCase ? 'P': 'p';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="uncoveredLine">  return writeSignedDecimal (dst, exponent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="uncoveredLine">hash_code hash_value(const IEEEFloat &Arg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="uncoveredLine">  if (!Arg.isFiniteNonZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="uncoveredLine">    return hash_combine((uint8_t)Arg.category,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="">                        // NaN has no sign, fix it at zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="uncoveredLine">                        Arg.isNaN() ? (uint8_t)0 : (uint8_t)Arg.sign,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="uncoveredLine">                        Arg.semantics->precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="">  // Normal floats need their exponent and significand hashed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="uncoveredLine">  return hash_combine((uint8_t)Arg.category, (uint8_t)Arg.sign,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="uncoveredLine">                      Arg.semantics->precision, Arg.exponent,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="uncoveredLine">                      hash_combine_range(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="">                        Arg.significandParts(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="uncoveredLine">                        Arg.significandParts() + Arg.partCount()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="">// Conversion from APFloat to/from host float/double.  It may eventually be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="">// possible to eliminate these and have everybody deal with APFloats, but that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="">// will take a while.  This approach will not easily extend to long double.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="">// Current implementation requires integerPartWidth==64, which is correct at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="">// the moment but could be made more general.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="">// Denormals have exponent minExponent in APFloat, but minExponent-1 in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="">// the actual IEEE respresentations.  We compensate for that here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertF80LongDoubleAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="uncoveredLine">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="uncoveredLine">  assert(partCount()==2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="">  uint64_t myexponent, mysignificand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="uncoveredLine">  if (isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="uncoveredLine">    myexponent = exponent+16383; //bias</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="uncoveredLine">    mysignificand = significandParts()[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="uncoveredLine">    if (myexponent==1 && !(mysignificand & 0x8000000000000000ULL))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="uncoveredLine">      myexponent = 0;   // denormal</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="uncoveredLine">  } else if (category==fcZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="uncoveredLine">    myexponent = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="uncoveredLine">    mysignificand = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="uncoveredLine">  } else if (category==fcInfinity) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="uncoveredLine">    myexponent = 0x7fff;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="uncoveredLine">    mysignificand = 0x8000000000000000ULL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="uncoveredLine">    assert(category == fcNaN && "Unknown category");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="uncoveredLine">    myexponent = 0x7fff;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="uncoveredLine">    mysignificand = significandParts()[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="">  uint64_t words[2];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="uncoveredLine">  words[0] = mysignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="uncoveredLine">  words[1] =  ((uint64_t)(sign & 1) << 15) |</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="uncoveredLine">              (myexponent & 0x7fffLL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="uncoveredLine">  return APInt(80, words);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertPPCDoubleDoubleAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="uncoveredLine">  assert(semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="uncoveredLine">  assert(partCount()==2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="">  uint64_t words[2];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class="">  bool losesInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="">  // Convert number to double.  To avoid spurious underflows, we re-</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="">  // normalize against the "double" minExponent first, and only *then*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="">  // truncate the mantissa.  The result of that second conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="">  // may be inexact, but should never underflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="">  // Declare fltSemantics before APFloat that uses it (and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="">  // saves pointer to it) to ensure correct destruction order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="uncoveredLine">  fltSemantics extendedSemantics = *semantics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="uncoveredLine">  extendedSemantics.minExponent = semIEEEdouble.minExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="uncoveredLine">  IEEEFloat extended(*this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="uncoveredLine">  fs = extended.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="uncoveredLine">  assert(fs == opOK && !losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="">  (void)fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="uncoveredLine">  IEEEFloat u(extended);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="uncoveredLine">  fs = u.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="uncoveredLine">  assert(fs == opOK || fs == opInexact);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="">  (void)fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="uncoveredLine">  words[0] = *u.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="">  // If conversion was exact or resulted in a special case, we're done;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="">  // just set the second double to zero.  Otherwise, re-convert back to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="">  // the extended format and compute the difference.  This now should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="">  // convert exactly to double.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="uncoveredLine">  if (u.isFiniteNonZero() && losesInfo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="uncoveredLine">    fs = u.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="uncoveredLine">    assert(fs == opOK && !losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="">    (void)fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="uncoveredLine">    IEEEFloat v(extended);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="uncoveredLine">    v.subtract(u, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class="uncoveredLine">    fs = v.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="uncoveredLine">    assert(fs == opOK && !losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="">    (void)fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="uncoveredLine">    words[1] = *v.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="uncoveredLine">    words[1] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="uncoveredLine">  return APInt(128, words);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="">template <const fltSemantics &S></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertIEEEFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="uncoveredLine">  assert(semantics == &S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="uncoveredLine">  constexpr int bias = -(S.minExponent - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="uncoveredLine">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="uncoveredLine">  constexpr int integer_bit_part = trailing_significand_bits / integerPartWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="uncoveredLine">  constexpr integerPart integer_bit =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="">      integerPart{1} << (trailing_significand_bits % integerPartWidth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="uncoveredLine">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="uncoveredLine">  constexpr unsigned int exponent_bits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="">  static_assert(exponent_bits < 64);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="uncoveredLine">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="">  uint64_t myexponent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="">  std::array<integerPart, partCountForBits(trailing_significand_bits)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="">      mysignificand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="uncoveredLine">  if (isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="uncoveredLine">    myexponent = exponent + bias;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="uncoveredLine">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="">                mysignificand.begin());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="uncoveredLine">    if (myexponent == 1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="uncoveredLine">        !(significandParts()[integer_bit_part] & integer_bit))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="uncoveredLine">      myexponent = 0; // denormal</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="uncoveredLine">  } else if (category == fcZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="uncoveredLine">    myexponent = ::exponentZero(S) + bias;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="uncoveredLine">    mysignificand.fill(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="uncoveredLine">  } else if (category == fcInfinity) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class="uncoveredLine">    if (S.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="uncoveredLine">      llvm_unreachable("semantics don't support inf!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="uncoveredLine">    myexponent = ::exponentInf(S) + bias;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="uncoveredLine">    mysignificand.fill(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="uncoveredLine">    assert(category == fcNaN && "Unknown category!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="uncoveredLine">    myexponent = ::exponentNaN(S) + bias;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="uncoveredLine">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="">                mysignificand.begin());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="">  std::array<uint64_t, (S.sizeInBits + 63) / 64> words;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="">  auto words_iter =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="uncoveredLine">      std::copy_n(mysignificand.begin(), mysignificand.size(), words.begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="">  if constexpr (significand_mask != 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="">    // Clear the integer bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="uncoveredLine">    words[mysignificand.size() - 1] &= significand_mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="uncoveredLine">  std::fill(words_iter, words.end(), uint64_t{0});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="uncoveredLine">  constexpr size_t last_word = words.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="uncoveredLine">  uint64_t shifted_sign = static_cast<uint64_t>(sign & 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="uncoveredLine">                          << ((S.sizeInBits - 1) % 64);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="uncoveredLine">  words[last_word] |= shifted_sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="uncoveredLine">  uint64_t shifted_exponent = (myexponent & exponent_mask)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="uncoveredLine">                              << (trailing_significand_bits % 64);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="uncoveredLine">  words[last_word] |= shifted_exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="">  if constexpr (last_word == 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="uncoveredLine">    return APInt(S.sizeInBits, words[0]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="uncoveredLine">  return APInt(S.sizeInBits, words);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertQuadrupleAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="uncoveredLine">  assert(partCount() == 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semIEEEquad>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertDoubleAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="uncoveredLine">  assert(partCount()==1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semIEEEdouble>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertFloatAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="uncoveredLine">  assert(partCount()==1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semIEEEsingle>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertBFloatAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="uncoveredLine">  assert(partCount() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semBFloat>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertHalfAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="uncoveredLine">  assert(partCount()==1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semIEEEhalf>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertFloat8E5M2APFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="uncoveredLine">  assert(partCount() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semFloat8E5M2>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertFloat8E5M2FNUZAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="uncoveredLine">  assert(partCount() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semFloat8E5M2FNUZ>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertFloat8E4M3FNAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="uncoveredLine">  assert(partCount() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semFloat8E4M3FN>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertFloat8E4M3FNUZAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="uncoveredLine">  assert(partCount() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semFloat8E4M3FNUZ>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertFloat8E4M3B11FNUZAPFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="uncoveredLine">  assert(partCount() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semFloat8E4M3B11FNUZ>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="uncoveredLine">APInt IEEEFloat::convertFloatTF32APFloatToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="uncoveredLine">  assert(partCount() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="uncoveredLine">  return convertIEEEFloatToAPInt<semFloatTF32>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="">// This function creates an APInt that is just a bit map of the floating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="">// point constant as it would appear in memory.  It is not a conversion,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="">// and treating the result as a normal integer is unlikely to be useful.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="uncoveredLine">APInt IEEEFloat::bitcastToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEhalf)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="uncoveredLine">    return convertHalfAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semBFloat)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="uncoveredLine">    return convertBFloatAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEsingle)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="uncoveredLine">    return convertFloatAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEdouble)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="uncoveredLine">    return convertDoubleAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEquad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="uncoveredLine">    return convertQuadrupleAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="uncoveredLine">    return convertPPCDoubleDoubleAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="uncoveredLine">    return convertFloat8E5M2APFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2FNUZ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="uncoveredLine">    return convertFloat8E5M2FNUZAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="uncoveredLine">    return convertFloat8E4M3FNAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FNUZ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="uncoveredLine">    return convertFloat8E4M3FNUZAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3B11FNUZ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="uncoveredLine">    return convertFloat8E4M3B11FNUZAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="uncoveredLine">  if (semantics == (const llvm::fltSemantics *)&semFloatTF32)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="uncoveredLine">    return convertFloatTF32APFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="uncoveredLine">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="">         "unknown format!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="uncoveredLine">  return convertF80LongDoubleAPFloatToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="uncoveredLine">float IEEEFloat::convertToFloat() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="uncoveredLine">  assert(semantics == (const llvm::fltSemantics*)&semIEEEsingle &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="">         "Float semantics are not IEEEsingle");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="uncoveredLine">  APInt api = bitcastToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="uncoveredLine">  return api.bitsToFloat();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="uncoveredLine">double IEEEFloat::convertToDouble() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="uncoveredLine">  assert(semantics == (const llvm::fltSemantics*)&semIEEEdouble &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="">         "Float semantics are not IEEEdouble");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="uncoveredLine">  APInt api = bitcastToAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="uncoveredLine">  return api.bitsToDouble();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="">/// Integer bit is explicit in this format.  Intel hardware (387 and later)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="">/// does not support these bit patterns:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="">///  exponent = all 1's, integer bit 0, significand 0 ("pseudoinfinity")</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="">///  exponent = all 1's, integer bit 0, significand nonzero ("pseudoNaN")</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="">///  exponent!=0 nor all 1's, integer bit 0 ("unnormal")</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="">///  exponent = 0, integer bit 1 ("pseudodenormal")</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="">/// At the moment, the first three are treated as NaNs, the last one as Normal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="uncoveredLine">void IEEEFloat::initFromF80LongDoubleAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="uncoveredLine">  uint64_t i1 = api.getRawData()[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="uncoveredLine">  uint64_t i2 = api.getRawData()[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="uncoveredLine">  uint64_t myexponent = (i2 & 0x7fff);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="uncoveredLine">  uint64_t mysignificand = i1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="uncoveredLine">  uint8_t myintegerbit = mysignificand >> 63;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="uncoveredLine">  initialize(&semX87DoubleExtended);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="uncoveredLine">  assert(partCount()==2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="uncoveredLine">  sign = static_cast<unsigned int>(i2>>15);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="uncoveredLine">  if (myexponent == 0 && mysignificand == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="uncoveredLine">    makeZero(sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="uncoveredLine">  } else if (myexponent==0x7fff && mysignificand==0x8000000000000000ULL) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="uncoveredLine">    makeInf(sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="uncoveredLine">  } else if ((myexponent == 0x7fff && mysignificand != 0x8000000000000000ULL) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="uncoveredLine">             (myexponent != 0x7fff && myexponent != 0 && myintegerbit == 0)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="uncoveredLine">    category = fcNaN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="uncoveredLine">    exponent = exponentNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class="uncoveredLine">    significandParts()[0] = mysignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="uncoveredLine">    significandParts()[1] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="uncoveredLine">    category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="uncoveredLine">    exponent = myexponent - 16383;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="uncoveredLine">    significandParts()[0] = mysignificand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="uncoveredLine">    significandParts()[1] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="uncoveredLine">    if (myexponent==0)          // denormal</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="uncoveredLine">      exponent = -16382;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="uncoveredLine">void IEEEFloat::initFromPPCDoubleDoubleAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="uncoveredLine">  uint64_t i1 = api.getRawData()[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="uncoveredLine">  uint64_t i2 = api.getRawData()[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="">  opStatus fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="">  bool losesInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="">  // Get the first double and convert to our format.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="uncoveredLine">  initFromDoubleAPInt(APInt(64, i1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="uncoveredLine">  fs = convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="uncoveredLine">  assert(fs == opOK && !losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="">  (void)fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="">  // Unless we have a special case, add in second double.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="uncoveredLine">  if (isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="uncoveredLine">    IEEEFloat v(semIEEEdouble, APInt(64, i2));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="uncoveredLine">    fs = v.convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="uncoveredLine">    assert(fs == opOK && !losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="">    (void)fs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="uncoveredLine">    add(v, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="">template <const fltSemantics &S></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="coveredLine">void IEEEFloat::initFromIEEEAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="coveredLine">  assert(api.getBitWidth() == S.sizeInBits);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="coveredLine">  constexpr integerPart integer_bit = integerPart{1}</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="">                                      << ((S.precision - 1) % integerPartWidth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="coveredLine">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="coveredLine">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="coveredLine">  constexpr unsigned int stored_significand_parts =</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="">      partCountForBits(trailing_significand_bits);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="coveredLine">  constexpr unsigned int exponent_bits =</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="">  static_assert(exponent_bits < 64);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="coveredLine">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="coveredLine">  constexpr int bias = -(S.minExponent - 1);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="">  // Copy the bits of the significand. We need to clear out the exponent and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="">  // sign bit in the last word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="">  std::array<integerPart, stored_significand_parts> mysignificand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="coveredLine">  std::copy_n(api.getRawData(), mysignificand.size(), mysignificand.begin());</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="">  if constexpr (significand_mask != 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="coveredLine">    mysignificand[mysignificand.size() - 1] &= significand_mask;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="">  // We assume the last word holds the sign bit, the exponent, and potentially</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="">  // some of the trailing significand field.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="coveredLine">  uint64_t last_word = api.getRawData()[api.getNumWords() - 1];</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="coveredLine">  uint64_t myexponent =</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="coveredLine">      (last_word >> (trailing_significand_bits % 64)) & exponent_mask;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="coveredLine">  initialize(&S);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="coveredLine">  assert(partCount() == mysignificand.size());</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="coveredLine">  sign = static_cast<unsigned int>(last_word >> ((S.sizeInBits - 1) % 64));</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="">  bool all_zero_significand =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="coveredLine">      llvm::all_of(mysignificand, [](integerPart bits) { return bits == 0; });</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="coveredLine">  bool is_zero = myexponent == 0 && all_zero_significand;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="">  if constexpr (S.nonFiniteBehavior == fltNonfiniteBehavior::IEEE754) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="coveredLine">    if (myexponent - bias == ::exponentInf(S) && all_zero_significand) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="uncoveredLine">      makeInf(sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="coveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="coveredLine">  bool is_nan = false;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="">  if constexpr (S.nanEncoding == fltNanEncoding::IEEE) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="coveredLine">    is_nan = myexponent - bias == ::exponentNaN(S) && !all_zero_significand;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="">  } else if constexpr (S.nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="uncoveredLine">    bool all_ones_significand =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="uncoveredLine">        std::all_of(mysignificand.begin(), mysignificand.end() - 1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="uncoveredLine">                    [](integerPart bits) { return bits == ~integerPart{0}; }) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class="">        (!significand_mask ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="uncoveredLine">         mysignificand[mysignificand.size() - 1] == significand_mask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="uncoveredLine">    is_nan = myexponent - bias == ::exponentNaN(S) && all_ones_significand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="">  } else if constexpr (S.nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="uncoveredLine">    is_nan = is_zero && sign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="coveredLine">  if (is_nan) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="uncoveredLine">    category = fcNaN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="uncoveredLine">    exponent = ::exponentNaN(S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="uncoveredLine">    std::copy_n(mysignificand.begin(), mysignificand.size(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="">                significandParts());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="coveredLine">  if (is_zero) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="coveredLine">    makeZero(sign);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="coveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="uncoveredLine">  exponent = myexponent - bias;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="uncoveredLine">  std::copy_n(mysignificand.begin(), mysignificand.size(), significandParts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="uncoveredLine">  if (myexponent == 0) // denormal</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="uncoveredLine">    exponent = S.minExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="uncoveredLine">    significandParts()[mysignificand.size()-1] |= integer_bit; // integer bit</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="uncoveredLine">void IEEEFloat::initFromQuadrupleAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semIEEEquad>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="coveredLine">void IEEEFloat::initFromDoubleAPInt(const APInt &api) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="coveredLine">  initFromIEEEAPInt<semIEEEdouble>(api);</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="coveredLine">}</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="uncoveredLine">void IEEEFloat::initFromFloatAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semIEEEsingle>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="uncoveredLine">void IEEEFloat::initFromBFloatAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semBFloat>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="uncoveredLine">void IEEEFloat::initFromHalfAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semIEEEhalf>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="uncoveredLine">void IEEEFloat::initFromFloat8E5M2APInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semFloat8E5M2>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="uncoveredLine">void IEEEFloat::initFromFloat8E5M2FNUZAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semFloat8E5M2FNUZ>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="uncoveredLine">void IEEEFloat::initFromFloat8E4M3FNAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semFloat8E4M3FN>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="uncoveredLine">void IEEEFloat::initFromFloat8E4M3FNUZAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semFloat8E4M3FNUZ>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="uncoveredLine">void IEEEFloat::initFromFloat8E4M3B11FNUZAPInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semFloat8E4M3B11FNUZ>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="uncoveredLine">void IEEEFloat::initFromFloatTF32APInt(const APInt &api) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="uncoveredLine">  initFromIEEEAPInt<semFloatTF32>(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="">/// Treat api as containing the bits of a floating point number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="coveredLine">void IEEEFloat::initFromAPInt(const fltSemantics *Sem, const APInt &api) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="coveredLine">  assert(api.getBitWidth() == Sem->sizeInBits);</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class="coveredLine">  if (Sem == &semIEEEhalf)</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="uncoveredLine">    return initFromHalfAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="coveredLine">  if (Sem == &semBFloat)</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="uncoveredLine">    return initFromBFloatAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="coveredLine">  if (Sem == &semIEEEsingle)</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="uncoveredLine">    return initFromFloatAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="coveredLine">  if (Sem == &semIEEEdouble)</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="coveredLine">    return initFromDoubleAPInt(api);</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="uncoveredLine">  if (Sem == &semX87DoubleExtended)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="uncoveredLine">    return initFromF80LongDoubleAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="uncoveredLine">  if (Sem == &semIEEEquad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="uncoveredLine">    return initFromQuadrupleAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="uncoveredLine">  if (Sem == &semPPCDoubleDoubleLegacy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="uncoveredLine">    return initFromPPCDoubleDoubleAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="uncoveredLine">  if (Sem == &semFloat8E5M2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="uncoveredLine">    return initFromFloat8E5M2APInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="uncoveredLine">  if (Sem == &semFloat8E5M2FNUZ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="uncoveredLine">    return initFromFloat8E5M2FNUZAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="uncoveredLine">  if (Sem == &semFloat8E4M3FN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="uncoveredLine">    return initFromFloat8E4M3FNAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="uncoveredLine">  if (Sem == &semFloat8E4M3FNUZ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="uncoveredLine">    return initFromFloat8E4M3FNUZAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="uncoveredLine">  if (Sem == &semFloat8E4M3B11FNUZ)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="uncoveredLine">    return initFromFloat8E4M3B11FNUZAPInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="uncoveredLine">  if (Sem == &semFloatTF32)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="uncoveredLine">    return initFromFloatTF32APInt(api);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="uncoveredLine">  llvm_unreachable(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="">/// Make this number the largest magnitude normal number in the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="">/// semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="uncoveredLine">void IEEEFloat::makeLargest(bool Negative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="">  // We want (in interchange format):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="">  //   sign = {Negative}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="">  //   exponent = 1..10</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="">  //   significand = 1..1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="uncoveredLine">  sign = Negative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="uncoveredLine">  exponent = semantics->maxExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="">  // Use memset to set all but the highest integerPart to all ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="uncoveredLine">  integerPart *significand = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="uncoveredLine">  unsigned PartCount = partCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="uncoveredLine">  memset(significand, 0xFF, sizeof(integerPart)*(PartCount - 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="">  // Set the high integerPart especially setting all unused top bits for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="">  // internal consistency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="uncoveredLine">  const unsigned NumUnusedHighBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="uncoveredLine">    PartCount*integerPartWidth - semantics->precision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="uncoveredLine">  significand[PartCount - 1] = (NumUnusedHighBits < integerPartWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="uncoveredLine">                                   ? (~integerPart(0) >> NumUnusedHighBits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="">                                   : 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="uncoveredLine">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="uncoveredLine">    significand[0] &= ~integerPart(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="">/// Make this number the smallest magnitude denormal number in the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="">/// semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="uncoveredLine">void IEEEFloat::makeSmallest(bool Negative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="">  // We want (in interchange format):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="">  //   sign = {Negative}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="">  //   exponent = 0..0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="">  //   significand = 0..01</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="uncoveredLine">  sign = Negative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="uncoveredLine">  exponent = semantics->minExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="uncoveredLine">  APInt::tcSet(significandParts(), 1, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="uncoveredLine">void IEEEFloat::makeSmallestNormalized(bool Negative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="">  // We want (in interchange format):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="">  //   sign = {Negative}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="">  //   exponent = 0..0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="">  //   significand = 10..0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="uncoveredLine">  category = fcNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="uncoveredLine">  zeroSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="uncoveredLine">  sign = Negative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="uncoveredLine">  exponent = semantics->minExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="uncoveredLine">  APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="uncoveredLine">IEEEFloat::IEEEFloat(const fltSemantics &Sem, const APInt &API) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="uncoveredLine">  initFromAPInt(&Sem, API);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="uncoveredLine">IEEEFloat::IEEEFloat(float f) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="uncoveredLine">  initFromAPInt(&semIEEEsingle, APInt::floatToBits(f));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="coveredLine">IEEEFloat::IEEEFloat(double d) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="coveredLine">  initFromAPInt(&semIEEEdouble, APInt::doubleToBits(d));</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="coveredLine">}</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="uncoveredLine">  void append(SmallVectorImpl<char> &Buffer, StringRef Str) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="uncoveredLine">    Buffer.append(Str.begin(), Str.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="">  /// Removes data from the given significand until it is no more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class="">  /// precise than is required for the desired precision.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="uncoveredLine">  void AdjustToPrecision(APInt &significand,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="">                         int &exp, unsigned FormatPrecision) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="uncoveredLine">    unsigned bits = significand.getActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="">    // 196/59 is a very slight overestimate of lg_2(10).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="uncoveredLine">    unsigned bitsRequired = (FormatPrecision * 196 + 58) / 59;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="uncoveredLine">    if (bits <= bitsRequired) return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="uncoveredLine">    unsigned tensRemovable = (bits - bitsRequired) * 59 / 196;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="uncoveredLine">    if (!tensRemovable) return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="uncoveredLine">    exp += tensRemovable;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="uncoveredLine">    APInt divisor(significand.getBitWidth(), 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="uncoveredLine">    APInt powten(significand.getBitWidth(), 10);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="">    while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="uncoveredLine">      if (tensRemovable & 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="uncoveredLine">        divisor *= powten;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="uncoveredLine">      tensRemovable >>= 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="uncoveredLine">      if (!tensRemovable) break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="uncoveredLine">      powten *= powten;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="uncoveredLine">    significand = significand.udiv(divisor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="">    // Truncate the significand down to its active bit count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class="uncoveredLine">    significand = significand.trunc(significand.getActiveBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="uncoveredLine">  void AdjustToPrecision(SmallVectorImpl<char> &buffer,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="">                         int &exp, unsigned FormatPrecision) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="uncoveredLine">    unsigned N = buffer.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class="uncoveredLine">    if (N <= FormatPrecision) return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="">    // The most significant figures are the last ones in the buffer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="uncoveredLine">    unsigned FirstSignificant = N - FormatPrecision;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="">    // Round.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="">    // FIXME: this probably shouldn't use 'round half up'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="">    // Rounding down is just a truncation, except we also want to drop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="">    // trailing zeros from the new result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="uncoveredLine">    if (buffer[FirstSignificant - 1] < '5') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class="uncoveredLine">      while (FirstSignificant < N && buffer[FirstSignificant] == '0')</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="uncoveredLine">        FirstSignificant++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="uncoveredLine">      exp += FirstSignificant;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="uncoveredLine">      buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="">    // Rounding up requires a decimal add-with-carry.  If we continue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="">    // the carry, the newly-introduced zeros will just be truncated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="uncoveredLine">    for (unsigned I = FirstSignificant; I != N; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="uncoveredLine">      if (buffer[I] == '9') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="uncoveredLine">        FirstSignificant++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="uncoveredLine">        buffer[I]++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="">    // If we carried through, we have exactly one digit of precision.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="uncoveredLine">    if (FirstSignificant == N) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="uncoveredLine">      exp += FirstSignificant;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="uncoveredLine">      buffer.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="uncoveredLine">      buffer.push_back('1');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="uncoveredLine">    exp += FirstSignificant;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="uncoveredLine">    buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="uncoveredLine">void IEEEFloat::toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="">                         unsigned FormatMaxPadding, bool TruncateZero) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="uncoveredLine">  switch (category) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="uncoveredLine">  case fcInfinity:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="uncoveredLine">    if (isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="uncoveredLine">      return append(Str, "-Inf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="uncoveredLine">      return append(Str, "+Inf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="uncoveredLine">  case fcNaN: return append(Str, "NaN");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="uncoveredLine">  case fcZero:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="uncoveredLine">    if (isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="uncoveredLine">      Str.push_back('-');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="uncoveredLine">    if (!FormatMaxPadding) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="uncoveredLine">      if (TruncateZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="uncoveredLine">        append(Str, "0.0E+0");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="">      else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="uncoveredLine">        append(Str, "0.0");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="uncoveredLine">        if (FormatPrecision > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="uncoveredLine">          Str.append(FormatPrecision - 1, '0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="uncoveredLine">        append(Str, "e+00");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="uncoveredLine">      Str.push_back('0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="uncoveredLine">  case fcNormal:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="uncoveredLine">  if (isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="uncoveredLine">    Str.push_back('-');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="">  // Decompose the number into an APInt and an exponent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="uncoveredLine">  int exp = exponent - ((int) semantics->precision - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="">  APInt significand(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="uncoveredLine">      semantics->precision,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="uncoveredLine">      ArrayRef(significandParts(), partCountForBits(semantics->precision)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="">  // Set FormatPrecision if zero.  We want to do this before we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="">  // truncate trailing zeros, as those are part of the precision.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="uncoveredLine">  if (!FormatPrecision) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="">    // We use enough digits so the number can be round-tripped back to an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="">    // APFloat. The formula comes from "How to Print Floating-Point Numbers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="">    // Accurately" by Steele and White.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="">    // FIXME: Using a formula based purely on the precision is conservative;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="">    // we can print fewer digits depending on the actual value being printed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="">    // FormatPrecision = 2 + floor(significandBits / lg_2(10))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="uncoveredLine">    FormatPrecision = 2 + semantics->precision * 59 / 196;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="">  // Ignore trailing binary zeros.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="uncoveredLine">  int trailingZeros = significand.countr_zero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="uncoveredLine">  exp += trailingZeros;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="uncoveredLine">  significand.lshrInPlace(trailingZeros);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="">  // Change the exponent from 2^e to 10^e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="uncoveredLine">  if (exp == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="">    // Nothing to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="uncoveredLine">  } else if (exp > 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="">    // Just shift left.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="uncoveredLine">    significand = significand.zext(semantics->precision + exp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="uncoveredLine">    significand <<= exp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="uncoveredLine">    exp = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="">  } else { /* exp < 0 */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="uncoveredLine">    int texp = -exp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="">    // We transform this using the identity:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="">    //   (N)(2^-e) == (N)(5^e)(10^-e)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="">    // This means we have to multiply N (the significand) by 5^e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="">    // To avoid overflow, we have to operate on numbers large</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="">    // enough to store N * 5^e:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="">    //   log2(N * 5^e) == log2(N) + e * log2(5)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="">    //                 <= semantics->precision + e * 137 / 59</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="">    //   (log_2(5) ~ 2.321928 < 2.322034 ~ 137/59)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="uncoveredLine">    unsigned precision = semantics->precision + (137 * texp + 136) / 59;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="">    // Multiply significand by 5^e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="">    //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="uncoveredLine">    significand = significand.zext(precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="uncoveredLine">    APInt five_to_the_i(precision, 5);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="">    while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="uncoveredLine">      if (texp & 1) significand *= five_to_the_i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="uncoveredLine">      texp >>= 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="uncoveredLine">      if (!texp) break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="uncoveredLine">      five_to_the_i *= five_to_the_i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="uncoveredLine">  AdjustToPrecision(significand, exp, FormatPrecision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="uncoveredLine">  SmallVector<char, 256> buffer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="">  // Fill the buffer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="uncoveredLine">  unsigned precision = significand.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="uncoveredLine">  if (precision < 4) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="">    // We need enough precision to store the value 10.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="uncoveredLine">    precision = 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="uncoveredLine">    significand = significand.zext(precision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="uncoveredLine">  APInt ten(precision, 10);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="uncoveredLine">  APInt digit(precision, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="uncoveredLine">  bool inTrail = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="uncoveredLine">  while (significand != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="">    // digit <- significand % 10</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="">    // significand <- significand / 10</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="uncoveredLine">    APInt::udivrem(significand, ten, significand, digit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="uncoveredLine">    unsigned d = digit.getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="">    // Drop trailing zeros.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="uncoveredLine">    if (inTrail && !d) exp++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="">    else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="uncoveredLine">      buffer.push_back((char) ('0' + d));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="uncoveredLine">      inTrail = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="uncoveredLine">  assert(!buffer.empty() && "no characters in buffer!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="">  // Drop down to FormatPrecision.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="">  // TODO: don't do more precise calculations above than are required.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="uncoveredLine">  AdjustToPrecision(buffer, exp, FormatPrecision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="uncoveredLine">  unsigned NDigits = buffer.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="">  // Check whether we should use scientific notation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="">  bool FormatScientific;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="uncoveredLine">  if (!FormatMaxPadding)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="uncoveredLine">    FormatScientific = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="uncoveredLine">    if (exp >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="">      // 765e3 --> 765000</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="">      //              ^^^</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="">      // But we shouldn't make the number look more precise than it is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="uncoveredLine">      FormatScientific = ((unsigned) exp > FormatMaxPadding ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="uncoveredLine">                          NDigits + (unsigned) exp > FormatPrecision);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="">      // Power of the most significant digit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="uncoveredLine">      int MSD = exp + (int) (NDigits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="uncoveredLine">      if (MSD >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="">        // 765e-2 == 7.65</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="uncoveredLine">        FormatScientific = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="">        // 765e-5 == 0.00765</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="">        //           ^ ^^</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="uncoveredLine">        FormatScientific = ((unsigned) -MSD) > FormatMaxPadding;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="">  // Scientific formatting is pretty straightforward.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="uncoveredLine">  if (FormatScientific) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="uncoveredLine">    exp += (NDigits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="uncoveredLine">    Str.push_back(buffer[NDigits-1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="uncoveredLine">    Str.push_back('.');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="uncoveredLine">    if (NDigits == 1 && TruncateZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="uncoveredLine">      Str.push_back('0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="uncoveredLine">      for (unsigned I = 1; I != NDigits; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="uncoveredLine">        Str.push_back(buffer[NDigits-1-I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="">    // Fill with zeros up to FormatPrecision.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="uncoveredLine">    if (!TruncateZero && FormatPrecision > NDigits - 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="uncoveredLine">      Str.append(FormatPrecision - NDigits + 1, '0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="">    // For !TruncateZero we use lower 'e'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="uncoveredLine">    Str.push_back(TruncateZero ? 'E' : 'e');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="uncoveredLine">    Str.push_back(exp >= 0 ? '+' : '-');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="uncoveredLine">    if (exp < 0) exp = -exp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="uncoveredLine">    SmallVector<char, 6> expbuf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="uncoveredLine">      expbuf.push_back((char) ('0' + (exp % 10)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class="uncoveredLine">      exp /= 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="uncoveredLine">    } while (exp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="">    // Exponent always at least two digits if we do not truncate zeros.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="uncoveredLine">    if (!TruncateZero && expbuf.size() < 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="uncoveredLine">      expbuf.push_back('0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="uncoveredLine">    for (unsigned I = 0, E = expbuf.size(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="uncoveredLine">      Str.push_back(expbuf[E-1-I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="">  // Non-scientific, positive exponents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="uncoveredLine">  if (exp >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="uncoveredLine">    for (unsigned I = 0; I != NDigits; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="uncoveredLine">      Str.push_back(buffer[NDigits-1-I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="uncoveredLine">    for (unsigned I = 0; I != (unsigned) exp; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="uncoveredLine">      Str.push_back('0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="">  // Non-scientific, negative exponents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="">  // The number of digits to the left of the decimal point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="uncoveredLine">  int NWholeDigits = exp + (int) NDigits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="uncoveredLine">  unsigned I = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="uncoveredLine">  if (NWholeDigits > 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="uncoveredLine">    for (; I != (unsigned) NWholeDigits; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="uncoveredLine">      Str.push_back(buffer[NDigits-I-1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="uncoveredLine">    Str.push_back('.');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="uncoveredLine">    unsigned NZeros = 1 + (unsigned) -NWholeDigits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="uncoveredLine">    Str.push_back('0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="uncoveredLine">    Str.push_back('.');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="uncoveredLine">    for (unsigned Z = 1; Z != NZeros; ++Z)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="uncoveredLine">      Str.push_back('0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="uncoveredLine">  for (; I != NDigits; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="uncoveredLine">    Str.push_back(buffer[NDigits-I-1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="uncoveredLine">bool IEEEFloat::getExactInverse(APFloat *inv) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="">  // Special floats and denormals have no exact inverse.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="uncoveredLine">  if (!isFiniteNonZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="">  // Check that the number is a power of two by making sure that only the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="">  // integer bit is set in the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="uncoveredLine">  if (significandLSB() != semantics->precision - 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="">  // Get the inverse.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="uncoveredLine">  IEEEFloat reciprocal(*semantics, 1ULL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="uncoveredLine">  if (reciprocal.divide(*this, rmNearestTiesToEven) != opOK)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="">  // Avoid multiplication with a denormal, it is not safe on all platforms and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="">  // may be slower than a normal division.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="uncoveredLine">  if (reciprocal.isDenormal())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="uncoveredLine">  assert(reciprocal.isFiniteNonZero() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="">         reciprocal.significandLSB() == reciprocal.semantics->precision - 1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="uncoveredLine">  if (inv)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="uncoveredLine">    *inv = APFloat(reciprocal, *semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="uncoveredLine">bool IEEEFloat::isSignaling() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="uncoveredLine">  if (!isNaN())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="">  // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="">  // first bit of the trailing significand being 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="uncoveredLine">  return !APInt::tcExtractBit(significandParts(), semantics->precision - 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="">/// IEEE-754R 2008 5.3.1: nextUp/nextDown.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="">/// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="">/// appropriate sign switching before/after the computation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="uncoveredLine">IEEEFloat::opStatus IEEEFloat::next(bool nextDown) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="">  // If we are performing nextDown, swap sign so we have -x.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="uncoveredLine">  if (nextDown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="uncoveredLine">    changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="">  // Compute nextUp(x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="uncoveredLine">  opStatus result = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="">  // Handle each float category separately.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="uncoveredLine">  switch (category) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class="uncoveredLine">  case fcInfinity:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="">    // nextUp(+inf) = +inf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="uncoveredLine">    if (!isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="">    // nextUp(-inf) = -getLargest()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="uncoveredLine">    makeLargest(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="uncoveredLine">  case fcNaN:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="">    // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="">    // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="">    //                     change the payload.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="uncoveredLine">    if (isSignaling()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="uncoveredLine">      result = opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="">      // For consistency, propagate the sign of the sNaN to the qNaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="uncoveredLine">      makeNaN(false, isNegative(), nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="uncoveredLine">  case fcZero:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="">    // nextUp(pm 0) = +getSmallest()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="uncoveredLine">    makeSmallest(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="uncoveredLine">  case fcNormal:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="">    // nextUp(-getSmallest()) = -0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="uncoveredLine">    if (isSmallest() && isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="uncoveredLine">      APInt::tcSet(significandParts(), 0, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="uncoveredLine">      category = fcZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="uncoveredLine">      exponent = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="uncoveredLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="uncoveredLine">        sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="uncoveredLine">    if (isLargest() && !isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="uncoveredLine">      if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="">        // nextUp(getLargest()) == NAN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="uncoveredLine">        makeNaN();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="">        // nextUp(getLargest()) == INFINITY</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="uncoveredLine">        APInt::tcSet(significandParts(), 0, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="uncoveredLine">        category = fcInfinity;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="uncoveredLine">        exponent = semantics->maxExponent + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="">    // nextUp(normal) == normal + inc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="uncoveredLine">    if (isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="">      // If we are negative, we need to decrement the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="">      // We only cross a binade boundary that requires adjusting the exponent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="">      // if:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="">      //   1. exponent != semantics->minExponent. This implies we are not in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="">      //   smallest binade or are dealing with denormals.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="">      //   2. Our significand excluding the integral bit is all zeros.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="">      bool WillCrossBinadeBoundary =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="uncoveredLine">        exponent != semantics->minExponent && isSignificandAllZeros();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="">      // Decrement the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="">      // We always do this since:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="">      //   1. If we are dealing with a non-binade decrement, by definition we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="">      //   just decrement the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="">      //   2. If we are dealing with a normal -> normal binade decrement, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="">      //   we have an explicit integral bit the fact that all bits but the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="">      //   integral bit are zero implies that subtracting one will yield a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class="">      //   significand with 0 integral bit and 1 in all other spots. Thus we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="">      //   must just adjust the exponent and set the integral bit to 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="">      //   3. If we are dealing with a normal -> denormal binade decrement,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="">      //   since we set the integral bit to 0 when we represent denormals, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="">      //   just decrement the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class="uncoveredLine">      integerPart *Parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="uncoveredLine">      APInt::tcDecrement(Parts, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="uncoveredLine">      if (WillCrossBinadeBoundary) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="">        // Our result is a normal number. Do the following:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="">        // 1. Set the integral bit to 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="">        // 2. Decrement the exponent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="uncoveredLine">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="uncoveredLine">        exponent--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="">      // If we are positive, we need to increment the significand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="">      // We only cross a binade boundary that requires adjusting the exponent if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="">      // the input is not a denormal and all of said input's significand bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="">      // are set. If all of said conditions are true: clear the significand, set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="">      // the integral bit to 1, and increment the exponent. If we have a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="">      // denormal always increment since moving denormals and the numbers in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="">      // smallest normal binade have the same exponent in our representation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="uncoveredLine">      bool WillCrossBinadeBoundary = !isDenormal() && isSignificandAllOnes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="uncoveredLine">      if (WillCrossBinadeBoundary) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="uncoveredLine">        integerPart *Parts = significandParts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="uncoveredLine">        APInt::tcSet(Parts, 0, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="uncoveredLine">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="uncoveredLine">        assert(exponent != semantics->maxExponent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="">               "We can not increment an exponent beyond the maxExponent allowed"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="">               " by the given floating point semantics.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="uncoveredLine">        exponent++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="uncoveredLine">        incrementSignificand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="">  // If we are performing nextDown, swap sign so we have -nextUp(-x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="uncoveredLine">  if (nextDown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="uncoveredLine">    changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="uncoveredLine">  return result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="uncoveredLine">APFloatBase::ExponentType IEEEFloat::exponentNaN() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="uncoveredLine">  return ::exponentNaN(*semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="uncoveredLine">APFloatBase::ExponentType IEEEFloat::exponentInf() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="uncoveredLine">  return ::exponentInf(*semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="coveredLine">APFloatBase::ExponentType IEEEFloat::exponentZero() const {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="coveredLine">  return ::exponentZero(*semantics);</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="uncoveredLine">void IEEEFloat::makeInf(bool Negative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="">    // There is no Inf, so make NaN instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="uncoveredLine">    makeNaN(false, Negative);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="uncoveredLine">  category = fcInfinity;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="uncoveredLine">  sign = Negative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="uncoveredLine">  exponent = exponentInf();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="uncoveredLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="coveredLine">void IEEEFloat::makeZero(bool Negative) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="coveredLine">  category = fcZero;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="coveredLine">  sign = Negative;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="coveredLine">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="">    // Merge negative zero to positive because 0b10000...000 is used for NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="uncoveredLine">    sign = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="coveredLine">  exponent = exponentZero();</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="coveredLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="coveredLine">}</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="uncoveredLine">void IEEEFloat::makeQuiet() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="uncoveredLine">  assert(isNaN());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="uncoveredLine">  if (semantics->nonFiniteBehavior != fltNonfiniteBehavior::NanOnly)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="uncoveredLine">    APInt::tcSetBit(significandParts(), semantics->precision - 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="uncoveredLine">int ilogb(const IEEEFloat &Arg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="uncoveredLine">  if (Arg.isNaN())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="uncoveredLine">    return IEEEFloat::IEK_NaN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="uncoveredLine">  if (Arg.isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="uncoveredLine">    return IEEEFloat::IEK_Zero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="uncoveredLine">  if (Arg.isInfinity())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="uncoveredLine">    return IEEEFloat::IEK_Inf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="uncoveredLine">  if (!Arg.isDenormal())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="uncoveredLine">    return Arg.exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="uncoveredLine">  IEEEFloat Normalized(Arg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="uncoveredLine">  int SignificandBits = Arg.getSemantics().precision - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="uncoveredLine">  Normalized.exponent += SignificandBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="uncoveredLine">  Normalized.normalize(IEEEFloat::rmNearestTiesToEven, lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="uncoveredLine">  return Normalized.exponent - SignificandBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="uncoveredLine">IEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode RoundingMode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="uncoveredLine">  auto MaxExp = X.getSemantics().maxExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="uncoveredLine">  auto MinExp = X.getSemantics().minExponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="">  // If Exp is wildly out-of-scale, simply adding it to X.exponent will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="">  // overflow; clamp it to a safe range before adding, but ensure that the range</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="">  // is large enough that the clamp does not change the result. The range we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="">  // need to support is the difference between the largest possible exponent and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="">  // the normalized exponent of half the smallest denormal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="uncoveredLine">  int SignificandBits = X.getSemantics().precision - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="uncoveredLine">  int MaxIncrement = MaxExp - (MinExp - SignificandBits) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="">  // Clamp to one past the range ends to let normalize handle overlflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="uncoveredLine">  X.exponent += std::clamp(Exp, -MaxIncrement - 1, MaxIncrement);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="uncoveredLine">  X.normalize(RoundingMode, lfExactlyZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="uncoveredLine">  if (X.isNaN())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="uncoveredLine">    X.makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="uncoveredLine">  return X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="uncoveredLine">IEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="uncoveredLine">  Exp = ilogb(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="">  // Quiet signalling nans.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="uncoveredLine">  if (Exp == IEEEFloat::IEK_NaN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="uncoveredLine">    IEEEFloat Quiet(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="uncoveredLine">    Quiet.makeQuiet();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="uncoveredLine">    return Quiet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="uncoveredLine">  if (Exp == IEEEFloat::IEK_Inf)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="uncoveredLine">    return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="">  // 1 is added because frexp is defined to return a normalized fraction in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="">  // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="uncoveredLine">  Exp = Exp == IEEEFloat::IEK_Zero ? 0 : Exp + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="uncoveredLine">  return scalbn(Val, -Exp, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="uncoveredLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="uncoveredLine">    : Semantics(&S),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="uncoveredLine">      Floats(new APFloat[2]{APFloat(semIEEEdouble), APFloat(semIEEEdouble)}) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="uncoveredLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, uninitializedTag)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="uncoveredLine">    : Semantics(&S),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="uncoveredLine">      Floats(new APFloat[2]{APFloat(semIEEEdouble, uninitialized),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="uncoveredLine">                            APFloat(semIEEEdouble, uninitialized)}) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="uncoveredLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, integerPart I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="uncoveredLine">    : Semantics(&S), Floats(new APFloat[2]{APFloat(semIEEEdouble, I),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="uncoveredLine">                                           APFloat(semIEEEdouble)}) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="uncoveredLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, const APInt &I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="uncoveredLine">    : Semantics(&S),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="uncoveredLine">      Floats(new APFloat[2]{</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="uncoveredLine">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[0])),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="uncoveredLine">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[1]))}) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="uncoveredLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, APFloat &&First,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="">                             APFloat &&Second)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class="uncoveredLine">    : Semantics(&S),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="uncoveredLine">      Floats(new APFloat[2]{std::move(First), std::move(Second)}) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="uncoveredLine">  assert(&Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="uncoveredLine">  assert(&Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="uncoveredLine">DoubleAPFloat::DoubleAPFloat(const DoubleAPFloat &RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="uncoveredLine">    : Semantics(RHS.Semantics),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="uncoveredLine">      Floats(RHS.Floats ? new APFloat[2]{APFloat(RHS.Floats[0]),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="uncoveredLine">                                         APFloat(RHS.Floats[1])}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="uncoveredLine">                        : nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="uncoveredLine">DoubleAPFloat::DoubleAPFloat(DoubleAPFloat &&RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="uncoveredLine">    : Semantics(RHS.Semantics), Floats(std::move(RHS.Floats)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="uncoveredLine">  RHS.Semantics = &semBogus;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="uncoveredLine">DoubleAPFloat &DoubleAPFloat::operator=(const DoubleAPFloat &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="uncoveredLine">  if (Semantics == RHS.Semantics && RHS.Floats) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="uncoveredLine">    Floats[0] = RHS.Floats[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="uncoveredLine">    Floats[1] = RHS.Floats[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="uncoveredLine">  } else if (this != &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="uncoveredLine">    this->~DoubleAPFloat();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="uncoveredLine">    new (this) DoubleAPFloat(RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="">// Implement addition, subtraction, multiplication and division based on:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="">// "Software for Doubled-Precision Floating-Point Computations",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="">// by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::addImpl(const APFloat &a, const APFloat &aa,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="">                                         const APFloat &c, const APFloat &cc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="">                                         roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="uncoveredLine">  int Status = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="uncoveredLine">  APFloat z = a;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="uncoveredLine">  Status |= z.add(c, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="uncoveredLine">  if (!z.isFinite()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="uncoveredLine">    if (!z.isInfinity()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="uncoveredLine">      Floats[0] = std::move(z);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="uncoveredLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="uncoveredLine">      return (opStatus)Status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="uncoveredLine">    Status = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="uncoveredLine">    auto AComparedToC = a.compareAbsoluteValue(c);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="uncoveredLine">    z = cc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="uncoveredLine">    Status |= z.add(aa, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="uncoveredLine">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="">      // z = cc + aa + c + a;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="uncoveredLine">      Status |= z.add(c, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="uncoveredLine">      Status |= z.add(a, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="">      // z = cc + aa + a + c;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="uncoveredLine">      Status |= z.add(a, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="uncoveredLine">      Status |= z.add(c, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="uncoveredLine">    if (!z.isFinite()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="uncoveredLine">      Floats[0] = std::move(z);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="uncoveredLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="uncoveredLine">      return (opStatus)Status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="uncoveredLine">    Floats[0] = z;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="uncoveredLine">    APFloat zz = aa;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="uncoveredLine">    Status |= zz.add(cc, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="uncoveredLine">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="">      // Floats[1] = a - z + c + zz;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="uncoveredLine">      Floats[1] = a;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="uncoveredLine">      Status |= Floats[1].subtract(z, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="uncoveredLine">      Status |= Floats[1].add(c, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="uncoveredLine">      Status |= Floats[1].add(zz, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="">      // Floats[1] = c - z + a + zz;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="uncoveredLine">      Floats[1] = c;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="uncoveredLine">      Status |= Floats[1].subtract(z, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="uncoveredLine">      Status |= Floats[1].add(a, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="uncoveredLine">      Status |= Floats[1].add(zz, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="">    // q = a - z;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="uncoveredLine">    APFloat q = a;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="uncoveredLine">    Status |= q.subtract(z, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="">    // zz = q + c + (a - (q + z)) + aa + cc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="">    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="uncoveredLine">    auto zz = q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="uncoveredLine">    Status |= zz.add(c, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="uncoveredLine">    Status |= q.add(z, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="uncoveredLine">    Status |= q.subtract(a, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="uncoveredLine">    q.changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="uncoveredLine">    Status |= zz.add(q, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="uncoveredLine">    Status |= zz.add(aa, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="uncoveredLine">    Status |= zz.add(cc, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="uncoveredLine">    if (zz.isZero() && !zz.isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="uncoveredLine">      Floats[0] = std::move(z);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="uncoveredLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="uncoveredLine">      return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="uncoveredLine">    Floats[0] = z;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="uncoveredLine">    Status |= Floats[0].add(zz, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="uncoveredLine">    if (!Floats[0].isFinite()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="uncoveredLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="uncoveredLine">      return (opStatus)Status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="uncoveredLine">    Floats[1] = std::move(z);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="uncoveredLine">    Status |= Floats[1].subtract(Floats[0], RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="uncoveredLine">    Status |= Floats[1].add(zz, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="uncoveredLine">  return (opStatus)Status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::addWithSpecial(const DoubleAPFloat &LHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="">                                                const DoubleAPFloat &RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="">                                                DoubleAPFloat &Out,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="">                                                roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="uncoveredLine">  if (LHS.getCategory() == fcNaN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="uncoveredLine">    Out = LHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="uncoveredLine">  if (RHS.getCategory() == fcNaN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="uncoveredLine">    Out = RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="uncoveredLine">  if (LHS.getCategory() == fcZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="uncoveredLine">    Out = RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="uncoveredLine">  if (RHS.getCategory() == fcZero) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="uncoveredLine">    Out = LHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="uncoveredLine">  if (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcInfinity &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="uncoveredLine">      LHS.isNegative() != RHS.isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="uncoveredLine">    Out.makeNaN(false, Out.isNegative(), nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="uncoveredLine">    return opInvalidOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="uncoveredLine">  if (LHS.getCategory() == fcInfinity) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="uncoveredLine">    Out = LHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="uncoveredLine">  if (RHS.getCategory() == fcInfinity) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="uncoveredLine">    Out = RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="uncoveredLine">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="uncoveredLine">  APFloat A(LHS.Floats[0]), AA(LHS.Floats[1]), C(RHS.Floats[0]),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="uncoveredLine">      CC(RHS.Floats[1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="uncoveredLine">  assert(&A.getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="uncoveredLine">  assert(&AA.getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="uncoveredLine">  assert(&C.getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="uncoveredLine">  assert(&CC.getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="uncoveredLine">  assert(&Out.Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="uncoveredLine">  assert(&Out.Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="uncoveredLine">  return Out.addImpl(A, AA, C, CC, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::add(const DoubleAPFloat &RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="">                                     roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="uncoveredLine">  return addWithSpecial(*this, RHS, *this, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::subtract(const DoubleAPFloat &RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="">                                          roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="uncoveredLine">  changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="uncoveredLine">  auto Ret = add(RHS, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="uncoveredLine">  changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::multiply(const DoubleAPFloat &RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="">                                          APFloat::roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="uncoveredLine">  const auto &LHS = *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="uncoveredLine">  auto &Out = *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="">  /* Interesting observation: For special categories, finding the lowest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="">     common ancestor of the following layered graph gives the correct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="">     return category:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="">        NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="">       /   \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="">     Zero  Inf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="">       \   /</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="">       Normal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="">     e.g. NaN * NaN = NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class="">          Zero * Inf = NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="">          Normal * Zero = Zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="">          Normal * Inf = Inf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="">  */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="uncoveredLine">  if (LHS.getCategory() == fcNaN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="uncoveredLine">    Out = LHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="uncoveredLine">  if (RHS.getCategory() == fcNaN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="uncoveredLine">    Out = RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="uncoveredLine">  if ((LHS.getCategory() == fcZero && RHS.getCategory() == fcInfinity) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="uncoveredLine">      (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcZero)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="uncoveredLine">    Out.makeNaN(false, false, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="uncoveredLine">  if (LHS.getCategory() == fcZero || LHS.getCategory() == fcInfinity) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="uncoveredLine">    Out = LHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="uncoveredLine">  if (RHS.getCategory() == fcZero || RHS.getCategory() == fcInfinity) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="uncoveredLine">    Out = RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="uncoveredLine">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="">         "Special cases not handled exhaustively");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="uncoveredLine">  int Status = opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="uncoveredLine">  APFloat A = Floats[0], B = Floats[1], C = RHS.Floats[0], D = RHS.Floats[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="">  // t = a * c</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="uncoveredLine">  APFloat T = A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="uncoveredLine">  Status |= T.multiply(C, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="uncoveredLine">  if (!T.isFiniteNonZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="uncoveredLine">    Floats[0] = T;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="uncoveredLine">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="uncoveredLine">    return (opStatus)Status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="">  // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="uncoveredLine">  APFloat Tau = A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="uncoveredLine">  T.changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="uncoveredLine">  Status |= Tau.fusedMultiplyAdd(C, T, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="uncoveredLine">  T.changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="">  {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="">    // v = a * d</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="uncoveredLine">    APFloat V = A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="uncoveredLine">    Status |= V.multiply(D, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="">    // w = b * c</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="uncoveredLine">    APFloat W = B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="uncoveredLine">    Status |= W.multiply(C, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="uncoveredLine">    Status |= V.add(W, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="">    // tau += v + w</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="uncoveredLine">    Status |= Tau.add(V, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="">  // u = t + tau</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="uncoveredLine">  APFloat U = T;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="uncoveredLine">  Status |= U.add(Tau, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="uncoveredLine">  Floats[0] = U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="uncoveredLine">  if (!U.isFinite()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="uncoveredLine">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="">    // Floats[1] = (t - u) + tau</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="uncoveredLine">    Status |= T.subtract(U, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="uncoveredLine">    Status |= T.add(Tau, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="uncoveredLine">    Floats[1] = T;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="uncoveredLine">  return (opStatus)Status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::divide(const DoubleAPFloat &RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="">                                        APFloat::roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="">  auto Ret =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="uncoveredLine">      Tmp.divide(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()), RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::remainder(const DoubleAPFloat &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="">  auto Ret =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="uncoveredLine">      Tmp.remainder(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::mod(const DoubleAPFloat &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="uncoveredLine">  auto Ret = Tmp.mod(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="">APFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="uncoveredLine">DoubleAPFloat::fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="">                                const DoubleAPFloat &Addend,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="">                                APFloat::roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="uncoveredLine">  auto Ret = Tmp.fusedMultiplyAdd(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="uncoveredLine">      APFloat(semPPCDoubleDoubleLegacy, Multiplicand.bitcastToAPInt()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="uncoveredLine">      APFloat(semPPCDoubleDoubleLegacy, Addend.bitcastToAPInt()), RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::roundToIntegral(APFloat::roundingMode RM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="uncoveredLine">  auto Ret = Tmp.roundToIntegral(RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="uncoveredLine">void DoubleAPFloat::changeSign() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="uncoveredLine">  Floats[0].changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="uncoveredLine">  Floats[1].changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="">APFloat::cmpResult</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="uncoveredLine">DoubleAPFloat::compareAbsoluteValue(const DoubleAPFloat &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="uncoveredLine">  auto Result = Floats[0].compareAbsoluteValue(RHS.Floats[0]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="uncoveredLine">  if (Result != cmpEqual)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="uncoveredLine">    return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="uncoveredLine">  Result = Floats[1].compareAbsoluteValue(RHS.Floats[1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="uncoveredLine">  if (Result == cmpLessThan || Result == cmpGreaterThan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="uncoveredLine">    auto Against = Floats[0].isNegative() ^ Floats[1].isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="uncoveredLine">    auto RHSAgainst = RHS.Floats[0].isNegative() ^ RHS.Floats[1].isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="uncoveredLine">    if (Against && !RHSAgainst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="uncoveredLine">      return cmpLessThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="uncoveredLine">    if (!Against && RHSAgainst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="uncoveredLine">      return cmpGreaterThan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="uncoveredLine">    if (!Against && !RHSAgainst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="uncoveredLine">      return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="uncoveredLine">    if (Against && RHSAgainst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="uncoveredLine">      return (cmpResult)(cmpLessThan + cmpGreaterThan - Result);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="uncoveredLine">APFloat::fltCategory DoubleAPFloat::getCategory() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="uncoveredLine">  return Floats[0].getCategory();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="uncoveredLine">bool DoubleAPFloat::isNegative() const { return Floats[0].isNegative(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="uncoveredLine">void DoubleAPFloat::makeInf(bool Neg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="uncoveredLine">  Floats[0].makeInf(Neg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="uncoveredLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="uncoveredLine">void DoubleAPFloat::makeZero(bool Neg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="uncoveredLine">  Floats[0].makeZero(Neg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="uncoveredLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="uncoveredLine">void DoubleAPFloat::makeLargest(bool Neg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="uncoveredLine">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x7fefffffffffffffull));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="uncoveredLine">  Floats[1] = APFloat(semIEEEdouble, APInt(64, 0x7c8ffffffffffffeull));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="uncoveredLine">  if (Neg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="uncoveredLine">    changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="uncoveredLine">void DoubleAPFloat::makeSmallest(bool Neg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="uncoveredLine">  Floats[0].makeSmallest(Neg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="uncoveredLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="uncoveredLine">void DoubleAPFloat::makeSmallestNormalized(bool Neg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="uncoveredLine">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x0360000000000000ull));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="uncoveredLine">  if (Neg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="uncoveredLine">    Floats[0].changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="uncoveredLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="uncoveredLine">void DoubleAPFloat::makeNaN(bool SNaN, bool Neg, const APInt *fill) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="uncoveredLine">  Floats[0].makeNaN(SNaN, Neg, fill);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="uncoveredLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="uncoveredLine">APFloat::cmpResult DoubleAPFloat::compare(const DoubleAPFloat &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="uncoveredLine">  auto Result = Floats[0].compare(RHS.Floats[0]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="">  // |Float[0]| > |Float[1]|</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="uncoveredLine">  if (Result == APFloat::cmpEqual)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="uncoveredLine">    return Floats[1].compare(RHS.Floats[1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="uncoveredLine">bool DoubleAPFloat::bitwiseIsEqual(const DoubleAPFloat &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="uncoveredLine">  return Floats[0].bitwiseIsEqual(RHS.Floats[0]) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="uncoveredLine">         Floats[1].bitwiseIsEqual(RHS.Floats[1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="uncoveredLine">hash_code hash_value(const DoubleAPFloat &Arg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="uncoveredLine">  if (Arg.Floats)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="uncoveredLine">    return hash_combine(hash_value(Arg.Floats[0]), hash_value(Arg.Floats[1]));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="uncoveredLine">  return hash_combine(Arg.Semantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="uncoveredLine">APInt DoubleAPFloat::bitcastToAPInt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="">  uint64_t Data[] = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="uncoveredLine">      Floats[0].bitcastToAPInt().getRawData()[0],</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="uncoveredLine">      Floats[1].bitcastToAPInt().getRawData()[0],</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="uncoveredLine">  return APInt(128, 2, Data);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="uncoveredLine">Expected<APFloat::opStatus> DoubleAPFloat::convertFromString(StringRef S,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="">                                                             roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="uncoveredLine">  auto Ret = Tmp.convertFromString(S, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::next(bool nextDown) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="uncoveredLine">  auto Ret = Tmp.next(nextDown);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="">APFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="uncoveredLine">DoubleAPFloat::convertToInteger(MutableArrayRef<integerPart> Input,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="">                                unsigned int Width, bool IsSigned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="">                                roundingMode RM, bool *IsExact) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="uncoveredLine">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="uncoveredLine">      .convertToInteger(Input, Width, IsSigned, RM, IsExact);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class="uncoveredLine">APFloat::opStatus DoubleAPFloat::convertFromAPInt(const APInt &Input,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="">                                                  bool IsSigned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="">                                                  roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="uncoveredLine">  auto Ret = Tmp.convertFromAPInt(Input, IsSigned, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="">APFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="uncoveredLine">DoubleAPFloat::convertFromSignExtendedInteger(const integerPart *Input,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="">                                              unsigned int InputSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="">                                              bool IsSigned, roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="uncoveredLine">  auto Ret = Tmp.convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="">APFloat::opStatus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="uncoveredLine">DoubleAPFloat::convertFromZeroExtendedInteger(const integerPart *Input,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="">                                              unsigned int InputSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="">                                              bool IsSigned, roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="uncoveredLine">  auto Ret = Tmp.convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="uncoveredLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="uncoveredLine">unsigned int DoubleAPFloat::convertToHexString(char *DST,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class="">                                               unsigned int HexDigits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="">                                               bool UpperCase,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="">                                               roundingMode RM) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="uncoveredLine">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="uncoveredLine">      .convertToHexString(DST, HexDigits, UpperCase, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class="uncoveredLine">bool DoubleAPFloat::isDenormal() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="uncoveredLine">  return getCategory() == fcNormal &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="uncoveredLine">         (Floats[0].isDenormal() || Floats[1].isDenormal() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="">          // (double)(Hi + Lo) == Hi defines a normal number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="uncoveredLine">          Floats[0] != Floats[0] + Floats[1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="uncoveredLine">bool DoubleAPFloat::isSmallest() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="uncoveredLine">  if (getCategory() != fcNormal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="uncoveredLine">  DoubleAPFloat Tmp(*this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="uncoveredLine">  Tmp.makeSmallest(this->isNegative());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="uncoveredLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="uncoveredLine">bool DoubleAPFloat::isSmallestNormalized() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="uncoveredLine">  if (getCategory() != fcNormal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="uncoveredLine">  DoubleAPFloat Tmp(*this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="uncoveredLine">  Tmp.makeSmallestNormalized(this->isNegative());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="uncoveredLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="uncoveredLine">bool DoubleAPFloat::isLargest() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="uncoveredLine">  if (getCategory() != fcNormal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="uncoveredLine">  DoubleAPFloat Tmp(*this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="uncoveredLine">  Tmp.makeLargest(this->isNegative());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="uncoveredLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="uncoveredLine">bool DoubleAPFloat::isInteger() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="uncoveredLine">  return Floats[0].isInteger() && Floats[1].isInteger();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="uncoveredLine">void DoubleAPFloat::toString(SmallVectorImpl<char> &Str,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="">                             unsigned FormatPrecision,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="">                             unsigned FormatMaxPadding,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="">                             bool TruncateZero) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="uncoveredLine">  APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="uncoveredLine">      .toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="uncoveredLine">bool DoubleAPFloat::getExactInverse(APFloat *inv) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="uncoveredLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="uncoveredLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="uncoveredLine">  if (!inv)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="uncoveredLine">    return Tmp.getExactInverse(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="uncoveredLine">  APFloat Inv(semPPCDoubleDoubleLegacy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="uncoveredLine">  auto Ret = Tmp.getExactInverse(&Inv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="uncoveredLine">  *inv = APFloat(semPPCDoubleDouble, Inv.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="uncoveredLine">DoubleAPFloat scalbn(const DoubleAPFloat &Arg, int Exp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="">                     APFloat::roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="uncoveredLine">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="uncoveredLine">  return DoubleAPFloat(semPPCDoubleDouble, scalbn(Arg.Floats[0], Exp, RM),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="uncoveredLine">                       scalbn(Arg.Floats[1], Exp, RM));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="uncoveredLine">DoubleAPFloat frexp(const DoubleAPFloat &Arg, int &Exp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="">                    APFloat::roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="uncoveredLine">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="uncoveredLine">  APFloat First = frexp(Arg.Floats[0], Exp, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="uncoveredLine">  APFloat Second = Arg.Floats[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="uncoveredLine">  if (Arg.getCategory() == APFloat::fcNormal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="uncoveredLine">    Second = scalbn(Second, -Exp, RM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="uncoveredLine">  return DoubleAPFloat(semPPCDoubleDouble, std::move(First), std::move(Second));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="coveredLine">APFloat::Storage::Storage(IEEEFloat F, const fltSemantics &Semantics) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="coveredLine">  if (usesLayout<IEEEFloat>(Semantics)) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="coveredLine">    new (&IEEE) IEEEFloat(std::move(F));</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="coveredLine">    return;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class="uncoveredLine">  if (usesLayout<DoubleAPFloat>(Semantics)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="uncoveredLine">    const fltSemantics& S = F.getSemantics();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="uncoveredLine">    new (&Double)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="uncoveredLine">        DoubleAPFloat(Semantics, APFloat(std::move(F), S),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="uncoveredLine">                      APFloat(semIEEEdouble));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="uncoveredLine">  llvm_unreachable("Unexpected semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="uncoveredLine">Expected<APFloat::opStatus> APFloat::convertFromString(StringRef Str,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="">                                                       roundingMode RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="uncoveredLine">  APFLOAT_DISPATCH_ON_SEMANTICS(convertFromString(Str, RM));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="uncoveredLine">hash_code hash_value(const APFloat &Arg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="uncoveredLine">  if (APFloat::usesLayout<detail::IEEEFloat>(Arg.getSemantics()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="uncoveredLine">    return hash_value(Arg.U.IEEE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="uncoveredLine">  if (APFloat::usesLayout<detail::DoubleAPFloat>(Arg.getSemantics()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="uncoveredLine">    return hash_value(Arg.U.Double);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="uncoveredLine">  llvm_unreachable("Unexpected semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="uncoveredLine">APFloat::APFloat(const fltSemantics &Semantics, StringRef S)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="uncoveredLine">    : APFloat(Semantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="uncoveredLine">  auto StatusOrErr = convertFromString(S, rmNearestTiesToEven);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="uncoveredLine">  assert(StatusOrErr && "Invalid floating point representation");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="uncoveredLine">  consumeError(StatusOrErr.takeError());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="uncoveredLine">FPClassTest APFloat::classify() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class="uncoveredLine">  if (isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="uncoveredLine">    return isNegative() ? fcNegZero : fcPosZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="uncoveredLine">  if (isNormal())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="uncoveredLine">    return isNegative() ? fcNegNormal : fcPosNormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="uncoveredLine">  if (isDenormal())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="uncoveredLine">    return isNegative() ? fcNegSubnormal : fcPosSubnormal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="uncoveredLine">  if (isInfinity())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="uncoveredLine">    return isNegative() ? fcNegInf : fcPosInf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="uncoveredLine">  assert(isNaN() && "Other class of FP constant");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="uncoveredLine">  return isSignaling() ? fcSNan : fcQNan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="uncoveredLine">APFloat::opStatus APFloat::convert(const fltSemantics &ToSemantics,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="">                                   roundingMode RM, bool *losesInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="uncoveredLine">  if (&getSemantics() == &ToSemantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="uncoveredLine">    *losesInfo = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="uncoveredLine">    return opOK;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class="uncoveredLine">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="uncoveredLine">      usesLayout<IEEEFloat>(ToSemantics))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="uncoveredLine">    return U.IEEE.convert(ToSemantics, RM, losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="uncoveredLine">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="uncoveredLine">      usesLayout<DoubleAPFloat>(ToSemantics)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="uncoveredLine">    assert(&ToSemantics == &semPPCDoubleDouble);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="uncoveredLine">    auto Ret = U.IEEE.convert(semPPCDoubleDoubleLegacy, RM, losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="uncoveredLine">    *this = APFloat(ToSemantics, U.IEEE.bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class="uncoveredLine">    return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="uncoveredLine">  if (usesLayout<DoubleAPFloat>(getSemantics()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="uncoveredLine">      usesLayout<IEEEFloat>(ToSemantics)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class="uncoveredLine">    auto Ret = getIEEE().convert(ToSemantics, RM, losesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="uncoveredLine">    *this = APFloat(std::move(getIEEE()), ToSemantics);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="uncoveredLine">    return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="uncoveredLine">  llvm_unreachable("Unexpected semantics");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="uncoveredLine">APFloat APFloat::getAllOnesValue(const fltSemantics &Semantics) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="uncoveredLine">  return APFloat(Semantics, APInt::getAllOnes(Semantics.sizeInBits));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="uncoveredLine">void APFloat::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="uncoveredLine">  SmallVector<char, 16> Buffer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="uncoveredLine">  toString(Buffer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="uncoveredLine">  OS << Buffer << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void APFloat::dump() const { print(dbgs()); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="uncoveredLine">void APFloat::Profile(FoldingSetNodeID &NID) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="uncoveredLine">  NID.Add(bitcastToAPInt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="">/* Same as convertToInteger(integerPart*, ...), except the result is returned in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="">   an APSInt, whose initial bit-width and signed-ness are used to determine the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="">   precision of the conversion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class=""> */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="uncoveredLine">APFloat::opStatus APFloat::convertToInteger(APSInt &result,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class="">                                            roundingMode rounding_mode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5206</td>
    <td class="">                                            bool *isExact) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5207</td>
    <td class="uncoveredLine">  unsigned bitWidth = result.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5208</td>
    <td class="uncoveredLine">  SmallVector<uint64_t, 4> parts(result.getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5209</td>
    <td class="uncoveredLine">  opStatus status = convertToInteger(parts, bitWidth, result.isSigned(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5210</td>
    <td class="">                                     rounding_mode, isExact);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5211</td>
    <td class="">  // Keeps the original signed-ness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5212</td>
    <td class="uncoveredLine">  result = APInt(bitWidth, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5213</td>
    <td class="uncoveredLine">  return status;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5214</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5216</td>
    <td class="uncoveredLine">double APFloat::convertToDouble() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5217</td>
    <td class="uncoveredLine">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEdouble)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5218</td>
    <td class="uncoveredLine">    return getIEEE().convertToDouble();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5219</td>
    <td class="uncoveredLine">  assert(getSemantics().isRepresentableBy(semIEEEdouble) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5220</td>
    <td class="">         "Float semantics is not representable by IEEEdouble");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5221</td>
    <td class="uncoveredLine">  APFloat Temp = *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5222</td>
    <td class="">  bool LosesInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5223</td>
    <td class="uncoveredLine">  opStatus St = Temp.convert(semIEEEdouble, rmNearestTiesToEven, &LosesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5224</td>
    <td class="uncoveredLine">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5225</td>
    <td class="">  (void)St;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5226</td>
    <td class="uncoveredLine">  return Temp.getIEEE().convertToDouble();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5227</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5229</td>
    <td class="uncoveredLine">float APFloat::convertToFloat() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5230</td>
    <td class="uncoveredLine">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEsingle)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5231</td>
    <td class="uncoveredLine">    return getIEEE().convertToFloat();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5232</td>
    <td class="uncoveredLine">  assert(getSemantics().isRepresentableBy(semIEEEsingle) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5233</td>
    <td class="">         "Float semantics is not representable by IEEEsingle");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5234</td>
    <td class="uncoveredLine">  APFloat Temp = *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5235</td>
    <td class="">  bool LosesInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5236</td>
    <td class="uncoveredLine">  opStatus St = Temp.convert(semIEEEsingle, rmNearestTiesToEven, &LosesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5237</td>
    <td class="uncoveredLine">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5238</td>
    <td class="">  (void)St;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5239</td>
    <td class="uncoveredLine">  return Temp.getIEEE().convertToFloat();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5240</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5242</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5244</td>
    <td class="">#undef APFLOAT_DISPATCH_ON_SEMANTICS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm12fltSemantics17isRepresentableByERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase15EnumToSemanticsENS0_9SemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase15SemanticsToEnumERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase8IEEEhalfEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase6BFloatEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase10IEEEsingleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase10IEEEdoubleEv</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase8IEEEquadEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase15PPCDoubleDoubleEv</td>
    <td class="numberOfCalls">134</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase10Float8E5M2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase14Float8E5M2FNUZEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase12Float8E4M3FNEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase14Float8E4M3FNUZEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase17Float8E4M3B11FNUZEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase9FloatTF32Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase17x87DoubleExtendedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase5BogusEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase18semanticsPrecisionERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase20semanticsMaxExponentERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase20semanticsMinExponentERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase19semanticsSizeInBitsERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase22semanticsIntSizeInBitsERKNS_12fltSemanticsEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase25isRepresentableAsNormalInERKNS_12fltSemanticsES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11APFloatBase13getSizeInBitsERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL12exponentZeroERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL11exponentInfERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL11exponentNaNERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL11createErrorERKNS_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL16partCountForBitsEj</td>
    <td class="numberOfCalls">469</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL13decDigitValueEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL12readExponentEPKcS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL13totalExponentEPKcS1_i</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL26skipLeadingZeroesAndAnyDotEPKcS1_PS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL16interpretDecimalEPKcS1_PNS_11decimalInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL27trailingHexadecimalFractionEPKcS1_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL29lostFractionThroughTruncationEPKmjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL10shiftRightEPmjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL20combineLostFractionsENS_12lostFractionES0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL10HUerrBoundEbjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL16ulpsFromBoundaryEPKmjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL8powerOf5EPmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL9partAsHexEPcmjPKc</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL20writeUnsignedDecimalEPcj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmL18writeSignedDecimalEPci</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat15freeSignificandEv</td>
    <td class="numberOfCalls">201</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat6assignERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat15copySignificandERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloataSERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloataSEOS1_</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat10isDenormalEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat10isSmallestEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat20isSmallestNormalizedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat20isSignificandAllOnesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat29isSignificandAllOnesExceptLSBEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat21isSignificandAllZerosEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat30isSignificandAllZerosExceptMSBEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat9isLargestEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat9isIntegerEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat14bitwiseIsEqualERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2ERKNS_12fltSemanticsEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2ERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2ERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2EOS1_</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatD2Ev</td>
    <td class="numberOfCalls">134</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat9partCountEv</td>
    <td class="numberOfCalls">469</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat16significandPartsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat16significandPartsEv</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat15zeroSignificandEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat20incrementSignificandEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat14addSignificandERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat19subtractSignificandERKS1_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat19multiplySignificandERKS1_S1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat19multiplySignificandERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17divideSignificandERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat14significandMSBEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat14significandLSBEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat21shiftSignificandRightEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat20shiftSignificandLeftEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat20compareAbsoluteValueERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detailL25tcSetLeastSignificantBitsEPmjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat14handleOverflowENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat17roundAwayFromZeroENS_12RoundingModeENS_12lostFractionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat9normalizeENS_12RoundingModeENS_12lostFractionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat21addOrSubtractSpecialsERKS1_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat24addOrSubtractSignificandERKS1_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat16multiplySpecialsERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat14divideSpecialsERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat11modSpecialsERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17remainderSpecialsERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat10changeSignEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat13addOrSubtractERKS1_NS_12RoundingModeEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat3addERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat8subtractERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat8multiplyERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat6divideERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat9remainderERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat3modERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat16fusedMultiplyAddERKS1_S3_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat15roundToIntegralENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat7compareERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_12RoundingModeEPb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat28convertToSignExtendedIntegerENS_15MutableArrayRefImEEjbNS_12RoundingModeEPb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_12RoundingModeEPb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat16convertFromAPIntERKNS_5APIntEbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat30convertFromSignExtendedIntegerEPKmjbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat30convertFromZeroExtendedIntegerEPKmjbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat28convertFromHexadecimalStringENS_9StringRefENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat28roundSignificandWithExponentEPKmjiNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat24convertFromDecimalStringENS_9StringRefENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat25convertFromStringSpecialsENS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17convertFromStringENS_9StringRefENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat18convertToHexStringEPcjbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat24convertNormalToHexStringEPcjbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10hash_valueERKNS0_9IEEEFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat34convertF80LongDoubleAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat36convertPPCDoubleDoubleAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L13semIEEEdoubleEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L12semFloatTF32EEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L20semFloat8E4M3B11FNUZEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L17semFloat8E4M3FNUZEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L15semFloat8E4M3FNEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L17semFloat8E5M2FNUZEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L13semFloat8E5M2EEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L11semIEEEhalfEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L9semBFloatEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L13semIEEEsingleEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat23convertIEEEFloatToAPIntIL_ZNS_L11semIEEEquadEEEENS_5APIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat30convertQuadrupleAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat27convertDoubleAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat26convertFloatAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat27convertBFloatAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat25convertHalfAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat31convertFloat8E5M2APFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat35convertFloat8E5M2FNUZAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat33convertFloat8E4M3FNAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat35convertFloat8E4M3FNUZAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat38convertFloat8E4M3B11FNUZAPFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat30convertFloatTF32APFloatToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat14bitcastToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat14convertToFloatEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat15convertToDoubleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat26initFromF80LongDoubleAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat28initFromPPCDoubleDoubleAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L9semBFloatEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semIEEEsingleEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L11semIEEEhalfEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semFloat8E5M2EEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semIEEEdoubleEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L17semFloat8E5M2FNUZEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L15semFloat8E4M3FNEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L11semIEEEquadEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L17semFloat8E4M3FNUZEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L20semFloat8E4M3B11FNUZEEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L12semFloatTF32EEEEvRKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semIEEEdoubleEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L12semFloatTF32EEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semIEEEsingleEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L11semIEEEquadEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L9semBFloatEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L11semIEEEhalfEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semFloat8E5M2EEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L17semFloat8E5M2FNUZEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L15semFloat8E4M3FNEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L17semFloat8E4M3FNUZEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L20semFloat8E4M3B11FNUZEEEEvRKNS_5APIntEENKUlmE_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L15semFloat8E4M3FNEEEEvRKNS_5APIntEENKUlmE0_clEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat22initFromQuadrupleAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat19initFromDoubleAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat18initFromFloatAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat19initFromBFloatAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat17initFromHalfAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat23initFromFloat8E5M2APIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat27initFromFloat8E5M2FNUZAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat25initFromFloat8E4M3FNAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat27initFromFloat8E4M3FNUZAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat30initFromFloat8E4M3B11FNUZAPIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat22initFromFloatTF32APIntERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat13initFromAPIntEPKNS_12fltSemanticsERKNS_5APIntE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat11makeLargestEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat12makeSmallestEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat22makeSmallestNormalizedEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2ERKNS_12fltSemanticsERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2Ef</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloatC2Ed</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12_GLOBAL__N_117AdjustToPrecisionERNS_5APIntERij</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12_GLOBAL__N_117AdjustToPrecisionERNS_15SmallVectorImplIcEERij</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat8toStringERNS_15SmallVectorImplIcEEjjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat15getExactInverseEPNS_7APFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat11isSignalingEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat4nextEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat11exponentNaNEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat11exponentInfEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail9IEEEFloat12exponentZeroEv</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat7makeInfEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat8makeZeroEb</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail9IEEEFloat9makeQuietEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5ilogbERKNS0_9IEEEFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail6scalbnENS0_9IEEEFloatEiNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5frexpERKNS0_9IEEEFloatERiNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloatC2ERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloatC2ERKNS_12fltSemanticsEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloatC2ERKNS_12fltSemanticsERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloatC2ERKNS_12fltSemanticsEONS_7APFloatES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloatC2ERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloatC2EOS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloataSERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat7addImplERKNS_7APFloatES4_S4_S4_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat14addWithSpecialERKS1_S3_RS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat3addERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat8subtractERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat8multiplyERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat6divideERKS1_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat9remainderERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat3modERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat16fusedMultiplyAddERKS1_S3_NS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat15roundToIntegralENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat10changeSignEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat20compareAbsoluteValueERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat11getCategoryEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat10isNegativeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat7makeInfEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat8makeZeroEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat11makeLargestEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat12makeSmallestEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat22makeSmallestNormalizedEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat7makeNaNEbbPKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat7compareERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat14bitwiseIsEqualERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10hash_valueERKNS0_13DoubleAPFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat14bitcastToAPIntEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat17convertFromStringENS_9StringRefENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat4nextEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_12RoundingModeEPb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat16convertFromAPIntERKNS_5APIntEbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat30convertFromSignExtendedIntegerEPKmjbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail13DoubleAPFloat30convertFromZeroExtendedIntegerEPKmjbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat18convertToHexStringEPcjbNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat10isDenormalEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat10isSmallestEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat20isSmallestNormalizedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat9isLargestEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat9isIntegerEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat8toStringERNS_15SmallVectorImplIcEEjjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail13DoubleAPFloat15getExactInverseEPNS_7APFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail6scalbnERKNS0_13DoubleAPFloatEiNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5frexpERKNS0_13DoubleAPFloatERiNS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7APFloat7StorageC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7APFloat17convertFromStringENS_9StringRefENS_12RoundingModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10hash_valueERKNS_7APFloatE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7APFloatC2ERKNS_12fltSemanticsENS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7APFloat8classifyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7APFloat7convertERKNS_12fltSemanticsENS_12RoundingModeEPb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7APFloat15getAllOnesValueERKNS_12fltSemanticsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7APFloat5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7APFloat4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7APFloat7ProfileERNS_16FoldingSetNodeIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7APFloat16convertToIntegerERNS_6APSIntENS_12RoundingModeEPb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7APFloat15convertToDoubleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7APFloat14convertToFloatEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- APFloat.cpp - Implement APFloat class -----------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- APFloat.cpp - Implement APFloat class -----------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements a class to represent arbitrary precision floating</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements a class to represent arbitrary precision floating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// point values and provide a variety of arithmetic operations on them.</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// point values and provide a variety of arithmetic operations on them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/APFloat.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/APSInt.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/APSInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/FloatingPointMode.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/FloatingPointMode.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/FoldingSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/StringExtras.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/StringExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/Error.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/Error.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include <cstring></td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include <cstring></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include <limits.h></td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include <limits.h></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">  do {                                                                         \</td>
    <td class="lineNumber">32</td>
    <td class="codeline">  do {                                                                         \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">    if (usesLayout<IEEEFloat>(getSemantics()))                                 \</td>
    <td class="lineNumber">33</td>
    <td class="codeline">    if (usesLayout<IEEEFloat>(getSemantics()))                                 \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">      return U.IEEE.METHOD_CALL;                                               \</td>
    <td class="lineNumber">34</td>
    <td class="codeline">      return U.IEEE.METHOD_CALL;                                               \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \</td>
    <td class="lineNumber">35</td>
    <td class="codeline">    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">      return U.Double.METHOD_CALL;                                             \</td>
    <td class="lineNumber">36</td>
    <td class="codeline">      return U.Double.METHOD_CALL;                                             \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">    llvm_unreachable("Unexpected semantics");                                  \</td>
    <td class="lineNumber">37</td>
    <td class="codeline">    llvm_unreachable("Unexpected semantics");                                  \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">  } while (false)</td>
    <td class="lineNumber">38</td>
    <td class="codeline">  } while (false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">40</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">/// A macro used to combine two fcCategory enums into one key which can be used</td>
    <td class="lineNumber">42</td>
    <td class="codeline">/// A macro used to combine two fcCategory enums into one key which can be used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">/// in a switch statement to classify how the interaction of two APFloat's</td>
    <td class="lineNumber">43</td>
    <td class="codeline">/// in a switch statement to classify how the interaction of two APFloat's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">/// categories affects an operation.</td>
    <td class="lineNumber">44</td>
    <td class="codeline">/// categories affects an operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">///</td>
    <td class="lineNumber">45</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">/// TODO: If clang source code is ever allowed to use constexpr in its own</td>
    <td class="lineNumber">46</td>
    <td class="codeline">/// TODO: If clang source code is ever allowed to use constexpr in its own</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">/// codebase, change this into a static inline function.</td>
    <td class="lineNumber">47</td>
    <td class="codeline">/// codebase, change this into a static inline function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#define PackCategoriesIntoKey(_lhs, _rhs) ((_lhs) * 4 + (_rhs))</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#define PackCategoriesIntoKey(_lhs, _rhs) ((_lhs) * 4 + (_rhs))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">/* Assumed in hexadecimal significand parsing, and conversion to</td>
    <td class="lineNumber">50</td>
    <td class="codeline">/* Assumed in hexadecimal significand parsing, and conversion to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">   hexadecimal strings.  */</td>
    <td class="lineNumber">51</td>
    <td class="codeline">   hexadecimal strings.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">static_assert(APFloatBase::integerPartWidth % 4 == 0, "Part width must be divisible by 4!");</td>
    <td class="lineNumber">52</td>
    <td class="codeline">static_assert(APFloatBase::integerPartWidth % 4 == 0, "Part width must be divisible by 4!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">54</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline"></td>
    <td class="lineNumber">55</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">// How the nonfinite values Inf and NaN are represented.</td>
    <td class="lineNumber">56</td>
    <td class="codeline">// How the nonfinite values Inf and NaN are represented.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">enum class fltNonfiniteBehavior {</td>
    <td class="lineNumber">57</td>
    <td class="codeline">enum class fltNonfiniteBehavior {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">  // Represents standard IEEE 754 behavior. A value is nonfinite if the</td>
    <td class="lineNumber">58</td>
    <td class="codeline">  // Represents standard IEEE 754 behavior. A value is nonfinite if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">  // exponent field is all 1s. In such cases, a value is Inf if the</td>
    <td class="lineNumber">59</td>
    <td class="codeline">  // exponent field is all 1s. In such cases, a value is Inf if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">  // significand bits are all zero, and NaN otherwise</td>
    <td class="lineNumber">60</td>
    <td class="codeline">  // significand bits are all zero, and NaN otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">  IEEE754,</td>
    <td class="lineNumber">61</td>
    <td class="codeline">  IEEE754,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline"></td>
    <td class="lineNumber">62</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">  // This behavior is present in the Float8ExMyFN* types (Float8E4M3FN,</td>
    <td class="lineNumber">63</td>
    <td class="codeline">  // This behavior is present in the Float8ExMyFN* types (Float8E4M3FN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">  // Float8E5M2FNUZ, Float8E4M3FNUZ, and Float8E4M3B11FNUZ). There is no</td>
    <td class="lineNumber">64</td>
    <td class="codeline">  // Float8E5M2FNUZ, Float8E4M3FNUZ, and Float8E4M3B11FNUZ). There is no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">  // representation for Inf, and operations that would ordinarily produce Inf</td>
    <td class="lineNumber">65</td>
    <td class="codeline">  // representation for Inf, and operations that would ordinarily produce Inf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">  // produce NaN instead.</td>
    <td class="lineNumber">66</td>
    <td class="codeline">  // produce NaN instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">  // The details of the NaN representation(s) in this form are determined by the</td>
    <td class="lineNumber">67</td>
    <td class="codeline">  // The details of the NaN representation(s) in this form are determined by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  // `fltNanEncoding` enum. We treat all NaNs as quiet, as the available</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  // `fltNanEncoding` enum. We treat all NaNs as quiet, as the available</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">  // encodings do not distinguish between signalling and quiet NaN.</td>
    <td class="lineNumber">69</td>
    <td class="codeline">  // encodings do not distinguish between signalling and quiet NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">  NanOnly,</td>
    <td class="lineNumber">70</td>
    <td class="codeline">  NanOnly,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">};</td>
    <td class="lineNumber">71</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">// How NaN values are represented. This is curently only used in combination</td>
    <td class="lineNumber">73</td>
    <td class="codeline">// How NaN values are represented. This is curently only used in combination</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">// with fltNonfiniteBehavior::NanOnly, and using a variant other than IEEE</td>
    <td class="lineNumber">74</td>
    <td class="codeline">// with fltNonfiniteBehavior::NanOnly, and using a variant other than IEEE</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">// while having IEEE non-finite behavior is liable to lead to unexpected</td>
    <td class="lineNumber">75</td>
    <td class="codeline">// while having IEEE non-finite behavior is liable to lead to unexpected</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">// results.</td>
    <td class="lineNumber">76</td>
    <td class="codeline">// results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">enum class fltNanEncoding {</td>
    <td class="lineNumber">77</td>
    <td class="codeline">enum class fltNanEncoding {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">  // Represents the standard IEEE behavior where a value is NaN if its</td>
    <td class="lineNumber">78</td>
    <td class="codeline">  // Represents the standard IEEE behavior where a value is NaN if its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  // exponent is all 1s and the significand is non-zero.</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  // exponent is all 1s and the significand is non-zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  IEEE,</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  IEEE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  // Represents the behavior in the Float8E4M3 floating point type where NaN is</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  // Represents the behavior in the Float8E4M3 floating point type where NaN is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  // represented by having the exponent and mantissa set to all 1s.</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  // represented by having the exponent and mantissa set to all 1s.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  // This behavior matches the FP8 E4M3 type described in</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  // This behavior matches the FP8 E4M3 type described in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  // https://arxiv.org/abs/2209.05433. We treat both signed and unsigned NaNs</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  // https://arxiv.org/abs/2209.05433. We treat both signed and unsigned NaNs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  // as non-signalling, although the paper does not state whether the NaN</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  // as non-signalling, although the paper does not state whether the NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  // values are signalling or not.</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  // values are signalling or not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  AllOnes,</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  AllOnes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  // Represents the behavior in Float8E{5,4}E{2,3}FNUZ floating point types</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  // Represents the behavior in Float8E{5,4}E{2,3}FNUZ floating point types</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  // where NaN is represented by a sign bit of 1 and all 0s in the exponent</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  // where NaN is represented by a sign bit of 1 and all 0s in the exponent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  // and mantissa (i.e. the negative zero encoding in a IEEE float). Since</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  // and mantissa (i.e. the negative zero encoding in a IEEE float). Since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  // there is only one NaN value, it is treated as quiet NaN. This matches the</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  // there is only one NaN value, it is treated as quiet NaN. This matches the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  // behavior described in https://arxiv.org/abs/2206.02915 .</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  // behavior described in https://arxiv.org/abs/2206.02915 .</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  NegativeZero,</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  NegativeZero,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">};</td>
    <td class="lineNumber">96</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">/* Represents floating point arithmetic semantics.  */</td>
    <td class="lineNumber">98</td>
    <td class="codeline">/* Represents floating point arithmetic semantics.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">struct fltSemantics {</td>
    <td class="lineNumber">99</td>
    <td class="codeline">struct fltSemantics {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  /* The largest E such that 2^E is representable; this matches the</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  /* The largest E such that 2^E is representable; this matches the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">     definition of IEEE 754.  */</td>
    <td class="lineNumber">101</td>
    <td class="codeline">     definition of IEEE 754.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  APFloatBase::ExponentType maxExponent;</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  APFloatBase::ExponentType maxExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  /* The smallest E such that 2^E is a normalized number; this</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  /* The smallest E such that 2^E is a normalized number; this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">     matches the definition of IEEE 754.  */</td>
    <td class="lineNumber">105</td>
    <td class="codeline">     matches the definition of IEEE 754.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  APFloatBase::ExponentType minExponent;</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  APFloatBase::ExponentType minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  /* Number of bits in the significand.  This includes the integer</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  /* Number of bits in the significand.  This includes the integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">     bit.  */</td>
    <td class="lineNumber">109</td>
    <td class="codeline">     bit.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  unsigned int precision;</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  unsigned int precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  /* Number of bits actually used in the semantics. */</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  /* Number of bits actually used in the semantics. */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  unsigned int sizeInBits;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  unsigned int sizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  fltNonfiniteBehavior nonFiniteBehavior = fltNonfiniteBehavior::IEEE754;</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  fltNonfiniteBehavior nonFiniteBehavior = fltNonfiniteBehavior::IEEE754;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  fltNanEncoding nanEncoding = fltNanEncoding::IEEE;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  fltNanEncoding nanEncoding = fltNanEncoding::IEEE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  // Returns true if any number described by this semantics can be precisely</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  // Returns true if any number described by this semantics can be precisely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  // represented by the specified semantics. Does not take into account</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  // represented by the specified semantics. Does not take into account</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  // the value of fltNonfiniteBehavior.</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  // the value of fltNonfiniteBehavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  bool isRepresentableBy(const fltSemantics &S) const {</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  bool isRepresentableBy(const fltSemantics &S) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">    return maxExponent <= S.maxExponent && minExponent >= S.minExponent &&</td>
    <td class="lineNumber">122</td>
    <td class="codeline">    return maxExponent <= S.maxExponent && minExponent >= S.minExponent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">           precision <= S.precision;</td>
    <td class="lineNumber">123</td>
    <td class="codeline">           precision <= S.precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">};</td>
    <td class="lineNumber">125</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">static constexpr fltSemantics semIEEEhalf = {15, -14, 11, 16};</td>
    <td class="lineNumber">127</td>
    <td class="codeline">static constexpr fltSemantics semIEEEhalf = {15, -14, 11, 16};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">static constexpr fltSemantics semBFloat = {127, -126, 8, 16};</td>
    <td class="lineNumber">128</td>
    <td class="codeline">static constexpr fltSemantics semBFloat = {127, -126, 8, 16};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">static constexpr fltSemantics semIEEEsingle = {127, -126, 24, 32};</td>
    <td class="lineNumber">129</td>
    <td class="codeline">static constexpr fltSemantics semIEEEsingle = {127, -126, 24, 32};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">static constexpr fltSemantics semIEEEdouble = {1023, -1022, 53, 64};</td>
    <td class="lineNumber">130</td>
    <td class="codeline">static constexpr fltSemantics semIEEEdouble = {1023, -1022, 53, 64};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">static constexpr fltSemantics semIEEEquad = {16383, -16382, 113, 128};</td>
    <td class="lineNumber">131</td>
    <td class="codeline">static constexpr fltSemantics semIEEEquad = {16383, -16382, 113, 128};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E5M2 = {15, -14, 3, 8};</td>
    <td class="lineNumber">132</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E5M2 = {15, -14, 3, 8};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E5M2FNUZ = {</td>
    <td class="lineNumber">133</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E5M2FNUZ = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    15, -15, 3, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    15, -15, 3, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E4M3FN = {</td>
    <td class="lineNumber">135</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E4M3FN = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">    8, -6, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::AllOnes};</td>
    <td class="lineNumber">136</td>
    <td class="codeline">    8, -6, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::AllOnes};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E4M3FNUZ = {</td>
    <td class="lineNumber">137</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E4M3FNUZ = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">    7, -7, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">138</td>
    <td class="codeline">    7, -7, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E4M3B11FNUZ = {</td>
    <td class="lineNumber">139</td>
    <td class="codeline">static constexpr fltSemantics semFloat8E4M3B11FNUZ = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">    4, -10, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">140</td>
    <td class="codeline">    4, -10, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">static constexpr fltSemantics semFloatTF32 = {127, -126, 11, 19};</td>
    <td class="lineNumber">141</td>
    <td class="codeline">static constexpr fltSemantics semFloatTF32 = {127, -126, 11, 19};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">static constexpr fltSemantics semX87DoubleExtended = {16383, -16382, 64, 80};</td>
    <td class="lineNumber">142</td>
    <td class="codeline">static constexpr fltSemantics semX87DoubleExtended = {16383, -16382, 64, 80};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">static constexpr fltSemantics semBogus = {0, 0, 0, 0};</td>
    <td class="lineNumber">143</td>
    <td class="codeline">static constexpr fltSemantics semBogus = {0, 0, 0, 0};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">/* The IBM double-double semantics. Such a number consists of a pair of IEEE</td>
    <td class="lineNumber">145</td>
    <td class="codeline">/* The IBM double-double semantics. Such a number consists of a pair of IEEE</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">   64-bit doubles (Hi, Lo), where |Hi| > |Lo|, and if normal,</td>
    <td class="lineNumber">146</td>
    <td class="codeline">   64-bit doubles (Hi, Lo), where |Hi| > |Lo|, and if normal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">   (double)(Hi + Lo) == Hi. The numeric value it's modeling is Hi + Lo.</td>
    <td class="lineNumber">147</td>
    <td class="codeline">   (double)(Hi + Lo) == Hi. The numeric value it's modeling is Hi + Lo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">   Therefore it has two 53-bit mantissa parts that aren't necessarily adjacent</td>
    <td class="lineNumber">148</td>
    <td class="codeline">   Therefore it has two 53-bit mantissa parts that aren't necessarily adjacent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">   to each other, and two 11-bit exponents.</td>
    <td class="lineNumber">149</td>
    <td class="codeline">   to each other, and two 11-bit exponents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">   Note: we need to make the value different from semBogus as otherwise</td>
    <td class="lineNumber">151</td>
    <td class="codeline">   Note: we need to make the value different from semBogus as otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">   an unsafe optimization may collapse both values to a single address,</td>
    <td class="lineNumber">152</td>
    <td class="codeline">   an unsafe optimization may collapse both values to a single address,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">   and we heavily rely on them having distinct addresses.             */</td>
    <td class="lineNumber">153</td>
    <td class="codeline">   and we heavily rely on them having distinct addresses.             */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">static constexpr fltSemantics semPPCDoubleDouble = {-1, 0, 0, 128};</td>
    <td class="lineNumber">154</td>
    <td class="codeline">static constexpr fltSemantics semPPCDoubleDouble = {-1, 0, 0, 128};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">/* These are legacy semantics for the fallback, inaccrurate implementation of</td>
    <td class="lineNumber">156</td>
    <td class="codeline">/* These are legacy semantics for the fallback, inaccrurate implementation of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">   IBM double-double, if the accurate semPPCDoubleDouble doesn't handle the</td>
    <td class="lineNumber">157</td>
    <td class="codeline">   IBM double-double, if the accurate semPPCDoubleDouble doesn't handle the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">   operation. It's equivalent to having an IEEE number with consecutive 106</td>
    <td class="lineNumber">158</td>
    <td class="codeline">   operation. It's equivalent to having an IEEE number with consecutive 106</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">   bits of mantissa and 11 bits of exponent.</td>
    <td class="lineNumber">159</td>
    <td class="codeline">   bits of mantissa and 11 bits of exponent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">   It's not equivalent to IBM double-double. For example, a legit IBM</td>
    <td class="lineNumber">161</td>
    <td class="codeline">   It's not equivalent to IBM double-double. For example, a legit IBM</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">   double-double, 1 + epsilon:</td>
    <td class="lineNumber">162</td>
    <td class="codeline">   double-double, 1 + epsilon:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">     1 + epsilon = 1 + (1 >> 1076)</td>
    <td class="lineNumber">164</td>
    <td class="codeline">     1 + epsilon = 1 + (1 >> 1076)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">   is not representable by a consecutive 106 bits of mantissa.</td>
    <td class="lineNumber">166</td>
    <td class="codeline">   is not representable by a consecutive 106 bits of mantissa.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">   Currently, these semantics are used in the following way:</td>
    <td class="lineNumber">168</td>
    <td class="codeline">   Currently, these semantics are used in the following way:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline"></td>
    <td class="lineNumber">169</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">     semPPCDoubleDouble -> (IEEEdouble, IEEEdouble) -></td>
    <td class="lineNumber">170</td>
    <td class="codeline">     semPPCDoubleDouble -> (IEEEdouble, IEEEdouble) -></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">     (64-bit APInt, 64-bit APInt) -> (128-bit APInt) -></td>
    <td class="lineNumber">171</td>
    <td class="codeline">     (64-bit APInt, 64-bit APInt) -> (128-bit APInt) -></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">     semPPCDoubleDoubleLegacy -> IEEE operations</td>
    <td class="lineNumber">172</td>
    <td class="codeline">     semPPCDoubleDoubleLegacy -> IEEE operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">   We use bitcastToAPInt() to get the bit representation (in APInt) of the</td>
    <td class="lineNumber">174</td>
    <td class="codeline">   We use bitcastToAPInt() to get the bit representation (in APInt) of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">   underlying IEEEdouble, then use the APInt constructor to construct the</td>
    <td class="lineNumber">175</td>
    <td class="codeline">   underlying IEEEdouble, then use the APInt constructor to construct the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">   legacy IEEE float.</td>
    <td class="lineNumber">176</td>
    <td class="codeline">   legacy IEEE float.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">   TODO: Implement all operations in semPPCDoubleDouble, and delete these</td>
    <td class="lineNumber">178</td>
    <td class="codeline">   TODO: Implement all operations in semPPCDoubleDouble, and delete these</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">   semantics.  */</td>
    <td class="lineNumber">179</td>
    <td class="codeline">   semantics.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">static constexpr fltSemantics semPPCDoubleDoubleLegacy = {1023, -1022 + 53,</td>
    <td class="lineNumber">180</td>
    <td class="codeline">static constexpr fltSemantics semPPCDoubleDoubleLegacy = {1023, -1022 + 53,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">                                                          53 + 53, 128};</td>
    <td class="lineNumber">181</td>
    <td class="codeline">                                                          53 + 53, 128};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">const llvm::fltSemantics &APFloatBase::EnumToSemantics(Semantics S) {</td>
    <td class="lineNumber">183</td>
    <td class="codeline">const llvm::fltSemantics &APFloatBase::EnumToSemantics(Semantics S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  switch (S) {</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  switch (S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  case S_IEEEhalf:</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  case S_IEEEhalf:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">    return IEEEhalf();</td>
    <td class="lineNumber">186</td>
    <td class="codeline">    return IEEEhalf();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  case S_BFloat:</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  case S_BFloat:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    return BFloat();</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    return BFloat();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  case S_IEEEsingle:</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  case S_IEEEsingle:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">    return IEEEsingle();</td>
    <td class="lineNumber">190</td>
    <td class="codeline">    return IEEEsingle();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  case S_IEEEdouble:</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  case S_IEEEdouble:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    return IEEEdouble();</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    return IEEEdouble();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  case S_IEEEquad:</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  case S_IEEEquad:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">    return IEEEquad();</td>
    <td class="lineNumber">194</td>
    <td class="codeline">    return IEEEquad();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  case S_PPCDoubleDouble:</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  case S_PPCDoubleDouble:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    return PPCDoubleDouble();</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    return PPCDoubleDouble();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  case S_Float8E5M2:</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  case S_Float8E5M2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    return Float8E5M2();</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    return Float8E5M2();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  case S_Float8E5M2FNUZ:</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  case S_Float8E5M2FNUZ:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">    return Float8E5M2FNUZ();</td>
    <td class="lineNumber">200</td>
    <td class="codeline">    return Float8E5M2FNUZ();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  case S_Float8E4M3FN:</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  case S_Float8E4M3FN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    return Float8E4M3FN();</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    return Float8E4M3FN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  case S_Float8E4M3FNUZ:</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  case S_Float8E4M3FNUZ:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">    return Float8E4M3FNUZ();</td>
    <td class="lineNumber">204</td>
    <td class="codeline">    return Float8E4M3FNUZ();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  case S_Float8E4M3B11FNUZ:</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  case S_Float8E4M3B11FNUZ:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">    return Float8E4M3B11FNUZ();</td>
    <td class="lineNumber">206</td>
    <td class="codeline">    return Float8E4M3B11FNUZ();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  case S_FloatTF32:</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  case S_FloatTF32:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    return FloatTF32();</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    return FloatTF32();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  case S_x87DoubleExtended:</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  case S_x87DoubleExtended:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    return x87DoubleExtended();</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    return x87DoubleExtended();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  llvm_unreachable("Unrecognised floating semantics");</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  llvm_unreachable("Unrecognised floating semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">}</td>
    <td class="lineNumber">213</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">APFloatBase::Semantics</td>
    <td class="lineNumber">215</td>
    <td class="codeline">APFloatBase::Semantics</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">APFloatBase::SemanticsToEnum(const llvm::fltSemantics &Sem) {</td>
    <td class="lineNumber">216</td>
    <td class="codeline">APFloatBase::SemanticsToEnum(const llvm::fltSemantics &Sem) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  if (&Sem == &llvm::APFloat::IEEEhalf())</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  if (&Sem == &llvm::APFloat::IEEEhalf())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">    return S_IEEEhalf;</td>
    <td class="lineNumber">218</td>
    <td class="codeline">    return S_IEEEhalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::BFloat())</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::BFloat())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">    return S_BFloat;</td>
    <td class="lineNumber">220</td>
    <td class="codeline">    return S_BFloat;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::IEEEsingle())</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::IEEEsingle())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    return S_IEEEsingle;</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    return S_IEEEsingle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::IEEEdouble())</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::IEEEdouble())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">    return S_IEEEdouble;</td>
    <td class="lineNumber">224</td>
    <td class="codeline">    return S_IEEEdouble;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::IEEEquad())</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::IEEEquad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    return S_IEEEquad;</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    return S_IEEEquad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::PPCDoubleDouble())</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::PPCDoubleDouble())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">    return S_PPCDoubleDouble;</td>
    <td class="lineNumber">228</td>
    <td class="codeline">    return S_PPCDoubleDouble;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E5M2())</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E5M2())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">    return S_Float8E5M2;</td>
    <td class="lineNumber">230</td>
    <td class="codeline">    return S_Float8E5M2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E5M2FNUZ())</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E5M2FNUZ())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">    return S_Float8E5M2FNUZ;</td>
    <td class="lineNumber">232</td>
    <td class="codeline">    return S_Float8E5M2FNUZ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E4M3FN())</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E4M3FN())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    return S_Float8E4M3FN;</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    return S_Float8E4M3FN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E4M3FNUZ())</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E4M3FNUZ())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    return S_Float8E4M3FNUZ;</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    return S_Float8E4M3FNUZ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E4M3B11FNUZ())</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::Float8E4M3B11FNUZ())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">    return S_Float8E4M3B11FNUZ;</td>
    <td class="lineNumber">238</td>
    <td class="codeline">    return S_Float8E4M3B11FNUZ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::FloatTF32())</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::FloatTF32())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    return S_FloatTF32;</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    return S_FloatTF32;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::x87DoubleExtended())</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  else if (&Sem == &llvm::APFloat::x87DoubleExtended())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    return S_x87DoubleExtended;</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    return S_x87DoubleExtended;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">    llvm_unreachable("Unknown floating semantics");</td>
    <td class="lineNumber">244</td>
    <td class="codeline">    llvm_unreachable("Unknown floating semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">}</td>
    <td class="lineNumber">245</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEhalf() { return semIEEEhalf; }</td>
    <td class="lineNumber">247</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEhalf() { return semIEEEhalf; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">const fltSemantics &APFloatBase::BFloat() { return semBFloat; }</td>
    <td class="lineNumber">248</td>
    <td class="codeline">const fltSemantics &APFloatBase::BFloat() { return semBFloat; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEsingle() { return semIEEEsingle; }</td>
    <td class="lineNumber">249</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEsingle() { return semIEEEsingle; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEdouble() { return semIEEEdouble; }</td>
    <td class="lineNumber">250</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEdouble() { return semIEEEdouble; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEquad() { return semIEEEquad; }</td>
    <td class="lineNumber">251</td>
    <td class="codeline">const fltSemantics &APFloatBase::IEEEquad() { return semIEEEquad; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">const fltSemantics &APFloatBase::PPCDoubleDouble() {</td>
    <td class="lineNumber">252</td>
    <td class="codeline">const fltSemantics &APFloatBase::PPCDoubleDouble() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  return semPPCDoubleDouble;</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  return semPPCDoubleDouble;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">}</td>
    <td class="lineNumber">254</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E5M2() { return semFloat8E5M2; }</td>
    <td class="lineNumber">255</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E5M2() { return semFloat8E5M2; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E5M2FNUZ() { return semFloat8E5M2FNUZ; }</td>
    <td class="lineNumber">256</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E5M2FNUZ() { return semFloat8E5M2FNUZ; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E4M3FN() { return semFloat8E4M3FN; }</td>
    <td class="lineNumber">257</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E4M3FN() { return semFloat8E4M3FN; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E4M3FNUZ() { return semFloat8E4M3FNUZ; }</td>
    <td class="lineNumber">258</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E4M3FNUZ() { return semFloat8E4M3FNUZ; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E4M3B11FNUZ() {</td>
    <td class="lineNumber">259</td>
    <td class="codeline">const fltSemantics &APFloatBase::Float8E4M3B11FNUZ() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  return semFloat8E4M3B11FNUZ;</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  return semFloat8E4M3B11FNUZ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">}</td>
    <td class="lineNumber">261</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">const fltSemantics &APFloatBase::FloatTF32() { return semFloatTF32; }</td>
    <td class="lineNumber">262</td>
    <td class="codeline">const fltSemantics &APFloatBase::FloatTF32() { return semFloatTF32; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">const fltSemantics &APFloatBase::x87DoubleExtended() {</td>
    <td class="lineNumber">263</td>
    <td class="codeline">const fltSemantics &APFloatBase::x87DoubleExtended() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  return semX87DoubleExtended;</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  return semX87DoubleExtended;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">}</td>
    <td class="lineNumber">265</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">const fltSemantics &APFloatBase::Bogus() { return semBogus; }</td>
    <td class="lineNumber">266</td>
    <td class="codeline">const fltSemantics &APFloatBase::Bogus() { return semBogus; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmNearestTiesToEven;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmNearestTiesToEven;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmTowardPositive;</td>
    <td class="lineNumber">269</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmTowardPositive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmTowardNegative;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmTowardNegative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmTowardZero;</td>
    <td class="lineNumber">271</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmTowardZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmNearestTiesToAway;</td>
    <td class="lineNumber">272</td>
    <td class="codeline">constexpr RoundingMode APFloatBase::rmNearestTiesToAway;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">/* A tight upper bound on number of parts required to hold the value</td>
    <td class="lineNumber">274</td>
    <td class="codeline">/* A tight upper bound on number of parts required to hold the value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">   pow(5, power) is</td>
    <td class="lineNumber">275</td>
    <td class="codeline">   pow(5, power) is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">     power * 815 / (351 * integerPartWidth) + 1</td>
    <td class="lineNumber">277</td>
    <td class="codeline">     power * 815 / (351 * integerPartWidth) + 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">   However, whilst the result may require only this many parts,</td>
    <td class="lineNumber">279</td>
    <td class="codeline">   However, whilst the result may require only this many parts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">   because we are multiplying two values to get it, the</td>
    <td class="lineNumber">280</td>
    <td class="codeline">   because we are multiplying two values to get it, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">   multiplication may require an extra part with the excess part</td>
    <td class="lineNumber">281</td>
    <td class="codeline">   multiplication may require an extra part with the excess part</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">   being zero (consider the trivial case of 1 * 1, tcFullMultiply</td>
    <td class="lineNumber">282</td>
    <td class="codeline">   being zero (consider the trivial case of 1 * 1, tcFullMultiply</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">   requires two parts to hold the single-part result).  So we add an</td>
    <td class="lineNumber">283</td>
    <td class="codeline">   requires two parts to hold the single-part result).  So we add an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">   extra one to guarantee enough space whilst multiplying.  */</td>
    <td class="lineNumber">284</td>
    <td class="codeline">   extra one to guarantee enough space whilst multiplying.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">const unsigned int maxExponent = 16383;</td>
    <td class="lineNumber">285</td>
    <td class="codeline">const unsigned int maxExponent = 16383;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">const unsigned int maxPrecision = 113;</td>
    <td class="lineNumber">286</td>
    <td class="codeline">const unsigned int maxPrecision = 113;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">const unsigned int maxPowerOfFiveExponent = maxExponent + maxPrecision - 1;</td>
    <td class="lineNumber">287</td>
    <td class="codeline">const unsigned int maxPowerOfFiveExponent = maxExponent + maxPrecision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">const unsigned int maxPowerOfFiveParts =</td>
    <td class="lineNumber">288</td>
    <td class="codeline">const unsigned int maxPowerOfFiveParts =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    2 +</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    2 +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    ((maxPowerOfFiveExponent * 815) / (351 * APFloatBase::integerPartWidth));</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    ((maxPowerOfFiveExponent * 815) / (351 * APFloatBase::integerPartWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">unsigned int APFloatBase::semanticsPrecision(const fltSemantics &semantics) {</td>
    <td class="lineNumber">292</td>
    <td class="codeline">unsigned int APFloatBase::semanticsPrecision(const fltSemantics &semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  return semantics.precision;</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  return semantics.precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">}</td>
    <td class="lineNumber">294</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">APFloatBase::ExponentType</td>
    <td class="lineNumber">295</td>
    <td class="codeline">APFloatBase::ExponentType</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">APFloatBase::semanticsMaxExponent(const fltSemantics &semantics) {</td>
    <td class="lineNumber">296</td>
    <td class="codeline">APFloatBase::semanticsMaxExponent(const fltSemantics &semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  return semantics.maxExponent;</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  return semantics.maxExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">}</td>
    <td class="lineNumber">298</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">APFloatBase::ExponentType</td>
    <td class="lineNumber">299</td>
    <td class="codeline">APFloatBase::ExponentType</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">APFloatBase::semanticsMinExponent(const fltSemantics &semantics) {</td>
    <td class="lineNumber">300</td>
    <td class="codeline">APFloatBase::semanticsMinExponent(const fltSemantics &semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  return semantics.minExponent;</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  return semantics.minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">}</td>
    <td class="lineNumber">302</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">unsigned int APFloatBase::semanticsSizeInBits(const fltSemantics &semantics) {</td>
    <td class="lineNumber">303</td>
    <td class="codeline">unsigned int APFloatBase::semanticsSizeInBits(const fltSemantics &semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  return semantics.sizeInBits;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  return semantics.sizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">}</td>
    <td class="lineNumber">305</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">unsigned int APFloatBase::semanticsIntSizeInBits(const fltSemantics &semantics,</td>
    <td class="lineNumber">306</td>
    <td class="codeline">unsigned int APFloatBase::semanticsIntSizeInBits(const fltSemantics &semantics,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">                                                 bool isSigned) {</td>
    <td class="lineNumber">307</td>
    <td class="codeline">                                                 bool isSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  // The max FP value is pow(2, MaxExponent) * (1 + MaxFraction), so we need</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  // The max FP value is pow(2, MaxExponent) * (1 + MaxFraction), so we need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  // at least one more bit than the MaxExponent to hold the max FP value.</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  // at least one more bit than the MaxExponent to hold the max FP value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  unsigned int MinBitWidth = semanticsMaxExponent(semantics) + 1;</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  unsigned int MinBitWidth = semanticsMaxExponent(semantics) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  // Extra sign bit needed.</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  // Extra sign bit needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  if (isSigned)</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  if (isSigned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    ++MinBitWidth;</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    ++MinBitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  return MinBitWidth;</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  return MinBitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">}</td>
    <td class="lineNumber">315</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">bool APFloatBase::isRepresentableAsNormalIn(const fltSemantics &Src,</td>
    <td class="lineNumber">317</td>
    <td class="codeline">bool APFloatBase::isRepresentableAsNormalIn(const fltSemantics &Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">                                            const fltSemantics &Dst) {</td>
    <td class="lineNumber">318</td>
    <td class="codeline">                                            const fltSemantics &Dst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  // Exponent range must be larger.</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  // Exponent range must be larger.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  if (Src.maxExponent >= Dst.maxExponent || Src.minExponent <= Dst.minExponent)</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  if (Src.maxExponent >= Dst.maxExponent || Src.minExponent <= Dst.minExponent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  // If the mantissa is long enough, the result value could still be denormal</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  // If the mantissa is long enough, the result value could still be denormal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  // with a larger exponent range.</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  // with a larger exponent range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  // FIXME: This condition is probably not accurate but also shouldn't be a</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  // FIXME: This condition is probably not accurate but also shouldn't be a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  // practical concern with existing types.</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  // practical concern with existing types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  return Dst.precision >= Src.precision;</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  return Dst.precision >= Src.precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">}</td>
    <td class="lineNumber">329</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline"></td>
    <td class="lineNumber">330</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">unsigned APFloatBase::getSizeInBits(const fltSemantics &Sem) {</td>
    <td class="lineNumber">331</td>
    <td class="codeline">unsigned APFloatBase::getSizeInBits(const fltSemantics &Sem) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  return Sem.sizeInBits;</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  return Sem.sizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">}</td>
    <td class="lineNumber">333</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">335</td>
    <td class="codeline">static constexpr APFloatBase::ExponentType</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">exponentZero(const fltSemantics &semantics) {</td>
    <td class="lineNumber">336</td>
    <td class="codeline">exponentZero(const fltSemantics &semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  return semantics.minExponent - 1;</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  return semantics.minExponent - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">}</td>
    <td class="lineNumber">338</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline"></td>
    <td class="lineNumber">339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">340</td>
    <td class="codeline">static constexpr APFloatBase::ExponentType</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">exponentInf(const fltSemantics &semantics) {</td>
    <td class="lineNumber">341</td>
    <td class="codeline">exponentInf(const fltSemantics &semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">  return semantics.maxExponent + 1;</td>
    <td class="lineNumber">342</td>
    <td class="codeline">  return semantics.maxExponent + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">}</td>
    <td class="lineNumber">343</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">345</td>
    <td class="codeline">static constexpr APFloatBase::ExponentType</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">exponentNaN(const fltSemantics &semantics) {</td>
    <td class="lineNumber">346</td>
    <td class="codeline">exponentNaN(const fltSemantics &semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  if (semantics.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  if (semantics.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    if (semantics.nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    if (semantics.nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">      return exponentZero(semantics);</td>
    <td class="lineNumber">349</td>
    <td class="codeline">      return exponentZero(semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">    return semantics.maxExponent;</td>
    <td class="lineNumber">350</td>
    <td class="codeline">    return semantics.maxExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  return semantics.maxExponent + 1;</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  return semantics.maxExponent + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">}</td>
    <td class="lineNumber">353</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">/* A bunch of private, handy routines.  */</td>
    <td class="lineNumber">355</td>
    <td class="codeline">/* A bunch of private, handy routines.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">static inline Error createError(const Twine &Err) {</td>
    <td class="lineNumber">357</td>
    <td class="codeline">static inline Error createError(const Twine &Err) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  return make_error<StringError>(Err, inconvertibleErrorCode());</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  return make_error<StringError>(Err, inconvertibleErrorCode());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">}</td>
    <td class="lineNumber">359</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline"></td>
    <td class="lineNumber">360</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">static constexpr inline unsigned int partCountForBits(unsigned int bits) {</td>
    <td class="lineNumber">361</td>
    <td class="codeline">static constexpr inline unsigned int partCountForBits(unsigned int bits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  return ((bits) + APFloatBase::integerPartWidth - 1) / APFloatBase::integerPartWidth;</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  return ((bits) + APFloatBase::integerPartWidth - 1) / APFloatBase::integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">}</td>
    <td class="lineNumber">363</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">/* Returns 0U-9U.  Return values >= 10U are not digits.  */</td>
    <td class="lineNumber">365</td>
    <td class="codeline">/* Returns 0U-9U.  Return values >= 10U are not digits.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">static inline unsigned int</td>
    <td class="lineNumber">366</td>
    <td class="codeline">static inline unsigned int</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">decDigitValue(unsigned int c)</td>
    <td class="lineNumber">367</td>
    <td class="codeline">decDigitValue(unsigned int c)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">{</td>
    <td class="lineNumber">368</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  return c - '0';</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  return c - '0';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">}</td>
    <td class="lineNumber">370</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">/* Return the value of a decimal exponent of the form</td>
    <td class="lineNumber">372</td>
    <td class="codeline">/* Return the value of a decimal exponent of the form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">   [+-]ddddddd.</td>
    <td class="lineNumber">373</td>
    <td class="codeline">   [+-]ddddddd.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">   If the exponent overflows, returns a large exponent with the</td>
    <td class="lineNumber">375</td>
    <td class="codeline">   If the exponent overflows, returns a large exponent with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">   appropriate sign.  */</td>
    <td class="lineNumber">376</td>
    <td class="codeline">   appropriate sign.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">static Expected<int> readExponent(StringRef::iterator begin,</td>
    <td class="lineNumber">377</td>
    <td class="codeline">static Expected<int> readExponent(StringRef::iterator begin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">                                  StringRef::iterator end) {</td>
    <td class="lineNumber">378</td>
    <td class="codeline">                                  StringRef::iterator end) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  bool isNegative;</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  bool isNegative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  unsigned int absExponent;</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  unsigned int absExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  const unsigned int overlargeExponent = 24000;  /* FIXME.  */</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  const unsigned int overlargeExponent = 24000;  /* FIXME.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  StringRef::iterator p = begin;</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  StringRef::iterator p = begin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline"></td>
    <td class="lineNumber">383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  // Treat no exponent as 0 to match binutils</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  // Treat no exponent as 0 to match binutils</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  if (p == end || ((*p == '-' || *p == '+') && (p + 1) == end)) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  if (p == end || ((*p == '-' || *p == '+') && (p + 1) == end)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  isNegative = (*p == '-');</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  isNegative = (*p == '-');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">391</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    if (p == end)</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    if (p == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">      return createError("Exponent has no digits");</td>
    <td class="lineNumber">393</td>
    <td class="codeline">      return createError("Exponent has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  absExponent = decDigitValue(*p++);</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  absExponent = decDigitValue(*p++);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  if (absExponent >= 10U)</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  if (absExponent >= 10U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">    return createError("Invalid character in exponent");</td>
    <td class="lineNumber">398</td>
    <td class="codeline">    return createError("Invalid character in exponent");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  for (; p != end; ++p) {</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  for (; p != end; ++p) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">    unsigned int value;</td>
    <td class="lineNumber">401</td>
    <td class="codeline">    unsigned int value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    value = decDigitValue(*p);</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    value = decDigitValue(*p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    if (value >= 10U)</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    if (value >= 10U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">      return createError("Invalid character in exponent");</td>
    <td class="lineNumber">405</td>
    <td class="codeline">      return createError("Invalid character in exponent");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline"></td>
    <td class="lineNumber">406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    absExponent = absExponent * 10U + value;</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    absExponent = absExponent * 10U + value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">    if (absExponent >= overlargeExponent) {</td>
    <td class="lineNumber">408</td>
    <td class="codeline">    if (absExponent >= overlargeExponent) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">      absExponent = overlargeExponent;</td>
    <td class="lineNumber">409</td>
    <td class="codeline">      absExponent = overlargeExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">410</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">411</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  if (isNegative)</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  if (isNegative)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    return -(int) absExponent;</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    return -(int) absExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">    return (int) absExponent;</td>
    <td class="lineNumber">417</td>
    <td class="codeline">    return (int) absExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">}</td>
    <td class="lineNumber">418</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">/* This is ugly and needs cleaning up, but I don't immediately see</td>
    <td class="lineNumber">420</td>
    <td class="codeline">/* This is ugly and needs cleaning up, but I don't immediately see</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">   how whilst remaining safe.  */</td>
    <td class="lineNumber">421</td>
    <td class="codeline">   how whilst remaining safe.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">static Expected<int> totalExponent(StringRef::iterator p,</td>
    <td class="lineNumber">422</td>
    <td class="codeline">static Expected<int> totalExponent(StringRef::iterator p,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">                                   StringRef::iterator end,</td>
    <td class="lineNumber">423</td>
    <td class="codeline">                                   StringRef::iterator end,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">                                   int exponentAdjustment) {</td>
    <td class="lineNumber">424</td>
    <td class="codeline">                                   int exponentAdjustment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  int unsignedExponent;</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  int unsignedExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  bool negative, overflow;</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  bool negative, overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  int exponent = 0;</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  int exponent = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  if (p == end)</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  if (p == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">    return createError("Exponent has no digits");</td>
    <td class="lineNumber">430</td>
    <td class="codeline">    return createError("Exponent has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline"></td>
    <td class="lineNumber">431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  negative = *p == '-';</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  negative = *p == '-';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">434</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    if (p == end)</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    if (p == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">      return createError("Exponent has no digits");</td>
    <td class="lineNumber">436</td>
    <td class="codeline">      return createError("Exponent has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  unsignedExponent = 0;</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  unsignedExponent = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  overflow = false;</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  overflow = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  for (; p != end; ++p) {</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  for (; p != end; ++p) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">    unsigned int value;</td>
    <td class="lineNumber">442</td>
    <td class="codeline">    unsigned int value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">    value = decDigitValue(*p);</td>
    <td class="lineNumber">444</td>
    <td class="codeline">    value = decDigitValue(*p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    if (value >= 10U)</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    if (value >= 10U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">      return createError("Invalid character in exponent");</td>
    <td class="lineNumber">446</td>
    <td class="codeline">      return createError("Invalid character in exponent");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline"></td>
    <td class="lineNumber">447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">    unsignedExponent = unsignedExponent * 10 + value;</td>
    <td class="lineNumber">448</td>
    <td class="codeline">    unsignedExponent = unsignedExponent * 10 + value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">    if (unsignedExponent > 32767) {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">    if (unsignedExponent > 32767) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">      overflow = true;</td>
    <td class="lineNumber">450</td>
    <td class="codeline">      overflow = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">451</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">452</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  if (exponentAdjustment > 32767 || exponentAdjustment < -32768)</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  if (exponentAdjustment > 32767 || exponentAdjustment < -32768)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">    overflow = true;</td>
    <td class="lineNumber">456</td>
    <td class="codeline">    overflow = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  if (!overflow) {</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  if (!overflow) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">    exponent = unsignedExponent;</td>
    <td class="lineNumber">459</td>
    <td class="codeline">    exponent = unsignedExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    if (negative)</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    if (negative)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">      exponent = -exponent;</td>
    <td class="lineNumber">461</td>
    <td class="codeline">      exponent = -exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">    exponent += exponentAdjustment;</td>
    <td class="lineNumber">462</td>
    <td class="codeline">    exponent += exponentAdjustment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">    if (exponent > 32767 || exponent < -32768)</td>
    <td class="lineNumber">463</td>
    <td class="codeline">    if (exponent > 32767 || exponent < -32768)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">      overflow = true;</td>
    <td class="lineNumber">464</td>
    <td class="codeline">      overflow = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  if (overflow)</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  if (overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">    exponent = negative ? -32768: 32767;</td>
    <td class="lineNumber">468</td>
    <td class="codeline">    exponent = negative ? -32768: 32767;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  return exponent;</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  return exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">}</td>
    <td class="lineNumber">471</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline"></td>
    <td class="lineNumber">472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">static Expected<StringRef::iterator></td>
    <td class="lineNumber">473</td>
    <td class="codeline">static Expected<StringRef::iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">skipLeadingZeroesAndAnyDot(StringRef::iterator begin, StringRef::iterator end,</td>
    <td class="lineNumber">474</td>
    <td class="codeline">skipLeadingZeroesAndAnyDot(StringRef::iterator begin, StringRef::iterator end,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">                           StringRef::iterator *dot) {</td>
    <td class="lineNumber">475</td>
    <td class="codeline">                           StringRef::iterator *dot) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  StringRef::iterator p = begin;</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  StringRef::iterator p = begin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  *dot = end;</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  *dot = end;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  while (p != end && *p == '0')</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  while (p != end && *p == '0')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">479</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  if (p != end && *p == '.') {</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  if (p != end && *p == '.') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">    *dot = p++;</td>
    <td class="lineNumber">482</td>
    <td class="codeline">    *dot = p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">    if (end - begin == 1)</td>
    <td class="lineNumber">484</td>
    <td class="codeline">    if (end - begin == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">      return createError("Significand has no digits");</td>
    <td class="lineNumber">485</td>
    <td class="codeline">      return createError("Significand has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">    while (p != end && *p == '0')</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    while (p != end && *p == '0')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">      p++;</td>
    <td class="lineNumber">488</td>
    <td class="codeline">      p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline"></td>
    <td class="lineNumber">490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  return p;</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  return p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">}</td>
    <td class="lineNumber">492</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline"></td>
    <td class="lineNumber">493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">/* Given a normal decimal floating point number of the form</td>
    <td class="lineNumber">494</td>
    <td class="codeline">/* Given a normal decimal floating point number of the form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">     dddd.dddd[eE][+-]ddd</td>
    <td class="lineNumber">496</td>
    <td class="codeline">     dddd.dddd[eE][+-]ddd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline"></td>
    <td class="lineNumber">497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">   where the decimal point and exponent are optional, fill out the</td>
    <td class="lineNumber">498</td>
    <td class="codeline">   where the decimal point and exponent are optional, fill out the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">   structure D.  Exponent is appropriate if the significand is</td>
    <td class="lineNumber">499</td>
    <td class="codeline">   structure D.  Exponent is appropriate if the significand is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">   treated as an integer, and normalizedExponent if the significand</td>
    <td class="lineNumber">500</td>
    <td class="codeline">   treated as an integer, and normalizedExponent if the significand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">   is taken to have the decimal point after a single leading</td>
    <td class="lineNumber">501</td>
    <td class="codeline">   is taken to have the decimal point after a single leading</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">   non-zero digit.</td>
    <td class="lineNumber">502</td>
    <td class="codeline">   non-zero digit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">   If the value is zero, V->firstSigDigit points to a non-digit, and</td>
    <td class="lineNumber">504</td>
    <td class="codeline">   If the value is zero, V->firstSigDigit points to a non-digit, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">   the return exponent is zero.</td>
    <td class="lineNumber">505</td>
    <td class="codeline">   the return exponent is zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">*/</td>
    <td class="lineNumber">506</td>
    <td class="codeline">*/</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">struct decimalInfo {</td>
    <td class="lineNumber">507</td>
    <td class="codeline">struct decimalInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  const char *firstSigDigit;</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  const char *firstSigDigit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  const char *lastSigDigit;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  const char *lastSigDigit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  int exponent;</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  int exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  int normalizedExponent;</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  int normalizedExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">};</td>
    <td class="lineNumber">512</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">static Error interpretDecimal(StringRef::iterator begin,</td>
    <td class="lineNumber">514</td>
    <td class="codeline">static Error interpretDecimal(StringRef::iterator begin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">                              StringRef::iterator end, decimalInfo *D) {</td>
    <td class="lineNumber">515</td>
    <td class="codeline">                              StringRef::iterator end, decimalInfo *D) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  StringRef::iterator dot = end;</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  StringRef::iterator dot = end;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  if (!PtrOrErr)</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  if (!PtrOrErr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">    return PtrOrErr.takeError();</td>
    <td class="lineNumber">520</td>
    <td class="codeline">    return PtrOrErr.takeError();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  StringRef::iterator p = *PtrOrErr;</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  StringRef::iterator p = *PtrOrErr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline"></td>
    <td class="lineNumber">522</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  D->firstSigDigit = p;</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  D->firstSigDigit = p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  D->exponent = 0;</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  D->exponent = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  D->normalizedExponent = 0;</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  D->normalizedExponent = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  for (; p != end; ++p) {</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  for (; p != end; ++p) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    if (*p == '.') {</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    if (*p == '.') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">      if (dot != end)</td>
    <td class="lineNumber">529</td>
    <td class="codeline">      if (dot != end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">        return createError("String contains multiple dots");</td>
    <td class="lineNumber">530</td>
    <td class="codeline">        return createError("String contains multiple dots");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">      dot = p++;</td>
    <td class="lineNumber">531</td>
    <td class="codeline">      dot = p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">      if (p == end)</td>
    <td class="lineNumber">532</td>
    <td class="codeline">      if (p == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">533</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">    if (decDigitValue(*p) >= 10U)</td>
    <td class="lineNumber">535</td>
    <td class="codeline">    if (decDigitValue(*p) >= 10U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">536</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  if (p != end) {</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  if (p != end) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    if (*p != 'e' && *p != 'E')</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    if (*p != 'e' && *p != 'E')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">      return createError("Invalid character in significand");</td>
    <td class="lineNumber">541</td>
    <td class="codeline">      return createError("Invalid character in significand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">    if (p == begin)</td>
    <td class="lineNumber">542</td>
    <td class="codeline">    if (p == begin)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">      return createError("Significand has no digits");</td>
    <td class="lineNumber">543</td>
    <td class="codeline">      return createError("Significand has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">    if (dot != end && p - begin == 1)</td>
    <td class="lineNumber">544</td>
    <td class="codeline">    if (dot != end && p - begin == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">      return createError("Significand has no digits");</td>
    <td class="lineNumber">545</td>
    <td class="codeline">      return createError("Significand has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">    /* p points to the first non-digit in the string */</td>
    <td class="lineNumber">547</td>
    <td class="codeline">    /* p points to the first non-digit in the string */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">    auto ExpOrErr = readExponent(p + 1, end);</td>
    <td class="lineNumber">548</td>
    <td class="codeline">    auto ExpOrErr = readExponent(p + 1, end);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">    if (!ExpOrErr)</td>
    <td class="lineNumber">549</td>
    <td class="codeline">    if (!ExpOrErr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">      return ExpOrErr.takeError();</td>
    <td class="lineNumber">550</td>
    <td class="codeline">      return ExpOrErr.takeError();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">    D->exponent = *ExpOrErr;</td>
    <td class="lineNumber">551</td>
    <td class="codeline">    D->exponent = *ExpOrErr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">    /* Implied decimal point?  */</td>
    <td class="lineNumber">553</td>
    <td class="codeline">    /* Implied decimal point?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">    if (dot == end)</td>
    <td class="lineNumber">554</td>
    <td class="codeline">    if (dot == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">      dot = p;</td>
    <td class="lineNumber">555</td>
    <td class="codeline">      dot = p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline"></td>
    <td class="lineNumber">557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">  /* If number is all zeroes accept any exponent.  */</td>
    <td class="lineNumber">558</td>
    <td class="codeline">  /* If number is all zeroes accept any exponent.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">  if (p != D->firstSigDigit) {</td>
    <td class="lineNumber">559</td>
    <td class="codeline">  if (p != D->firstSigDigit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    /* Drop insignificant trailing zeroes.  */</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    /* Drop insignificant trailing zeroes.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">    if (p != begin) {</td>
    <td class="lineNumber">561</td>
    <td class="codeline">    if (p != begin) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">      do</td>
    <td class="lineNumber">562</td>
    <td class="codeline">      do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">        do</td>
    <td class="lineNumber">563</td>
    <td class="codeline">        do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">          p--;</td>
    <td class="lineNumber">564</td>
    <td class="codeline">          p--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">        while (p != begin && *p == '0');</td>
    <td class="lineNumber">565</td>
    <td class="codeline">        while (p != begin && *p == '0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">      while (p != begin && *p == '.');</td>
    <td class="lineNumber">566</td>
    <td class="codeline">      while (p != begin && *p == '.');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">567</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">    /* Adjust the exponents for any decimal point.  */</td>
    <td class="lineNumber">569</td>
    <td class="codeline">    /* Adjust the exponents for any decimal point.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    D->exponent += static_cast<APFloat::ExponentType>((dot - p) - (dot > p));</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    D->exponent += static_cast<APFloat::ExponentType>((dot - p) - (dot > p));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    D->normalizedExponent = (D->exponent +</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    D->normalizedExponent = (D->exponent +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">              static_cast<APFloat::ExponentType>((p - D->firstSigDigit)</td>
    <td class="lineNumber">572</td>
    <td class="codeline">              static_cast<APFloat::ExponentType>((p - D->firstSigDigit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">                                      - (dot > D->firstSigDigit && dot < p)));</td>
    <td class="lineNumber">573</td>
    <td class="codeline">                                      - (dot > D->firstSigDigit && dot < p)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  D->lastSigDigit = p;</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  D->lastSigDigit = p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  return Error::success();</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  return Error::success();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">}</td>
    <td class="lineNumber">578</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">/* Return the trailing fraction of a hexadecimal number.</td>
    <td class="lineNumber">580</td>
    <td class="codeline">/* Return the trailing fraction of a hexadecimal number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">   DIGITVALUE is the first hex digit of the fraction, P points to</td>
    <td class="lineNumber">581</td>
    <td class="codeline">   DIGITVALUE is the first hex digit of the fraction, P points to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">   the next digit.  */</td>
    <td class="lineNumber">582</td>
    <td class="codeline">   the next digit.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">static Expected<lostFraction></td>
    <td class="lineNumber">583</td>
    <td class="codeline">static Expected<lostFraction></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">trailingHexadecimalFraction(StringRef::iterator p, StringRef::iterator end,</td>
    <td class="lineNumber">584</td>
    <td class="codeline">trailingHexadecimalFraction(StringRef::iterator p, StringRef::iterator end,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">                            unsigned int digitValue) {</td>
    <td class="lineNumber">585</td>
    <td class="codeline">                            unsigned int digitValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  unsigned int hexDigit;</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  unsigned int hexDigit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">  /* If the first trailing digit isn't 0 or 8 we can work out the</td>
    <td class="lineNumber">588</td>
    <td class="codeline">  /* If the first trailing digit isn't 0 or 8 we can work out the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">     fraction immediately.  */</td>
    <td class="lineNumber">589</td>
    <td class="codeline">     fraction immediately.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  if (digitValue > 8)</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  if (digitValue > 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    return lfMoreThanHalf;</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    return lfMoreThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  else if (digitValue < 8 && digitValue > 0)</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  else if (digitValue < 8 && digitValue > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    return lfLessThanHalf;</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    return lfLessThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  // Otherwise we need to find the first non-zero digit.</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  // Otherwise we need to find the first non-zero digit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  while (p != end && (*p == '0' || *p == '.'))</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  while (p != end && (*p == '0' || *p == '.'))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  if (p == end)</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  if (p == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">    return createError("Invalid trailing hexadecimal fraction!");</td>
    <td class="lineNumber">600</td>
    <td class="codeline">    return createError("Invalid trailing hexadecimal fraction!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  hexDigit = hexDigitValue(*p);</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  hexDigit = hexDigitValue(*p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  /* If we ran off the end it is exactly zero or one-half, otherwise</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  /* If we ran off the end it is exactly zero or one-half, otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">     a little more.  */</td>
    <td class="lineNumber">605</td>
    <td class="codeline">     a little more.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  if (hexDigit == UINT_MAX)</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  if (hexDigit == UINT_MAX)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    return digitValue == 0 ? lfExactlyZero: lfExactlyHalf;</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    return digitValue == 0 ? lfExactlyZero: lfExactlyHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">    return digitValue == 0 ? lfLessThanHalf: lfMoreThanHalf;</td>
    <td class="lineNumber">609</td>
    <td class="codeline">    return digitValue == 0 ? lfLessThanHalf: lfMoreThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">}</td>
    <td class="lineNumber">610</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">/* Return the fraction lost were a bignum truncated losing the least</td>
    <td class="lineNumber">612</td>
    <td class="codeline">/* Return the fraction lost were a bignum truncated losing the least</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">   significant BITS bits.  */</td>
    <td class="lineNumber">613</td>
    <td class="codeline">   significant BITS bits.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">static lostFraction</td>
    <td class="lineNumber">614</td>
    <td class="codeline">static lostFraction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">lostFractionThroughTruncation(const APFloatBase::integerPart *parts,</td>
    <td class="lineNumber">615</td>
    <td class="codeline">lostFractionThroughTruncation(const APFloatBase::integerPart *parts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">                              unsigned int partCount,</td>
    <td class="lineNumber">616</td>
    <td class="codeline">                              unsigned int partCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">                              unsigned int bits)</td>
    <td class="lineNumber">617</td>
    <td class="codeline">                              unsigned int bits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">{</td>
    <td class="lineNumber">618</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  unsigned int lsb;</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  unsigned int lsb;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline"></td>
    <td class="lineNumber">620</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">  lsb = APInt::tcLSB(parts, partCount);</td>
    <td class="lineNumber">621</td>
    <td class="codeline">  lsb = APInt::tcLSB(parts, partCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline"></td>
    <td class="lineNumber">622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  /* Note this is guaranteed true if bits == 0, or LSB == UINT_MAX.  */</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  /* Note this is guaranteed true if bits == 0, or LSB == UINT_MAX.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  if (bits <= lsb)</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  if (bits <= lsb)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">    return lfExactlyZero;</td>
    <td class="lineNumber">625</td>
    <td class="codeline">    return lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  if (bits == lsb + 1)</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  if (bits == lsb + 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    return lfExactlyHalf;</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    return lfExactlyHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  if (bits <= partCount * APFloatBase::integerPartWidth &&</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  if (bits <= partCount * APFloatBase::integerPartWidth &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">      APInt::tcExtractBit(parts, bits - 1))</td>
    <td class="lineNumber">629</td>
    <td class="codeline">      APInt::tcExtractBit(parts, bits - 1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    return lfMoreThanHalf;</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    return lfMoreThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  return lfLessThanHalf;</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  return lfLessThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">}</td>
    <td class="lineNumber">633</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline"></td>
    <td class="lineNumber">634</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">/* Shift DST right BITS bits noting lost fraction.  */</td>
    <td class="lineNumber">635</td>
    <td class="codeline">/* Shift DST right BITS bits noting lost fraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">static lostFraction</td>
    <td class="lineNumber">636</td>
    <td class="codeline">static lostFraction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">shiftRight(APFloatBase::integerPart *dst, unsigned int parts, unsigned int bits)</td>
    <td class="lineNumber">637</td>
    <td class="codeline">shiftRight(APFloatBase::integerPart *dst, unsigned int parts, unsigned int bits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">{</td>
    <td class="lineNumber">638</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  lost_fraction = lostFractionThroughTruncation(dst, parts, bits);</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  lost_fraction = lostFractionThroughTruncation(dst, parts, bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  APInt::tcShiftRight(dst, parts, bits);</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  APInt::tcShiftRight(dst, parts, bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  return lost_fraction;</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  return lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">}</td>
    <td class="lineNumber">646</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">/* Combine the effect of two lost fractions.  */</td>
    <td class="lineNumber">648</td>
    <td class="codeline">/* Combine the effect of two lost fractions.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">static lostFraction</td>
    <td class="lineNumber">649</td>
    <td class="codeline">static lostFraction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">combineLostFractions(lostFraction moreSignificant,</td>
    <td class="lineNumber">650</td>
    <td class="codeline">combineLostFractions(lostFraction moreSignificant,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">                     lostFraction lessSignificant)</td>
    <td class="lineNumber">651</td>
    <td class="codeline">                     lostFraction lessSignificant)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">{</td>
    <td class="lineNumber">652</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  if (lessSignificant != lfExactlyZero) {</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  if (lessSignificant != lfExactlyZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    if (moreSignificant == lfExactlyZero)</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    if (moreSignificant == lfExactlyZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">      moreSignificant = lfLessThanHalf;</td>
    <td class="lineNumber">655</td>
    <td class="codeline">      moreSignificant = lfLessThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    else if (moreSignificant == lfExactlyHalf)</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    else if (moreSignificant == lfExactlyHalf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">      moreSignificant = lfMoreThanHalf;</td>
    <td class="lineNumber">657</td>
    <td class="codeline">      moreSignificant = lfMoreThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline"></td>
    <td class="lineNumber">659</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  return moreSignificant;</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  return moreSignificant;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">}</td>
    <td class="lineNumber">661</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline"></td>
    <td class="lineNumber">662</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">/* The error from the true value, in half-ulps, on multiplying two</td>
    <td class="lineNumber">663</td>
    <td class="codeline">/* The error from the true value, in half-ulps, on multiplying two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">   floating point numbers, which differ from the value they</td>
    <td class="lineNumber">664</td>
    <td class="codeline">   floating point numbers, which differ from the value they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">   approximate by at most HUE1 and HUE2 half-ulps, is strictly less</td>
    <td class="lineNumber">665</td>
    <td class="codeline">   approximate by at most HUE1 and HUE2 half-ulps, is strictly less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">   than the returned value.</td>
    <td class="lineNumber">666</td>
    <td class="codeline">   than the returned value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">   See "How to Read Floating Point Numbers Accurately" by William D</td>
    <td class="lineNumber">668</td>
    <td class="codeline">   See "How to Read Floating Point Numbers Accurately" by William D</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">   Clinger.  */</td>
    <td class="lineNumber">669</td>
    <td class="codeline">   Clinger.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">static unsigned int</td>
    <td class="lineNumber">670</td>
    <td class="codeline">static unsigned int</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">HUerrBound(bool inexactMultiply, unsigned int HUerr1, unsigned int HUerr2)</td>
    <td class="lineNumber">671</td>
    <td class="codeline">HUerrBound(bool inexactMultiply, unsigned int HUerr1, unsigned int HUerr2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">{</td>
    <td class="lineNumber">672</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  assert(HUerr1 < 2 || HUerr2 < 2 || (HUerr1 + HUerr2 < 8));</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  assert(HUerr1 < 2 || HUerr2 < 2 || (HUerr1 + HUerr2 < 8));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline"></td>
    <td class="lineNumber">674</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  if (HUerr1 + HUerr2 == 0)</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  if (HUerr1 + HUerr2 == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    return inexactMultiply * 2;  /* <= inexactMultiply half-ulps.  */</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    return inexactMultiply * 2;  /* <= inexactMultiply half-ulps.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">    return inexactMultiply + 2 * (HUerr1 + HUerr2);</td>
    <td class="lineNumber">678</td>
    <td class="codeline">    return inexactMultiply + 2 * (HUerr1 + HUerr2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">}</td>
    <td class="lineNumber">679</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">/* The number of ulps from the boundary (zero, or half if ISNEAREST)</td>
    <td class="lineNumber">681</td>
    <td class="codeline">/* The number of ulps from the boundary (zero, or half if ISNEAREST)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">   when the least significant BITS are truncated.  BITS cannot be</td>
    <td class="lineNumber">682</td>
    <td class="codeline">   when the least significant BITS are truncated.  BITS cannot be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">   zero.  */</td>
    <td class="lineNumber">683</td>
    <td class="codeline">   zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">static APFloatBase::integerPart</td>
    <td class="lineNumber">684</td>
    <td class="codeline">static APFloatBase::integerPart</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">ulpsFromBoundary(const APFloatBase::integerPart *parts, unsigned int bits,</td>
    <td class="lineNumber">685</td>
    <td class="codeline">ulpsFromBoundary(const APFloatBase::integerPart *parts, unsigned int bits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">                 bool isNearest) {</td>
    <td class="lineNumber">686</td>
    <td class="codeline">                 bool isNearest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  unsigned int count, partBits;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  unsigned int count, partBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  APFloatBase::integerPart part, boundary;</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  APFloatBase::integerPart part, boundary;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  assert(bits != 0);</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  assert(bits != 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  bits--;</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  bits--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  count = bits / APFloatBase::integerPartWidth;</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  count = bits / APFloatBase::integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  partBits = bits % APFloatBase::integerPartWidth + 1;</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  partBits = bits % APFloatBase::integerPartWidth + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline"></td>
    <td class="lineNumber">695</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  part = parts[count] & (~(APFloatBase::integerPart) 0 >> (APFloatBase::integerPartWidth - partBits));</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  part = parts[count] & (~(APFloatBase::integerPart) 0 >> (APFloatBase::integerPartWidth - partBits));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  if (isNearest)</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  if (isNearest)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">    boundary = (APFloatBase::integerPart) 1 << (partBits - 1);</td>
    <td class="lineNumber">699</td>
    <td class="codeline">    boundary = (APFloatBase::integerPart) 1 << (partBits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    boundary = 0;</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    boundary = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  if (count == 0) {</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  if (count == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    if (part - boundary <= boundary - part)</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    if (part - boundary <= boundary - part)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">      return part - boundary;</td>
    <td class="lineNumber">705</td>
    <td class="codeline">      return part - boundary;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">      return boundary - part;</td>
    <td class="lineNumber">707</td>
    <td class="codeline">      return boundary - part;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  if (part == boundary) {</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  if (part == boundary) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">    while (--count)</td>
    <td class="lineNumber">711</td>
    <td class="codeline">    while (--count)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">      if (parts[count])</td>
    <td class="lineNumber">712</td>
    <td class="codeline">      if (parts[count])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">713</td>
    <td class="codeline">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline"></td>
    <td class="lineNumber">714</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    return parts[0];</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    return parts[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  } else if (part == boundary - 1) {</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  } else if (part == boundary - 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">    while (--count)</td>
    <td class="lineNumber">717</td>
    <td class="codeline">    while (--count)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">      if (~parts[count])</td>
    <td class="lineNumber">718</td>
    <td class="codeline">      if (~parts[count])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">719</td>
    <td class="codeline">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">    return -parts[0];</td>
    <td class="lineNumber">721</td>
    <td class="codeline">    return -parts[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline"></td>
    <td class="lineNumber">723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">  return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">724</td>
    <td class="codeline">  return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">}</td>
    <td class="lineNumber">725</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">/* Place pow(5, power) in DST, and return the number of parts used.</td>
    <td class="lineNumber">727</td>
    <td class="codeline">/* Place pow(5, power) in DST, and return the number of parts used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">   DST must be at least one part larger than size of the answer.  */</td>
    <td class="lineNumber">728</td>
    <td class="codeline">   DST must be at least one part larger than size of the answer.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">static unsigned int</td>
    <td class="lineNumber">729</td>
    <td class="codeline">static unsigned int</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">powerOf5(APFloatBase::integerPart *dst, unsigned int power) {</td>
    <td class="lineNumber">730</td>
    <td class="codeline">powerOf5(APFloatBase::integerPart *dst, unsigned int power) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  static const APFloatBase::integerPart firstEightPowers[] = { 1, 5, 25, 125, 625, 3125, 15625, 78125 };</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  static const APFloatBase::integerPart firstEightPowers[] = { 1, 5, 25, 125, 625, 3125, 15625, 78125 };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  APFloatBase::integerPart pow5s[maxPowerOfFiveParts * 2 + 5];</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  APFloatBase::integerPart pow5s[maxPowerOfFiveParts * 2 + 5];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  pow5s[0] = 78125 * 5;</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  pow5s[0] = 78125 * 5;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline"></td>
    <td class="lineNumber">734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  unsigned int partsCount[16] = { 1 };</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  unsigned int partsCount[16] = { 1 };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  APFloatBase::integerPart scratch[maxPowerOfFiveParts], *p1, *p2, *pow5;</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  APFloatBase::integerPart scratch[maxPowerOfFiveParts], *p1, *p2, *pow5;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">  unsigned int result;</td>
    <td class="lineNumber">737</td>
    <td class="codeline">  unsigned int result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  assert(power <= maxExponent);</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  assert(power <= maxExponent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  p1 = dst;</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  p1 = dst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  p2 = scratch;</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  p2 = scratch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  *p1 = firstEightPowers[power & 7];</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  *p1 = firstEightPowers[power & 7];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  power >>= 3;</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  power >>= 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline"></td>
    <td class="lineNumber">745</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  result = 1;</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  result = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  pow5 = pow5s;</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  pow5 = pow5s;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline"></td>
    <td class="lineNumber">748</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  for (unsigned int n = 0; power; power >>= 1, n++) {</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  for (unsigned int n = 0; power; power >>= 1, n++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    unsigned int pc;</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    unsigned int pc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    pc = partsCount[n];</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    pc = partsCount[n];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    /* Calculate pow(5,pow(2,n+3)) if we haven't yet.  */</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    /* Calculate pow(5,pow(2,n+3)) if we haven't yet.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">    if (pc == 0) {</td>
    <td class="lineNumber">755</td>
    <td class="codeline">    if (pc == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">      pc = partsCount[n - 1];</td>
    <td class="lineNumber">756</td>
    <td class="codeline">      pc = partsCount[n - 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">      APInt::tcFullMultiply(pow5, pow5 - pc, pow5 - pc, pc, pc);</td>
    <td class="lineNumber">757</td>
    <td class="codeline">      APInt::tcFullMultiply(pow5, pow5 - pc, pow5 - pc, pc, pc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">      pc *= 2;</td>
    <td class="lineNumber">758</td>
    <td class="codeline">      pc *= 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">      if (pow5[pc - 1] == 0)</td>
    <td class="lineNumber">759</td>
    <td class="codeline">      if (pow5[pc - 1] == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">        pc--;</td>
    <td class="lineNumber">760</td>
    <td class="codeline">        pc--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">      partsCount[n] = pc;</td>
    <td class="lineNumber">761</td>
    <td class="codeline">      partsCount[n] = pc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline"></td>
    <td class="lineNumber">763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">    if (power & 1) {</td>
    <td class="lineNumber">764</td>
    <td class="codeline">    if (power & 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">      APFloatBase::integerPart *tmp;</td>
    <td class="lineNumber">765</td>
    <td class="codeline">      APFloatBase::integerPart *tmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">      APInt::tcFullMultiply(p2, p1, pow5, result, pc);</td>
    <td class="lineNumber">767</td>
    <td class="codeline">      APInt::tcFullMultiply(p2, p1, pow5, result, pc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">      result += pc;</td>
    <td class="lineNumber">768</td>
    <td class="codeline">      result += pc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">      if (p2[result - 1] == 0)</td>
    <td class="lineNumber">769</td>
    <td class="codeline">      if (p2[result - 1] == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">        result--;</td>
    <td class="lineNumber">770</td>
    <td class="codeline">        result--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">      /* Now result is in p1 with partsCount parts and p2 is scratch</td>
    <td class="lineNumber">772</td>
    <td class="codeline">      /* Now result is in p1 with partsCount parts and p2 is scratch</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">         space.  */</td>
    <td class="lineNumber">773</td>
    <td class="codeline">         space.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">      tmp = p1;</td>
    <td class="lineNumber">774</td>
    <td class="codeline">      tmp = p1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">      p1 = p2;</td>
    <td class="lineNumber">775</td>
    <td class="codeline">      p1 = p2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">      p2 = tmp;</td>
    <td class="lineNumber">776</td>
    <td class="codeline">      p2 = tmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">777</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    pow5 += pc;</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    pow5 += pc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">780</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  if (p1 != dst)</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  if (p1 != dst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">    APInt::tcAssign(dst, p1, result);</td>
    <td class="lineNumber">783</td>
    <td class="codeline">    APInt::tcAssign(dst, p1, result);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  return result;</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  return result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">}</td>
    <td class="lineNumber">786</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">/* Zero at the end to avoid modular arithmetic when adding one; used</td>
    <td class="lineNumber">788</td>
    <td class="codeline">/* Zero at the end to avoid modular arithmetic when adding one; used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">   when rounding up during hexadecimal output.  */</td>
    <td class="lineNumber">789</td>
    <td class="codeline">   when rounding up during hexadecimal output.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">static const char hexDigitsLower[] = "0123456789abcdef0";</td>
    <td class="lineNumber">790</td>
    <td class="codeline">static const char hexDigitsLower[] = "0123456789abcdef0";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">static const char hexDigitsUpper[] = "0123456789ABCDEF0";</td>
    <td class="lineNumber">791</td>
    <td class="codeline">static const char hexDigitsUpper[] = "0123456789ABCDEF0";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">static const char infinityL[] = "infinity";</td>
    <td class="lineNumber">792</td>
    <td class="codeline">static const char infinityL[] = "infinity";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">static const char infinityU[] = "INFINITY";</td>
    <td class="lineNumber">793</td>
    <td class="codeline">static const char infinityU[] = "INFINITY";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">static const char NaNL[] = "nan";</td>
    <td class="lineNumber">794</td>
    <td class="codeline">static const char NaNL[] = "nan";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">static const char NaNU[] = "NAN";</td>
    <td class="lineNumber">795</td>
    <td class="codeline">static const char NaNU[] = "NAN";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">/* Write out an integerPart in hexadecimal, starting with the most</td>
    <td class="lineNumber">797</td>
    <td class="codeline">/* Write out an integerPart in hexadecimal, starting with the most</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">   significant nibble.  Write out exactly COUNT hexdigits, return</td>
    <td class="lineNumber">798</td>
    <td class="codeline">   significant nibble.  Write out exactly COUNT hexdigits, return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">   COUNT.  */</td>
    <td class="lineNumber">799</td>
    <td class="codeline">   COUNT.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">static unsigned int</td>
    <td class="lineNumber">800</td>
    <td class="codeline">static unsigned int</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">partAsHex (char *dst, APFloatBase::integerPart part, unsigned int count,</td>
    <td class="lineNumber">801</td>
    <td class="codeline">partAsHex (char *dst, APFloatBase::integerPart part, unsigned int count,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">           const char *hexDigitChars)</td>
    <td class="lineNumber">802</td>
    <td class="codeline">           const char *hexDigitChars)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">{</td>
    <td class="lineNumber">803</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  unsigned int result = count;</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  unsigned int result = count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  assert(count != 0 && count <= APFloatBase::integerPartWidth / 4);</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  assert(count != 0 && count <= APFloatBase::integerPartWidth / 4);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  part >>= (APFloatBase::integerPartWidth - 4 * count);</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  part >>= (APFloatBase::integerPartWidth - 4 * count);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  while (count--) {</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  while (count--) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    dst[count] = hexDigitChars[part & 0xf];</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    dst[count] = hexDigitChars[part & 0xf];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">    part >>= 4;</td>
    <td class="lineNumber">811</td>
    <td class="codeline">    part >>= 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline"></td>
    <td class="lineNumber">813</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  return result;</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  return result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">}</td>
    <td class="lineNumber">815</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">/* Write out an unsigned decimal integer.  */</td>
    <td class="lineNumber">817</td>
    <td class="codeline">/* Write out an unsigned decimal integer.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">static char *</td>
    <td class="lineNumber">818</td>
    <td class="codeline">static char *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">writeUnsignedDecimal (char *dst, unsigned int n)</td>
    <td class="lineNumber">819</td>
    <td class="codeline">writeUnsignedDecimal (char *dst, unsigned int n)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">{</td>
    <td class="lineNumber">820</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  char buff[40], *p;</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  char buff[40], *p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  p = buff;</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  p = buff;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  do</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">    *p++ = '0' + n % 10;</td>
    <td class="lineNumber">825</td>
    <td class="codeline">    *p++ = '0' + n % 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  while (n /= 10);</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  while (n /= 10);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  do</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">    *dst++ = *--p;</td>
    <td class="lineNumber">829</td>
    <td class="codeline">    *dst++ = *--p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  while (p != buff);</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  while (p != buff);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline"></td>
    <td class="lineNumber">831</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  return dst;</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  return dst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">}</td>
    <td class="lineNumber">833</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline"></td>
    <td class="lineNumber">834</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">/* Write out a signed decimal integer.  */</td>
    <td class="lineNumber">835</td>
    <td class="codeline">/* Write out a signed decimal integer.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">static char *</td>
    <td class="lineNumber">836</td>
    <td class="codeline">static char *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">writeSignedDecimal (char *dst, int value)</td>
    <td class="lineNumber">837</td>
    <td class="codeline">writeSignedDecimal (char *dst, int value)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">{</td>
    <td class="lineNumber">838</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  if (value < 0) {</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  if (value < 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">    *dst++ = '-';</td>
    <td class="lineNumber">840</td>
    <td class="codeline">    *dst++ = '-';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">    dst = writeUnsignedDecimal(dst, -(unsigned) value);</td>
    <td class="lineNumber">841</td>
    <td class="codeline">    dst = writeUnsignedDecimal(dst, -(unsigned) value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">    dst = writeUnsignedDecimal(dst, value);</td>
    <td class="lineNumber">843</td>
    <td class="codeline">    dst = writeUnsignedDecimal(dst, value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  return dst;</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  return dst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">}</td>
    <td class="lineNumber">846</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">848</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">/* Constructors.  */</td>
    <td class="lineNumber">849</td>
    <td class="codeline">/* Constructors.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">void IEEEFloat::initialize(const fltSemantics *ourSemantics) {</td>
    <td class="lineNumber">850</td>
    <td class="codeline">void IEEEFloat::initialize(const fltSemantics *ourSemantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">  unsigned int count;</td>
    <td class="lineNumber">851</td>
    <td class="codeline">  unsigned int count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline"></td>
    <td class="lineNumber">852</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  semantics = ourSemantics;</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  semantics = ourSemantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  count = partCount();</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  count = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  if (count > 1)</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  if (count > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    significand.parts = new integerPart[count];</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    significand.parts = new integerPart[count];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">}</td>
    <td class="lineNumber">857</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">void IEEEFloat::freeSignificand() {</td>
    <td class="lineNumber">859</td>
    <td class="codeline">void IEEEFloat::freeSignificand() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  if (needsCleanup())</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  if (needsCleanup())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">    delete [] significand.parts;</td>
    <td class="lineNumber">861</td>
    <td class="codeline">    delete [] significand.parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">}</td>
    <td class="lineNumber">862</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">void IEEEFloat::assign(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">864</td>
    <td class="codeline">void IEEEFloat::assign(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  sign = rhs.sign;</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  sign = rhs.sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  category = rhs.category;</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  category = rhs.category;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  exponent = rhs.exponent;</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  exponent = rhs.exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  if (isFiniteNonZero() || category == fcNaN)</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  if (isFiniteNonZero() || category == fcNaN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">    copySignificand(rhs);</td>
    <td class="lineNumber">871</td>
    <td class="codeline">    copySignificand(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">}</td>
    <td class="lineNumber">872</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">void IEEEFloat::copySignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">874</td>
    <td class="codeline">void IEEEFloat::copySignificand(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  assert(isFiniteNonZero() || category == fcNaN);</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  assert(isFiniteNonZero() || category == fcNaN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  assert(rhs.partCount() >= partCount());</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  assert(rhs.partCount() >= partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  APInt::tcAssign(significandParts(), rhs.significandParts(),</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  APInt::tcAssign(significandParts(), rhs.significandParts(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">                  partCount());</td>
    <td class="lineNumber">879</td>
    <td class="codeline">                  partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">}</td>
    <td class="lineNumber">880</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">/* Make this number a NaN, with an arbitrary but deterministic value</td>
    <td class="lineNumber">882</td>
    <td class="codeline">/* Make this number a NaN, with an arbitrary but deterministic value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">   for the significand.  If double or longer, this is a signalling NaN,</td>
    <td class="lineNumber">883</td>
    <td class="codeline">   for the significand.  If double or longer, this is a signalling NaN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">   which may not be ideal.  If float, this is QNaN(0).  */</td>
    <td class="lineNumber">884</td>
    <td class="codeline">   which may not be ideal.  If float, this is QNaN(0).  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">void IEEEFloat::makeNaN(bool SNaN, bool Negative, const APInt *fill) {</td>
    <td class="lineNumber">885</td>
    <td class="codeline">void IEEEFloat::makeNaN(bool SNaN, bool Negative, const APInt *fill) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  category = fcNaN;</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  category = fcNaN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  sign = Negative;</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  sign = Negative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  exponent = exponentNaN();</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  exponent = exponentNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">890</td>
    <td class="codeline">  integerPart *significand = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  unsigned numParts = partCount();</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  unsigned numParts = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline"></td>
    <td class="lineNumber">892</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  APInt fill_storage;</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  APInt fill_storage;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">894</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    // Finite-only types do not distinguish signalling and quiet NaN, so</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    // Finite-only types do not distinguish signalling and quiet NaN, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    // make them all signalling.</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    // make them all signalling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">    SNaN = false;</td>
    <td class="lineNumber">897</td>
    <td class="codeline">    SNaN = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">898</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">      sign = true;</td>
    <td class="lineNumber">899</td>
    <td class="codeline">      sign = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">      fill_storage = APInt::getZero(semantics->precision - 1);</td>
    <td class="lineNumber">900</td>
    <td class="codeline">      fill_storage = APInt::getZero(semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">901</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">      fill_storage = APInt::getAllOnes(semantics->precision - 1);</td>
    <td class="lineNumber">902</td>
    <td class="codeline">      fill_storage = APInt::getAllOnes(semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">    fill = &fill_storage;</td>
    <td class="lineNumber">904</td>
    <td class="codeline">    fill = &fill_storage;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  // Set the significand bits to the fill.</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  // Set the significand bits to the fill.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  if (!fill || fill->getNumWords() < numParts)</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  if (!fill || fill->getNumWords() < numParts)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">    APInt::tcSet(significand, 0, numParts);</td>
    <td class="lineNumber">909</td>
    <td class="codeline">    APInt::tcSet(significand, 0, numParts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  if (fill) {</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  if (fill) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">    APInt::tcAssign(significand, fill->getRawData(),</td>
    <td class="lineNumber">911</td>
    <td class="codeline">    APInt::tcAssign(significand, fill->getRawData(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">                    std::min(fill->getNumWords(), numParts));</td>
    <td class="lineNumber">912</td>
    <td class="codeline">                    std::min(fill->getNumWords(), numParts));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">    // Zero out the excess bits of the significand.</td>
    <td class="lineNumber">914</td>
    <td class="codeline">    // Zero out the excess bits of the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">    unsigned bitsToPreserve = semantics->precision - 1;</td>
    <td class="lineNumber">915</td>
    <td class="codeline">    unsigned bitsToPreserve = semantics->precision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">    unsigned part = bitsToPreserve / 64;</td>
    <td class="lineNumber">916</td>
    <td class="codeline">    unsigned part = bitsToPreserve / 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">    bitsToPreserve %= 64;</td>
    <td class="lineNumber">917</td>
    <td class="codeline">    bitsToPreserve %= 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">    significand[part] &= ((1ULL << bitsToPreserve) - 1);</td>
    <td class="lineNumber">918</td>
    <td class="codeline">    significand[part] &= ((1ULL << bitsToPreserve) - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    for (part++; part != numParts; ++part)</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    for (part++; part != numParts; ++part)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">      significand[part] = 0;</td>
    <td class="lineNumber">920</td>
    <td class="codeline">      significand[part] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">921</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">  unsigned QNaNBit = semantics->precision - 2;</td>
    <td class="lineNumber">923</td>
    <td class="codeline">  unsigned QNaNBit = semantics->precision - 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  if (SNaN) {</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  if (SNaN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">    // We always have to clear the QNaN bit to make it an SNaN.</td>
    <td class="lineNumber">926</td>
    <td class="codeline">    // We always have to clear the QNaN bit to make it an SNaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">    APInt::tcClearBit(significand, QNaNBit);</td>
    <td class="lineNumber">927</td>
    <td class="codeline">    APInt::tcClearBit(significand, QNaNBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    // If there are no bits set in the payload, we have to set</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    // If there are no bits set in the payload, we have to set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">    // *something* to make it a NaN instead of an infinity;</td>
    <td class="lineNumber">930</td>
    <td class="codeline">    // *something* to make it a NaN instead of an infinity;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">    // conventionally, this is the next bit down from the QNaN bit.</td>
    <td class="lineNumber">931</td>
    <td class="codeline">    // conventionally, this is the next bit down from the QNaN bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">    if (APInt::tcIsZero(significand, numParts))</td>
    <td class="lineNumber">932</td>
    <td class="codeline">    if (APInt::tcIsZero(significand, numParts))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">      APInt::tcSetBit(significand, QNaNBit - 1);</td>
    <td class="lineNumber">933</td>
    <td class="codeline">      APInt::tcSetBit(significand, QNaNBit - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">  } else if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">934</td>
    <td class="codeline">  } else if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">    // The only NaN is a quiet NaN, and it has no bits sets in the significand.</td>
    <td class="lineNumber">935</td>
    <td class="codeline">    // The only NaN is a quiet NaN, and it has no bits sets in the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    // Do nothing.</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    // Do nothing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">    // We always have to set the QNaN bit to make it a QNaN.</td>
    <td class="lineNumber">938</td>
    <td class="codeline">    // We always have to set the QNaN bit to make it a QNaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">    APInt::tcSetBit(significand, QNaNBit);</td>
    <td class="lineNumber">939</td>
    <td class="codeline">    APInt::tcSetBit(significand, QNaNBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">940</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline"></td>
    <td class="lineNumber">941</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  // For x87 extended precision, we want to make a NaN, not a</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  // For x87 extended precision, we want to make a NaN, not a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">  // pseudo-NaN.  Maybe we should expose the ability to make</td>
    <td class="lineNumber">943</td>
    <td class="codeline">  // pseudo-NaN.  Maybe we should expose the ability to make</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  // pseudo-NaNs?</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  // pseudo-NaNs?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  if (semantics == &semX87DoubleExtended)</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  if (semantics == &semX87DoubleExtended)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    APInt::tcSetBit(significand, QNaNBit + 1);</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    APInt::tcSetBit(significand, QNaNBit + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">}</td>
    <td class="lineNumber">947</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline"></td>
    <td class="lineNumber">948</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">IEEEFloat &IEEEFloat::operator=(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">949</td>
    <td class="codeline">IEEEFloat &IEEEFloat::operator=(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  if (this != &rhs) {</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  if (this != &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">    if (semantics != rhs.semantics) {</td>
    <td class="lineNumber">951</td>
    <td class="codeline">    if (semantics != rhs.semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">      freeSignificand();</td>
    <td class="lineNumber">952</td>
    <td class="codeline">      freeSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">      initialize(rhs.semantics);</td>
    <td class="lineNumber">953</td>
    <td class="codeline">      initialize(rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">954</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    assign(rhs);</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">956</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline"></td>
    <td class="lineNumber">957</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">}</td>
    <td class="lineNumber">959</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline"></td>
    <td class="lineNumber">960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">IEEEFloat &IEEEFloat::operator=(IEEEFloat &&rhs) {</td>
    <td class="lineNumber">961</td>
    <td class="codeline">IEEEFloat &IEEEFloat::operator=(IEEEFloat &&rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  freeSignificand();</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  freeSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline"></td>
    <td class="lineNumber">963</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  semantics = rhs.semantics;</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  semantics = rhs.semantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  significand = rhs.significand;</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  significand = rhs.significand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  exponent = rhs.exponent;</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  exponent = rhs.exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  category = rhs.category;</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  category = rhs.category;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  sign = rhs.sign;</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  sign = rhs.sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  rhs.semantics = &semBogus;</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  rhs.semantics = &semBogus;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">}</td>
    <td class="lineNumber">972</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">bool IEEEFloat::isDenormal() const {</td>
    <td class="lineNumber">974</td>
    <td class="codeline">bool IEEEFloat::isDenormal() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  return isFiniteNonZero() && (exponent == semantics->minExponent) &&</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  return isFiniteNonZero() && (exponent == semantics->minExponent) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">         (APInt::tcExtractBit(significandParts(),</td>
    <td class="lineNumber">976</td>
    <td class="codeline">         (APInt::tcExtractBit(significandParts(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">                              semantics->precision - 1) == 0);</td>
    <td class="lineNumber">977</td>
    <td class="codeline">                              semantics->precision - 1) == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">bool IEEEFloat::isSmallest() const {</td>
    <td class="lineNumber">980</td>
    <td class="codeline">bool IEEEFloat::isSmallest() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  // The smallest number by magnitude in our format will be the smallest</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  // The smallest number by magnitude in our format will be the smallest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  // denormal, i.e. the floating point number with exponent being minimum</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  // denormal, i.e. the floating point number with exponent being minimum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  // exponent and significand bitwise equal to 1 (i.e. with MSB equal to 0).</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  // exponent and significand bitwise equal to 1 (i.e. with MSB equal to 0).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  return isFiniteNonZero() && exponent == semantics->minExponent &&</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  return isFiniteNonZero() && exponent == semantics->minExponent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    significandMSB() == 0;</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    significandMSB() == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">}</td>
    <td class="lineNumber">986</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">bool IEEEFloat::isSmallestNormalized() const {</td>
    <td class="lineNumber">988</td>
    <td class="codeline">bool IEEEFloat::isSmallestNormalized() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  return getCategory() == fcNormal && exponent == semantics->minExponent &&</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  return getCategory() == fcNormal && exponent == semantics->minExponent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">         isSignificandAllZerosExceptMSB();</td>
    <td class="lineNumber">990</td>
    <td class="codeline">         isSignificandAllZerosExceptMSB();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">}</td>
    <td class="lineNumber">991</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllOnes() const {</td>
    <td class="lineNumber">993</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllOnes() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">  // Test if the significand excluding the integral bit is all ones. This allows</td>
    <td class="lineNumber">994</td>
    <td class="codeline">  // Test if the significand excluding the integral bit is all ones. This allows</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  // us to test for binade boundaries.</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  // us to test for binade boundaries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    if (~Parts[i])</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    if (~Parts[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  // Set the unused high bits to all ones when we compare.</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  // Set the unused high bits to all ones when we compare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    PartCount*integerPartWidth - semantics->precision + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">         "Can not have more high bits to fill than integerPartWidth");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  const integerPart HighBitFill =</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  const integerPart HighBitFill =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">    ~integerPart(0) << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">    ~integerPart(0) << (integerPartWidth - NumHighBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  if (~(Parts[PartCount - 1] | HighBitFill))</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  if (~(Parts[PartCount - 1] | HighBitFill))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline"></td>
    <td class="lineNumber">1014</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllOnesExceptLSB() const {</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllOnesExceptLSB() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  // Test if the significand excluding the integral bit is all ones except for</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  // Test if the significand excluding the integral bit is all ones except for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  // the least significant bit.</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  // the least significant bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline"></td>
    <td class="lineNumber">1019</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  if (Parts[0] & 1)</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  if (Parts[0] & 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">    if (~Parts[i] & ~unsigned{!i})</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">    if (~Parts[i] & ~unsigned{!i})</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline"></td>
    <td class="lineNumber">1028</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  // Set the unused high bits to all ones when we compare.</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  // Set the unused high bits to all ones when we compare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">      PartCount * integerPartWidth - semantics->precision + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">         "Can not have more high bits to fill than integerPartWidth");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  const integerPart HighBitFill = ~integerPart(0)</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  const integerPart HighBitFill = ~integerPart(0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">                                  << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">                                  << (integerPartWidth - NumHighBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  if (~(Parts[PartCount - 1] | HighBitFill | 0x1))</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  if (~(Parts[PartCount - 1] | HighBitFill | 0x1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllZeros() const {</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllZeros() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  // Test if the significand excluding the integral bit is all zeros. This</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  // Test if the significand excluding the integral bit is all zeros. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  // allows us to test for binade boundaries.</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  // allows us to test for binade boundaries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">    if (Parts[i])</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">    if (Parts[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  // Compute how many bits are used in the final word.</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  // Compute how many bits are used in the final word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">    PartCount*integerPartWidth - semantics->precision + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  assert(NumHighBits < integerPartWidth && "Can not have more high bits to "</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  assert(NumHighBits < integerPartWidth && "Can not have more high bits to "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">         "clear than integerPartWidth");</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">         "clear than integerPartWidth");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  const integerPart HighBitMask = ~integerPart(0) >> NumHighBits;</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  const integerPart HighBitMask = ~integerPart(0) >> NumHighBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  if (Parts[PartCount - 1] & HighBitMask)</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  if (Parts[PartCount - 1] & HighBitMask)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline"></td>
    <td class="lineNumber">1064</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllZerosExceptMSB() const {</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">bool IEEEFloat::isSignificandAllZerosExceptMSB() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  const integerPart *Parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">    if (Parts[i])</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">    if (Parts[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline"></td>
    <td class="lineNumber">1073</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">  const unsigned NumHighBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">      PartCount * integerPartWidth - semantics->precision + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  return Parts[PartCount - 1] == integerPart(1)</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  return Parts[PartCount - 1] == integerPart(1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">                                     << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">                                     << (integerPartWidth - NumHighBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">bool IEEEFloat::isLargest() const {</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">bool IEEEFloat::isLargest() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">    // The largest number by magnitude in our format will be the floating point</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">    // The largest number by magnitude in our format will be the floating point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">    // number with maximum exponent and with significand that is all ones except</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">    // number with maximum exponent and with significand that is all ones except</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    // the LSB.</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    // the LSB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">           isSignificandAllOnesExceptLSB();</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">           isSignificandAllOnesExceptLSB();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">    // The largest number by magnitude in our format will be the floating point</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">    // The largest number by magnitude in our format will be the floating point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">    // number with maximum exponent and with significand that is all ones.</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">    // number with maximum exponent and with significand that is all ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">           isSignificandAllOnes();</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">           isSignificandAllOnes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">bool IEEEFloat::isInteger() const {</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">bool IEEEFloat::isInteger() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  // This could be made more efficient; I'm going for obviously correct.</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  // This could be made more efficient; I'm going for obviously correct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">  if (!isFinite()) return false;</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">  if (!isFinite()) return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">  IEEEFloat truncated = *this;</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">  IEEEFloat truncated = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  truncated.roundToIntegral(rmTowardZero);</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  truncated.roundToIntegral(rmTowardZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  return compare(truncated) == cmpEqual;</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  return compare(truncated) == cmpEqual;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">bool IEEEFloat::bitwiseIsEqual(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">bool IEEEFloat::bitwiseIsEqual(const IEEEFloat &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  if (this == &rhs)</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  if (this == &rhs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  if (semantics != rhs.semantics ||</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  if (semantics != rhs.semantics ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">      category != rhs.category ||</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">      category != rhs.category ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">      sign != rhs.sign)</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">      sign != rhs.sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  if (category==fcZero || category==fcInfinity)</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  if (category==fcZero || category==fcInfinity)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  if (isFiniteNonZero() && exponent != rhs.exponent)</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  if (isFiniteNonZero() && exponent != rhs.exponent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline"></td>
    <td class="lineNumber">1116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  return std::equal(significandParts(), significandParts() + partCount(),</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  return std::equal(significandParts(), significandParts() + partCount(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">                    rhs.significandParts());</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">                    rhs.significandParts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline"></td>
    <td class="lineNumber">1120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, integerPart value) {</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, integerPart value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  initialize(&ourSemantics);</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  initialize(&ourSemantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">  sign = 0;</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">  sign = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  zeroSignificand();</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  zeroSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  exponent = ourSemantics.precision - 1;</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  exponent = ourSemantics.precision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  significandParts()[0] = value;</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  significandParts()[0] = value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  normalize(rmNearestTiesToEven, lfExactlyZero);</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  normalize(rmNearestTiesToEven, lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics) {</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">  initialize(&ourSemantics);</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">  initialize(&ourSemantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">  makeZero(false);</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">  makeZero(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline"></td>
    <td class="lineNumber">1135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">// Delegate to the previous constructor, because later copy constructor may</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">// Delegate to the previous constructor, because later copy constructor may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">// actually inspects category, which can't be garbage.</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">// actually inspects category, which can't be garbage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, uninitializedTag tag)</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, uninitializedTag tag)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">    : IEEEFloat(ourSemantics) {}</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">    : IEEEFloat(ourSemantics) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  initialize(rhs.semantics);</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  initialize(rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">  assign(rhs);</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">  assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline"></td>
    <td class="lineNumber">1145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">IEEEFloat::IEEEFloat(IEEEFloat &&rhs) : semantics(&semBogus) {</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">IEEEFloat::IEEEFloat(IEEEFloat &&rhs) : semantics(&semBogus) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  *this = std::move(rhs);</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  *this = std::move(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline"></td>
    <td class="lineNumber">1149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">IEEEFloat::~IEEEFloat() { freeSignificand(); }</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">IEEEFloat::~IEEEFloat() { freeSignificand(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">unsigned int IEEEFloat::partCount() const {</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">unsigned int IEEEFloat::partCount() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  return partCountForBits(semantics->precision + 1);</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  return partCountForBits(semantics->precision + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">const IEEEFloat::integerPart *IEEEFloat::significandParts() const {</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">const IEEEFloat::integerPart *IEEEFloat::significandParts() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  return const_cast<IEEEFloat *>(this)->significandParts();</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  return const_cast<IEEEFloat *>(this)->significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">IEEEFloat::integerPart *IEEEFloat::significandParts() {</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">IEEEFloat::integerPart *IEEEFloat::significandParts() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">  if (partCount() > 1)</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">  if (partCount() > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">    return significand.parts;</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">    return significand.parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">    return &significand.part;</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">    return &significand.part;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline"></td>
    <td class="lineNumber">1166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">void IEEEFloat::zeroSignificand() {</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">void IEEEFloat::zeroSignificand() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 0, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">/* Increment an fcNormal floating point number's significand.  */</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">/* Increment an fcNormal floating point number's significand.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">void IEEEFloat::incrementSignificand() {</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">void IEEEFloat::incrementSignificand() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  integerPart carry;</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  integerPart carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline"></td>
    <td class="lineNumber">1174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  carry = APInt::tcIncrement(significandParts(), partCount());</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  carry = APInt::tcIncrement(significandParts(), partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  /* Our callers should never cause us to overflow.  */</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  /* Our callers should never cause us to overflow.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">  assert(carry == 0);</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">  assert(carry == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">  (void)carry;</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">  (void)carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">/* Add the significand of the RHS.  Returns the carry flag.  */</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">/* Add the significand of the RHS.  Returns the carry flag.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">IEEEFloat::integerPart IEEEFloat::addSignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">IEEEFloat::integerPart IEEEFloat::addSignificand(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  integerPart *parts;</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  integerPart *parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline"></td>
    <td class="lineNumber">1185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">  parts = significandParts();</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">  parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline"></td>
    <td class="lineNumber">1187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  assert(exponent == rhs.exponent);</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  assert(exponent == rhs.exponent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline"></td>
    <td class="lineNumber">1190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  return APInt::tcAdd(parts, rhs.significandParts(), 0, partCount());</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  return APInt::tcAdd(parts, rhs.significandParts(), 0, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">/* Subtract the significand of the RHS with a borrow flag.  Returns</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">/* Subtract the significand of the RHS with a borrow flag.  Returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">   the borrow flag.  */</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">   the borrow flag.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">IEEEFloat::integerPart IEEEFloat::subtractSignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">IEEEFloat::integerPart IEEEFloat::subtractSignificand(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">                                                      integerPart borrow) {</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">                                                      integerPart borrow) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  integerPart *parts;</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  integerPart *parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  parts = significandParts();</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline"></td>
    <td class="lineNumber">1201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  assert(exponent == rhs.exponent);</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  assert(exponent == rhs.exponent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  return APInt::tcSubtract(parts, rhs.significandParts(), borrow,</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  return APInt::tcSubtract(parts, rhs.significandParts(), borrow,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">                           partCount());</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">                           partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">/* Multiply the significand of the RHS.  If ADDEND is non-NULL, add it</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">/* Multiply the significand of the RHS.  If ADDEND is non-NULL, add it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">   on to the full-precision result of the multiplication.  Returns the</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">   on to the full-precision result of the multiplication.  Returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">   lost fraction.  */</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">   lost fraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">                                            IEEEFloat addend) {</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">                                            IEEEFloat addend) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  unsigned int omsb;        // One, not zero, based MSB.</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  unsigned int omsb;        // One, not zero, based MSB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  unsigned int partsCount, newPartsCount, precision;</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  unsigned int partsCount, newPartsCount, precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  integerPart *lhsSignificand;</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  integerPart *lhsSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  integerPart scratch[4];</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  integerPart scratch[4];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  integerPart *fullSignificand;</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  integerPart *fullSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  bool ignored;</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  bool ignored;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline"></td>
    <td class="lineNumber">1223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  precision = semantics->precision;</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  precision = semantics->precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  // Allocate space for twice as many bits as the original significand, plus one</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  // Allocate space for twice as many bits as the original significand, plus one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  // extra bit for the addition to overflow into.</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  // extra bit for the addition to overflow into.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  newPartsCount = partCountForBits(precision * 2 + 1);</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  newPartsCount = partCountForBits(precision * 2 + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  if (newPartsCount > 4)</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  if (newPartsCount > 4)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">    fullSignificand = new integerPart[newPartsCount];</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">    fullSignificand = new integerPart[newPartsCount];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">    fullSignificand = scratch;</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">    fullSignificand = scratch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  lhsSignificand = significandParts();</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  lhsSignificand = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  partsCount = partCount();</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  partsCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline"></td>
    <td class="lineNumber">1237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  APInt::tcFullMultiply(fullSignificand, lhsSignificand,</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  APInt::tcFullMultiply(fullSignificand, lhsSignificand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">                        rhs.significandParts(), partsCount, partsCount);</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">                        rhs.significandParts(), partsCount, partsCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline"></td>
    <td class="lineNumber">1240</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  lost_fraction = lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  exponent += rhs.exponent;</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  exponent += rhs.exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline"></td>
    <td class="lineNumber">1244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  // Assume the operands involved in the multiplication are single-precision</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  // Assume the operands involved in the multiplication are single-precision</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">  // FP, and the two multiplicants are:</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">  // FP, and the two multiplicants are:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  //   *this = a23 . a22 ... a0 * 2^e1</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  //   *this = a23 . a22 ... a0 * 2^e1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  //     rhs = b23 . b22 ... b0 * 2^e2</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  //     rhs = b23 . b22 ... b0 * 2^e2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  // the result of multiplication is:</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  // the result of multiplication is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  //   *this = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  //   *this = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  // Note that there are three significant bits at the left-hand side of the</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  // Note that there are three significant bits at the left-hand side of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  // radix point: two for the multiplication, and an overflow bit for the</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  // radix point: two for the multiplication, and an overflow bit for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  // addition (that will always be zero at this point). Move the radix point</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  // addition (that will always be zero at this point). Move the radix point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  // toward left by two bits, and adjust exponent accordingly.</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  // toward left by two bits, and adjust exponent accordingly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  exponent += 2;</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  exponent += 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  if (addend.isNonZero()) {</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  if (addend.isNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">    // The intermediate result of the multiplication has "2 * precision"</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">    // The intermediate result of the multiplication has "2 * precision"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">    // signicant bit; adjust the addend to be consistent with mul result.</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">    // signicant bit; adjust the addend to be consistent with mul result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">    Significand savedSignificand = significand;</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">    Significand savedSignificand = significand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">    const fltSemantics *savedSemantics = semantics;</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">    const fltSemantics *savedSemantics = semantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">    fltSemantics extendedSemantics;</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">    fltSemantics extendedSemantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    opStatus status;</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    opStatus status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">    unsigned int extendedPrecision;</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">    unsigned int extendedPrecision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    // Normalize our MSB to one below the top bit to allow for overflow.</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    // Normalize our MSB to one below the top bit to allow for overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    extendedPrecision = 2 * precision + 1;</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    extendedPrecision = 2 * precision + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">    if (omsb != extendedPrecision - 1) {</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">    if (omsb != extendedPrecision - 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">      assert(extendedPrecision > omsb);</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">      assert(extendedPrecision > omsb);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">      APInt::tcShiftLeft(fullSignificand, newPartsCount,</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">      APInt::tcShiftLeft(fullSignificand, newPartsCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">                         (extendedPrecision - 1) - omsb);</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">                         (extendedPrecision - 1) - omsb);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">      exponent -= (extendedPrecision - 1) - omsb;</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">      exponent -= (extendedPrecision - 1) - omsb;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline"></td>
    <td class="lineNumber">1275</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">    /* Create new semantics.  */</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">    /* Create new semantics.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">    extendedSemantics = *semantics;</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">    extendedSemantics = *semantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    extendedSemantics.precision = extendedPrecision;</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    extendedSemantics.precision = extendedPrecision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline"></td>
    <td class="lineNumber">1279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">    if (newPartsCount == 1)</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">    if (newPartsCount == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">      significand.part = fullSignificand[0];</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">      significand.part = fullSignificand[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">      significand.parts = fullSignificand;</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">      significand.parts = fullSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">    semantics = &extendedSemantics;</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">    semantics = &extendedSemantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">    // Make a copy so we can convert it to the extended semantics.</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">    // Make a copy so we can convert it to the extended semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">    // Note that we cannot convert the addend directly, as the extendedSemantics</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">    // Note that we cannot convert the addend directly, as the extendedSemantics</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">    // is a local variable (which we take a reference to).</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">    // is a local variable (which we take a reference to).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">    IEEEFloat extendedAddend(addend);</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">    IEEEFloat extendedAddend(addend);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">    status = extendedAddend.convert(extendedSemantics, rmTowardZero, &ignored);</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">    status = extendedAddend.convert(extendedSemantics, rmTowardZero, &ignored);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    assert(status == opOK);</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    assert(status == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    (void)status;</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    (void)status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">    // Shift the significand of the addend right by one bit. This guarantees</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">    // Shift the significand of the addend right by one bit. This guarantees</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">    // that the high bit of the significand is zero (same as fullSignificand),</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">    // that the high bit of the significand is zero (same as fullSignificand),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    // so the addition will overflow (if it does overflow at all) into the top bit.</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    // so the addition will overflow (if it does overflow at all) into the top bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">    lost_fraction = extendedAddend.shiftSignificandRight(1);</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">    lost_fraction = extendedAddend.shiftSignificandRight(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    assert(lost_fraction == lfExactlyZero &&</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    assert(lost_fraction == lfExactlyZero &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">           "Lost precision while shifting addend for fused-multiply-add.");</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">           "Lost precision while shifting addend for fused-multiply-add.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">    lost_fraction = addOrSubtractSignificand(extendedAddend, false);</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">    lost_fraction = addOrSubtractSignificand(extendedAddend, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline"></td>
    <td class="lineNumber">1302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">    /* Restore our state.  */</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">    /* Restore our state.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">    if (newPartsCount == 1)</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">    if (newPartsCount == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">      fullSignificand[0] = significand.part;</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">      fullSignificand[0] = significand.part;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">    significand = savedSignificand;</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">    significand = savedSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">    semantics = savedSemantics;</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">    semantics = savedSemantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">    omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">    omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  // Convert the result having "2 * precision" significant-bits back to the one</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  // Convert the result having "2 * precision" significant-bits back to the one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  // having "precision" significant-bits. First, move the radix point from</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  // having "precision" significant-bits. First, move the radix point from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  // poision "2*precision - 1" to "precision - 1". The exponent need to be</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  // poision "2*precision - 1" to "precision - 1". The exponent need to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  // adjusted by "2*precision - 1" - "precision - 1" = "precision".</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  // adjusted by "2*precision - 1" - "precision - 1" = "precision".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  exponent -= precision + 1;</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  exponent -= precision + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  // In case MSB resides at the left-hand side of radix point, shift the</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  // In case MSB resides at the left-hand side of radix point, shift the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  // mantissa right by some amount to make sure the MSB reside right before</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  // mantissa right by some amount to make sure the MSB reside right before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  // the radix point (i.e. "MSB . rest-significant-bits").</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  // the radix point (i.e. "MSB . rest-significant-bits").</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  // Note that the result is not normalized when "omsb < precision". So, the</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  // Note that the result is not normalized when "omsb < precision". So, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  // caller needs to call IEEEFloat::normalize() if normalized value is</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  // caller needs to call IEEEFloat::normalize() if normalized value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  // expected.</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  // expected.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">  if (omsb > precision) {</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">  if (omsb > precision) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    unsigned int bits, significantParts;</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    unsigned int bits, significantParts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">    lostFraction lf;</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">    lostFraction lf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">    bits = omsb - precision;</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">    bits = omsb - precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">    significantParts = partCountForBits(omsb);</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">    significantParts = partCountForBits(omsb);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">    lf = shiftRight(fullSignificand, significantParts, bits);</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">    lf = shiftRight(fullSignificand, significantParts, bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    lost_fraction = combineLostFractions(lf, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">    exponent += bits;</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">    exponent += bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  APInt::tcAssign(lhsSignificand, fullSignificand, partsCount);</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  APInt::tcAssign(lhsSignificand, fullSignificand, partsCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline"></td>
    <td class="lineNumber">1337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">  if (newPartsCount > 4)</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">  if (newPartsCount > 4)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">    delete [] fullSignificand;</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">    delete [] fullSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  return lost_fraction;</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  return lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  return multiplySignificand(rhs, IEEEFloat(*semantics));</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  return multiplySignificand(rhs, IEEEFloat(*semantics));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">/* Multiply the significands of LHS and RHS to DST.  */</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">/* Multiply the significands of LHS and RHS to DST.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">lostFraction IEEEFloat::divideSignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">lostFraction IEEEFloat::divideSignificand(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  unsigned int bit, i, partsCount;</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  unsigned int bit, i, partsCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  const integerPart *rhsSignificand;</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  const integerPart *rhsSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  integerPart *lhsSignificand, *dividend, *divisor;</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  integerPart *lhsSignificand, *dividend, *divisor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  integerPart scratch[4];</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  integerPart scratch[4];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline"></td>
    <td class="lineNumber">1355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline"></td>
    <td class="lineNumber">1357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">  lhsSignificand = significandParts();</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">  lhsSignificand = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">  rhsSignificand = rhs.significandParts();</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">  rhsSignificand = rhs.significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">  partsCount = partCount();</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">  partsCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">  if (partsCount > 2)</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">  if (partsCount > 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">    dividend = new integerPart[partsCount * 2];</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">    dividend = new integerPart[partsCount * 2];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    dividend = scratch;</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    dividend = scratch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">  divisor = dividend + partsCount;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">  divisor = dividend + partsCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline"></td>
    <td class="lineNumber">1368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  /* Copy the dividend and divisor as they will be modified in-place.  */</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  /* Copy the dividend and divisor as they will be modified in-place.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  for (i = 0; i < partsCount; i++) {</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  for (i = 0; i < partsCount; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">    dividend[i] = lhsSignificand[i];</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">    dividend[i] = lhsSignificand[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    divisor[i] = rhsSignificand[i];</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    divisor[i] = rhsSignificand[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    lhsSignificand[i] = 0;</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    lhsSignificand[i] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline"></td>
    <td class="lineNumber">1375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">  exponent -= rhs.exponent;</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">  exponent -= rhs.exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  unsigned int precision = semantics->precision;</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  unsigned int precision = semantics->precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">  /* Normalize the divisor.  */</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">  /* Normalize the divisor.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">  bit = precision - APInt::tcMSB(divisor, partsCount) - 1;</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">  bit = precision - APInt::tcMSB(divisor, partsCount) - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">  if (bit) {</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">  if (bit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">    exponent += bit;</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">    exponent += bit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    APInt::tcShiftLeft(divisor, partsCount, bit);</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    APInt::tcShiftLeft(divisor, partsCount, bit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  /* Normalize the dividend.  */</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  /* Normalize the dividend.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">  bit = precision - APInt::tcMSB(dividend, partsCount) - 1;</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">  bit = precision - APInt::tcMSB(dividend, partsCount) - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">  if (bit) {</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">  if (bit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">    exponent -= bit;</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">    exponent -= bit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">    APInt::tcShiftLeft(dividend, partsCount, bit);</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">    APInt::tcShiftLeft(dividend, partsCount, bit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  /* Ensure the dividend >= divisor initially for the loop below.</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  /* Ensure the dividend >= divisor initially for the loop below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">     Incidentally, this means that the division loop below is</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">     Incidentally, this means that the division loop below is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">     guaranteed to set the integer bit to one.  */</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">     guaranteed to set the integer bit to one.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  if (APInt::tcCompare(dividend, divisor, partsCount) < 0) {</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  if (APInt::tcCompare(dividend, divisor, partsCount) < 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">    exponent--;</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">    exponent--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">    assert(APInt::tcCompare(dividend, divisor, partsCount) >= 0);</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">    assert(APInt::tcCompare(dividend, divisor, partsCount) >= 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline"></td>
    <td class="lineNumber">1402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  /* Long division.  */</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  /* Long division.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">  for (bit = precision; bit; bit -= 1) {</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">  for (bit = precision; bit; bit -= 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    if (APInt::tcCompare(dividend, divisor, partsCount) >= 0) {</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    if (APInt::tcCompare(dividend, divisor, partsCount) >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">      APInt::tcSubtract(dividend, divisor, 0, partsCount);</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">      APInt::tcSubtract(dividend, divisor, 0, partsCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">      APInt::tcSetBit(lhsSignificand, bit - 1);</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">      APInt::tcSetBit(lhsSignificand, bit - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline"></td>
    <td class="lineNumber">1409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">  /* Figure out the lost fraction.  */</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">  /* Figure out the lost fraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">  int cmp = APInt::tcCompare(dividend, divisor, partsCount);</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">  int cmp = APInt::tcCompare(dividend, divisor, partsCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline"></td>
    <td class="lineNumber">1415</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">  if (cmp > 0)</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">  if (cmp > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">    lost_fraction = lfMoreThanHalf;</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">    lost_fraction = lfMoreThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">  else if (cmp == 0)</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">  else if (cmp == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    lost_fraction = lfExactlyHalf;</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    lost_fraction = lfExactlyHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">  else if (APInt::tcIsZero(dividend, partsCount))</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">  else if (APInt::tcIsZero(dividend, partsCount))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">    lost_fraction = lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">    lost_fraction = lfLessThanHalf;</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">    lost_fraction = lfLessThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">  if (partsCount > 2)</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">  if (partsCount > 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">    delete [] dividend;</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">    delete [] dividend;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline"></td>
    <td class="lineNumber">1427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  return lost_fraction;</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  return lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">unsigned int IEEEFloat::significandMSB() const {</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">unsigned int IEEEFloat::significandMSB() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">  return APInt::tcMSB(significandParts(), partCount());</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">  return APInt::tcMSB(significandParts(), partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">unsigned int IEEEFloat::significandLSB() const {</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">unsigned int IEEEFloat::significandLSB() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">  return APInt::tcLSB(significandParts(), partCount());</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">  return APInt::tcLSB(significandParts(), partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline"></td>
    <td class="lineNumber">1438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">/* Note that a zero result is NOT normalized to fcZero.  */</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">/* Note that a zero result is NOT normalized to fcZero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">lostFraction IEEEFloat::shiftSignificandRight(unsigned int bits) {</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">lostFraction IEEEFloat::shiftSignificandRight(unsigned int bits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">  /* Our exponent should not overflow.  */</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">  /* Our exponent should not overflow.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">  assert((ExponentType) (exponent + bits) >= exponent);</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">  assert((ExponentType) (exponent + bits) >= exponent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  exponent += bits;</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  exponent += bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  return shiftRight(significandParts(), partCount(), bits);</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  return shiftRight(significandParts(), partCount(), bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline"></td>
    <td class="lineNumber">1448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">/* Shift the significand left BITS bits, subtract BITS from its exponent.  */</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">/* Shift the significand left BITS bits, subtract BITS from its exponent.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">void IEEEFloat::shiftSignificandLeft(unsigned int bits) {</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">void IEEEFloat::shiftSignificandLeft(unsigned int bits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  assert(bits < semantics->precision);</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  assert(bits < semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline"></td>
    <td class="lineNumber">1452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">  if (bits) {</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">  if (bits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">    unsigned int partsCount = partCount();</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">    unsigned int partsCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">    APInt::tcShiftLeft(significandParts(), partsCount, bits);</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">    APInt::tcShiftLeft(significandParts(), partsCount, bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">    exponent -= bits;</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">    exponent -= bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline"></td>
    <td class="lineNumber">1458</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">    assert(!APInt::tcIsZero(significandParts(), partsCount));</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">    assert(!APInt::tcIsZero(significandParts(), partsCount));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">IEEEFloat::cmpResult</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">IEEEFloat::cmpResult</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">IEEEFloat::compareAbsoluteValue(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">IEEEFloat::compareAbsoluteValue(const IEEEFloat &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  int compare;</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  int compare;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  assert(isFiniteNonZero());</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  assert(isFiniteNonZero());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  assert(rhs.isFiniteNonZero());</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  assert(rhs.isFiniteNonZero());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  compare = exponent - rhs.exponent;</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  compare = exponent - rhs.exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">  /* If exponents are equal, do an unsigned bignum comparison of the</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">  /* If exponents are equal, do an unsigned bignum comparison of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">     significands.  */</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">     significands.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  if (compare == 0)</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  if (compare == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">    compare = APInt::tcCompare(significandParts(), rhs.significandParts(),</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">    compare = APInt::tcCompare(significandParts(), rhs.significandParts(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">                               partCount());</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">                               partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline"></td>
    <td class="lineNumber">1478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  if (compare > 0)</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  if (compare > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">    return cmpGreaterThan;</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">    return cmpGreaterThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">  else if (compare < 0)</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">  else if (compare < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    return cmpLessThan;</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    return cmpLessThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">    return cmpEqual;</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">    return cmpEqual;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline"></td>
    <td class="lineNumber">1486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">/* Set the least significant BITS bits of a bignum, clear the</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">/* Set the least significant BITS bits of a bignum, clear the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">   rest.  */</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">   rest.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">static void tcSetLeastSignificantBits(APInt::WordType *dst, unsigned parts,</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">static void tcSetLeastSignificantBits(APInt::WordType *dst, unsigned parts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">                                      unsigned bits) {</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">                                      unsigned bits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  unsigned i = 0;</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  unsigned i = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  while (bits > APInt::APINT_BITS_PER_WORD) {</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  while (bits > APInt::APINT_BITS_PER_WORD) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">    dst[i++] = ~(APInt::WordType)0;</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">    dst[i++] = ~(APInt::WordType)0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">    bits -= APInt::APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">    bits -= APInt::APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  if (bits)</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  if (bits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">    dst[i++] = ~(APInt::WordType)0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">    dst[i++] = ~(APInt::WordType)0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">  while (i < parts)</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">  while (i < parts)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">    dst[i++] = 0;</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">    dst[i++] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline"></td>
    <td class="lineNumber">1503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">/* Handle overflow.  Sign is preserved.  We either become infinity or</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">/* Handle overflow.  Sign is preserved.  We either become infinity or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">   the largest finite number.  */</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">   the largest finite number.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::handleOverflow(roundingMode rounding_mode) {</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::handleOverflow(roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  /* Infinity?  */</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  /* Infinity?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  if (rounding_mode == rmNearestTiesToEven ||</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  if (rounding_mode == rmNearestTiesToEven ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">      rounding_mode == rmNearestTiesToAway ||</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">      rounding_mode == rmNearestTiesToAway ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">      (rounding_mode == rmTowardPositive && !sign) ||</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">      (rounding_mode == rmTowardPositive && !sign) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">      (rounding_mode == rmTowardNegative && sign)) {</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">      (rounding_mode == rmTowardNegative && sign)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">      makeNaN(false, sign);</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">      makeNaN(false, sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">      category = fcInfinity;</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">      category = fcInfinity;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">    return (opStatus) (opOverflow | opInexact);</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">    return (opStatus) (opOverflow | opInexact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline"></td>
    <td class="lineNumber">1518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">  /* Otherwise we become the largest finite number.  */</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">  /* Otherwise we become the largest finite number.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">  exponent = semantics->maxExponent;</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">  exponent = semantics->maxExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">  tcSetLeastSignificantBits(significandParts(), partCount(),</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">  tcSetLeastSignificantBits(significandParts(), partCount(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">                            semantics->precision);</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">                            semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    APInt::tcClearBit(significandParts(), 0);</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    APInt::tcClearBit(significandParts(), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline"></td>
    <td class="lineNumber">1527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">  return opInexact;</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">  return opInexact;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline"></td>
    <td class="lineNumber">1530</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">/* Returns TRUE if, when truncating the current number, with BIT the</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">/* Returns TRUE if, when truncating the current number, with BIT the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">   new LSB, with the given lost fraction and rounding mode, the result</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">   new LSB, with the given lost fraction and rounding mode, the result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">   would need to be rounded away from zero (i.e., by increasing the</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">   would need to be rounded away from zero (i.e., by increasing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">   signficand).  This routine must work for fcZero of both signs, and</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">   signficand).  This routine must work for fcZero of both signs, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">   fcNormal numbers.  */</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">   fcNormal numbers.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">bool IEEEFloat::roundAwayFromZero(roundingMode rounding_mode,</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">bool IEEEFloat::roundAwayFromZero(roundingMode rounding_mode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">                                  lostFraction lost_fraction,</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">                                  lostFraction lost_fraction,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">                                  unsigned int bit) const {</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">                                  unsigned int bit) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">  /* NaNs and infinities should not have lost fractions.  */</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">  /* NaNs and infinities should not have lost fractions.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  assert(isFiniteNonZero() || category == fcZero);</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  assert(isFiniteNonZero() || category == fcZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">  /* Current callers never pass this so we don't handle it.  */</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">  /* Current callers never pass this so we don't handle it.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  assert(lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  assert(lost_fraction != lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">  switch (rounding_mode) {</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">  switch (rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  case rmNearestTiesToAway:</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  case rmNearestTiesToAway:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">    return lost_fraction == lfExactlyHalf || lost_fraction == lfMoreThanHalf;</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">    return lost_fraction == lfExactlyHalf || lost_fraction == lfMoreThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">  case rmNearestTiesToEven:</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">  case rmNearestTiesToEven:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">    if (lost_fraction == lfMoreThanHalf)</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">    if (lost_fraction == lfMoreThanHalf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">    /* Our zeroes don't have a significand to test.  */</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">    /* Our zeroes don't have a significand to test.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">    if (lost_fraction == lfExactlyHalf && category != fcZero)</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">    if (lost_fraction == lfExactlyHalf && category != fcZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">      return APInt::tcExtractBit(significandParts(), bit);</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">      return APInt::tcExtractBit(significandParts(), bit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline"></td>
    <td class="lineNumber">1556</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  case rmTowardZero:</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  case rmTowardZero:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline"></td>
    <td class="lineNumber">1561</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">  case rmTowardPositive:</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">  case rmTowardPositive:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">    return !sign;</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">    return !sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">  case rmTowardNegative:</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">  case rmTowardNegative:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">    return sign;</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">    return sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline"></td>
    <td class="lineNumber">1567</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">  llvm_unreachable("Invalid rounding mode found");</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">  llvm_unreachable("Invalid rounding mode found");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::normalize(roundingMode rounding_mode,</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::normalize(roundingMode rounding_mode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">                                         lostFraction lost_fraction) {</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">                                         lostFraction lost_fraction) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">  unsigned int omsb;                /* One, not zero, based MSB.  */</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">  unsigned int omsb;                /* One, not zero, based MSB.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">  int exponentChange;</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">  int exponentChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  if (!isFiniteNonZero())</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  if (!isFiniteNonZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">  /* Before rounding normalize the exponent of fcNormal numbers.  */</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">  /* Before rounding normalize the exponent of fcNormal numbers.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">  omsb = significandMSB() + 1;</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">  omsb = significandMSB() + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline"></td>
    <td class="lineNumber">1584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">  if (omsb) {</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">  if (omsb) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">    /* OMSB is numbered from 1.  We want to place it in the integer</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">    /* OMSB is numbered from 1.  We want to place it in the integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">       bit numbered PRECISION if possible, with a compensating change in</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">       bit numbered PRECISION if possible, with a compensating change in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">       the exponent.  */</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">       the exponent.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">    exponentChange = omsb - semantics->precision;</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">    exponentChange = omsb - semantics->precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline"></td>
    <td class="lineNumber">1590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">    /* If the resulting exponent is too high, overflow according to</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">    /* If the resulting exponent is too high, overflow according to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">       the rounding mode.  */</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">       the rounding mode.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">    if (exponent + exponentChange > semantics->maxExponent)</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">    if (exponent + exponentChange > semantics->maxExponent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">      return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">      return handleOverflow(rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline"></td>
    <td class="lineNumber">1595</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    /* Subnormal numbers have exponent minExponent, and their MSB</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    /* Subnormal numbers have exponent minExponent, and their MSB</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">       is forced based on that.  */</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">       is forced based on that.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">    if (exponent + exponentChange < semantics->minExponent)</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">    if (exponent + exponentChange < semantics->minExponent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">      exponentChange = semantics->minExponent - exponent;</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">      exponentChange = semantics->minExponent - exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">    /* Shifting left is easy as we don't lose precision.  */</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">    /* Shifting left is easy as we don't lose precision.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">    if (exponentChange < 0) {</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">    if (exponentChange < 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">      assert(lost_fraction == lfExactlyZero);</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">      assert(lost_fraction == lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">      shiftSignificandLeft(-exponentChange);</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">      shiftSignificandLeft(-exponentChange);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">      return opOK;</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">      return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline"></td>
    <td class="lineNumber">1609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">    if (exponentChange > 0) {</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">    if (exponentChange > 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">      lostFraction lf;</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">      lostFraction lf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">      /* Shift right and capture any new lost fraction.  */</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">      /* Shift right and capture any new lost fraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">      lf = shiftSignificandRight(exponentChange);</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">      lf = shiftSignificandRight(exponentChange);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">      lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">      lost_fraction = combineLostFractions(lf, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline"></td>
    <td class="lineNumber">1617</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">      /* Keep OMSB up-to-date.  */</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">      /* Keep OMSB up-to-date.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">      if (omsb > (unsigned) exponentChange)</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">      if (omsb > (unsigned) exponentChange)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">        omsb -= exponentChange;</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">        omsb -= exponentChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">        omsb = 0;</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">        omsb = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline"></td>
    <td class="lineNumber">1625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">  // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">  // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">  // represented by negative zero, then it is a valid finite value.</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">  // represented by negative zero, then it is a valid finite value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">      exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">      exponent == semantics->maxExponent && isSignificandAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">    return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">    return handleOverflow(rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">  /* Now round the number according to rounding_mode given the lost</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">  /* Now round the number according to rounding_mode given the lost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">     fraction.  */</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">     fraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline"></td>
    <td class="lineNumber">1635</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">  /* As specified in IEEE 754, since we do not trap we do not report</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">  /* As specified in IEEE 754, since we do not trap we do not report</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">     underflow for exact results.  */</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">     underflow for exact results.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">  if (lost_fraction == lfExactlyZero) {</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">  if (lost_fraction == lfExactlyZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">    /* Canonicalize zeroes.  */</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">    /* Canonicalize zeroes.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">    if (omsb == 0) {</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">    if (omsb == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">      category = fcZero;</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">      category = fcZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">        sign = false;</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">        sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline"></td>
    <td class="lineNumber">1645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline"></td>
    <td class="lineNumber">1648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  /* Increment the significand if we're rounding away from zero.  */</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  /* Increment the significand if we're rounding away from zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  if (roundAwayFromZero(rounding_mode, lost_fraction, 0)) {</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  if (roundAwayFromZero(rounding_mode, lost_fraction, 0)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">    if (omsb == 0)</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">    if (omsb == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">      exponent = semantics->minExponent;</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">      exponent = semantics->minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline"></td>
    <td class="lineNumber">1653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">    incrementSignificand();</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">    incrementSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">    omsb = significandMSB() + 1;</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">    omsb = significandMSB() + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline"></td>
    <td class="lineNumber">1656</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">    /* Did the significand increment overflow?  */</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">    /* Did the significand increment overflow?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">    if (omsb == (unsigned) semantics->precision + 1) {</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">    if (omsb == (unsigned) semantics->precision + 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">      /* Renormalize by incrementing the exponent and shifting our</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">      /* Renormalize by incrementing the exponent and shifting our</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">         significand right one.  However if we already have the</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">         significand right one.  However if we already have the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">         maximum exponent we overflow to infinity.  */</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">         maximum exponent we overflow to infinity.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">      if (exponent == semantics->maxExponent)</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">      if (exponent == semantics->maxExponent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">        // Invoke overflow handling with a rounding mode that will guarantee</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">        // Invoke overflow handling with a rounding mode that will guarantee</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">        // that the result gets turned into the correct infinity representation.</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">        // that the result gets turned into the correct infinity representation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">        // This is needed instead of just setting the category to infinity to</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">        // This is needed instead of just setting the category to infinity to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">        // account for 8-bit floating point types that have no inf, only NaN.</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">        // account for 8-bit floating point types that have no inf, only NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">        return handleOverflow(sign ? rmTowardNegative : rmTowardPositive);</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">        return handleOverflow(sign ? rmTowardNegative : rmTowardPositive);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">      shiftSignificandRight(1);</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">      shiftSignificandRight(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline"></td>
    <td class="lineNumber">1670</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">      return opInexact;</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">      return opInexact;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline"></td>
    <td class="lineNumber">1673</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">    // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">    // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">    // represented by negative zero, then it is a valid finite value.</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">    // represented by negative zero, then it is a valid finite value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">        semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">        semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">        exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">        exponent == semantics->maxExponent && isSignificandAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">      return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">      return handleOverflow(rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  /* The normal case - we were and are not denormal, and any</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  /* The normal case - we were and are not denormal, and any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">     significand increment above didn't overflow.  */</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">     significand increment above didn't overflow.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  if (omsb == semantics->precision)</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  if (omsb == semantics->precision)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">    return opInexact;</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">    return opInexact;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  /* We have a non-zero denormal.  */</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  /* We have a non-zero denormal.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">  assert(omsb < semantics->precision);</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">  assert(omsb < semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">  /* Canonicalize zeroes.  */</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">  /* Canonicalize zeroes.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  if (omsb == 0) {</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  if (omsb == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">    category = fcZero;</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">    category = fcZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">      sign = false;</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">      sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  /* The fcZero case is a denormal that underflowed to zero.  */</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  /* The fcZero case is a denormal that underflowed to zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">  return (opStatus) (opUnderflow | opInexact);</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">  return (opStatus) (opUnderflow | opInexact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline"></td>
    <td class="lineNumber">1700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::addOrSubtractSpecials(const IEEEFloat &rhs,</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::addOrSubtractSpecials(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">                                                     bool subtract) {</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">                                                     bool subtract) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline"></td>
    <td class="lineNumber">1706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">    assign(rhs);</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">    assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">    [[fallthrough]];</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">    [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">    if (isSignaling()) {</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">    if (isSignaling()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">      makeQuiet();</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">      makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline"></td>
    <td class="lineNumber">1726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">    category = fcInfinity;</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">    category = fcInfinity;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">    sign = rhs.sign ^ subtract;</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">    sign = rhs.sign ^ subtract;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">    assign(rhs);</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">    assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">    sign = rhs.sign ^ subtract;</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">    sign = rhs.sign ^ subtract;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline"></td>
    <td class="lineNumber">1737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">    /* Sign depends on rounding mode; handled by caller.  */</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">    /* Sign depends on rounding mode; handled by caller.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline"></td>
    <td class="lineNumber">1741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">    /* Differently signed infinities can only be validly</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">    /* Differently signed infinities can only be validly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">       subtracted.  */</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">       subtracted.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">    if (((sign ^ rhs.sign)!=0) != subtract) {</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">    if (((sign ^ rhs.sign)!=0) != subtract) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">      makeNaN();</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">      makeNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline"></td>
    <td class="lineNumber">1751</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">    return opDivByZero;</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">    return opDivByZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline"></td>
    <td class="lineNumber">1756</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">/* Add or subtract two normal numbers.  */</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">/* Add or subtract two normal numbers.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">lostFraction IEEEFloat::addOrSubtractSignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">lostFraction IEEEFloat::addOrSubtractSignificand(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">                                                 bool subtract) {</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">                                                 bool subtract) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">  integerPart carry;</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">  integerPart carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">  int bits;</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">  int bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">  /* Determine if the operation on the absolute values is effectively</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">  /* Determine if the operation on the absolute values is effectively</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">     an addition or subtraction.  */</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">     an addition or subtraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  subtract ^= static_cast<bool>(sign ^ rhs.sign);</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  subtract ^= static_cast<bool>(sign ^ rhs.sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">  /* Are we bigger exponent-wise than the RHS?  */</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">  /* Are we bigger exponent-wise than the RHS?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">  bits = exponent - rhs.exponent;</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">  bits = exponent - rhs.exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline"></td>
    <td class="lineNumber">1770</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">  /* Subtraction is more subtle than one might naively expect.  */</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">  /* Subtraction is more subtle than one might naively expect.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">  if (subtract) {</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">  if (subtract) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    IEEEFloat temp_rhs(rhs);</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    IEEEFloat temp_rhs(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline"></td>
    <td class="lineNumber">1774</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    if (bits == 0)</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    if (bits == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">      lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">      lost_fraction = lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">    else if (bits > 0) {</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">    else if (bits > 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">      lost_fraction = temp_rhs.shiftSignificandRight(bits - 1);</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">      lost_fraction = temp_rhs.shiftSignificandRight(bits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">      shiftSignificandLeft(1);</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">      shiftSignificandLeft(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">      lost_fraction = shiftSignificandRight(-bits - 1);</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">      lost_fraction = shiftSignificandRight(-bits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">      temp_rhs.shiftSignificandLeft(1);</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">      temp_rhs.shiftSignificandLeft(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline"></td>
    <td class="lineNumber">1784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">    // Should we reverse the subtraction.</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">    // Should we reverse the subtraction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">    if (compareAbsoluteValue(temp_rhs) == cmpLessThan) {</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">    if (compareAbsoluteValue(temp_rhs) == cmpLessThan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">      carry = temp_rhs.subtractSignificand</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">      carry = temp_rhs.subtractSignificand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">        (*this, lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">        (*this, lost_fraction != lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">      copySignificand(temp_rhs);</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">      copySignificand(temp_rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">      sign = !sign;</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">      sign = !sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">      carry = subtractSignificand</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">      carry = subtractSignificand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">        (temp_rhs, lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">        (temp_rhs, lost_fraction != lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline"></td>
    <td class="lineNumber">1795</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">    /* Invert the lost fraction - it was on the RHS and</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">    /* Invert the lost fraction - it was on the RHS and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">       subtracted.  */</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">       subtracted.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">    if (lost_fraction == lfLessThanHalf)</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">    if (lost_fraction == lfLessThanHalf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">      lost_fraction = lfMoreThanHalf;</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">      lost_fraction = lfMoreThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">    else if (lost_fraction == lfMoreThanHalf)</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">    else if (lost_fraction == lfMoreThanHalf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">      lost_fraction = lfLessThanHalf;</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">      lost_fraction = lfLessThanHalf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline"></td>
    <td class="lineNumber">1802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">    /* The code above is intended to ensure that no borrow is</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">    /* The code above is intended to ensure that no borrow is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">       necessary.  */</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">       necessary.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">    assert(!carry);</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">    assert(!carry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">    (void)carry;</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">    (void)carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">    if (bits > 0) {</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">    if (bits > 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">      IEEEFloat temp_rhs(rhs);</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">      IEEEFloat temp_rhs(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline"></td>
    <td class="lineNumber">1810</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">      lost_fraction = temp_rhs.shiftSignificandRight(bits);</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">      lost_fraction = temp_rhs.shiftSignificandRight(bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">      carry = addSignificand(temp_rhs);</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">      carry = addSignificand(temp_rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">      lost_fraction = shiftSignificandRight(-bits);</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">      lost_fraction = shiftSignificandRight(-bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">      carry = addSignificand(rhs);</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">      carry = addSignificand(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline"></td>
    <td class="lineNumber">1817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">    /* We have a guard bit; generating a carry cannot happen.  */</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">    /* We have a guard bit; generating a carry cannot happen.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">    assert(!carry);</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">    assert(!carry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">    (void)carry;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">    (void)carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline"></td>
    <td class="lineNumber">1822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  return lost_fraction;</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  return lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline"></td>
    <td class="lineNumber">1825</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::multiplySpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::multiplySpecials(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline"></td>
    <td class="lineNumber">1830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">    assign(rhs);</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">    assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">    sign = false;</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">    sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">    [[fallthrough]];</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">    [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">    sign ^= rhs.sign; // restore the original sign</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">    sign ^= rhs.sign; // restore the original sign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">    if (isSignaling()) {</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">    if (isSignaling()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">      makeQuiet();</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">      makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">    category = fcInfinity;</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">    category = fcInfinity;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline"></td>
    <td class="lineNumber">1853</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">    category = fcZero;</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">    category = fcZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline"></td>
    <td class="lineNumber">1859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">    makeNaN();</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">    makeNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">    return opInvalidOp;</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">    return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline"></td>
    <td class="lineNumber">1864</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline"></td>
    <td class="lineNumber">1869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::divideSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::divideSpecials(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline"></td>
    <td class="lineNumber">1874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">    assign(rhs);</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">    assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">    sign = false;</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">    sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">    [[fallthrough]];</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">    [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">    sign ^= rhs.sign; // restore the original sign</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">    sign ^= rhs.sign; // restore the original sign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">    if (isSignaling()) {</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">    if (isSignaling()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">      makeQuiet();</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">      makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline"></td>
    <td class="lineNumber">1891</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline"></td>
    <td class="lineNumber">1897</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">    category = fcZero;</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">    category = fcZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline"></td>
    <td class="lineNumber">1901</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">      makeNaN(false, sign);</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">      makeNaN(false, sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">      category = fcInfinity;</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">      category = fcInfinity;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">    return opDivByZero;</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">    return opDivByZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline"></td>
    <td class="lineNumber">1908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">    makeNaN();</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">    makeNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">    return opInvalidOp;</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">    return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline"></td>
    <td class="lineNumber">1918</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::modSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::modSpecials(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">    assign(rhs);</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">    assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">    [[fallthrough]];</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">    [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">    if (isSignaling()) {</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">    if (isSignaling()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">      makeQuiet();</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">      makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline"></td>
    <td class="lineNumber">1938</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline"></td>
    <td class="lineNumber">1943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">    makeNaN();</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">    makeNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">    return opInvalidOp;</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">    return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::remainderSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::remainderSpecials(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline"></td>
    <td class="lineNumber">1961</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    assign(rhs);</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    assign(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">    [[fallthrough]];</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">    [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">    if (isSignaling()) {</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">    if (isSignaling()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">      makeQuiet();</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">      makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline"></td>
    <td class="lineNumber">1976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline"></td>
    <td class="lineNumber">1981</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">    makeNaN();</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">    makeNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">    return opInvalidOp;</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">    return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">    return opDivByZero; // fake status, indicating this is not a special case</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">    return opDivByZero; // fake status, indicating this is not a special case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline"></td>
    <td class="lineNumber">1994</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">/* Change sign.  */</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">/* Change sign.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">void IEEEFloat::changeSign() {</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">void IEEEFloat::changeSign() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">  // With NaN-as-negative-zero, neither NaN or negative zero can change</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">  // With NaN-as-negative-zero, neither NaN or negative zero can change</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">  // their signs.</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">  // their signs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">      (isZero() || isNaN()))</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">      (isZero() || isNaN()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">  /* Look mummy, this one's easy.  */</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">  /* Look mummy, this one's easy.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">  sign = !sign;</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">  sign = !sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline"></td>
    <td class="lineNumber">2005</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">/* Normalized addition or subtraction.  */</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">/* Normalized addition or subtraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::addOrSubtract(const IEEEFloat &rhs,</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::addOrSubtract(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">                                             roundingMode rounding_mode,</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">                                             roundingMode rounding_mode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">                                             bool subtract) {</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">                                             bool subtract) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline"></td>
    <td class="lineNumber">2011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  fs = addOrSubtractSpecials(rhs, subtract);</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  fs = addOrSubtractSpecials(rhs, subtract);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline"></td>
    <td class="lineNumber">2013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  /* This return code means it was not a simple case.  */</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  /* This return code means it was not a simple case.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  if (fs == opDivByZero) {</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  if (fs == opDivByZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">    lostFraction lost_fraction;</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">    lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline"></td>
    <td class="lineNumber">2017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    lost_fraction = addOrSubtractSignificand(rhs, subtract);</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    lost_fraction = addOrSubtractSignificand(rhs, subtract);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">    /* Can only be zero if we lost no fraction.  */</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">    /* Can only be zero if we lost no fraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">    assert(category != fcZero || lost_fraction == lfExactlyZero);</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">    assert(category != fcZero || lost_fraction == lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline"></td>
    <td class="lineNumber">2024</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">  /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">  /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">     positive zero unless rounding to minus infinity, except that</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">     positive zero unless rounding to minus infinity, except that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">     adding two like-signed zeroes gives that zero.  */</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">     adding two like-signed zeroes gives that zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  if (category == fcZero) {</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  if (category == fcZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">    if (rhs.category != fcZero || (sign == rhs.sign) == subtract)</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">    if (rhs.category != fcZero || (sign == rhs.sign) == subtract)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">      sign = (rounding_mode == rmTowardNegative);</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">      sign = (rounding_mode == rmTowardNegative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">    // NaN-in-negative-zero means zeros need to be normalized to +0.</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">    // NaN-in-negative-zero means zeros need to be normalized to +0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">      sign = false;</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">      sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline"></td>
    <td class="lineNumber">2038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">/* Normalized addition.  */</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">/* Normalized addition.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::add(const IEEEFloat &rhs,</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::add(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">                                   roundingMode rounding_mode) {</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">                                   roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">  return addOrSubtract(rhs, rounding_mode, false);</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">  return addOrSubtract(rhs, rounding_mode, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline"></td>
    <td class="lineNumber">2044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">/* Normalized subtraction.  */</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">/* Normalized subtraction.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::subtract(const IEEEFloat &rhs,</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::subtract(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  return addOrSubtract(rhs, rounding_mode, true);</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  return addOrSubtract(rhs, rounding_mode, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline"></td>
    <td class="lineNumber">2050</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">/* Normalized multiply.  */</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">/* Normalized multiply.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::multiply(const IEEEFloat &rhs,</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::multiply(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline"></td>
    <td class="lineNumber">2055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  sign ^= rhs.sign;</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  sign ^= rhs.sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  fs = multiplySpecials(rhs);</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  fs = multiplySpecials(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline"></td>
    <td class="lineNumber">2058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">    sign = false;</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">    sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">    lostFraction lost_fraction = multiplySignificand(rhs);</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">    lostFraction lost_fraction = multiplySignificand(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">      fs = (opStatus) (fs | opInexact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline"></td>
    <td class="lineNumber">2067</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline"></td>
    <td class="lineNumber">2070</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">/* Normalized divide.  */</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">/* Normalized divide.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::divide(const IEEEFloat &rhs,</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::divide(const IEEEFloat &rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">                                      roundingMode rounding_mode) {</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">                                      roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  sign ^= rhs.sign;</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  sign ^= rhs.sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  fs = divideSpecials(rhs);</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  fs = divideSpecials(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">    sign = false;</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">    sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">    lostFraction lost_fraction = divideSignificand(rhs);</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">    lostFraction lost_fraction = divideSignificand(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">      fs = (opStatus) (fs | opInexact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline"></td>
    <td class="lineNumber">2087</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline"></td>
    <td class="lineNumber">2090</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">/* Normalized remainder.  */</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">/* Normalized remainder.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::remainder(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::remainder(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  unsigned int origSign = sign;</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  unsigned int origSign = sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline"></td>
    <td class="lineNumber">2095</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  // First handle the special cases.</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  // First handle the special cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">  fs = remainderSpecials(rhs);</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">  fs = remainderSpecials(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  if (fs != opDivByZero)</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  if (fs != opDivByZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">    return fs;</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">    return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  fs = opOK;</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  fs = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  // Make sure the current value is less than twice the denom. If the addition</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  // Make sure the current value is less than twice the denom. If the addition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  // did not succeed (an overflow has happened), which means that the finite</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  // did not succeed (an overflow has happened), which means that the finite</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  // value we currently posses must be less than twice the denom (as we are</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  // value we currently posses must be less than twice the denom (as we are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  // using the same semantics).</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  // using the same semantics).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  IEEEFloat P2 = rhs;</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  IEEEFloat P2 = rhs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  if (P2.add(rhs, rmNearestTiesToEven) == opOK) {</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  if (P2.add(rhs, rmNearestTiesToEven) == opOK) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">    fs = mod(P2);</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">    fs = mod(P2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">    assert(fs == opOK);</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">    assert(fs == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline"></td>
    <td class="lineNumber">2112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  // Lets work with absolute numbers.</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  // Lets work with absolute numbers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">  IEEEFloat P = rhs;</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">  IEEEFloat P = rhs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  P.sign = false;</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  P.sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">  sign = false;</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">  sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  // To calculate the remainder we use the following scheme.</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  // To calculate the remainder we use the following scheme.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">  // The remainder is defained as follows:</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">  // The remainder is defained as follows:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">  // remainder = numer - rquot * denom = x - r * p</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">  // remainder = numer - rquot * denom = x - r * p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  // Where r is the result of: x/p, rounded toward the nearest integral value</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  // Where r is the result of: x/p, rounded toward the nearest integral value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">  // (with halfway cases rounded toward the even number).</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">  // (with halfway cases rounded toward the even number).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">  // Currently, (after x mod 2p):</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">  // Currently, (after x mod 2p):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">  // r is the number of 2p's present inside x, which is inherently, an even</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">  // r is the number of 2p's present inside x, which is inherently, an even</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">  // number of p's.</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">  // number of p's.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  // We may split the remaining calculation into 4 options:</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  // We may split the remaining calculation into 4 options:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">  // - if x == 0.5p then we round to the nearest even number which is 0, and we</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">  // - if x == 0.5p then we round to the nearest even number which is 0, and we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">  //   are done as well.</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">  //   are done as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">  // - if 0.5p < x < p then we round to nearest number which is 1, and we have</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">  // - if 0.5p < x < p then we round to nearest number which is 1, and we have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">  //   to subtract 1p at least once.</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">  //   to subtract 1p at least once.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  // - if x >= p then we must subtract p at least once, as x must be a</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  // - if x >= p then we must subtract p at least once, as x must be a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">  //   remainder.</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">  //   remainder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">  // By now, we were done, or we added 1 to r, which in turn, now an odd number.</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">  // By now, we were done, or we added 1 to r, which in turn, now an odd number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  // We can now split the remaining calculation to the following 3 options:</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  // We can now split the remaining calculation to the following 3 options:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  // - if x == 0.5p then we round to the nearest even number. As r is odd, we</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  // - if x == 0.5p then we round to the nearest even number. As r is odd, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">  //   must round up to the next even number. so we must subtract p once more.</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">  //   must round up to the next even number. so we must subtract p once more.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">  // - if x > 0.5p (and inherently x < p) then we must round r up to the next</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">  // - if x > 0.5p (and inherently x < p) then we must round r up to the next</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">  //   integral, and subtract p once more.</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">  //   integral, and subtract p once more.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">  // Extend the semantics to prevent an overflow/underflow or inexact result.</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">  // Extend the semantics to prevent an overflow/underflow or inexact result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">  bool losesInfo;</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">  bool losesInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">  fltSemantics extendedSemantics = *semantics;</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">  fltSemantics extendedSemantics = *semantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">  extendedSemantics.maxExponent++;</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">  extendedSemantics.maxExponent++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">  extendedSemantics.minExponent--;</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">  extendedSemantics.minExponent--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  extendedSemantics.precision += 2;</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  extendedSemantics.precision += 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">  IEEEFloat VEx = *this;</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">  IEEEFloat VEx = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">  fs = VEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">  fs = VEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  IEEEFloat PEx = P;</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  IEEEFloat PEx = P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">  fs = PEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">  fs = PEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline"></td>
    <td class="lineNumber">2164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  // It is simpler to work with 2x instead of 0.5p, and we do not need to lose</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  // It is simpler to work with 2x instead of 0.5p, and we do not need to lose</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  // any fraction.</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  // any fraction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">  fs = VEx.add(VEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">  fs = VEx.add(VEx, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  assert(fs == opOK);</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  assert(fs == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline"></td>
    <td class="lineNumber">2169</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">  if (VEx.compare(PEx) == cmpGreaterThan) {</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">  if (VEx.compare(PEx) == cmpGreaterThan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">    fs = subtract(P, rmNearestTiesToEven);</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">    fs = subtract(P, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">    assert(fs == opOK);</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">    assert(fs == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline"></td>
    <td class="lineNumber">2173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">    // Make VEx = this.add(this), but because we have different semantics, we do</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">    // Make VEx = this.add(this), but because we have different semantics, we do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">    // not want to `convert` again, so we just subtract PEx twice (which equals</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">    // not want to `convert` again, so we just subtract PEx twice (which equals</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">    // to the desired value).</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">    // to the desired value).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">    assert(fs == opOK);</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">    assert(fs == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">    assert(fs == opOK);</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">    assert(fs == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">    cmpResult result = VEx.compare(PEx);</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">    cmpResult result = VEx.compare(PEx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">    if (result == cmpGreaterThan || result == cmpEqual) {</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">    if (result == cmpGreaterThan || result == cmpEqual) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">      fs = subtract(P, rmNearestTiesToEven);</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">      fs = subtract(P, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">      assert(fs == opOK);</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">      assert(fs == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline"></td>
    <td class="lineNumber">2188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">  if (isZero()) {</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">  if (isZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">    sign = origSign;    // IEEE754 requires this</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">    sign = origSign;    // IEEE754 requires this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">      // But some 8-bit floats only have positive 0.</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">      // But some 8-bit floats only have positive 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">      sign = false;</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">      sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">    sign ^= origSign;</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">    sign ^= origSign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline"></td>
    <td class="lineNumber">2200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">/* Normalized llvm frem (C fmod). */</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">/* Normalized llvm frem (C fmod). */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::mod(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::mod(const IEEEFloat &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">  fs = modSpecials(rhs);</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">  fs = modSpecials(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">  unsigned int origSign = sign;</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">  unsigned int origSign = sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline"></td>
    <td class="lineNumber">2206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">  while (isFiniteNonZero() && rhs.isFiniteNonZero() &&</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">  while (isFiniteNonZero() && rhs.isFiniteNonZero() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">         compareAbsoluteValue(rhs) != cmpLessThan) {</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">         compareAbsoluteValue(rhs) != cmpLessThan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">    int Exp = ilogb(*this) - ilogb(rhs);</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">    int Exp = ilogb(*this) - ilogb(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">    IEEEFloat V = scalbn(rhs, Exp, rmNearestTiesToEven);</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">    IEEEFloat V = scalbn(rhs, Exp, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">    // V can overflow to NaN with fltNonfiniteBehavior::NanOnly, so explicitly</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">    // V can overflow to NaN with fltNonfiniteBehavior::NanOnly, so explicitly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">    // check for it.</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">    // check for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">    if (V.isNaN() || compareAbsoluteValue(V) == cmpLessThan)</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">    if (V.isNaN() || compareAbsoluteValue(V) == cmpLessThan)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">      V = scalbn(rhs, Exp - 1, rmNearestTiesToEven);</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">      V = scalbn(rhs, Exp - 1, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">    V.sign = sign;</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">    V.sign = sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">    fs = subtract(V, rmNearestTiesToEven);</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">    fs = subtract(V, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">    assert(fs==opOK);</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">    assert(fs==opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">  if (isZero()) {</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">  if (isZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">    sign = origSign; // fmod requires this</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">    sign = origSign; // fmod requires this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">      sign = false;</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">      sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline"></td>
    <td class="lineNumber">2227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">/* Normalized fused-multiply-add.  */</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">/* Normalized fused-multiply-add.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::fusedMultiplyAdd(const IEEEFloat &multiplicand,</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::fusedMultiplyAdd(const IEEEFloat &multiplicand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">                                                const IEEEFloat &addend,</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">                                                const IEEEFloat &addend,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">                                                roundingMode rounding_mode) {</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">                                                roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline"></td>
    <td class="lineNumber">2233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  /* Post-multiplication sign, before addition.  */</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  /* Post-multiplication sign, before addition.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">  sign ^= multiplicand.sign;</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">  sign ^= multiplicand.sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline"></td>
    <td class="lineNumber">2236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  /* If and only if all arguments are normal do we need to do an</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  /* If and only if all arguments are normal do we need to do an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">     extended-precision calculation.  */</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">     extended-precision calculation.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  if (isFiniteNonZero() &&</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  if (isFiniteNonZero() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">      multiplicand.isFiniteNonZero() &&</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">      multiplicand.isFiniteNonZero() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">      addend.isFinite()) {</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">      addend.isFinite()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">    lostFraction lost_fraction;</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">    lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">    lost_fraction = multiplySignificand(multiplicand, addend);</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">    lost_fraction = multiplySignificand(multiplicand, addend);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">    fs = normalize(rounding_mode, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">      fs = (opStatus) (fs | opInexact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">    /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">    /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">       positive zero unless rounding to minus infinity, except that</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">       positive zero unless rounding to minus infinity, except that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">       adding two like-signed zeroes gives that zero.  */</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">       adding two like-signed zeroes gives that zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">    if (category == fcZero && !(fs & opUnderflow) && sign != addend.sign) {</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">    if (category == fcZero && !(fs & opUnderflow) && sign != addend.sign) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">      sign = (rounding_mode == rmTowardNegative);</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">      sign = (rounding_mode == rmTowardNegative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">        sign = false;</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">        sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">    fs = multiplySpecials(multiplicand);</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">    fs = multiplySpecials(multiplicand);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline"></td>
    <td class="lineNumber">2259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    /* FS can only be opOK or opInvalidOp.  There is no more work</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    /* FS can only be opOK or opInvalidOp.  There is no more work</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">       to do in the latter case.  The IEEE-754R standard says it is</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">       to do in the latter case.  The IEEE-754R standard says it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">       implementation-defined in this case whether, if ADDEND is a</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">       implementation-defined in this case whether, if ADDEND is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">       quiet NaN, we raise invalid op; this implementation does so.</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">       quiet NaN, we raise invalid op; this implementation does so.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline"></td>
    <td class="lineNumber">2264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">       If we need to do the addition we can do so with normal</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">       If we need to do the addition we can do so with normal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">       precision.  */</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">       precision.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">    if (fs == opOK)</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">    if (fs == opOK)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">      fs = addOrSubtract(addend, rounding_mode, false);</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">      fs = addOrSubtract(addend, rounding_mode, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline"></td>
    <td class="lineNumber">2270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">/* Rounding-mode correct round to integral value.  */</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">/* Rounding-mode correct round to integral value.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::roundToIntegral(roundingMode rounding_mode) {</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::roundToIntegral(roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline"></td>
    <td class="lineNumber">2277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">  if (isInfinity())</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">  if (isInfinity())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">    // [IEEE Std 754-2008 6.1]:</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">    // [IEEE Std 754-2008 6.1]:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">    // The behavior of infinity in floating-point arithmetic is derived from the</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">    // The behavior of infinity in floating-point arithmetic is derived from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">    // limiting cases of real arithmetic with operands of arbitrarily</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">    // limiting cases of real arithmetic with operands of arbitrarily</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">    // large magnitude, when such a limit exists.</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">    // large magnitude, when such a limit exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">    // ...</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">    // ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">    // Operations on infinite operands are usually exact and therefore signal no</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">    // Operations on infinite operands are usually exact and therefore signal no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">    // exceptions ...</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">    // exceptions ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline"></td>
    <td class="lineNumber">2287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">  if (isNaN()) {</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">  if (isNaN()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">    if (isSignaling()) {</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">    if (isSignaling()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">      // [IEEE Std 754-2008 6.2]:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">      // Under default exception handling, any operation signaling an invalid</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">      // Under default exception handling, any operation signaling an invalid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">      // operation exception and for which a floating-point result is to be</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">      // operation exception and for which a floating-point result is to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">      // delivered shall deliver a quiet NaN.</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">      // delivered shall deliver a quiet NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">      makeQuiet();</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">      makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">      // [IEEE Std 754-2008 6.2]:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">      // Signaling NaNs shall be reserved operands that, under default exception</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">      // Signaling NaNs shall be reserved operands that, under default exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">      // handling, signal the invalid operation exception(see 7.2) for every</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">      // handling, signal the invalid operation exception(see 7.2) for every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">      // general-computational and signaling-computational operation except for</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">      // general-computational and signaling-computational operation except for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">      // the conversions described in 5.12.</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">      // the conversions described in 5.12.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">      // [IEEE Std 754-2008 6.2]:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">      // For an operation with quiet NaN inputs, other than maximum and minimum</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">      // For an operation with quiet NaN inputs, other than maximum and minimum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">      // operations, if a floating-point result is to be delivered the result</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">      // operations, if a floating-point result is to be delivered the result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">      // shall be a quiet NaN which should be one of the input NaNs.</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">      // shall be a quiet NaN which should be one of the input NaNs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">      // ...</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">      // ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">      // Every general-computational and quiet-computational operation involving</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">      // Every general-computational and quiet-computational operation involving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">      // one or more input NaNs, none of them signaling, shall signal no</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">      // one or more input NaNs, none of them signaling, shall signal no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">      // exception, except fusedMultiplyAdd might signal the invalid operation</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">      // exception, except fusedMultiplyAdd might signal the invalid operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">      // exception(see 7.2).</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">      // exception(see 7.2).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">      return opOK;</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">      return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline"></td>
    <td class="lineNumber">2314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">  if (isZero()) {</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">  if (isZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">    // [IEEE Std 754-2008 6.3]:</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">    // [IEEE Std 754-2008 6.3]:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">    // ... the sign of the result of conversions, the quantize operation, the</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">    // ... the sign of the result of conversions, the quantize operation, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">    // roundToIntegral operations, and the roundToIntegralExact(see 5.3.1) is</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">    // roundToIntegral operations, and the roundToIntegralExact(see 5.3.1) is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">    // the sign of the first or only operand.</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">    // the sign of the first or only operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline"></td>
    <td class="lineNumber">2322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">  // If the exponent is large enough, we know that this value is already</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">  // If the exponent is large enough, we know that this value is already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  // integral, and the arithmetic below would potentially cause it to saturate</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  // integral, and the arithmetic below would potentially cause it to saturate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  // to +/-Inf.  Bail out early instead.</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  // to +/-Inf.  Bail out early instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">  if (exponent+1 >= (int)semanticsPrecision(*semantics))</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">  if (exponent+1 >= (int)semanticsPrecision(*semantics))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline"></td>
    <td class="lineNumber">2328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">  // The algorithm here is quite simple: we add 2^(p-1), where p is the</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">  // The algorithm here is quite simple: we add 2^(p-1), where p is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  // precision of our format, and then subtract it back off again.  The choice</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  // precision of our format, and then subtract it back off again.  The choice</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">  // of rounding modes for the addition/subtraction determines the rounding mode</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">  // of rounding modes for the addition/subtraction determines the rounding mode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  // for our integral rounding as well.</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  // for our integral rounding as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">  // NOTE: When the input value is negative, we do subtraction followed by</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">  // NOTE: When the input value is negative, we do subtraction followed by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">  // addition instead.</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">  // addition instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">  APInt IntegerConstant(NextPowerOf2(semanticsPrecision(*semantics)), 1);</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">  APInt IntegerConstant(NextPowerOf2(semanticsPrecision(*semantics)), 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  IntegerConstant <<= semanticsPrecision(*semantics)-1;</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  IntegerConstant <<= semanticsPrecision(*semantics)-1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">  IEEEFloat MagicConstant(*semantics);</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">  IEEEFloat MagicConstant(*semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  fs = MagicConstant.convertFromAPInt(IntegerConstant, false,</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  fs = MagicConstant.convertFromAPInt(IntegerConstant, false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">                                      rmNearestTiesToEven);</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">                                      rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">  assert(fs == opOK);</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">  assert(fs == opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  MagicConstant.sign = sign;</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  MagicConstant.sign = sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">  // Preserve the input sign so that we can handle the case of zero result</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">  // Preserve the input sign so that we can handle the case of zero result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">  // correctly.</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">  // correctly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">  bool inputSign = isNegative();</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">  bool inputSign = isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline"></td>
    <td class="lineNumber">2346</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">  fs = add(MagicConstant, rounding_mode);</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">  fs = add(MagicConstant, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline"></td>
    <td class="lineNumber">2348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">  // Current value and 'MagicConstant' are both integers, so the result of the</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">  // Current value and 'MagicConstant' are both integers, so the result of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">  // subtraction is always exact according to Sterbenz' lemma.</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">  // subtraction is always exact according to Sterbenz' lemma.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">  subtract(MagicConstant, rounding_mode);</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">  subtract(MagicConstant, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">  // Restore the input sign.</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">  // Restore the input sign.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">  if (inputSign != isNegative())</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">  if (inputSign != isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">    changeSign();</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">    changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline"></td>
    <td class="lineNumber">2356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline"></td>
    <td class="lineNumber">2360</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">/* Comparison requires normalized numbers.  */</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">/* Comparison requires normalized numbers.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">IEEEFloat::cmpResult IEEEFloat::compare(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">IEEEFloat::cmpResult IEEEFloat::compare(const IEEEFloat &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  cmpResult result;</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  cmpResult result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline"></td>
    <td class="lineNumber">2364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  assert(semantics == rhs.semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline"></td>
    <td class="lineNumber">2366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">    llvm_unreachable(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline"></td>
    <td class="lineNumber">2370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">    return cmpUnordered;</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">    return cmpUnordered;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">    if (sign)</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">    if (sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">      return cmpLessThan;</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">      return cmpLessThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">      return cmpGreaterThan;</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">      return cmpGreaterThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">    if (rhs.sign)</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">    if (rhs.sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">      return cmpGreaterThan;</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">      return cmpGreaterThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">      return cmpLessThan;</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">      return cmpLessThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline"></td>
    <td class="lineNumber">2395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">    if (sign == rhs.sign)</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">    if (sign == rhs.sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">      return cmpEqual;</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">      return cmpEqual;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">    else if (sign)</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">    else if (sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">      return cmpLessThan;</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">      return cmpLessThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">      return cmpGreaterThan;</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">      return cmpGreaterThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">    return cmpEqual;</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">    return cmpEqual;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline"></td>
    <td class="lineNumber">2410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">  /* Two normal numbers.  Do they have the same sign?  */</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">  /* Two normal numbers.  Do they have the same sign?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">  if (sign != rhs.sign) {</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">  if (sign != rhs.sign) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">    if (sign)</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">    if (sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">      result = cmpLessThan;</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">      result = cmpLessThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">      result = cmpGreaterThan;</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">      result = cmpGreaterThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">    /* Compare absolute values; invert result if negative.  */</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">    /* Compare absolute values; invert result if negative.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">    result = compareAbsoluteValue(rhs);</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">    result = compareAbsoluteValue(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline"></td>
    <td class="lineNumber">2420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">    if (sign) {</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">    if (sign) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">      if (result == cmpLessThan)</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">      if (result == cmpLessThan)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">        result = cmpGreaterThan;</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">        result = cmpGreaterThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">      else if (result == cmpGreaterThan)</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">      else if (result == cmpGreaterThan)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">        result = cmpLessThan;</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">        result = cmpLessThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline"></td>
    <td class="lineNumber">2428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">  return result;</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">  return result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline"></td>
    <td class="lineNumber">2431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">/// IEEEFloat::convert - convert a value of one floating point type to another.</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">/// IEEEFloat::convert - convert a value of one floating point type to another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">/// The return value corresponds to the IEEE754 exceptions.  *losesInfo</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">/// The return value corresponds to the IEEE754 exceptions.  *losesInfo</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">/// records whether the transformation lost information, i.e. whether</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">/// records whether the transformation lost information, i.e. whether</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">/// converting the result back to the original type will produce the</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">/// converting the result back to the original type will produce the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">/// original value (this is almost the same as return value==fsOK, but there</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">/// original value (this is almost the same as return value==fsOK, but there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">/// are edge cases where this is not so).</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">/// are edge cases where this is not so).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline"></td>
    <td class="lineNumber">2438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convert(const fltSemantics &toSemantics,</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convert(const fltSemantics &toSemantics,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">                                       roundingMode rounding_mode,</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">                                       roundingMode rounding_mode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">                                       bool *losesInfo) {</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">                                       bool *losesInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">  lostFraction lostFraction;</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">  lostFraction lostFraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">  unsigned int newPartCount, oldPartCount;</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">  unsigned int newPartCount, oldPartCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">  int shift;</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">  int shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">  const fltSemantics &fromSemantics = *semantics;</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">  const fltSemantics &fromSemantics = *semantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  bool is_signaling = isSignaling();</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  bool is_signaling = isSignaling();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">  lostFraction = lfExactlyZero;</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">  lostFraction = lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">  newPartCount = partCountForBits(toSemantics.precision + 1);</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">  newPartCount = partCountForBits(toSemantics.precision + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  oldPartCount = partCount();</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  oldPartCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">  shift = toSemantics.precision - fromSemantics.precision;</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">  shift = toSemantics.precision - fromSemantics.precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">  bool X86SpecialNan = false;</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">  bool X86SpecialNan = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">  if (&fromSemantics == &semX87DoubleExtended &&</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">  if (&fromSemantics == &semX87DoubleExtended &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">      &toSemantics != &semX87DoubleExtended && category == fcNaN &&</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">      &toSemantics != &semX87DoubleExtended && category == fcNaN &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">      (!(*significandParts() & 0x8000000000000000ULL) ||</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">      (!(*significandParts() & 0x8000000000000000ULL) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">       !(*significandParts() & 0x4000000000000000ULL))) {</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">       !(*significandParts() & 0x4000000000000000ULL))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">    // x86 has some unusual NaNs which cannot be represented in any other</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">    // x86 has some unusual NaNs which cannot be represented in any other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">    // format; note them here.</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">    // format; note them here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">    X86SpecialNan = true;</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">    X86SpecialNan = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  // If this is a truncation of a denormal number, and the target semantics</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  // If this is a truncation of a denormal number, and the target semantics</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">  // has larger exponent range than the source semantics (this can happen</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">  // has larger exponent range than the source semantics (this can happen</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">  // when truncating from PowerPC double-double to double format), the</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">  // when truncating from PowerPC double-double to double format), the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">  // right shift could lose result mantissa bits.  Adjust exponent instead</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">  // right shift could lose result mantissa bits.  Adjust exponent instead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">  // of performing excessive shift.</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">  // of performing excessive shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">  // Also do a similar trick in case shifting denormal would produce zero</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">  // Also do a similar trick in case shifting denormal would produce zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">  // significand as this case isn't handled correctly by normalize.</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">  // significand as this case isn't handled correctly by normalize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">  if (shift < 0 && isFiniteNonZero()) {</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">  if (shift < 0 && isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">    int omsb = significandMSB() + 1;</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">    int omsb = significandMSB() + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">    int exponentChange = omsb - fromSemantics.precision;</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">    int exponentChange = omsb - fromSemantics.precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">    if (exponent + exponentChange < toSemantics.minExponent)</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">    if (exponent + exponentChange < toSemantics.minExponent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">      exponentChange = toSemantics.minExponent - exponent;</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">      exponentChange = toSemantics.minExponent - exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">    if (exponentChange < shift)</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">    if (exponentChange < shift)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">      exponentChange = shift;</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">      exponentChange = shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">    if (exponentChange < 0) {</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">    if (exponentChange < 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">      shift -= exponentChange;</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">      shift -= exponentChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">      exponent += exponentChange;</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">      exponent += exponentChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">    } else if (omsb <= -shift) {</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">    } else if (omsb <= -shift) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">      exponentChange = omsb + shift - 1; // leave at least one bit set</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">      exponentChange = omsb + shift - 1; // leave at least one bit set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">      shift -= exponentChange;</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">      shift -= exponentChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">      exponent += exponentChange;</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">      exponent += exponentChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline"></td>
    <td class="lineNumber">2487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">  // If this is a truncation, perform the shift before we narrow the storage.</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">  // If this is a truncation, perform the shift before we narrow the storage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">  if (shift < 0 && (isFiniteNonZero() ||</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">  if (shift < 0 && (isFiniteNonZero() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">                    (category == fcNaN && semantics->nonFiniteBehavior !=</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">                    (category == fcNaN && semantics->nonFiniteBehavior !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">                                              fltNonfiniteBehavior::NanOnly)))</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">                                              fltNonfiniteBehavior::NanOnly)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">    lostFraction = shiftRight(significandParts(), oldPartCount, -shift);</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">    lostFraction = shiftRight(significandParts(), oldPartCount, -shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline"></td>
    <td class="lineNumber">2493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">  // Fix the storage so it can hold to new value.</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">  // Fix the storage so it can hold to new value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">  if (newPartCount > oldPartCount) {</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">  if (newPartCount > oldPartCount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">    // The new type requires more storage; make it available.</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">    // The new type requires more storage; make it available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">    integerPart *newParts;</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">    integerPart *newParts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">    newParts = new integerPart[newPartCount];</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">    newParts = new integerPart[newPartCount];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">    APInt::tcSet(newParts, 0, newPartCount);</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">    APInt::tcSet(newParts, 0, newPartCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">    if (isFiniteNonZero() || category==fcNaN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">      APInt::tcAssign(newParts, significandParts(), oldPartCount);</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">      APInt::tcAssign(newParts, significandParts(), oldPartCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">    freeSignificand();</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">    freeSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">    significand.parts = newParts;</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">    significand.parts = newParts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">  } else if (newPartCount == 1 && oldPartCount != 1) {</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">  } else if (newPartCount == 1 && oldPartCount != 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">    // Switch to built-in storage for a single part.</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">    // Switch to built-in storage for a single part.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">    integerPart newPart = 0;</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">    integerPart newPart = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">    if (isFiniteNonZero() || category==fcNaN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">      newPart = significandParts()[0];</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">      newPart = significandParts()[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">    freeSignificand();</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">    freeSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">    significand.part = newPart;</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">    significand.part = newPart;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">  // Now that we have the right storage, switch the semantics.</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">  // Now that we have the right storage, switch the semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">  semantics = &toSemantics;</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">  semantics = &toSemantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline"></td>
    <td class="lineNumber">2515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">  // If this is an extension, perform the shift now that the storage is</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">  // If this is an extension, perform the shift now that the storage is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">  // available.</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">  // available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">  if (shift > 0 && (isFiniteNonZero() || category==fcNaN))</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">  if (shift > 0 && (isFiniteNonZero() || category==fcNaN))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">    APInt::tcShiftLeft(significandParts(), newPartCount, shift);</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">    APInt::tcShiftLeft(significandParts(), newPartCount, shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline"></td>
    <td class="lineNumber">2520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">    fs = normalize(rounding_mode, lostFraction);</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">    fs = normalize(rounding_mode, lostFraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">    *losesInfo = (fs != opOK);</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">    *losesInfo = (fs != opOK);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">  } else if (category == fcNaN) {</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">  } else if (category == fcNaN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">      *losesInfo =</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">      *losesInfo =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">          fromSemantics.nonFiniteBehavior != fltNonfiniteBehavior::NanOnly;</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">          fromSemantics.nonFiniteBehavior != fltNonfiniteBehavior::NanOnly;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">      makeNaN(false, sign);</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">      makeNaN(false, sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">      return is_signaling ? opInvalidOp : opOK;</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">      return is_signaling ? opInvalidOp : opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">    // If NaN is negative zero, we need to create a new NaN to avoid converting</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">    // If NaN is negative zero, we need to create a new NaN to avoid converting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">    // NaN to -Inf.</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">    // NaN to -Inf.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">    if (fromSemantics.nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">    if (fromSemantics.nanEncoding == fltNanEncoding::NegativeZero &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">        semantics->nanEncoding != fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">        semantics->nanEncoding != fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">      makeNaN(false, false);</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">      makeNaN(false, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline"></td>
    <td class="lineNumber">2537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">    *losesInfo = lostFraction != lfExactlyZero || X86SpecialNan;</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">    *losesInfo = lostFraction != lfExactlyZero || X86SpecialNan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline"></td>
    <td class="lineNumber">2539</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">    // For x87 extended precision, we want to make a NaN, not a special NaN if</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">    // For x87 extended precision, we want to make a NaN, not a special NaN if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">    // the input wasn't special either.</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">    // the input wasn't special either.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">    if (!X86SpecialNan && semantics == &semX87DoubleExtended)</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">    if (!X86SpecialNan && semantics == &semX87DoubleExtended)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">      APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">      APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline"></td>
    <td class="lineNumber">2544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">    // Convert of sNaN creates qNaN and raises an exception (invalid op).</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">    // Convert of sNaN creates qNaN and raises an exception (invalid op).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">    // This also guarantees that a sNaN does not become Inf on a truncation</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">    // This also guarantees that a sNaN does not become Inf on a truncation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">    // that loses all payload bits.</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">    // that loses all payload bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">    if (is_signaling) {</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">    if (is_signaling) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">      makeQuiet();</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">      makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">      fs = opInvalidOp;</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">      fs = opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">      fs = opOK;</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">      fs = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">  } else if (category == fcInfinity &&</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">  } else if (category == fcInfinity &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">             semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">             semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">    makeNaN(false, sign);</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">    makeNaN(false, sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">    *losesInfo = true;</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">    *losesInfo = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">    fs = opInexact;</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">    fs = opInexact;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">  } else if (category == fcZero &&</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">  } else if (category == fcZero &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">             semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">             semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">    // Negative zero loses info, but positive zero doesn't.</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">    // Negative zero loses info, but positive zero doesn't.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">    *losesInfo =</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">    *losesInfo =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">        fromSemantics.nanEncoding != fltNanEncoding::NegativeZero && sign;</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">        fromSemantics.nanEncoding != fltNanEncoding::NegativeZero && sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">    fs = *losesInfo ? opInexact : opOK;</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">    fs = *losesInfo ? opInexact : opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">    // NaN is negative zero means -0 -> +0, which can lose information</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">    // NaN is negative zero means -0 -> +0, which can lose information</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">    sign = false;</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">    sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">    *losesInfo = false;</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">    *losesInfo = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">    fs = opOK;</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">    fs = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline"></td>
    <td class="lineNumber">2571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline"></td>
    <td class="lineNumber">2574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">/* Convert a floating point number to an integer according to the</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">/* Convert a floating point number to an integer according to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">   rounding mode.  If the rounded integer value is out of range this</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">   rounding mode.  If the rounded integer value is out of range this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">   returns an invalid operation exception and the contents of the</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">   returns an invalid operation exception and the contents of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">   destination parts are unspecified.  If the rounded value is in</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">   destination parts are unspecified.  If the rounded value is in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">   range but the floating point number is not the exact integer, the C</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">   range but the floating point number is not the exact integer, the C</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">   standard doesn't require an inexact exception to be raised.  IEEE</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">   standard doesn't require an inexact exception to be raised.  IEEE</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">   854 does require it so we do that.</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">   854 does require it so we do that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline"></td>
    <td class="lineNumber">2582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">   Note that for conversions to integer type the C standard requires</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">   Note that for conversions to integer type the C standard requires</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">   round-to-zero to always be used.  */</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">   round-to-zero to always be used.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convertToSignExtendedInteger(</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convertToSignExtendedInteger(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">    MutableArrayRef<integerPart> parts, unsigned int width, bool isSigned,</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">    MutableArrayRef<integerPart> parts, unsigned int width, bool isSigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">    roundingMode rounding_mode, bool *isExact) const {</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">    roundingMode rounding_mode, bool *isExact) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">  const integerPart *src;</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">  const integerPart *src;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">  unsigned int dstPartsCount, truncatedBits;</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">  unsigned int dstPartsCount, truncatedBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline"></td>
    <td class="lineNumber">2591</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">  *isExact = false;</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">  *isExact = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline"></td>
    <td class="lineNumber">2593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">  /* Handle the three special cases first.  */</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">  /* Handle the three special cases first.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">  if (category == fcInfinity || category == fcNaN)</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">  if (category == fcInfinity || category == fcNaN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">    return opInvalidOp;</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">    return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline"></td>
    <td class="lineNumber">2597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">  dstPartsCount = partCountForBits(width);</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">  dstPartsCount = partCountForBits(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">  assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">  assert(dstPartsCount <= parts.size() && "Integer too big");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline"></td>
    <td class="lineNumber">2600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">  if (category == fcZero) {</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">  if (category == fcZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">    // Negative zero can't be represented as an int.</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">    // Negative zero can't be represented as an int.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">    *isExact = !sign;</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">    *isExact = !sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline"></td>
    <td class="lineNumber">2607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">  src = significandParts();</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">  src = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline"></td>
    <td class="lineNumber">2609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">  /* Step 1: place our absolute value, with any fraction truncated, in</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">  /* Step 1: place our absolute value, with any fraction truncated, in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">     the destination.  */</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">     the destination.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">  if (exponent < 0) {</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">  if (exponent < 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">    /* Our absolute value is less than one; truncate everything.  */</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">    /* Our absolute value is less than one; truncate everything.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">    /* For exponent -1 the integer bit represents .5, look at that.</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">    /* For exponent -1 the integer bit represents .5, look at that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">       For smaller exponents leftmost truncated bit is 0. */</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">       For smaller exponents leftmost truncated bit is 0. */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">    truncatedBits = semantics->precision -1U - exponent;</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">    truncatedBits = semantics->precision -1U - exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2618</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">    /* We want the most significant (exponent + 1) bits; the rest are</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">    /* We want the most significant (exponent + 1) bits; the rest are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">       truncated.  */</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">       truncated.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">    unsigned int bits = exponent + 1U;</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">    unsigned int bits = exponent + 1U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline"></td>
    <td class="lineNumber">2622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">    /* Hopelessly large in magnitude?  */</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">    /* Hopelessly large in magnitude?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline">    if (bits > width)</td>
    <td class="lineNumber">2624</td>
    <td class="codeline">    if (bits > width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline"></td>
    <td class="lineNumber">2626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">    if (bits < semantics->precision) {</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">    if (bits < semantics->precision) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">      /* We truncate (semantics->precision - bits) bits.  */</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">      /* We truncate (semantics->precision - bits) bits.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">      truncatedBits = semantics->precision - bits;</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">      truncatedBits = semantics->precision - bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">      APInt::tcExtract(parts.data(), dstPartsCount, src, bits, truncatedBits);</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">      APInt::tcExtract(parts.data(), dstPartsCount, src, bits, truncatedBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">      /* We want at least as many bits as are available.  */</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">      /* We want at least as many bits as are available.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">      APInt::tcExtract(parts.data(), dstPartsCount, src, semantics->precision,</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">      APInt::tcExtract(parts.data(), dstPartsCount, src, semantics->precision,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">                       0);</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">                       0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">      APInt::tcShiftLeft(parts.data(), dstPartsCount,</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">      APInt::tcShiftLeft(parts.data(), dstPartsCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">                         bits - semantics->precision);</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">                         bits - semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">      truncatedBits = 0;</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">      truncatedBits = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2638</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline"></td>
    <td class="lineNumber">2640</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">  /* Step 2: work out any lost fraction, and increment the absolute</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">  /* Step 2: work out any lost fraction, and increment the absolute</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">     value if we would round away from zero.  */</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">     value if we would round away from zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">  if (truncatedBits) {</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">  if (truncatedBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline">    lost_fraction = lostFractionThroughTruncation(src, partCount(),</td>
    <td class="lineNumber">2644</td>
    <td class="codeline">    lost_fraction = lostFractionThroughTruncation(src, partCount(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">                                                  truncatedBits);</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">                                                  truncatedBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero &&</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">    if (lost_fraction != lfExactlyZero &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline">        roundAwayFromZero(rounding_mode, lost_fraction, truncatedBits)) {</td>
    <td class="lineNumber">2647</td>
    <td class="codeline">        roundAwayFromZero(rounding_mode, lost_fraction, truncatedBits)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">      if (APInt::tcIncrement(parts.data(), dstPartsCount))</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">      if (APInt::tcIncrement(parts.data(), dstPartsCount))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">        return opInvalidOp;     /* Overflow.  */</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">        return opInvalidOp;     /* Overflow.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2651</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">    lost_fraction = lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline"></td>
    <td class="lineNumber">2654</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">  /* Step 3: check if we fit in the destination.  */</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">  /* Step 3: check if we fit in the destination.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">  unsigned int omsb = APInt::tcMSB(parts.data(), dstPartsCount) + 1;</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">  unsigned int omsb = APInt::tcMSB(parts.data(), dstPartsCount) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline"></td>
    <td class="lineNumber">2657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline">  if (sign) {</td>
    <td class="lineNumber">2658</td>
    <td class="codeline">  if (sign) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline">    if (!isSigned) {</td>
    <td class="lineNumber">2659</td>
    <td class="codeline">    if (!isSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline">      /* Negative numbers cannot be represented as unsigned.  */</td>
    <td class="lineNumber">2660</td>
    <td class="codeline">      /* Negative numbers cannot be represented as unsigned.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">      if (omsb != 0)</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">      if (omsb != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">        return opInvalidOp;</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">        return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">      /* It takes omsb bits to represent the unsigned integer value.</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">      /* It takes omsb bits to represent the unsigned integer value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">         We lose a bit for the sign, but care is needed as the</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">         We lose a bit for the sign, but care is needed as the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline">         maximally negative integer is a special case.  */</td>
    <td class="lineNumber">2666</td>
    <td class="codeline">         maximally negative integer is a special case.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">      if (omsb == width &&</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">      if (omsb == width &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline">          APInt::tcLSB(parts.data(), dstPartsCount) + 1 != omsb)</td>
    <td class="lineNumber">2668</td>
    <td class="codeline">          APInt::tcLSB(parts.data(), dstPartsCount) + 1 != omsb)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">        return opInvalidOp;</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">        return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline"></td>
    <td class="lineNumber">2670</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline">      /* This case can happen because of rounding.  */</td>
    <td class="lineNumber">2671</td>
    <td class="codeline">      /* This case can happen because of rounding.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline">      if (omsb > width)</td>
    <td class="lineNumber">2672</td>
    <td class="codeline">      if (omsb > width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline">        return opInvalidOp;</td>
    <td class="lineNumber">2673</td>
    <td class="codeline">        return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline"></td>
    <td class="lineNumber">2675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline">    APInt::tcNegate (parts.data(), dstPartsCount);</td>
    <td class="lineNumber">2676</td>
    <td class="codeline">    APInt::tcNegate (parts.data(), dstPartsCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2677</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">    if (omsb >= width + !isSigned)</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">    if (omsb >= width + !isSigned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">      return opInvalidOp;</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">      return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2680</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline"></td>
    <td class="lineNumber">2681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">  if (lost_fraction == lfExactlyZero) {</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">  if (lost_fraction == lfExactlyZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline">    *isExact = true;</td>
    <td class="lineNumber">2683</td>
    <td class="codeline">    *isExact = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">2684</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">2685</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline">    return opInexact;</td>
    <td class="lineNumber">2686</td>
    <td class="codeline">    return opInexact;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline"></td>
    <td class="lineNumber">2688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">/* Same as convertToSignExtendedInteger, except we provide</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">/* Same as convertToSignExtendedInteger, except we provide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline">   deterministic values in case of an invalid operation exception,</td>
    <td class="lineNumber">2690</td>
    <td class="codeline">   deterministic values in case of an invalid operation exception,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline">   namely zero for NaNs and the minimal or maximal value respectively</td>
    <td class="lineNumber">2691</td>
    <td class="codeline">   namely zero for NaNs and the minimal or maximal value respectively</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">   for underflow or overflow.</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">   for underflow or overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">   The *isExact output tells whether the result is exact, in the sense</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">   The *isExact output tells whether the result is exact, in the sense</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline">   that converting it back to the original floating point type produces</td>
    <td class="lineNumber">2694</td>
    <td class="codeline">   that converting it back to the original floating point type produces</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline">   the original value.  This is almost equivalent to result==opOK,</td>
    <td class="lineNumber">2695</td>
    <td class="codeline">   the original value.  This is almost equivalent to result==opOK,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline">   except for negative zeroes.</td>
    <td class="lineNumber">2696</td>
    <td class="codeline">   except for negative zeroes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">*/</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">*/</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline">IEEEFloat::opStatus</td>
    <td class="lineNumber">2698</td>
    <td class="codeline">IEEEFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline">IEEEFloat::convertToInteger(MutableArrayRef<integerPart> parts,</td>
    <td class="lineNumber">2699</td>
    <td class="codeline">IEEEFloat::convertToInteger(MutableArrayRef<integerPart> parts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline">                            unsigned int width, bool isSigned,</td>
    <td class="lineNumber">2700</td>
    <td class="codeline">                            unsigned int width, bool isSigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline">                            roundingMode rounding_mode, bool *isExact) const {</td>
    <td class="lineNumber">2701</td>
    <td class="codeline">                            roundingMode rounding_mode, bool *isExact) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">2702</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline"></td>
    <td class="lineNumber">2703</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline">  fs = convertToSignExtendedInteger(parts, width, isSigned, rounding_mode,</td>
    <td class="lineNumber">2704</td>
    <td class="codeline">  fs = convertToSignExtendedInteger(parts, width, isSigned, rounding_mode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">                                    isExact);</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">                                    isExact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline"></td>
    <td class="lineNumber">2706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline">  if (fs == opInvalidOp) {</td>
    <td class="lineNumber">2707</td>
    <td class="codeline">  if (fs == opInvalidOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">    unsigned int bits, dstPartsCount;</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">    unsigned int bits, dstPartsCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline"></td>
    <td class="lineNumber">2709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline">    dstPartsCount = partCountForBits(width);</td>
    <td class="lineNumber">2710</td>
    <td class="codeline">    dstPartsCount = partCountForBits(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline">    assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td class="lineNumber">2711</td>
    <td class="codeline">    assert(dstPartsCount <= parts.size() && "Integer too big");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline"></td>
    <td class="lineNumber">2712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">    if (category == fcNaN)</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">    if (category == fcNaN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline">      bits = 0;</td>
    <td class="lineNumber">2714</td>
    <td class="codeline">      bits = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline">    else if (sign)</td>
    <td class="lineNumber">2715</td>
    <td class="codeline">    else if (sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">      bits = isSigned;</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">      bits = isSigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2717</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline">      bits = width - isSigned;</td>
    <td class="lineNumber">2718</td>
    <td class="codeline">      bits = width - isSigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline"></td>
    <td class="lineNumber">2719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline">    tcSetLeastSignificantBits(parts.data(), dstPartsCount, bits);</td>
    <td class="lineNumber">2720</td>
    <td class="codeline">    tcSetLeastSignificantBits(parts.data(), dstPartsCount, bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline">    if (sign && isSigned)</td>
    <td class="lineNumber">2721</td>
    <td class="codeline">    if (sign && isSigned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline">      APInt::tcShiftLeft(parts.data(), dstPartsCount, width - 1);</td>
    <td class="lineNumber">2722</td>
    <td class="codeline">      APInt::tcShiftLeft(parts.data(), dstPartsCount, width - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2723</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline"></td>
    <td class="lineNumber">2724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">2725</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2726</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline"></td>
    <td class="lineNumber">2727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeline">/* Convert an unsigned integer SRC to a floating point number,</td>
    <td class="lineNumber">2728</td>
    <td class="codeline">/* Convert an unsigned integer SRC to a floating point number,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeline">   rounding according to ROUNDING_MODE.  The sign of the floating</td>
    <td class="lineNumber">2729</td>
    <td class="codeline">   rounding according to ROUNDING_MODE.  The sign of the floating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeline">   point number is not modified.  */</td>
    <td class="lineNumber">2730</td>
    <td class="codeline">   point number is not modified.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convertFromUnsignedParts(</td>
    <td class="lineNumber">2731</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convertFromUnsignedParts(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeline">    const integerPart *src, unsigned int srcCount, roundingMode rounding_mode) {</td>
    <td class="lineNumber">2732</td>
    <td class="codeline">    const integerPart *src, unsigned int srcCount, roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeline">  unsigned int omsb, precision, dstCount;</td>
    <td class="lineNumber">2733</td>
    <td class="codeline">  unsigned int omsb, precision, dstCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeline">  integerPart *dst;</td>
    <td class="lineNumber">2734</td>
    <td class="codeline">  integerPart *dst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
    <td class="lineNumber">2735</td>
    <td class="codeline">  lostFraction lost_fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeline"></td>
    <td class="lineNumber">2736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">2737</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeline">  omsb = APInt::tcMSB(src, srcCount) + 1;</td>
    <td class="lineNumber">2738</td>
    <td class="codeline">  omsb = APInt::tcMSB(src, srcCount) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeline">  dst = significandParts();</td>
    <td class="lineNumber">2739</td>
    <td class="codeline">  dst = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeline">  dstCount = partCount();</td>
    <td class="lineNumber">2740</td>
    <td class="codeline">  dstCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeline">  precision = semantics->precision;</td>
    <td class="lineNumber">2741</td>
    <td class="codeline">  precision = semantics->precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeline"></td>
    <td class="lineNumber">2742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeline">  /* We want the most significant PRECISION bits of SRC.  There may not</td>
    <td class="lineNumber">2743</td>
    <td class="codeline">  /* We want the most significant PRECISION bits of SRC.  There may not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeline">     be that many; extract what we can.  */</td>
    <td class="lineNumber">2744</td>
    <td class="codeline">     be that many; extract what we can.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeline">  if (precision <= omsb) {</td>
    <td class="lineNumber">2745</td>
    <td class="codeline">  if (precision <= omsb) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeline">    exponent = omsb - 1;</td>
    <td class="lineNumber">2746</td>
    <td class="codeline">    exponent = omsb - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeline">    lost_fraction = lostFractionThroughTruncation(src, srcCount,</td>
    <td class="lineNumber">2747</td>
    <td class="codeline">    lost_fraction = lostFractionThroughTruncation(src, srcCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeline">                                                  omsb - precision);</td>
    <td class="lineNumber">2748</td>
    <td class="codeline">                                                  omsb - precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeline">    APInt::tcExtract(dst, dstCount, src, precision, omsb - precision);</td>
    <td class="lineNumber">2749</td>
    <td class="codeline">    APInt::tcExtract(dst, dstCount, src, precision, omsb - precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2750</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeline">    exponent = precision - 1;</td>
    <td class="lineNumber">2751</td>
    <td class="codeline">    exponent = precision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeline">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">2752</td>
    <td class="codeline">    lost_fraction = lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeline">    APInt::tcExtract(dst, dstCount, src, omsb, 0);</td>
    <td class="lineNumber">2753</td>
    <td class="codeline">    APInt::tcExtract(dst, dstCount, src, omsb, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2754</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeline"></td>
    <td class="lineNumber">2755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeline">  return normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">2756</td>
    <td class="codeline">  return normalize(rounding_mode, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2757</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeline"></td>
    <td class="lineNumber">2758</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convertFromAPInt(const APInt &Val, bool isSigned,</td>
    <td class="lineNumber">2759</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::convertFromAPInt(const APInt &Val, bool isSigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeline">                                                roundingMode rounding_mode) {</td>
    <td class="lineNumber">2760</td>
    <td class="codeline">                                                roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeline">  unsigned int partCount = Val.getNumWords();</td>
    <td class="lineNumber">2761</td>
    <td class="codeline">  unsigned int partCount = Val.getNumWords();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeline">  APInt api = Val;</td>
    <td class="lineNumber">2762</td>
    <td class="codeline">  APInt api = Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeline"></td>
    <td class="lineNumber">2763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeline">  sign = false;</td>
    <td class="lineNumber">2764</td>
    <td class="codeline">  sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeline">  if (isSigned && api.isNegative()) {</td>
    <td class="lineNumber">2765</td>
    <td class="codeline">  if (isSigned && api.isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeline">    sign = true;</td>
    <td class="lineNumber">2766</td>
    <td class="codeline">    sign = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeline">    api = -api;</td>
    <td class="lineNumber">2767</td>
    <td class="codeline">    api = -api;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2768</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeline"></td>
    <td class="lineNumber">2769</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeline">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td class="lineNumber">2770</td>
    <td class="codeline">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2771</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeline"></td>
    <td class="lineNumber">2772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeline">/* Convert a two's complement integer SRC to a floating point number,</td>
    <td class="lineNumber">2773</td>
    <td class="codeline">/* Convert a two's complement integer SRC to a floating point number,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeline">   rounding according to ROUNDING_MODE.  ISSIGNED is true if the</td>
    <td class="lineNumber">2774</td>
    <td class="codeline">   rounding according to ROUNDING_MODE.  ISSIGNED is true if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeline">   integer is signed, in which case it must be sign-extended.  */</td>
    <td class="lineNumber">2775</td>
    <td class="codeline">   integer is signed, in which case it must be sign-extended.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeline">IEEEFloat::opStatus</td>
    <td class="lineNumber">2776</td>
    <td class="codeline">IEEEFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeline">IEEEFloat::convertFromSignExtendedInteger(const integerPart *src,</td>
    <td class="lineNumber">2777</td>
    <td class="codeline">IEEEFloat::convertFromSignExtendedInteger(const integerPart *src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeline">                                          unsigned int srcCount, bool isSigned,</td>
    <td class="lineNumber">2778</td>
    <td class="codeline">                                          unsigned int srcCount, bool isSigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeline">                                          roundingMode rounding_mode) {</td>
    <td class="lineNumber">2779</td>
    <td class="codeline">                                          roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeline">  opStatus status;</td>
    <td class="lineNumber">2780</td>
    <td class="codeline">  opStatus status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeline"></td>
    <td class="lineNumber">2781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeline">  if (isSigned &&</td>
    <td class="lineNumber">2782</td>
    <td class="codeline">  if (isSigned &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeline">      APInt::tcExtractBit(src, srcCount * integerPartWidth - 1)) {</td>
    <td class="lineNumber">2783</td>
    <td class="codeline">      APInt::tcExtractBit(src, srcCount * integerPartWidth - 1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeline">    integerPart *copy;</td>
    <td class="lineNumber">2784</td>
    <td class="codeline">    integerPart *copy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeline"></td>
    <td class="lineNumber">2785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeline">    /* If we're signed and negative negate a copy.  */</td>
    <td class="lineNumber">2786</td>
    <td class="codeline">    /* If we're signed and negative negate a copy.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeline">    sign = true;</td>
    <td class="lineNumber">2787</td>
    <td class="codeline">    sign = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeline">    copy = new integerPart[srcCount];</td>
    <td class="lineNumber">2788</td>
    <td class="codeline">    copy = new integerPart[srcCount];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeline">    APInt::tcAssign(copy, src, srcCount);</td>
    <td class="lineNumber">2789</td>
    <td class="codeline">    APInt::tcAssign(copy, src, srcCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeline">    APInt::tcNegate(copy, srcCount);</td>
    <td class="lineNumber">2790</td>
    <td class="codeline">    APInt::tcNegate(copy, srcCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeline">    status = convertFromUnsignedParts(copy, srcCount, rounding_mode);</td>
    <td class="lineNumber">2791</td>
    <td class="codeline">    status = convertFromUnsignedParts(copy, srcCount, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeline">    delete [] copy;</td>
    <td class="lineNumber">2792</td>
    <td class="codeline">    delete [] copy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2793</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeline">    sign = false;</td>
    <td class="lineNumber">2794</td>
    <td class="codeline">    sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeline">    status = convertFromUnsignedParts(src, srcCount, rounding_mode);</td>
    <td class="lineNumber">2795</td>
    <td class="codeline">    status = convertFromUnsignedParts(src, srcCount, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2796</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeline"></td>
    <td class="lineNumber">2797</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeline">  return status;</td>
    <td class="lineNumber">2798</td>
    <td class="codeline">  return status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2799</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeline">/* FIXME: should this just take a const APInt reference?  */</td>
    <td class="lineNumber">2801</td>
    <td class="codeline">/* FIXME: should this just take a const APInt reference?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeline">IEEEFloat::opStatus</td>
    <td class="lineNumber">2802</td>
    <td class="codeline">IEEEFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeline">IEEEFloat::convertFromZeroExtendedInteger(const integerPart *parts,</td>
    <td class="lineNumber">2803</td>
    <td class="codeline">IEEEFloat::convertFromZeroExtendedInteger(const integerPart *parts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeline">                                          unsigned int width, bool isSigned,</td>
    <td class="lineNumber">2804</td>
    <td class="codeline">                                          unsigned int width, bool isSigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeline">                                          roundingMode rounding_mode) {</td>
    <td class="lineNumber">2805</td>
    <td class="codeline">                                          roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeline">  unsigned int partCount = partCountForBits(width);</td>
    <td class="lineNumber">2806</td>
    <td class="codeline">  unsigned int partCount = partCountForBits(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeline">  APInt api = APInt(width, ArrayRef(parts, partCount));</td>
    <td class="lineNumber">2807</td>
    <td class="codeline">  APInt api = APInt(width, ArrayRef(parts, partCount));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeline"></td>
    <td class="lineNumber">2808</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeline">  sign = false;</td>
    <td class="lineNumber">2809</td>
    <td class="codeline">  sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeline">  if (isSigned && APInt::tcExtractBit(parts, width - 1)) {</td>
    <td class="lineNumber">2810</td>
    <td class="codeline">  if (isSigned && APInt::tcExtractBit(parts, width - 1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeline">    sign = true;</td>
    <td class="lineNumber">2811</td>
    <td class="codeline">    sign = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeline">    api = -api;</td>
    <td class="lineNumber">2812</td>
    <td class="codeline">    api = -api;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2813</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeline"></td>
    <td class="lineNumber">2814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeline">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td class="lineNumber">2815</td>
    <td class="codeline">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2816</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeline"></td>
    <td class="lineNumber">2817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeline">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">2818</td>
    <td class="codeline">Expected<IEEEFloat::opStatus></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeline">IEEEFloat::convertFromHexadecimalString(StringRef s,</td>
    <td class="lineNumber">2819</td>
    <td class="codeline">IEEEFloat::convertFromHexadecimalString(StringRef s,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">2820</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeline">  lostFraction lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">2821</td>
    <td class="codeline">  lostFraction lost_fraction = lfExactlyZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeline"></td>
    <td class="lineNumber">2822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">2823</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeline">  zeroSignificand();</td>
    <td class="lineNumber">2824</td>
    <td class="codeline">  zeroSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeline">  exponent = 0;</td>
    <td class="lineNumber">2825</td>
    <td class="codeline">  exponent = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeline"></td>
    <td class="lineNumber">2826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeline">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">2827</td>
    <td class="codeline">  integerPart *significand = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeline">  unsigned partsCount = partCount();</td>
    <td class="lineNumber">2828</td>
    <td class="codeline">  unsigned partsCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeline">  unsigned bitPos = partsCount * integerPartWidth;</td>
    <td class="lineNumber">2829</td>
    <td class="codeline">  unsigned bitPos = partsCount * integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeline">  bool computedTrailingFraction = false;</td>
    <td class="lineNumber">2830</td>
    <td class="codeline">  bool computedTrailingFraction = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeline"></td>
    <td class="lineNumber">2831</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeline">  // Skip leading zeroes and any (hexa)decimal point.</td>
    <td class="lineNumber">2832</td>
    <td class="codeline">  // Skip leading zeroes and any (hexa)decimal point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeline">  StringRef::iterator begin = s.begin();</td>
    <td class="lineNumber">2833</td>
    <td class="codeline">  StringRef::iterator begin = s.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeline">  StringRef::iterator end = s.end();</td>
    <td class="lineNumber">2834</td>
    <td class="codeline">  StringRef::iterator end = s.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeline">  StringRef::iterator dot;</td>
    <td class="lineNumber">2835</td>
    <td class="codeline">  StringRef::iterator dot;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeline">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td class="lineNumber">2836</td>
    <td class="codeline">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeline">  if (!PtrOrErr)</td>
    <td class="lineNumber">2837</td>
    <td class="codeline">  if (!PtrOrErr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeline">    return PtrOrErr.takeError();</td>
    <td class="lineNumber">2838</td>
    <td class="codeline">    return PtrOrErr.takeError();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeline">  StringRef::iterator p = *PtrOrErr;</td>
    <td class="lineNumber">2839</td>
    <td class="codeline">  StringRef::iterator p = *PtrOrErr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeline">  StringRef::iterator firstSignificantDigit = p;</td>
    <td class="lineNumber">2840</td>
    <td class="codeline">  StringRef::iterator firstSignificantDigit = p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeline"></td>
    <td class="lineNumber">2841</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeline">  while (p != end) {</td>
    <td class="lineNumber">2842</td>
    <td class="codeline">  while (p != end) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeline">    integerPart hex_value;</td>
    <td class="lineNumber">2843</td>
    <td class="codeline">    integerPart hex_value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeline"></td>
    <td class="lineNumber">2844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeline">    if (*p == '.') {</td>
    <td class="lineNumber">2845</td>
    <td class="codeline">    if (*p == '.') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeline">      if (dot != end)</td>
    <td class="lineNumber">2846</td>
    <td class="codeline">      if (dot != end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeline">        return createError("String contains multiple dots");</td>
    <td class="lineNumber">2847</td>
    <td class="codeline">        return createError("String contains multiple dots");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeline">      dot = p++;</td>
    <td class="lineNumber">2848</td>
    <td class="codeline">      dot = p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2849</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2850</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeline"></td>
    <td class="lineNumber">2851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeline">    hex_value = hexDigitValue(*p);</td>
    <td class="lineNumber">2852</td>
    <td class="codeline">    hex_value = hexDigitValue(*p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeline">    if (hex_value == UINT_MAX)</td>
    <td class="lineNumber">2853</td>
    <td class="codeline">    if (hex_value == UINT_MAX)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2854</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeline"></td>
    <td class="lineNumber">2855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">2856</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeline"></td>
    <td class="lineNumber">2857</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeline">    // Store the number while we have space.</td>
    <td class="lineNumber">2858</td>
    <td class="codeline">    // Store the number while we have space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeline">    if (bitPos) {</td>
    <td class="lineNumber">2859</td>
    <td class="codeline">    if (bitPos) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeline">      bitPos -= 4;</td>
    <td class="lineNumber">2860</td>
    <td class="codeline">      bitPos -= 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeline">      hex_value <<= bitPos % integerPartWidth;</td>
    <td class="lineNumber">2861</td>
    <td class="codeline">      hex_value <<= bitPos % integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeline">      significand[bitPos / integerPartWidth] |= hex_value;</td>
    <td class="lineNumber">2862</td>
    <td class="codeline">      significand[bitPos / integerPartWidth] |= hex_value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeline">    } else if (!computedTrailingFraction) {</td>
    <td class="lineNumber">2863</td>
    <td class="codeline">    } else if (!computedTrailingFraction) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeline">      auto FractOrErr = trailingHexadecimalFraction(p, end, hex_value);</td>
    <td class="lineNumber">2864</td>
    <td class="codeline">      auto FractOrErr = trailingHexadecimalFraction(p, end, hex_value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeline">      if (!FractOrErr)</td>
    <td class="lineNumber">2865</td>
    <td class="codeline">      if (!FractOrErr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeline">        return FractOrErr.takeError();</td>
    <td class="lineNumber">2866</td>
    <td class="codeline">        return FractOrErr.takeError();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeline">      lost_fraction = *FractOrErr;</td>
    <td class="lineNumber">2867</td>
    <td class="codeline">      lost_fraction = *FractOrErr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeline">      computedTrailingFraction = true;</td>
    <td class="lineNumber">2868</td>
    <td class="codeline">      computedTrailingFraction = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2869</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2870</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeline"></td>
    <td class="lineNumber">2871</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeline">  /* Hex floats require an exponent but not a hexadecimal point.  */</td>
    <td class="lineNumber">2872</td>
    <td class="codeline">  /* Hex floats require an exponent but not a hexadecimal point.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeline">  if (p == end)</td>
    <td class="lineNumber">2873</td>
    <td class="codeline">  if (p == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeline">    return createError("Hex strings require an exponent");</td>
    <td class="lineNumber">2874</td>
    <td class="codeline">    return createError("Hex strings require an exponent");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeline">  if (*p != 'p' && *p != 'P')</td>
    <td class="lineNumber">2875</td>
    <td class="codeline">  if (*p != 'p' && *p != 'P')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeline">    return createError("Invalid character in significand");</td>
    <td class="lineNumber">2876</td>
    <td class="codeline">    return createError("Invalid character in significand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeline">  if (p == begin)</td>
    <td class="lineNumber">2877</td>
    <td class="codeline">  if (p == begin)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeline">    return createError("Significand has no digits");</td>
    <td class="lineNumber">2878</td>
    <td class="codeline">    return createError("Significand has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeline">  if (dot != end && p - begin == 1)</td>
    <td class="lineNumber">2879</td>
    <td class="codeline">  if (dot != end && p - begin == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeline">    return createError("Significand has no digits");</td>
    <td class="lineNumber">2880</td>
    <td class="codeline">    return createError("Significand has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeline"></td>
    <td class="lineNumber">2881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeline">  /* Ignore the exponent if we are zero.  */</td>
    <td class="lineNumber">2882</td>
    <td class="codeline">  /* Ignore the exponent if we are zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeline">  if (p != firstSignificantDigit) {</td>
    <td class="lineNumber">2883</td>
    <td class="codeline">  if (p != firstSignificantDigit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeline">    int expAdjustment;</td>
    <td class="lineNumber">2884</td>
    <td class="codeline">    int expAdjustment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeline"></td>
    <td class="lineNumber">2885</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeline">    /* Implicit hexadecimal point?  */</td>
    <td class="lineNumber">2886</td>
    <td class="codeline">    /* Implicit hexadecimal point?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeline">    if (dot == end)</td>
    <td class="lineNumber">2887</td>
    <td class="codeline">    if (dot == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeline">      dot = p;</td>
    <td class="lineNumber">2888</td>
    <td class="codeline">      dot = p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeline"></td>
    <td class="lineNumber">2889</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeline">    /* Calculate the exponent adjustment implicit in the number of</td>
    <td class="lineNumber">2890</td>
    <td class="codeline">    /* Calculate the exponent adjustment implicit in the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeline">       significant digits.  */</td>
    <td class="lineNumber">2891</td>
    <td class="codeline">       significant digits.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeline">    expAdjustment = static_cast<int>(dot - firstSignificantDigit);</td>
    <td class="lineNumber">2892</td>
    <td class="codeline">    expAdjustment = static_cast<int>(dot - firstSignificantDigit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeline">    if (expAdjustment < 0)</td>
    <td class="lineNumber">2893</td>
    <td class="codeline">    if (expAdjustment < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeline">      expAdjustment++;</td>
    <td class="lineNumber">2894</td>
    <td class="codeline">      expAdjustment++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeline">    expAdjustment = expAdjustment * 4 - 1;</td>
    <td class="lineNumber">2895</td>
    <td class="codeline">    expAdjustment = expAdjustment * 4 - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeline"></td>
    <td class="lineNumber">2896</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeline">    /* Adjust for writing the significand starting at the most</td>
    <td class="lineNumber">2897</td>
    <td class="codeline">    /* Adjust for writing the significand starting at the most</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeline">       significant nibble.  */</td>
    <td class="lineNumber">2898</td>
    <td class="codeline">       significant nibble.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeline">    expAdjustment += semantics->precision;</td>
    <td class="lineNumber">2899</td>
    <td class="codeline">    expAdjustment += semantics->precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeline">    expAdjustment -= partsCount * integerPartWidth;</td>
    <td class="lineNumber">2900</td>
    <td class="codeline">    expAdjustment -= partsCount * integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeline"></td>
    <td class="lineNumber">2901</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeline">    /* Adjust for the given exponent.  */</td>
    <td class="lineNumber">2902</td>
    <td class="codeline">    /* Adjust for the given exponent.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeline">    auto ExpOrErr = totalExponent(p + 1, end, expAdjustment);</td>
    <td class="lineNumber">2903</td>
    <td class="codeline">    auto ExpOrErr = totalExponent(p + 1, end, expAdjustment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeline">    if (!ExpOrErr)</td>
    <td class="lineNumber">2904</td>
    <td class="codeline">    if (!ExpOrErr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeline">      return ExpOrErr.takeError();</td>
    <td class="lineNumber">2905</td>
    <td class="codeline">      return ExpOrErr.takeError();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeline">    exponent = *ExpOrErr;</td>
    <td class="lineNumber">2906</td>
    <td class="codeline">    exponent = *ExpOrErr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2907</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeline"></td>
    <td class="lineNumber">2908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeline">  return normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">2909</td>
    <td class="codeline">  return normalize(rounding_mode, lost_fraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2910</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeline"></td>
    <td class="lineNumber">2911</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeline">IEEEFloat::opStatus</td>
    <td class="lineNumber">2912</td>
    <td class="codeline">IEEEFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeline">IEEEFloat::roundSignificandWithExponent(const integerPart *decSigParts,</td>
    <td class="lineNumber">2913</td>
    <td class="codeline">IEEEFloat::roundSignificandWithExponent(const integerPart *decSigParts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeline">                                        unsigned sigPartCount, int exp,</td>
    <td class="lineNumber">2914</td>
    <td class="codeline">                                        unsigned sigPartCount, int exp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">2915</td>
    <td class="codeline">                                        roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeline">  unsigned int parts, pow5PartCount;</td>
    <td class="lineNumber">2916</td>
    <td class="codeline">  unsigned int parts, pow5PartCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeline">  fltSemantics calcSemantics = { 32767, -32767, 0, 0 };</td>
    <td class="lineNumber">2917</td>
    <td class="codeline">  fltSemantics calcSemantics = { 32767, -32767, 0, 0 };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeline">  integerPart pow5Parts[maxPowerOfFiveParts];</td>
    <td class="lineNumber">2918</td>
    <td class="codeline">  integerPart pow5Parts[maxPowerOfFiveParts];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeline">  bool isNearest;</td>
    <td class="lineNumber">2919</td>
    <td class="codeline">  bool isNearest;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeline"></td>
    <td class="lineNumber">2920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeline">  isNearest = (rounding_mode == rmNearestTiesToEven ||</td>
    <td class="lineNumber">2921</td>
    <td class="codeline">  isNearest = (rounding_mode == rmNearestTiesToEven ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeline">               rounding_mode == rmNearestTiesToAway);</td>
    <td class="lineNumber">2922</td>
    <td class="codeline">               rounding_mode == rmNearestTiesToAway);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeline"></td>
    <td class="lineNumber">2923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeline">  parts = partCountForBits(semantics->precision + 11);</td>
    <td class="lineNumber">2924</td>
    <td class="codeline">  parts = partCountForBits(semantics->precision + 11);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeline"></td>
    <td class="lineNumber">2925</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeline">  /* Calculate pow(5, abs(exp)).  */</td>
    <td class="lineNumber">2926</td>
    <td class="codeline">  /* Calculate pow(5, abs(exp)).  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeline">  pow5PartCount = powerOf5(pow5Parts, exp >= 0 ? exp: -exp);</td>
    <td class="lineNumber">2927</td>
    <td class="codeline">  pow5PartCount = powerOf5(pow5Parts, exp >= 0 ? exp: -exp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeline"></td>
    <td class="lineNumber">2928</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeline">  for (;; parts *= 2) {</td>
    <td class="lineNumber">2929</td>
    <td class="codeline">  for (;; parts *= 2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeline">    opStatus sigStatus, powStatus;</td>
    <td class="lineNumber">2930</td>
    <td class="codeline">    opStatus sigStatus, powStatus;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeline">    unsigned int excessPrecision, truncatedBits;</td>
    <td class="lineNumber">2931</td>
    <td class="codeline">    unsigned int excessPrecision, truncatedBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeline"></td>
    <td class="lineNumber">2932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeline">    calcSemantics.precision = parts * integerPartWidth - 1;</td>
    <td class="lineNumber">2933</td>
    <td class="codeline">    calcSemantics.precision = parts * integerPartWidth - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeline">    excessPrecision = calcSemantics.precision - semantics->precision;</td>
    <td class="lineNumber">2934</td>
    <td class="codeline">    excessPrecision = calcSemantics.precision - semantics->precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeline">    truncatedBits = excessPrecision;</td>
    <td class="lineNumber">2935</td>
    <td class="codeline">    truncatedBits = excessPrecision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeline"></td>
    <td class="lineNumber">2936</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeline">    IEEEFloat decSig(calcSemantics, uninitialized);</td>
    <td class="lineNumber">2937</td>
    <td class="codeline">    IEEEFloat decSig(calcSemantics, uninitialized);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeline">    decSig.makeZero(sign);</td>
    <td class="lineNumber">2938</td>
    <td class="codeline">    decSig.makeZero(sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeline">    IEEEFloat pow5(calcSemantics);</td>
    <td class="lineNumber">2939</td>
    <td class="codeline">    IEEEFloat pow5(calcSemantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeline"></td>
    <td class="lineNumber">2940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeline">    sigStatus = decSig.convertFromUnsignedParts(decSigParts, sigPartCount,</td>
    <td class="lineNumber">2941</td>
    <td class="codeline">    sigStatus = decSig.convertFromUnsignedParts(decSigParts, sigPartCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeline">                                                rmNearestTiesToEven);</td>
    <td class="lineNumber">2942</td>
    <td class="codeline">                                                rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeline">    powStatus = pow5.convertFromUnsignedParts(pow5Parts, pow5PartCount,</td>
    <td class="lineNumber">2943</td>
    <td class="codeline">    powStatus = pow5.convertFromUnsignedParts(pow5Parts, pow5PartCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeline">                                              rmNearestTiesToEven);</td>
    <td class="lineNumber">2944</td>
    <td class="codeline">                                              rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeline">    /* Add exp, as 10^n = 5^n * 2^n.  */</td>
    <td class="lineNumber">2945</td>
    <td class="codeline">    /* Add exp, as 10^n = 5^n * 2^n.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeline">    decSig.exponent += exp;</td>
    <td class="lineNumber">2946</td>
    <td class="codeline">    decSig.exponent += exp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeline"></td>
    <td class="lineNumber">2947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeline">    lostFraction calcLostFraction;</td>
    <td class="lineNumber">2948</td>
    <td class="codeline">    lostFraction calcLostFraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeline">    integerPart HUerr, HUdistance;</td>
    <td class="lineNumber">2949</td>
    <td class="codeline">    integerPart HUerr, HUdistance;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeline">    unsigned int powHUerr;</td>
    <td class="lineNumber">2950</td>
    <td class="codeline">    unsigned int powHUerr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeline"></td>
    <td class="lineNumber">2951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeline">    if (exp >= 0) {</td>
    <td class="lineNumber">2952</td>
    <td class="codeline">    if (exp >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeline">      /* multiplySignificand leaves the precision-th bit set to 1.  */</td>
    <td class="lineNumber">2953</td>
    <td class="codeline">      /* multiplySignificand leaves the precision-th bit set to 1.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeline">      calcLostFraction = decSig.multiplySignificand(pow5);</td>
    <td class="lineNumber">2954</td>
    <td class="codeline">      calcLostFraction = decSig.multiplySignificand(pow5);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeline">      powHUerr = powStatus != opOK;</td>
    <td class="lineNumber">2955</td>
    <td class="codeline">      powHUerr = powStatus != opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2956</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeline">      calcLostFraction = decSig.divideSignificand(pow5);</td>
    <td class="lineNumber">2957</td>
    <td class="codeline">      calcLostFraction = decSig.divideSignificand(pow5);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeline">      /* Denormal numbers have less precision.  */</td>
    <td class="lineNumber">2958</td>
    <td class="codeline">      /* Denormal numbers have less precision.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeline">      if (decSig.exponent < semantics->minExponent) {</td>
    <td class="lineNumber">2959</td>
    <td class="codeline">      if (decSig.exponent < semantics->minExponent) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeline">        excessPrecision += (semantics->minExponent - decSig.exponent);</td>
    <td class="lineNumber">2960</td>
    <td class="codeline">        excessPrecision += (semantics->minExponent - decSig.exponent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeline">        truncatedBits = excessPrecision;</td>
    <td class="lineNumber">2961</td>
    <td class="codeline">        truncatedBits = excessPrecision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeline">        if (excessPrecision > calcSemantics.precision)</td>
    <td class="lineNumber">2962</td>
    <td class="codeline">        if (excessPrecision > calcSemantics.precision)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeline">          excessPrecision = calcSemantics.precision;</td>
    <td class="lineNumber">2963</td>
    <td class="codeline">          excessPrecision = calcSemantics.precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2964</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeline">      /* Extra half-ulp lost in reciprocal of exponent.  */</td>
    <td class="lineNumber">2965</td>
    <td class="codeline">      /* Extra half-ulp lost in reciprocal of exponent.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeline">      powHUerr = (powStatus == opOK && calcLostFraction == lfExactlyZero) ? 0:2;</td>
    <td class="lineNumber">2966</td>
    <td class="codeline">      powHUerr = (powStatus == opOK && calcLostFraction == lfExactlyZero) ? 0:2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2967</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeline"></td>
    <td class="lineNumber">2968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeline">    /* Both multiplySignificand and divideSignificand return the</td>
    <td class="lineNumber">2969</td>
    <td class="codeline">    /* Both multiplySignificand and divideSignificand return the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeline">       result with the integer bit set.  */</td>
    <td class="lineNumber">2970</td>
    <td class="codeline">       result with the integer bit set.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeline">    assert(APInt::tcExtractBit</td>
    <td class="lineNumber">2971</td>
    <td class="codeline">    assert(APInt::tcExtractBit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeline">           (decSig.significandParts(), calcSemantics.precision - 1) == 1);</td>
    <td class="lineNumber">2972</td>
    <td class="codeline">           (decSig.significandParts(), calcSemantics.precision - 1) == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeline"></td>
    <td class="lineNumber">2973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeline">    HUerr = HUerrBound(calcLostFraction != lfExactlyZero, sigStatus != opOK,</td>
    <td class="lineNumber">2974</td>
    <td class="codeline">    HUerr = HUerrBound(calcLostFraction != lfExactlyZero, sigStatus != opOK,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeline">                       powHUerr);</td>
    <td class="lineNumber">2975</td>
    <td class="codeline">                       powHUerr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeline">    HUdistance = 2 * ulpsFromBoundary(decSig.significandParts(),</td>
    <td class="lineNumber">2976</td>
    <td class="codeline">    HUdistance = 2 * ulpsFromBoundary(decSig.significandParts(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeline">                                      excessPrecision, isNearest);</td>
    <td class="lineNumber">2977</td>
    <td class="codeline">                                      excessPrecision, isNearest);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeline"></td>
    <td class="lineNumber">2978</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeline">    /* Are we guaranteed to round correctly if we truncate?  */</td>
    <td class="lineNumber">2979</td>
    <td class="codeline">    /* Are we guaranteed to round correctly if we truncate?  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeline">    if (HUdistance >= HUerr) {</td>
    <td class="lineNumber">2980</td>
    <td class="codeline">    if (HUdistance >= HUerr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeline">      APInt::tcExtract(significandParts(), partCount(), decSig.significandParts(),</td>
    <td class="lineNumber">2981</td>
    <td class="codeline">      APInt::tcExtract(significandParts(), partCount(), decSig.significandParts(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeline">                       calcSemantics.precision - excessPrecision,</td>
    <td class="lineNumber">2982</td>
    <td class="codeline">                       calcSemantics.precision - excessPrecision,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeline">                       excessPrecision);</td>
    <td class="lineNumber">2983</td>
    <td class="codeline">                       excessPrecision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeline">      /* Take the exponent of decSig.  If we tcExtract-ed less bits</td>
    <td class="lineNumber">2984</td>
    <td class="codeline">      /* Take the exponent of decSig.  If we tcExtract-ed less bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeline">         above we must adjust our exponent to compensate for the</td>
    <td class="lineNumber">2985</td>
    <td class="codeline">         above we must adjust our exponent to compensate for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeline">         implicit right shift.  */</td>
    <td class="lineNumber">2986</td>
    <td class="codeline">         implicit right shift.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeline">      exponent = (decSig.exponent + semantics->precision</td>
    <td class="lineNumber">2987</td>
    <td class="codeline">      exponent = (decSig.exponent + semantics->precision</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeline">                  - (calcSemantics.precision - excessPrecision));</td>
    <td class="lineNumber">2988</td>
    <td class="codeline">                  - (calcSemantics.precision - excessPrecision));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeline">      calcLostFraction = lostFractionThroughTruncation(decSig.significandParts(),</td>
    <td class="lineNumber">2989</td>
    <td class="codeline">      calcLostFraction = lostFractionThroughTruncation(decSig.significandParts(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeline">                                                       decSig.partCount(),</td>
    <td class="lineNumber">2990</td>
    <td class="codeline">                                                       decSig.partCount(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeline">                                                       truncatedBits);</td>
    <td class="lineNumber">2991</td>
    <td class="codeline">                                                       truncatedBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeline">      return normalize(rounding_mode, calcLostFraction);</td>
    <td class="lineNumber">2992</td>
    <td class="codeline">      return normalize(rounding_mode, calcLostFraction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2993</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2994</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2995</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeline"></td>
    <td class="lineNumber">2996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeline">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">2997</td>
    <td class="codeline">Expected<IEEEFloat::opStatus></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeline">IEEEFloat::convertFromDecimalString(StringRef str, roundingMode rounding_mode) {</td>
    <td class="lineNumber">2998</td>
    <td class="codeline">IEEEFloat::convertFromDecimalString(StringRef str, roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeline">  decimalInfo D;</td>
    <td class="lineNumber">2999</td>
    <td class="codeline">  decimalInfo D;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">3000</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeline"></td>
    <td class="lineNumber">3001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeline">  /* Scan the text.  */</td>
    <td class="lineNumber">3002</td>
    <td class="codeline">  /* Scan the text.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">3003</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeline">  if (Error Err = interpretDecimal(p, str.end(), &D))</td>
    <td class="lineNumber">3004</td>
    <td class="codeline">  if (Error Err = interpretDecimal(p, str.end(), &D))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeline">    return std::move(Err);</td>
    <td class="lineNumber">3005</td>
    <td class="codeline">    return std::move(Err);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeline"></td>
    <td class="lineNumber">3006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeline">  /* Handle the quick cases.  First the case of no significant digits,</td>
    <td class="lineNumber">3007</td>
    <td class="codeline">  /* Handle the quick cases.  First the case of no significant digits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeline">     i.e. zero, and then exponents that are obviously too large or too</td>
    <td class="lineNumber">3008</td>
    <td class="codeline">     i.e. zero, and then exponents that are obviously too large or too</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeline">     small.  Writing L for log 10 / log 2, a number d.ddddd*10^exp</td>
    <td class="lineNumber">3009</td>
    <td class="codeline">     small.  Writing L for log 10 / log 2, a number d.ddddd*10^exp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeline">     definitely overflows if</td>
    <td class="lineNumber">3010</td>
    <td class="codeline">     definitely overflows if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeline"></td>
    <td class="lineNumber">3011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeline">           (exp - 1) * L >= maxExponent</td>
    <td class="lineNumber">3012</td>
    <td class="codeline">           (exp - 1) * L >= maxExponent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeline"></td>
    <td class="lineNumber">3013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeline">     and definitely underflows to zero where</td>
    <td class="lineNumber">3014</td>
    <td class="codeline">     and definitely underflows to zero where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeline"></td>
    <td class="lineNumber">3015</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeline">           (exp + 1) * L <= minExponent - precision</td>
    <td class="lineNumber">3016</td>
    <td class="codeline">           (exp + 1) * L <= minExponent - precision</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeline"></td>
    <td class="lineNumber">3017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeline">     With integer arithmetic the tightest bounds for L are</td>
    <td class="lineNumber">3018</td>
    <td class="codeline">     With integer arithmetic the tightest bounds for L are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeline"></td>
    <td class="lineNumber">3019</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeline">           93/28 < L < 196/59            [ numerator <= 256 ]</td>
    <td class="lineNumber">3020</td>
    <td class="codeline">           93/28 < L < 196/59            [ numerator <= 256 ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeline">           42039/12655 < L < 28738/8651  [ numerator <= 65536 ]</td>
    <td class="lineNumber">3021</td>
    <td class="codeline">           42039/12655 < L < 28738/8651  [ numerator <= 65536 ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeline">  */</td>
    <td class="lineNumber">3022</td>
    <td class="codeline">  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeline"></td>
    <td class="lineNumber">3023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeline">  // Test if we have a zero number allowing for strings with no null terminators</td>
    <td class="lineNumber">3024</td>
    <td class="codeline">  // Test if we have a zero number allowing for strings with no null terminators</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeline">  // and zero decimals with non-zero exponents.</td>
    <td class="lineNumber">3025</td>
    <td class="codeline">  // and zero decimals with non-zero exponents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">3026</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeline">  // We computed firstSigDigit by ignoring all zeros and dots. Thus if</td>
    <td class="lineNumber">3027</td>
    <td class="codeline">  // We computed firstSigDigit by ignoring all zeros and dots. Thus if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeline">  // D->firstSigDigit equals str.end(), every digit must be a zero and there can</td>
    <td class="lineNumber">3028</td>
    <td class="codeline">  // D->firstSigDigit equals str.end(), every digit must be a zero and there can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeline">  // be at most one dot. On the other hand, if we have a zero with a non-zero</td>
    <td class="lineNumber">3029</td>
    <td class="codeline">  // be at most one dot. On the other hand, if we have a zero with a non-zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeline">  // exponent, then we know that D.firstSigDigit will be non-numeric.</td>
    <td class="lineNumber">3030</td>
    <td class="codeline">  // exponent, then we know that D.firstSigDigit will be non-numeric.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeline">  if (D.firstSigDigit == str.end() || decDigitValue(*D.firstSigDigit) >= 10U) {</td>
    <td class="lineNumber">3031</td>
    <td class="codeline">  if (D.firstSigDigit == str.end() || decDigitValue(*D.firstSigDigit) >= 10U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeline">    category = fcZero;</td>
    <td class="lineNumber">3032</td>
    <td class="codeline">    category = fcZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeline">    fs = opOK;</td>
    <td class="lineNumber">3033</td>
    <td class="codeline">    fs = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">3034</td>
    <td class="codeline">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeline">      sign = false;</td>
    <td class="lineNumber">3035</td>
    <td class="codeline">      sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeline"></td>
    <td class="lineNumber">3036</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeline">    /* Check whether the normalized exponent is high enough to overflow</td>
    <td class="lineNumber">3037</td>
    <td class="codeline">    /* Check whether the normalized exponent is high enough to overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeline">       max during the log-rebasing in the max-exponent check below. */</td>
    <td class="lineNumber">3038</td>
    <td class="codeline">       max during the log-rebasing in the max-exponent check below. */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeline">  } else if (D.normalizedExponent - 1 > INT_MAX / 42039) {</td>
    <td class="lineNumber">3039</td>
    <td class="codeline">  } else if (D.normalizedExponent - 1 > INT_MAX / 42039) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeline">    fs = handleOverflow(rounding_mode);</td>
    <td class="lineNumber">3040</td>
    <td class="codeline">    fs = handleOverflow(rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeline"></td>
    <td class="lineNumber">3041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeline">  /* If it wasn't, then it also wasn't high enough to overflow max</td>
    <td class="lineNumber">3042</td>
    <td class="codeline">  /* If it wasn't, then it also wasn't high enough to overflow max</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeline">     during the log-rebasing in the min-exponent check.  Check that it</td>
    <td class="lineNumber">3043</td>
    <td class="codeline">     during the log-rebasing in the min-exponent check.  Check that it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeline">     won't overflow min in either check, then perform the min-exponent</td>
    <td class="lineNumber">3044</td>
    <td class="codeline">     won't overflow min in either check, then perform the min-exponent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeline">     check. */</td>
    <td class="lineNumber">3045</td>
    <td class="codeline">     check. */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeline">  } else if (D.normalizedExponent - 1 < INT_MIN / 42039 ||</td>
    <td class="lineNumber">3046</td>
    <td class="codeline">  } else if (D.normalizedExponent - 1 < INT_MIN / 42039 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeline">             (D.normalizedExponent + 1) * 28738 <=</td>
    <td class="lineNumber">3047</td>
    <td class="codeline">             (D.normalizedExponent + 1) * 28738 <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeline">               8651 * (semantics->minExponent - (int) semantics->precision)) {</td>
    <td class="lineNumber">3048</td>
    <td class="codeline">               8651 * (semantics->minExponent - (int) semantics->precision)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeline">    /* Underflow to zero and round.  */</td>
    <td class="lineNumber">3049</td>
    <td class="codeline">    /* Underflow to zero and round.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeline">    category = fcNormal;</td>
    <td class="lineNumber">3050</td>
    <td class="codeline">    category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeline">    zeroSignificand();</td>
    <td class="lineNumber">3051</td>
    <td class="codeline">    zeroSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeline">    fs = normalize(rounding_mode, lfLessThanHalf);</td>
    <td class="lineNumber">3052</td>
    <td class="codeline">    fs = normalize(rounding_mode, lfLessThanHalf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeline"></td>
    <td class="lineNumber">3053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeline">  /* We can finally safely perform the max-exponent check. */</td>
    <td class="lineNumber">3054</td>
    <td class="codeline">  /* We can finally safely perform the max-exponent check. */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeline">  } else if ((D.normalizedExponent - 1) * 42039</td>
    <td class="lineNumber">3055</td>
    <td class="codeline">  } else if ((D.normalizedExponent - 1) * 42039</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeline">             >= 12655 * semantics->maxExponent) {</td>
    <td class="lineNumber">3056</td>
    <td class="codeline">             >= 12655 * semantics->maxExponent) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeline">    /* Overflow and round.  */</td>
    <td class="lineNumber">3057</td>
    <td class="codeline">    /* Overflow and round.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeline">    fs = handleOverflow(rounding_mode);</td>
    <td class="lineNumber">3058</td>
    <td class="codeline">    fs = handleOverflow(rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3059</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeline">    integerPart *decSignificand;</td>
    <td class="lineNumber">3060</td>
    <td class="codeline">    integerPart *decSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeline">    unsigned int partCount;</td>
    <td class="lineNumber">3061</td>
    <td class="codeline">    unsigned int partCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeline"></td>
    <td class="lineNumber">3062</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeline">    /* A tight upper bound on number of bits required to hold an</td>
    <td class="lineNumber">3063</td>
    <td class="codeline">    /* A tight upper bound on number of bits required to hold an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeline">       N-digit decimal integer is N * 196 / 59.  Allocate enough space</td>
    <td class="lineNumber">3064</td>
    <td class="codeline">       N-digit decimal integer is N * 196 / 59.  Allocate enough space</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeline">       to hold the full significand, and an extra part required by</td>
    <td class="lineNumber">3065</td>
    <td class="codeline">       to hold the full significand, and an extra part required by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeline">       tcMultiplyPart.  */</td>
    <td class="lineNumber">3066</td>
    <td class="codeline">       tcMultiplyPart.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeline">    partCount = static_cast<unsigned int>(D.lastSigDigit - D.firstSigDigit) + 1;</td>
    <td class="lineNumber">3067</td>
    <td class="codeline">    partCount = static_cast<unsigned int>(D.lastSigDigit - D.firstSigDigit) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeline">    partCount = partCountForBits(1 + 196 * partCount / 59);</td>
    <td class="lineNumber">3068</td>
    <td class="codeline">    partCount = partCountForBits(1 + 196 * partCount / 59);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeline">    decSignificand = new integerPart[partCount + 1];</td>
    <td class="lineNumber">3069</td>
    <td class="codeline">    decSignificand = new integerPart[partCount + 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeline">    partCount = 0;</td>
    <td class="lineNumber">3070</td>
    <td class="codeline">    partCount = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeline"></td>
    <td class="lineNumber">3071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeline">    /* Convert to binary efficiently - we do almost all multiplication</td>
    <td class="lineNumber">3072</td>
    <td class="codeline">    /* Convert to binary efficiently - we do almost all multiplication</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeline">       in an integerPart.  When this would overflow do we do a single</td>
    <td class="lineNumber">3073</td>
    <td class="codeline">       in an integerPart.  When this would overflow do we do a single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeline">       bignum multiplication, and then revert again to multiplication</td>
    <td class="lineNumber">3074</td>
    <td class="codeline">       bignum multiplication, and then revert again to multiplication</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeline">       in an integerPart.  */</td>
    <td class="lineNumber">3075</td>
    <td class="codeline">       in an integerPart.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">3076</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeline">      integerPart decValue, val, multiplier;</td>
    <td class="lineNumber">3077</td>
    <td class="codeline">      integerPart decValue, val, multiplier;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeline"></td>
    <td class="lineNumber">3078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeline">      val = 0;</td>
    <td class="lineNumber">3079</td>
    <td class="codeline">      val = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeline">      multiplier = 1;</td>
    <td class="lineNumber">3080</td>
    <td class="codeline">      multiplier = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeline"></td>
    <td class="lineNumber">3081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeline">      do {</td>
    <td class="lineNumber">3082</td>
    <td class="codeline">      do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeline">        if (*p == '.') {</td>
    <td class="lineNumber">3083</td>
    <td class="codeline">        if (*p == '.') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeline">          p++;</td>
    <td class="lineNumber">3084</td>
    <td class="codeline">          p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeline">          if (p == str.end()) {</td>
    <td class="lineNumber">3085</td>
    <td class="codeline">          if (p == str.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeline">            break;</td>
    <td class="lineNumber">3086</td>
    <td class="codeline">            break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">3087</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">3088</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeline">        decValue = decDigitValue(*p++);</td>
    <td class="lineNumber">3089</td>
    <td class="codeline">        decValue = decDigitValue(*p++);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeline">        if (decValue >= 10U) {</td>
    <td class="lineNumber">3090</td>
    <td class="codeline">        if (decValue >= 10U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeline">          delete[] decSignificand;</td>
    <td class="lineNumber">3091</td>
    <td class="codeline">          delete[] decSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeline">          return createError("Invalid character in significand");</td>
    <td class="lineNumber">3092</td>
    <td class="codeline">          return createError("Invalid character in significand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">3093</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeline">        multiplier *= 10;</td>
    <td class="lineNumber">3094</td>
    <td class="codeline">        multiplier *= 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeline">        val = val * 10 + decValue;</td>
    <td class="lineNumber">3095</td>
    <td class="codeline">        val = val * 10 + decValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeline">        /* The maximum number that can be multiplied by ten with any</td>
    <td class="lineNumber">3096</td>
    <td class="codeline">        /* The maximum number that can be multiplied by ten with any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeline">           digit added without overflowing an integerPart.  */</td>
    <td class="lineNumber">3097</td>
    <td class="codeline">           digit added without overflowing an integerPart.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeline">      } while (p <= D.lastSigDigit && multiplier <= (~ (integerPart) 0 - 9) / 10);</td>
    <td class="lineNumber">3098</td>
    <td class="codeline">      } while (p <= D.lastSigDigit && multiplier <= (~ (integerPart) 0 - 9) / 10);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeline"></td>
    <td class="lineNumber">3099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeline">      /* Multiply out the current part.  */</td>
    <td class="lineNumber">3100</td>
    <td class="codeline">      /* Multiply out the current part.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeline">      APInt::tcMultiplyPart(decSignificand, decSignificand, multiplier, val,</td>
    <td class="lineNumber">3101</td>
    <td class="codeline">      APInt::tcMultiplyPart(decSignificand, decSignificand, multiplier, val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeline">                            partCount, partCount + 1, false);</td>
    <td class="lineNumber">3102</td>
    <td class="codeline">                            partCount, partCount + 1, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeline"></td>
    <td class="lineNumber">3103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeline">      /* If we used another part (likely but not guaranteed), increase</td>
    <td class="lineNumber">3104</td>
    <td class="codeline">      /* If we used another part (likely but not guaranteed), increase</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeline">         the count.  */</td>
    <td class="lineNumber">3105</td>
    <td class="codeline">         the count.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeline">      if (decSignificand[partCount])</td>
    <td class="lineNumber">3106</td>
    <td class="codeline">      if (decSignificand[partCount])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeline">        partCount++;</td>
    <td class="lineNumber">3107</td>
    <td class="codeline">        partCount++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeline">    } while (p <= D.lastSigDigit);</td>
    <td class="lineNumber">3108</td>
    <td class="codeline">    } while (p <= D.lastSigDigit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeline"></td>
    <td class="lineNumber">3109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeline">    category = fcNormal;</td>
    <td class="lineNumber">3110</td>
    <td class="codeline">    category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeline">    fs = roundSignificandWithExponent(decSignificand, partCount,</td>
    <td class="lineNumber">3111</td>
    <td class="codeline">    fs = roundSignificandWithExponent(decSignificand, partCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeline">                                      D.exponent, rounding_mode);</td>
    <td class="lineNumber">3112</td>
    <td class="codeline">                                      D.exponent, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeline"></td>
    <td class="lineNumber">3113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeline">    delete [] decSignificand;</td>
    <td class="lineNumber">3114</td>
    <td class="codeline">    delete [] decSignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3115</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeline"></td>
    <td class="lineNumber">3116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeline">  return fs;</td>
    <td class="lineNumber">3117</td>
    <td class="codeline">  return fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3118</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeline"></td>
    <td class="lineNumber">3119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeline">bool IEEEFloat::convertFromStringSpecials(StringRef str) {</td>
    <td class="lineNumber">3120</td>
    <td class="codeline">bool IEEEFloat::convertFromStringSpecials(StringRef str) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeline">  const size_t MIN_NAME_SIZE = 3;</td>
    <td class="lineNumber">3121</td>
    <td class="codeline">  const size_t MIN_NAME_SIZE = 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeline"></td>
    <td class="lineNumber">3122</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeline">  if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">3123</td>
    <td class="codeline">  if (str.size() < MIN_NAME_SIZE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3124</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeline"></td>
    <td class="lineNumber">3125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeline">  if (str.equals("inf") || str.equals("INFINITY") || str.equals("+Inf")) {</td>
    <td class="lineNumber">3126</td>
    <td class="codeline">  if (str.equals("inf") || str.equals("INFINITY") || str.equals("+Inf")) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeline">    makeInf(false);</td>
    <td class="lineNumber">3127</td>
    <td class="codeline">    makeInf(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3128</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3129</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeline"></td>
    <td class="lineNumber">3130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeline">  bool IsNegative = str.front() == '-';</td>
    <td class="lineNumber">3131</td>
    <td class="codeline">  bool IsNegative = str.front() == '-';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeline">  if (IsNegative) {</td>
    <td class="lineNumber">3132</td>
    <td class="codeline">  if (IsNegative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeline">    str = str.drop_front();</td>
    <td class="lineNumber">3133</td>
    <td class="codeline">    str = str.drop_front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeline">    if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">3134</td>
    <td class="codeline">    if (str.size() < MIN_NAME_SIZE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3135</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeline"></td>
    <td class="lineNumber">3136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeline">    if (str.equals("inf") || str.equals("INFINITY") || str.equals("Inf")) {</td>
    <td class="lineNumber">3137</td>
    <td class="codeline">    if (str.equals("inf") || str.equals("INFINITY") || str.equals("Inf")) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeline">      makeInf(true);</td>
    <td class="lineNumber">3138</td>
    <td class="codeline">      makeInf(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3139</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3140</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3141</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeline"></td>
    <td class="lineNumber">3142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeline">  // If we have a 's' (or 'S') prefix, then this is a Signaling NaN.</td>
    <td class="lineNumber">3143</td>
    <td class="codeline">  // If we have a 's' (or 'S') prefix, then this is a Signaling NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeline">  bool IsSignaling = str.front() == 's' || str.front() == 'S';</td>
    <td class="lineNumber">3144</td>
    <td class="codeline">  bool IsSignaling = str.front() == 's' || str.front() == 'S';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeline">  if (IsSignaling) {</td>
    <td class="lineNumber">3145</td>
    <td class="codeline">  if (IsSignaling) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeline">    str = str.drop_front();</td>
    <td class="lineNumber">3146</td>
    <td class="codeline">    str = str.drop_front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeline">    if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">3147</td>
    <td class="codeline">    if (str.size() < MIN_NAME_SIZE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3148</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3149</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeline"></td>
    <td class="lineNumber">3150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeline">  if (str.startswith("nan") || str.startswith("NaN")) {</td>
    <td class="lineNumber">3151</td>
    <td class="codeline">  if (str.startswith("nan") || str.startswith("NaN")) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeline">    str = str.drop_front(3);</td>
    <td class="lineNumber">3152</td>
    <td class="codeline">    str = str.drop_front(3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeline"></td>
    <td class="lineNumber">3153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeline">    // A NaN without payload.</td>
    <td class="lineNumber">3154</td>
    <td class="codeline">    // A NaN without payload.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeline">    if (str.empty()) {</td>
    <td class="lineNumber">3155</td>
    <td class="codeline">    if (str.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeline">      makeNaN(IsSignaling, IsNegative);</td>
    <td class="lineNumber">3156</td>
    <td class="codeline">      makeNaN(IsSignaling, IsNegative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3157</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3158</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeline"></td>
    <td class="lineNumber">3159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeline">    // Allow the payload to be inside parentheses.</td>
    <td class="lineNumber">3160</td>
    <td class="codeline">    // Allow the payload to be inside parentheses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeline">    if (str.front() == '(') {</td>
    <td class="lineNumber">3161</td>
    <td class="codeline">    if (str.front() == '(') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeline">      // Parentheses should be balanced (and not empty).</td>
    <td class="lineNumber">3162</td>
    <td class="codeline">      // Parentheses should be balanced (and not empty).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeline">      if (str.size() <= 2 || str.back() != ')')</td>
    <td class="lineNumber">3163</td>
    <td class="codeline">      if (str.size() <= 2 || str.back() != ')')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">3164</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeline"></td>
    <td class="lineNumber">3165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeline">      str = str.slice(1, str.size() - 1);</td>
    <td class="lineNumber">3166</td>
    <td class="codeline">      str = str.slice(1, str.size() - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3167</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeline"></td>
    <td class="lineNumber">3168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeline">    // Determine the payload number's radix.</td>
    <td class="lineNumber">3169</td>
    <td class="codeline">    // Determine the payload number's radix.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeline">    unsigned Radix = 10;</td>
    <td class="lineNumber">3170</td>
    <td class="codeline">    unsigned Radix = 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeline">    if (str[0] == '0') {</td>
    <td class="lineNumber">3171</td>
    <td class="codeline">    if (str[0] == '0') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeline">      if (str.size() > 1 && tolower(str[1]) == 'x') {</td>
    <td class="lineNumber">3172</td>
    <td class="codeline">      if (str.size() > 1 && tolower(str[1]) == 'x') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeline">        str = str.drop_front(2);</td>
    <td class="lineNumber">3173</td>
    <td class="codeline">        str = str.drop_front(2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeline">        Radix = 16;</td>
    <td class="lineNumber">3174</td>
    <td class="codeline">        Radix = 16;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeline">      } else</td>
    <td class="lineNumber">3175</td>
    <td class="codeline">      } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeline">        Radix = 8;</td>
    <td class="lineNumber">3176</td>
    <td class="codeline">        Radix = 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3177</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeline"></td>
    <td class="lineNumber">3178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeline">    // Parse the payload and make the NaN.</td>
    <td class="lineNumber">3179</td>
    <td class="codeline">    // Parse the payload and make the NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeline">    APInt Payload;</td>
    <td class="lineNumber">3180</td>
    <td class="codeline">    APInt Payload;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeline">    if (!str.getAsInteger(Radix, Payload)) {</td>
    <td class="lineNumber">3181</td>
    <td class="codeline">    if (!str.getAsInteger(Radix, Payload)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeline">      makeNaN(IsSignaling, IsNegative, &Payload);</td>
    <td class="lineNumber">3182</td>
    <td class="codeline">      makeNaN(IsSignaling, IsNegative, &Payload);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3183</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3184</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3185</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeline"></td>
    <td class="lineNumber">3186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">3187</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3188</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeline"></td>
    <td class="lineNumber">3189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeline">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">3190</td>
    <td class="codeline">Expected<IEEEFloat::opStatus></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeline">IEEEFloat::convertFromString(StringRef str, roundingMode rounding_mode) {</td>
    <td class="lineNumber">3191</td>
    <td class="codeline">IEEEFloat::convertFromString(StringRef str, roundingMode rounding_mode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeline">  if (str.empty())</td>
    <td class="lineNumber">3192</td>
    <td class="codeline">  if (str.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeline">    return createError("Invalid string length");</td>
    <td class="lineNumber">3193</td>
    <td class="codeline">    return createError("Invalid string length");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeline"></td>
    <td class="lineNumber">3194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeline">  // Handle special cases.</td>
    <td class="lineNumber">3195</td>
    <td class="codeline">  // Handle special cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeline">  if (convertFromStringSpecials(str))</td>
    <td class="lineNumber">3196</td>
    <td class="codeline">  if (convertFromStringSpecials(str))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">3197</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeline"></td>
    <td class="lineNumber">3198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeline">  /* Handle a leading minus sign.  */</td>
    <td class="lineNumber">3199</td>
    <td class="codeline">  /* Handle a leading minus sign.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">3200</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeline">  size_t slen = str.size();</td>
    <td class="lineNumber">3201</td>
    <td class="codeline">  size_t slen = str.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeline">  sign = *p == '-' ? 1 : 0;</td>
    <td class="lineNumber">3202</td>
    <td class="codeline">  sign = *p == '-' ? 1 : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">3203</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">3204</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeline">    slen--;</td>
    <td class="lineNumber">3205</td>
    <td class="codeline">    slen--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeline">    if (!slen)</td>
    <td class="lineNumber">3206</td>
    <td class="codeline">    if (!slen)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeline">      return createError("String has no digits");</td>
    <td class="lineNumber">3207</td>
    <td class="codeline">      return createError("String has no digits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3208</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeline"></td>
    <td class="lineNumber">3209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeline">  if (slen >= 2 && p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {</td>
    <td class="lineNumber">3210</td>
    <td class="codeline">  if (slen >= 2 && p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeline">    if (slen == 2)</td>
    <td class="lineNumber">3211</td>
    <td class="codeline">    if (slen == 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeline">      return createError("Invalid string");</td>
    <td class="lineNumber">3212</td>
    <td class="codeline">      return createError("Invalid string");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeline">    return convertFromHexadecimalString(StringRef(p + 2, slen - 2),</td>
    <td class="lineNumber">3213</td>
    <td class="codeline">    return convertFromHexadecimalString(StringRef(p + 2, slen - 2),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeline">                                        rounding_mode);</td>
    <td class="lineNumber">3214</td>
    <td class="codeline">                                        rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3215</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeline"></td>
    <td class="lineNumber">3216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeline">  return convertFromDecimalString(StringRef(p, slen), rounding_mode);</td>
    <td class="lineNumber">3217</td>
    <td class="codeline">  return convertFromDecimalString(StringRef(p, slen), rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3218</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeline"></td>
    <td class="lineNumber">3219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeline">/* Write out a hexadecimal representation of the floating point value</td>
    <td class="lineNumber">3220</td>
    <td class="codeline">/* Write out a hexadecimal representation of the floating point value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeline">   to DST, which must be of sufficient size, in the C99 form</td>
    <td class="lineNumber">3221</td>
    <td class="codeline">   to DST, which must be of sufficient size, in the C99 form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeline">   [-]0xh.hhhhp[+-]d.  Return the number of characters written,</td>
    <td class="lineNumber">3222</td>
    <td class="codeline">   [-]0xh.hhhhp[+-]d.  Return the number of characters written,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeline">   excluding the terminating NUL.</td>
    <td class="lineNumber">3223</td>
    <td class="codeline">   excluding the terminating NUL.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeline"></td>
    <td class="lineNumber">3224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeline">   If UPPERCASE, the output is in upper case, otherwise in lower case.</td>
    <td class="lineNumber">3225</td>
    <td class="codeline">   If UPPERCASE, the output is in upper case, otherwise in lower case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeline"></td>
    <td class="lineNumber">3226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeline">   HEXDIGITS digits appear altogether, rounding the value if</td>
    <td class="lineNumber">3227</td>
    <td class="codeline">   HEXDIGITS digits appear altogether, rounding the value if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeline">   necessary.  If HEXDIGITS is 0, the minimal precision to display the</td>
    <td class="lineNumber">3228</td>
    <td class="codeline">   necessary.  If HEXDIGITS is 0, the minimal precision to display the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeline">   number precisely is used instead.  If nothing would appear after</td>
    <td class="lineNumber">3229</td>
    <td class="codeline">   number precisely is used instead.  If nothing would appear after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeline">   the decimal point it is suppressed.</td>
    <td class="lineNumber">3230</td>
    <td class="codeline">   the decimal point it is suppressed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeline"></td>
    <td class="lineNumber">3231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeline">   The decimal exponent is always printed and has at least one digit.</td>
    <td class="lineNumber">3232</td>
    <td class="codeline">   The decimal exponent is always printed and has at least one digit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeline">   Zero values display an exponent of zero.  Infinities and NaNs</td>
    <td class="lineNumber">3233</td>
    <td class="codeline">   Zero values display an exponent of zero.  Infinities and NaNs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeline">   appear as "infinity" or "nan" respectively.</td>
    <td class="lineNumber">3234</td>
    <td class="codeline">   appear as "infinity" or "nan" respectively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeline"></td>
    <td class="lineNumber">3235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeline">   The above rules are as specified by C99.  There is ambiguity about</td>
    <td class="lineNumber">3236</td>
    <td class="codeline">   The above rules are as specified by C99.  There is ambiguity about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeline">   what the leading hexadecimal digit should be.  This implementation</td>
    <td class="lineNumber">3237</td>
    <td class="codeline">   what the leading hexadecimal digit should be.  This implementation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeline">   uses whatever is necessary so that the exponent is displayed as</td>
    <td class="lineNumber">3238</td>
    <td class="codeline">   uses whatever is necessary so that the exponent is displayed as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeline">   stored.  This implies the exponent will fall within the IEEE format</td>
    <td class="lineNumber">3239</td>
    <td class="codeline">   stored.  This implies the exponent will fall within the IEEE format</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeline">   range, and the leading hexadecimal digit will be 0 (for denormals),</td>
    <td class="lineNumber">3240</td>
    <td class="codeline">   range, and the leading hexadecimal digit will be 0 (for denormals),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeline">   1 (normal numbers) or 2 (normal numbers rounded-away-from-zero with</td>
    <td class="lineNumber">3241</td>
    <td class="codeline">   1 (normal numbers) or 2 (normal numbers rounded-away-from-zero with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeline">   any other digits zero).</td>
    <td class="lineNumber">3242</td>
    <td class="codeline">   any other digits zero).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeline">*/</td>
    <td class="lineNumber">3243</td>
    <td class="codeline">*/</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeline">unsigned int IEEEFloat::convertToHexString(char *dst, unsigned int hexDigits,</td>
    <td class="lineNumber">3244</td>
    <td class="codeline">unsigned int IEEEFloat::convertToHexString(char *dst, unsigned int hexDigits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeline">                                           bool upperCase,</td>
    <td class="lineNumber">3245</td>
    <td class="codeline">                                           bool upperCase,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeline">                                           roundingMode rounding_mode) const {</td>
    <td class="lineNumber">3246</td>
    <td class="codeline">                                           roundingMode rounding_mode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeline">  char *p;</td>
    <td class="lineNumber">3247</td>
    <td class="codeline">  char *p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeline"></td>
    <td class="lineNumber">3248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeline">  p = dst;</td>
    <td class="lineNumber">3249</td>
    <td class="codeline">  p = dst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeline">  if (sign)</td>
    <td class="lineNumber">3250</td>
    <td class="codeline">  if (sign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeline">    *dst++ = '-';</td>
    <td class="lineNumber">3251</td>
    <td class="codeline">    *dst++ = '-';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeline"></td>
    <td class="lineNumber">3252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeline">  switch (category) {</td>
    <td class="lineNumber">3253</td>
    <td class="codeline">  switch (category) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeline">  case fcInfinity:</td>
    <td class="lineNumber">3254</td>
    <td class="codeline">  case fcInfinity:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeline">    memcpy (dst, upperCase ? infinityU: infinityL, sizeof infinityU - 1);</td>
    <td class="lineNumber">3255</td>
    <td class="codeline">    memcpy (dst, upperCase ? infinityU: infinityL, sizeof infinityU - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeline">    dst += sizeof infinityL - 1;</td>
    <td class="lineNumber">3256</td>
    <td class="codeline">    dst += sizeof infinityL - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">3257</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeline"></td>
    <td class="lineNumber">3258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeline">  case fcNaN:</td>
    <td class="lineNumber">3259</td>
    <td class="codeline">  case fcNaN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeline">    memcpy (dst, upperCase ? NaNU: NaNL, sizeof NaNU - 1);</td>
    <td class="lineNumber">3260</td>
    <td class="codeline">    memcpy (dst, upperCase ? NaNU: NaNL, sizeof NaNU - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeline">    dst += sizeof NaNU - 1;</td>
    <td class="lineNumber">3261</td>
    <td class="codeline">    dst += sizeof NaNU - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">3262</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeline"></td>
    <td class="lineNumber">3263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeline">  case fcZero:</td>
    <td class="lineNumber">3264</td>
    <td class="codeline">  case fcZero:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeline">    *dst++ = '0';</td>
    <td class="lineNumber">3265</td>
    <td class="codeline">    *dst++ = '0';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeline">    *dst++ = upperCase ? 'X': 'x';</td>
    <td class="lineNumber">3266</td>
    <td class="codeline">    *dst++ = upperCase ? 'X': 'x';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeline">    *dst++ = '0';</td>
    <td class="lineNumber">3267</td>
    <td class="codeline">    *dst++ = '0';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeline">    if (hexDigits > 1) {</td>
    <td class="lineNumber">3268</td>
    <td class="codeline">    if (hexDigits > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeline">      *dst++ = '.';</td>
    <td class="lineNumber">3269</td>
    <td class="codeline">      *dst++ = '.';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeline">      memset (dst, '0', hexDigits - 1);</td>
    <td class="lineNumber">3270</td>
    <td class="codeline">      memset (dst, '0', hexDigits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeline">      dst += hexDigits - 1;</td>
    <td class="lineNumber">3271</td>
    <td class="codeline">      dst += hexDigits - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3272</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeline">    *dst++ = upperCase ? 'P': 'p';</td>
    <td class="lineNumber">3273</td>
    <td class="codeline">    *dst++ = upperCase ? 'P': 'p';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeline">    *dst++ = '0';</td>
    <td class="lineNumber">3274</td>
    <td class="codeline">    *dst++ = '0';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">3275</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeline"></td>
    <td class="lineNumber">3276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeline">  case fcNormal:</td>
    <td class="lineNumber">3277</td>
    <td class="codeline">  case fcNormal:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="codeline">    dst = convertNormalToHexString (dst, hexDigits, upperCase, rounding_mode);</td>
    <td class="lineNumber">3278</td>
    <td class="codeline">    dst = convertNormalToHexString (dst, hexDigits, upperCase, rounding_mode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">3279</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3280</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class="codeline"></td>
    <td class="lineNumber">3281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="codeline">  *dst = 0;</td>
    <td class="lineNumber">3282</td>
    <td class="codeline">  *dst = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="codeline"></td>
    <td class="lineNumber">3283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="codeline">  return static_cast<unsigned int>(dst - p);</td>
    <td class="lineNumber">3284</td>
    <td class="codeline">  return static_cast<unsigned int>(dst - p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3285</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="codeline"></td>
    <td class="lineNumber">3286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="codeline">/* Does the hard work of outputting the correctly rounded hexadecimal</td>
    <td class="lineNumber">3287</td>
    <td class="codeline">/* Does the hard work of outputting the correctly rounded hexadecimal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="codeline">   form of a normal floating point number with the specified number of</td>
    <td class="lineNumber">3288</td>
    <td class="codeline">   form of a normal floating point number with the specified number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="codeline">   hexadecimal digits.  If HEXDIGITS is zero the minimum number of</td>
    <td class="lineNumber">3289</td>
    <td class="codeline">   hexadecimal digits.  If HEXDIGITS is zero the minimum number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="codeline">   digits necessary to print the value precisely is output.  */</td>
    <td class="lineNumber">3290</td>
    <td class="codeline">   digits necessary to print the value precisely is output.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="codeline">char *IEEEFloat::convertNormalToHexString(char *dst, unsigned int hexDigits,</td>
    <td class="lineNumber">3291</td>
    <td class="codeline">char *IEEEFloat::convertNormalToHexString(char *dst, unsigned int hexDigits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="codeline">                                          bool upperCase,</td>
    <td class="lineNumber">3292</td>
    <td class="codeline">                                          bool upperCase,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="codeline">                                          roundingMode rounding_mode) const {</td>
    <td class="lineNumber">3293</td>
    <td class="codeline">                                          roundingMode rounding_mode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="codeline">  unsigned int count, valueBits, shift, partsCount, outputDigits;</td>
    <td class="lineNumber">3294</td>
    <td class="codeline">  unsigned int count, valueBits, shift, partsCount, outputDigits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="codeline">  const char *hexDigitChars;</td>
    <td class="lineNumber">3295</td>
    <td class="codeline">  const char *hexDigitChars;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="codeline">  const integerPart *significand;</td>
    <td class="lineNumber">3296</td>
    <td class="codeline">  const integerPart *significand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="codeline">  char *p;</td>
    <td class="lineNumber">3297</td>
    <td class="codeline">  char *p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="codeline">  bool roundUp;</td>
    <td class="lineNumber">3298</td>
    <td class="codeline">  bool roundUp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="codeline"></td>
    <td class="lineNumber">3299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="codeline">  *dst++ = '0';</td>
    <td class="lineNumber">3300</td>
    <td class="codeline">  *dst++ = '0';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="codeline">  *dst++ = upperCase ? 'X': 'x';</td>
    <td class="lineNumber">3301</td>
    <td class="codeline">  *dst++ = upperCase ? 'X': 'x';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class="codeline"></td>
    <td class="lineNumber">3302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="codeline">  roundUp = false;</td>
    <td class="lineNumber">3303</td>
    <td class="codeline">  roundUp = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="codeline">  hexDigitChars = upperCase ? hexDigitsUpper: hexDigitsLower;</td>
    <td class="lineNumber">3304</td>
    <td class="codeline">  hexDigitChars = upperCase ? hexDigitsUpper: hexDigitsLower;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="codeline"></td>
    <td class="lineNumber">3305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="codeline">  significand = significandParts();</td>
    <td class="lineNumber">3306</td>
    <td class="codeline">  significand = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="codeline">  partsCount = partCount();</td>
    <td class="lineNumber">3307</td>
    <td class="codeline">  partsCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class="codeline"></td>
    <td class="lineNumber">3308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="codeline">  /* +3 because the first digit only uses the single integer bit, so</td>
    <td class="lineNumber">3309</td>
    <td class="codeline">  /* +3 because the first digit only uses the single integer bit, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="codeline">     we have 3 virtual zero most-significant-bits.  */</td>
    <td class="lineNumber">3310</td>
    <td class="codeline">     we have 3 virtual zero most-significant-bits.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="codeline">  valueBits = semantics->precision + 3;</td>
    <td class="lineNumber">3311</td>
    <td class="codeline">  valueBits = semantics->precision + 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="codeline">  shift = integerPartWidth - valueBits % integerPartWidth;</td>
    <td class="lineNumber">3312</td>
    <td class="codeline">  shift = integerPartWidth - valueBits % integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="codeline"></td>
    <td class="lineNumber">3313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="codeline">  /* The natural number of digits required ignoring trailing</td>
    <td class="lineNumber">3314</td>
    <td class="codeline">  /* The natural number of digits required ignoring trailing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="codeline">     insignificant zeroes.  */</td>
    <td class="lineNumber">3315</td>
    <td class="codeline">     insignificant zeroes.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="codeline">  outputDigits = (valueBits - significandLSB () + 3) / 4;</td>
    <td class="lineNumber">3316</td>
    <td class="codeline">  outputDigits = (valueBits - significandLSB () + 3) / 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="codeline"></td>
    <td class="lineNumber">3317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="codeline">  /* hexDigits of zero means use the required number for the</td>
    <td class="lineNumber">3318</td>
    <td class="codeline">  /* hexDigits of zero means use the required number for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="codeline">     precision.  Otherwise, see if we are truncating.  If we are,</td>
    <td class="lineNumber">3319</td>
    <td class="codeline">     precision.  Otherwise, see if we are truncating.  If we are,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="codeline">     find out if we need to round away from zero.  */</td>
    <td class="lineNumber">3320</td>
    <td class="codeline">     find out if we need to round away from zero.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="codeline">  if (hexDigits) {</td>
    <td class="lineNumber">3321</td>
    <td class="codeline">  if (hexDigits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="codeline">    if (hexDigits < outputDigits) {</td>
    <td class="lineNumber">3322</td>
    <td class="codeline">    if (hexDigits < outputDigits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="codeline">      /* We are dropping non-zero bits, so need to check how to round.</td>
    <td class="lineNumber">3323</td>
    <td class="codeline">      /* We are dropping non-zero bits, so need to check how to round.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="codeline">         "bits" is the number of dropped bits.  */</td>
    <td class="lineNumber">3324</td>
    <td class="codeline">         "bits" is the number of dropped bits.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="codeline">      unsigned int bits;</td>
    <td class="lineNumber">3325</td>
    <td class="codeline">      unsigned int bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="codeline">      lostFraction fraction;</td>
    <td class="lineNumber">3326</td>
    <td class="codeline">      lostFraction fraction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class="codeline"></td>
    <td class="lineNumber">3327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="codeline">      bits = valueBits - hexDigits * 4;</td>
    <td class="lineNumber">3328</td>
    <td class="codeline">      bits = valueBits - hexDigits * 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="codeline">      fraction = lostFractionThroughTruncation (significand, partsCount, bits);</td>
    <td class="lineNumber">3329</td>
    <td class="codeline">      fraction = lostFractionThroughTruncation (significand, partsCount, bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="codeline">      roundUp = roundAwayFromZero(rounding_mode, fraction, bits);</td>
    <td class="lineNumber">3330</td>
    <td class="codeline">      roundUp = roundAwayFromZero(rounding_mode, fraction, bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3331</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="codeline">    outputDigits = hexDigits;</td>
    <td class="lineNumber">3332</td>
    <td class="codeline">    outputDigits = hexDigits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3333</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class="codeline"></td>
    <td class="lineNumber">3334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="codeline">  /* Write the digits consecutively, and start writing in the location</td>
    <td class="lineNumber">3335</td>
    <td class="codeline">  /* Write the digits consecutively, and start writing in the location</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="codeline">     of the hexadecimal point.  We move the most significant digit</td>
    <td class="lineNumber">3336</td>
    <td class="codeline">     of the hexadecimal point.  We move the most significant digit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="codeline">     left and add the hexadecimal point later.  */</td>
    <td class="lineNumber">3337</td>
    <td class="codeline">     left and add the hexadecimal point later.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="codeline">  p = ++dst;</td>
    <td class="lineNumber">3338</td>
    <td class="codeline">  p = ++dst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="codeline"></td>
    <td class="lineNumber">3339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="codeline">  count = (valueBits + integerPartWidth - 1) / integerPartWidth;</td>
    <td class="lineNumber">3340</td>
    <td class="codeline">  count = (valueBits + integerPartWidth - 1) / integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="codeline"></td>
    <td class="lineNumber">3341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="codeline">  while (outputDigits && count) {</td>
    <td class="lineNumber">3342</td>
    <td class="codeline">  while (outputDigits && count) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="codeline">    integerPart part;</td>
    <td class="lineNumber">3343</td>
    <td class="codeline">    integerPart part;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class="codeline"></td>
    <td class="lineNumber">3344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="codeline">    /* Put the most significant integerPartWidth bits in "part".  */</td>
    <td class="lineNumber">3345</td>
    <td class="codeline">    /* Put the most significant integerPartWidth bits in "part".  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="codeline">    if (--count == partsCount)</td>
    <td class="lineNumber">3346</td>
    <td class="codeline">    if (--count == partsCount)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="codeline">      part = 0;  /* An imaginary higher zero part.  */</td>
    <td class="lineNumber">3347</td>
    <td class="codeline">      part = 0;  /* An imaginary higher zero part.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">3348</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="codeline">      part = significand[count] << shift;</td>
    <td class="lineNumber">3349</td>
    <td class="codeline">      part = significand[count] << shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="codeline"></td>
    <td class="lineNumber">3350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="codeline">    if (count && shift)</td>
    <td class="lineNumber">3351</td>
    <td class="codeline">    if (count && shift)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="codeline">      part |= significand[count - 1] >> (integerPartWidth - shift);</td>
    <td class="lineNumber">3352</td>
    <td class="codeline">      part |= significand[count - 1] >> (integerPartWidth - shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class="codeline"></td>
    <td class="lineNumber">3353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="codeline">    /* Convert as much of "part" to hexdigits as we can.  */</td>
    <td class="lineNumber">3354</td>
    <td class="codeline">    /* Convert as much of "part" to hexdigits as we can.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="codeline">    unsigned int curDigits = integerPartWidth / 4;</td>
    <td class="lineNumber">3355</td>
    <td class="codeline">    unsigned int curDigits = integerPartWidth / 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class="codeline"></td>
    <td class="lineNumber">3356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="codeline">    if (curDigits > outputDigits)</td>
    <td class="lineNumber">3357</td>
    <td class="codeline">    if (curDigits > outputDigits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="codeline">      curDigits = outputDigits;</td>
    <td class="lineNumber">3358</td>
    <td class="codeline">      curDigits = outputDigits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="codeline">    dst += partAsHex (dst, part, curDigits, hexDigitChars);</td>
    <td class="lineNumber">3359</td>
    <td class="codeline">    dst += partAsHex (dst, part, curDigits, hexDigitChars);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="codeline">    outputDigits -= curDigits;</td>
    <td class="lineNumber">3360</td>
    <td class="codeline">    outputDigits -= curDigits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3361</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="codeline"></td>
    <td class="lineNumber">3362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="codeline">  if (roundUp) {</td>
    <td class="lineNumber">3363</td>
    <td class="codeline">  if (roundUp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="codeline">    char *q = dst;</td>
    <td class="lineNumber">3364</td>
    <td class="codeline">    char *q = dst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class="codeline"></td>
    <td class="lineNumber">3365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="codeline">    /* Note that hexDigitChars has a trailing '0'.  */</td>
    <td class="lineNumber">3366</td>
    <td class="codeline">    /* Note that hexDigitChars has a trailing '0'.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">3367</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="codeline">      q--;</td>
    <td class="lineNumber">3368</td>
    <td class="codeline">      q--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="codeline">      *q = hexDigitChars[hexDigitValue (*q) + 1];</td>
    <td class="lineNumber">3369</td>
    <td class="codeline">      *q = hexDigitChars[hexDigitValue (*q) + 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="codeline">    } while (*q == '0');</td>
    <td class="lineNumber">3370</td>
    <td class="codeline">    } while (*q == '0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="codeline">    assert(q >= p);</td>
    <td class="lineNumber">3371</td>
    <td class="codeline">    assert(q >= p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3372</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="codeline">    /* Add trailing zeroes.  */</td>
    <td class="lineNumber">3373</td>
    <td class="codeline">    /* Add trailing zeroes.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="codeline">    memset (dst, '0', outputDigits);</td>
    <td class="lineNumber">3374</td>
    <td class="codeline">    memset (dst, '0', outputDigits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="codeline">    dst += outputDigits;</td>
    <td class="lineNumber">3375</td>
    <td class="codeline">    dst += outputDigits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3376</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class="codeline"></td>
    <td class="lineNumber">3377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="codeline">  /* Move the most significant digit to before the point, and if there</td>
    <td class="lineNumber">3378</td>
    <td class="codeline">  /* Move the most significant digit to before the point, and if there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="codeline">     is something after the decimal point add it.  This must come</td>
    <td class="lineNumber">3379</td>
    <td class="codeline">     is something after the decimal point add it.  This must come</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="codeline">     after rounding above.  */</td>
    <td class="lineNumber">3380</td>
    <td class="codeline">     after rounding above.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="codeline">  p[-1] = p[0];</td>
    <td class="lineNumber">3381</td>
    <td class="codeline">  p[-1] = p[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="codeline">  if (dst -1 == p)</td>
    <td class="lineNumber">3382</td>
    <td class="codeline">  if (dst -1 == p)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="codeline">    dst--;</td>
    <td class="lineNumber">3383</td>
    <td class="codeline">    dst--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">3384</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="codeline">    p[0] = '.';</td>
    <td class="lineNumber">3385</td>
    <td class="codeline">    p[0] = '.';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="codeline"></td>
    <td class="lineNumber">3386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="codeline">  /* Finally output the exponent.  */</td>
    <td class="lineNumber">3387</td>
    <td class="codeline">  /* Finally output the exponent.  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="codeline">  *dst++ = upperCase ? 'P': 'p';</td>
    <td class="lineNumber">3388</td>
    <td class="codeline">  *dst++ = upperCase ? 'P': 'p';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class="codeline"></td>
    <td class="lineNumber">3389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="codeline">  return writeSignedDecimal (dst, exponent);</td>
    <td class="lineNumber">3390</td>
    <td class="codeline">  return writeSignedDecimal (dst, exponent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3391</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="codeline"></td>
    <td class="lineNumber">3392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="codeline">hash_code hash_value(const IEEEFloat &Arg) {</td>
    <td class="lineNumber">3393</td>
    <td class="codeline">hash_code hash_value(const IEEEFloat &Arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="codeline">  if (!Arg.isFiniteNonZero())</td>
    <td class="lineNumber">3394</td>
    <td class="codeline">  if (!Arg.isFiniteNonZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="codeline">    return hash_combine((uint8_t)Arg.category,</td>
    <td class="lineNumber">3395</td>
    <td class="codeline">    return hash_combine((uint8_t)Arg.category,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="codeline">                        // NaN has no sign, fix it at zero.</td>
    <td class="lineNumber">3396</td>
    <td class="codeline">                        // NaN has no sign, fix it at zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="codeline">                        Arg.isNaN() ? (uint8_t)0 : (uint8_t)Arg.sign,</td>
    <td class="lineNumber">3397</td>
    <td class="codeline">                        Arg.isNaN() ? (uint8_t)0 : (uint8_t)Arg.sign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="codeline">                        Arg.semantics->precision);</td>
    <td class="lineNumber">3398</td>
    <td class="codeline">                        Arg.semantics->precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="codeline"></td>
    <td class="lineNumber">3399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="codeline">  // Normal floats need their exponent and significand hashed.</td>
    <td class="lineNumber">3400</td>
    <td class="codeline">  // Normal floats need their exponent and significand hashed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="codeline">  return hash_combine((uint8_t)Arg.category, (uint8_t)Arg.sign,</td>
    <td class="lineNumber">3401</td>
    <td class="codeline">  return hash_combine((uint8_t)Arg.category, (uint8_t)Arg.sign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="codeline">                      Arg.semantics->precision, Arg.exponent,</td>
    <td class="lineNumber">3402</td>
    <td class="codeline">                      Arg.semantics->precision, Arg.exponent,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="codeline">                      hash_combine_range(</td>
    <td class="lineNumber">3403</td>
    <td class="codeline">                      hash_combine_range(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="codeline">                        Arg.significandParts(),</td>
    <td class="lineNumber">3404</td>
    <td class="codeline">                        Arg.significandParts(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="codeline">                        Arg.significandParts() + Arg.partCount()));</td>
    <td class="lineNumber">3405</td>
    <td class="codeline">                        Arg.significandParts() + Arg.partCount()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3406</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="codeline"></td>
    <td class="lineNumber">3407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="codeline">// Conversion from APFloat to/from host float/double.  It may eventually be</td>
    <td class="lineNumber">3408</td>
    <td class="codeline">// Conversion from APFloat to/from host float/double.  It may eventually be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="codeline">// possible to eliminate these and have everybody deal with APFloats, but that</td>
    <td class="lineNumber">3409</td>
    <td class="codeline">// possible to eliminate these and have everybody deal with APFloats, but that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="codeline">// will take a while.  This approach will not easily extend to long double.</td>
    <td class="lineNumber">3410</td>
    <td class="codeline">// will take a while.  This approach will not easily extend to long double.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="codeline">// Current implementation requires integerPartWidth==64, which is correct at</td>
    <td class="lineNumber">3411</td>
    <td class="codeline">// Current implementation requires integerPartWidth==64, which is correct at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="codeline">// the moment but could be made more general.</td>
    <td class="lineNumber">3412</td>
    <td class="codeline">// the moment but could be made more general.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class="codeline"></td>
    <td class="lineNumber">3413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="codeline">// Denormals have exponent minExponent in APFloat, but minExponent-1 in</td>
    <td class="lineNumber">3414</td>
    <td class="codeline">// Denormals have exponent minExponent in APFloat, but minExponent-1 in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="codeline">// the actual IEEE respresentations.  We compensate for that here.</td>
    <td class="lineNumber">3415</td>
    <td class="codeline">// the actual IEEE respresentations.  We compensate for that here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="codeline"></td>
    <td class="lineNumber">3416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="codeline">APInt IEEEFloat::convertF80LongDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">3417</td>
    <td class="codeline">APInt IEEEFloat::convertF80LongDoubleAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended);</td>
    <td class="lineNumber">3418</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="codeline">  assert(partCount()==2);</td>
    <td class="lineNumber">3419</td>
    <td class="codeline">  assert(partCount()==2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="codeline"></td>
    <td class="lineNumber">3420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="codeline">  uint64_t myexponent, mysignificand;</td>
    <td class="lineNumber">3421</td>
    <td class="codeline">  uint64_t myexponent, mysignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class="codeline"></td>
    <td class="lineNumber">3422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">3423</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="codeline">    myexponent = exponent+16383; //bias</td>
    <td class="lineNumber">3424</td>
    <td class="codeline">    myexponent = exponent+16383; //bias</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="codeline">    mysignificand = significandParts()[0];</td>
    <td class="lineNumber">3425</td>
    <td class="codeline">    mysignificand = significandParts()[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="codeline">    if (myexponent==1 && !(mysignificand & 0x8000000000000000ULL))</td>
    <td class="lineNumber">3426</td>
    <td class="codeline">    if (myexponent==1 && !(mysignificand & 0x8000000000000000ULL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="codeline">      myexponent = 0;   // denormal</td>
    <td class="lineNumber">3427</td>
    <td class="codeline">      myexponent = 0;   // denormal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="codeline">  } else if (category==fcZero) {</td>
    <td class="lineNumber">3428</td>
    <td class="codeline">  } else if (category==fcZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="codeline">    myexponent = 0;</td>
    <td class="lineNumber">3429</td>
    <td class="codeline">    myexponent = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="codeline">    mysignificand = 0;</td>
    <td class="lineNumber">3430</td>
    <td class="codeline">    mysignificand = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="codeline">  } else if (category==fcInfinity) {</td>
    <td class="lineNumber">3431</td>
    <td class="codeline">  } else if (category==fcInfinity) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="codeline">    myexponent = 0x7fff;</td>
    <td class="lineNumber">3432</td>
    <td class="codeline">    myexponent = 0x7fff;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="codeline">    mysignificand = 0x8000000000000000ULL;</td>
    <td class="lineNumber">3433</td>
    <td class="codeline">    mysignificand = 0x8000000000000000ULL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3434</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="codeline">    assert(category == fcNaN && "Unknown category");</td>
    <td class="lineNumber">3435</td>
    <td class="codeline">    assert(category == fcNaN && "Unknown category");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="codeline">    myexponent = 0x7fff;</td>
    <td class="lineNumber">3436</td>
    <td class="codeline">    myexponent = 0x7fff;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="codeline">    mysignificand = significandParts()[0];</td>
    <td class="lineNumber">3437</td>
    <td class="codeline">    mysignificand = significandParts()[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3438</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class="codeline"></td>
    <td class="lineNumber">3439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="codeline">  uint64_t words[2];</td>
    <td class="lineNumber">3440</td>
    <td class="codeline">  uint64_t words[2];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="codeline">  words[0] = mysignificand;</td>
    <td class="lineNumber">3441</td>
    <td class="codeline">  words[0] = mysignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="codeline">  words[1] =  ((uint64_t)(sign & 1) << 15) |</td>
    <td class="lineNumber">3442</td>
    <td class="codeline">  words[1] =  ((uint64_t)(sign & 1) << 15) |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="codeline">              (myexponent & 0x7fffLL);</td>
    <td class="lineNumber">3443</td>
    <td class="codeline">              (myexponent & 0x7fffLL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="codeline">  return APInt(80, words);</td>
    <td class="lineNumber">3444</td>
    <td class="codeline">  return APInt(80, words);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3445</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class="codeline"></td>
    <td class="lineNumber">3446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="codeline">APInt IEEEFloat::convertPPCDoubleDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">3447</td>
    <td class="codeline">APInt IEEEFloat::convertPPCDoubleDoubleAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">3448</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="codeline">  assert(partCount()==2);</td>
    <td class="lineNumber">3449</td>
    <td class="codeline">  assert(partCount()==2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class="codeline"></td>
    <td class="lineNumber">3450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="codeline">  uint64_t words[2];</td>
    <td class="lineNumber">3451</td>
    <td class="codeline">  uint64_t words[2];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">3452</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class="codeline">  bool losesInfo;</td>
    <td class="lineNumber">3453</td>
    <td class="codeline">  bool losesInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="codeline"></td>
    <td class="lineNumber">3454</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="codeline">  // Convert number to double.  To avoid spurious underflows, we re-</td>
    <td class="lineNumber">3455</td>
    <td class="codeline">  // Convert number to double.  To avoid spurious underflows, we re-</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="codeline">  // normalize against the "double" minExponent first, and only *then*</td>
    <td class="lineNumber">3456</td>
    <td class="codeline">  // normalize against the "double" minExponent first, and only *then*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="codeline">  // truncate the mantissa.  The result of that second conversion</td>
    <td class="lineNumber">3457</td>
    <td class="codeline">  // truncate the mantissa.  The result of that second conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="codeline">  // may be inexact, but should never underflow.</td>
    <td class="lineNumber">3458</td>
    <td class="codeline">  // may be inexact, but should never underflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="codeline">  // Declare fltSemantics before APFloat that uses it (and</td>
    <td class="lineNumber">3459</td>
    <td class="codeline">  // Declare fltSemantics before APFloat that uses it (and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="codeline">  // saves pointer to it) to ensure correct destruction order.</td>
    <td class="lineNumber">3460</td>
    <td class="codeline">  // saves pointer to it) to ensure correct destruction order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="codeline">  fltSemantics extendedSemantics = *semantics;</td>
    <td class="lineNumber">3461</td>
    <td class="codeline">  fltSemantics extendedSemantics = *semantics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="codeline">  extendedSemantics.minExponent = semIEEEdouble.minExponent;</td>
    <td class="lineNumber">3462</td>
    <td class="codeline">  extendedSemantics.minExponent = semIEEEdouble.minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="codeline">  IEEEFloat extended(*this);</td>
    <td class="lineNumber">3463</td>
    <td class="codeline">  IEEEFloat extended(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="codeline">  fs = extended.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">3464</td>
    <td class="codeline">  fs = extended.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">3465</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="codeline">  (void)fs;</td>
    <td class="lineNumber">3466</td>
    <td class="codeline">  (void)fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="codeline"></td>
    <td class="lineNumber">3467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="codeline">  IEEEFloat u(extended);</td>
    <td class="lineNumber">3468</td>
    <td class="codeline">  IEEEFloat u(extended);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="codeline">  fs = u.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">3469</td>
    <td class="codeline">  fs = u.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="codeline">  assert(fs == opOK || fs == opInexact);</td>
    <td class="lineNumber">3470</td>
    <td class="codeline">  assert(fs == opOK || fs == opInexact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="codeline">  (void)fs;</td>
    <td class="lineNumber">3471</td>
    <td class="codeline">  (void)fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="codeline">  words[0] = *u.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td class="lineNumber">3472</td>
    <td class="codeline">  words[0] = *u.convertDoubleAPFloatToAPInt().getRawData();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="codeline"></td>
    <td class="lineNumber">3473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="codeline">  // If conversion was exact or resulted in a special case, we're done;</td>
    <td class="lineNumber">3474</td>
    <td class="codeline">  // If conversion was exact or resulted in a special case, we're done;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="codeline">  // just set the second double to zero.  Otherwise, re-convert back to</td>
    <td class="lineNumber">3475</td>
    <td class="codeline">  // just set the second double to zero.  Otherwise, re-convert back to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="codeline">  // the extended format and compute the difference.  This now should</td>
    <td class="lineNumber">3476</td>
    <td class="codeline">  // the extended format and compute the difference.  This now should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="codeline">  // convert exactly to double.</td>
    <td class="lineNumber">3477</td>
    <td class="codeline">  // convert exactly to double.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="codeline">  if (u.isFiniteNonZero() && losesInfo) {</td>
    <td class="lineNumber">3478</td>
    <td class="codeline">  if (u.isFiniteNonZero() && losesInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="codeline">    fs = u.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">3479</td>
    <td class="codeline">    fs = u.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="codeline">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">3480</td>
    <td class="codeline">    assert(fs == opOK && !losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="codeline">    (void)fs;</td>
    <td class="lineNumber">3481</td>
    <td class="codeline">    (void)fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="codeline"></td>
    <td class="lineNumber">3482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="codeline">    IEEEFloat v(extended);</td>
    <td class="lineNumber">3483</td>
    <td class="codeline">    IEEEFloat v(extended);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="codeline">    v.subtract(u, rmNearestTiesToEven);</td>
    <td class="lineNumber">3484</td>
    <td class="codeline">    v.subtract(u, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class="codeline">    fs = v.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">3485</td>
    <td class="codeline">    fs = v.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="codeline">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">3486</td>
    <td class="codeline">    assert(fs == opOK && !losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="codeline">    (void)fs;</td>
    <td class="lineNumber">3487</td>
    <td class="codeline">    (void)fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="codeline">    words[1] = *v.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td class="lineNumber">3488</td>
    <td class="codeline">    words[1] = *v.convertDoubleAPFloatToAPInt().getRawData();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3489</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="codeline">    words[1] = 0;</td>
    <td class="lineNumber">3490</td>
    <td class="codeline">    words[1] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3491</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="codeline"></td>
    <td class="lineNumber">3492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="codeline">  return APInt(128, words);</td>
    <td class="lineNumber">3493</td>
    <td class="codeline">  return APInt(128, words);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3494</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class="codeline"></td>
    <td class="lineNumber">3495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="codeline">template <const fltSemantics &S></td>
    <td class="lineNumber">3496</td>
    <td class="codeline">template <const fltSemantics &S></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="codeline">APInt IEEEFloat::convertIEEEFloatToAPInt() const {</td>
    <td class="lineNumber">3497</td>
    <td class="codeline">APInt IEEEFloat::convertIEEEFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="codeline">  assert(semantics == &S);</td>
    <td class="lineNumber">3498</td>
    <td class="codeline">  assert(semantics == &S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="codeline"></td>
    <td class="lineNumber">3499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="codeline">  constexpr int bias = -(S.minExponent - 1);</td>
    <td class="lineNumber">3500</td>
    <td class="codeline">  constexpr int bias = -(S.minExponent - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="codeline">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td class="lineNumber">3501</td>
    <td class="codeline">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="codeline">  constexpr int integer_bit_part = trailing_significand_bits / integerPartWidth;</td>
    <td class="lineNumber">3502</td>
    <td class="codeline">  constexpr int integer_bit_part = trailing_significand_bits / integerPartWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="codeline">  constexpr integerPart integer_bit =</td>
    <td class="lineNumber">3503</td>
    <td class="codeline">  constexpr integerPart integer_bit =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="codeline">      integerPart{1} << (trailing_significand_bits % integerPartWidth);</td>
    <td class="lineNumber">3504</td>
    <td class="codeline">      integerPart{1} << (trailing_significand_bits % integerPartWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="codeline">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td class="lineNumber">3505</td>
    <td class="codeline">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="codeline">  constexpr unsigned int exponent_bits =</td>
    <td class="lineNumber">3506</td>
    <td class="codeline">  constexpr unsigned int exponent_bits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="codeline">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td class="lineNumber">3507</td>
    <td class="codeline">      S.sizeInBits - 1 - trailing_significand_bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="codeline">  static_assert(exponent_bits < 64);</td>
    <td class="lineNumber">3508</td>
    <td class="codeline">  static_assert(exponent_bits < 64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="codeline">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td class="lineNumber">3509</td>
    <td class="codeline">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="codeline"></td>
    <td class="lineNumber">3510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="codeline">  uint64_t myexponent;</td>
    <td class="lineNumber">3511</td>
    <td class="codeline">  uint64_t myexponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="codeline">  std::array<integerPart, partCountForBits(trailing_significand_bits)></td>
    <td class="lineNumber">3512</td>
    <td class="codeline">  std::array<integerPart, partCountForBits(trailing_significand_bits)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="codeline">      mysignificand;</td>
    <td class="lineNumber">3513</td>
    <td class="codeline">      mysignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="codeline"></td>
    <td class="lineNumber">3514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">3515</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="codeline">    myexponent = exponent + bias;</td>
    <td class="lineNumber">3516</td>
    <td class="codeline">    myexponent = exponent + bias;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="codeline">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td class="lineNumber">3517</td>
    <td class="codeline">    std::copy_n(significandParts(), mysignificand.size(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="codeline">                mysignificand.begin());</td>
    <td class="lineNumber">3518</td>
    <td class="codeline">                mysignificand.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="codeline">    if (myexponent == 1 &&</td>
    <td class="lineNumber">3519</td>
    <td class="codeline">    if (myexponent == 1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="codeline">        !(significandParts()[integer_bit_part] & integer_bit))</td>
    <td class="lineNumber">3520</td>
    <td class="codeline">        !(significandParts()[integer_bit_part] & integer_bit))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="codeline">      myexponent = 0; // denormal</td>
    <td class="lineNumber">3521</td>
    <td class="codeline">      myexponent = 0; // denormal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="codeline">  } else if (category == fcZero) {</td>
    <td class="lineNumber">3522</td>
    <td class="codeline">  } else if (category == fcZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="codeline">    myexponent = ::exponentZero(S) + bias;</td>
    <td class="lineNumber">3523</td>
    <td class="codeline">    myexponent = ::exponentZero(S) + bias;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="codeline">    mysignificand.fill(0);</td>
    <td class="lineNumber">3524</td>
    <td class="codeline">    mysignificand.fill(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="codeline">  } else if (category == fcInfinity) {</td>
    <td class="lineNumber">3525</td>
    <td class="codeline">  } else if (category == fcInfinity) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class="codeline">    if (S.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">3526</td>
    <td class="codeline">    if (S.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="codeline">      llvm_unreachable("semantics don't support inf!");</td>
    <td class="lineNumber">3527</td>
    <td class="codeline">      llvm_unreachable("semantics don't support inf!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3528</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="codeline">    myexponent = ::exponentInf(S) + bias;</td>
    <td class="lineNumber">3529</td>
    <td class="codeline">    myexponent = ::exponentInf(S) + bias;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="codeline">    mysignificand.fill(0);</td>
    <td class="lineNumber">3530</td>
    <td class="codeline">    mysignificand.fill(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3531</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="codeline">    assert(category == fcNaN && "Unknown category!");</td>
    <td class="lineNumber">3532</td>
    <td class="codeline">    assert(category == fcNaN && "Unknown category!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="codeline">    myexponent = ::exponentNaN(S) + bias;</td>
    <td class="lineNumber">3533</td>
    <td class="codeline">    myexponent = ::exponentNaN(S) + bias;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="codeline">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td class="lineNumber">3534</td>
    <td class="codeline">    std::copy_n(significandParts(), mysignificand.size(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="codeline">                mysignificand.begin());</td>
    <td class="lineNumber">3535</td>
    <td class="codeline">                mysignificand.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3536</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="codeline">  std::array<uint64_t, (S.sizeInBits + 63) / 64> words;</td>
    <td class="lineNumber">3537</td>
    <td class="codeline">  std::array<uint64_t, (S.sizeInBits + 63) / 64> words;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="codeline">  auto words_iter =</td>
    <td class="lineNumber">3538</td>
    <td class="codeline">  auto words_iter =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="codeline">      std::copy_n(mysignificand.begin(), mysignificand.size(), words.begin());</td>
    <td class="lineNumber">3539</td>
    <td class="codeline">      std::copy_n(mysignificand.begin(), mysignificand.size(), words.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="codeline">  if constexpr (significand_mask != 0) {</td>
    <td class="lineNumber">3540</td>
    <td class="codeline">  if constexpr (significand_mask != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="codeline">    // Clear the integer bit.</td>
    <td class="lineNumber">3541</td>
    <td class="codeline">    // Clear the integer bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="codeline">    words[mysignificand.size() - 1] &= significand_mask;</td>
    <td class="lineNumber">3542</td>
    <td class="codeline">    words[mysignificand.size() - 1] &= significand_mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3543</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="codeline">  std::fill(words_iter, words.end(), uint64_t{0});</td>
    <td class="lineNumber">3544</td>
    <td class="codeline">  std::fill(words_iter, words.end(), uint64_t{0});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="codeline">  constexpr size_t last_word = words.size() - 1;</td>
    <td class="lineNumber">3545</td>
    <td class="codeline">  constexpr size_t last_word = words.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="codeline">  uint64_t shifted_sign = static_cast<uint64_t>(sign & 1)</td>
    <td class="lineNumber">3546</td>
    <td class="codeline">  uint64_t shifted_sign = static_cast<uint64_t>(sign & 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="codeline">                          << ((S.sizeInBits - 1) % 64);</td>
    <td class="lineNumber">3547</td>
    <td class="codeline">                          << ((S.sizeInBits - 1) % 64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="codeline">  words[last_word] |= shifted_sign;</td>
    <td class="lineNumber">3548</td>
    <td class="codeline">  words[last_word] |= shifted_sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="codeline">  uint64_t shifted_exponent = (myexponent & exponent_mask)</td>
    <td class="lineNumber">3549</td>
    <td class="codeline">  uint64_t shifted_exponent = (myexponent & exponent_mask)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="codeline">                              << (trailing_significand_bits % 64);</td>
    <td class="lineNumber">3550</td>
    <td class="codeline">                              << (trailing_significand_bits % 64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="codeline">  words[last_word] |= shifted_exponent;</td>
    <td class="lineNumber">3551</td>
    <td class="codeline">  words[last_word] |= shifted_exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="codeline">  if constexpr (last_word == 0) {</td>
    <td class="lineNumber">3552</td>
    <td class="codeline">  if constexpr (last_word == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="codeline">    return APInt(S.sizeInBits, words[0]);</td>
    <td class="lineNumber">3553</td>
    <td class="codeline">    return APInt(S.sizeInBits, words[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3554</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="codeline">  return APInt(S.sizeInBits, words);</td>
    <td class="lineNumber">3555</td>
    <td class="codeline">  return APInt(S.sizeInBits, words);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3556</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class="codeline"></td>
    <td class="lineNumber">3557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="codeline">APInt IEEEFloat::convertQuadrupleAPFloatToAPInt() const {</td>
    <td class="lineNumber">3558</td>
    <td class="codeline">APInt IEEEFloat::convertQuadrupleAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="codeline">  assert(partCount() == 2);</td>
    <td class="lineNumber">3559</td>
    <td class="codeline">  assert(partCount() == 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEquad>();</td>
    <td class="lineNumber">3560</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEquad>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3561</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class="codeline"></td>
    <td class="lineNumber">3562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="codeline">APInt IEEEFloat::convertDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">3563</td>
    <td class="codeline">APInt IEEEFloat::convertDoubleAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="codeline">  assert(partCount()==1);</td>
    <td class="lineNumber">3564</td>
    <td class="codeline">  assert(partCount()==1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEdouble>();</td>
    <td class="lineNumber">3565</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEdouble>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3566</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class="codeline"></td>
    <td class="lineNumber">3567</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="codeline">APInt IEEEFloat::convertFloatAPFloatToAPInt() const {</td>
    <td class="lineNumber">3568</td>
    <td class="codeline">APInt IEEEFloat::convertFloatAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="codeline">  assert(partCount()==1);</td>
    <td class="lineNumber">3569</td>
    <td class="codeline">  assert(partCount()==1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEsingle>();</td>
    <td class="lineNumber">3570</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEsingle>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3571</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class="codeline"></td>
    <td class="lineNumber">3572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="codeline">APInt IEEEFloat::convertBFloatAPFloatToAPInt() const {</td>
    <td class="lineNumber">3573</td>
    <td class="codeline">APInt IEEEFloat::convertBFloatAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="codeline">  assert(partCount() == 1);</td>
    <td class="lineNumber">3574</td>
    <td class="codeline">  assert(partCount() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semBFloat>();</td>
    <td class="lineNumber">3575</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semBFloat>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3576</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="codeline"></td>
    <td class="lineNumber">3577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="codeline">APInt IEEEFloat::convertHalfAPFloatToAPInt() const {</td>
    <td class="lineNumber">3578</td>
    <td class="codeline">APInt IEEEFloat::convertHalfAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="codeline">  assert(partCount()==1);</td>
    <td class="lineNumber">3579</td>
    <td class="codeline">  assert(partCount()==1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEhalf>();</td>
    <td class="lineNumber">3580</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semIEEEhalf>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3581</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="codeline"></td>
    <td class="lineNumber">3582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E5M2APFloatToAPInt() const {</td>
    <td class="lineNumber">3583</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E5M2APFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="codeline">  assert(partCount() == 1);</td>
    <td class="lineNumber">3584</td>
    <td class="codeline">  assert(partCount() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E5M2>();</td>
    <td class="lineNumber">3585</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E5M2>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3586</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class="codeline"></td>
    <td class="lineNumber">3587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E5M2FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">3588</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E5M2FNUZAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="codeline">  assert(partCount() == 1);</td>
    <td class="lineNumber">3589</td>
    <td class="codeline">  assert(partCount() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E5M2FNUZ>();</td>
    <td class="lineNumber">3590</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E5M2FNUZ>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3591</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class="codeline"></td>
    <td class="lineNumber">3592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E4M3FNAPFloatToAPInt() const {</td>
    <td class="lineNumber">3593</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E4M3FNAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="codeline">  assert(partCount() == 1);</td>
    <td class="lineNumber">3594</td>
    <td class="codeline">  assert(partCount() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E4M3FN>();</td>
    <td class="lineNumber">3595</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E4M3FN>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3596</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="codeline"></td>
    <td class="lineNumber">3597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E4M3FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">3598</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E4M3FNUZAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="codeline">  assert(partCount() == 1);</td>
    <td class="lineNumber">3599</td>
    <td class="codeline">  assert(partCount() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E4M3FNUZ>();</td>
    <td class="lineNumber">3600</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E4M3FNUZ>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3601</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class="codeline"></td>
    <td class="lineNumber">3602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E4M3B11FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">3603</td>
    <td class="codeline">APInt IEEEFloat::convertFloat8E4M3B11FNUZAPFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="codeline">  assert(partCount() == 1);</td>
    <td class="lineNumber">3604</td>
    <td class="codeline">  assert(partCount() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E4M3B11FNUZ>();</td>
    <td class="lineNumber">3605</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloat8E4M3B11FNUZ>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3606</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="codeline"></td>
    <td class="lineNumber">3607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="codeline">APInt IEEEFloat::convertFloatTF32APFloatToAPInt() const {</td>
    <td class="lineNumber">3608</td>
    <td class="codeline">APInt IEEEFloat::convertFloatTF32APFloatToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="codeline">  assert(partCount() == 1);</td>
    <td class="lineNumber">3609</td>
    <td class="codeline">  assert(partCount() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloatTF32>();</td>
    <td class="lineNumber">3610</td>
    <td class="codeline">  return convertIEEEFloatToAPInt<semFloatTF32>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3611</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="codeline"></td>
    <td class="lineNumber">3612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="codeline">// This function creates an APInt that is just a bit map of the floating</td>
    <td class="lineNumber">3613</td>
    <td class="codeline">// This function creates an APInt that is just a bit map of the floating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="codeline">// point constant as it would appear in memory.  It is not a conversion,</td>
    <td class="lineNumber">3614</td>
    <td class="codeline">// point constant as it would appear in memory.  It is not a conversion,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="codeline">// and treating the result as a normal integer is unlikely to be useful.</td>
    <td class="lineNumber">3615</td>
    <td class="codeline">// and treating the result as a normal integer is unlikely to be useful.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="codeline"></td>
    <td class="lineNumber">3616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="codeline">APInt IEEEFloat::bitcastToAPInt() const {</td>
    <td class="lineNumber">3617</td>
    <td class="codeline">APInt IEEEFloat::bitcastToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEhalf)</td>
    <td class="lineNumber">3618</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEhalf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="codeline">    return convertHalfAPFloatToAPInt();</td>
    <td class="lineNumber">3619</td>
    <td class="codeline">    return convertHalfAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class="codeline"></td>
    <td class="lineNumber">3620</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semBFloat)</td>
    <td class="lineNumber">3621</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semBFloat)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="codeline">    return convertBFloatAPFloatToAPInt();</td>
    <td class="lineNumber">3622</td>
    <td class="codeline">    return convertBFloatAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="codeline"></td>
    <td class="lineNumber">3623</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEsingle)</td>
    <td class="lineNumber">3624</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEsingle)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="codeline">    return convertFloatAPFloatToAPInt();</td>
    <td class="lineNumber">3625</td>
    <td class="codeline">    return convertFloatAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="codeline"></td>
    <td class="lineNumber">3626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEdouble)</td>
    <td class="lineNumber">3627</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEdouble)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="codeline">    return convertDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">3628</td>
    <td class="codeline">    return convertDoubleAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="codeline"></td>
    <td class="lineNumber">3629</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEquad)</td>
    <td class="lineNumber">3630</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics*)&semIEEEquad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="codeline">    return convertQuadrupleAPFloatToAPInt();</td>
    <td class="lineNumber">3631</td>
    <td class="codeline">    return convertQuadrupleAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="codeline"></td>
    <td class="lineNumber">3632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy)</td>
    <td class="lineNumber">3633</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="codeline">    return convertPPCDoubleDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">3634</td>
    <td class="codeline">    return convertPPCDoubleDoubleAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="codeline"></td>
    <td class="lineNumber">3635</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2)</td>
    <td class="lineNumber">3636</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="codeline">    return convertFloat8E5M2APFloatToAPInt();</td>
    <td class="lineNumber">3637</td>
    <td class="codeline">    return convertFloat8E5M2APFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="codeline"></td>
    <td class="lineNumber">3638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2FNUZ)</td>
    <td class="lineNumber">3639</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2FNUZ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="codeline">    return convertFloat8E5M2FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">3640</td>
    <td class="codeline">    return convertFloat8E5M2FNUZAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class="codeline"></td>
    <td class="lineNumber">3641</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FN)</td>
    <td class="lineNumber">3642</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="codeline">    return convertFloat8E4M3FNAPFloatToAPInt();</td>
    <td class="lineNumber">3643</td>
    <td class="codeline">    return convertFloat8E4M3FNAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="codeline"></td>
    <td class="lineNumber">3644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FNUZ)</td>
    <td class="lineNumber">3645</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FNUZ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="codeline">    return convertFloat8E4M3FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">3646</td>
    <td class="codeline">    return convertFloat8E4M3FNUZAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class="codeline"></td>
    <td class="lineNumber">3647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3B11FNUZ)</td>
    <td class="lineNumber">3648</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3B11FNUZ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="codeline">    return convertFloat8E4M3B11FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">3649</td>
    <td class="codeline">    return convertFloat8E4M3B11FNUZAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="codeline"></td>
    <td class="lineNumber">3650</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloatTF32)</td>
    <td class="lineNumber">3651</td>
    <td class="codeline">  if (semantics == (const llvm::fltSemantics *)&semFloatTF32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="codeline">    return convertFloatTF32APFloatToAPInt();</td>
    <td class="lineNumber">3652</td>
    <td class="codeline">    return convertFloatTF32APFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class="codeline"></td>
    <td class="lineNumber">3653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended &&</td>
    <td class="lineNumber">3654</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="codeline">         "unknown format!");</td>
    <td class="lineNumber">3655</td>
    <td class="codeline">         "unknown format!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="codeline">  return convertF80LongDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">3656</td>
    <td class="codeline">  return convertF80LongDoubleAPFloatToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3657</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="codeline"></td>
    <td class="lineNumber">3658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="codeline">float IEEEFloat::convertToFloat() const {</td>
    <td class="lineNumber">3659</td>
    <td class="codeline">float IEEEFloat::convertToFloat() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semIEEEsingle &&</td>
    <td class="lineNumber">3660</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semIEEEsingle &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="codeline">         "Float semantics are not IEEEsingle");</td>
    <td class="lineNumber">3661</td>
    <td class="codeline">         "Float semantics are not IEEEsingle");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="codeline">  APInt api = bitcastToAPInt();</td>
    <td class="lineNumber">3662</td>
    <td class="codeline">  APInt api = bitcastToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="codeline">  return api.bitsToFloat();</td>
    <td class="lineNumber">3663</td>
    <td class="codeline">  return api.bitsToFloat();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3664</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="codeline"></td>
    <td class="lineNumber">3665</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="codeline">double IEEEFloat::convertToDouble() const {</td>
    <td class="lineNumber">3666</td>
    <td class="codeline">double IEEEFloat::convertToDouble() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semIEEEdouble &&</td>
    <td class="lineNumber">3667</td>
    <td class="codeline">  assert(semantics == (const llvm::fltSemantics*)&semIEEEdouble &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="codeline">         "Float semantics are not IEEEdouble");</td>
    <td class="lineNumber">3668</td>
    <td class="codeline">         "Float semantics are not IEEEdouble");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="codeline">  APInt api = bitcastToAPInt();</td>
    <td class="lineNumber">3669</td>
    <td class="codeline">  APInt api = bitcastToAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="codeline">  return api.bitsToDouble();</td>
    <td class="lineNumber">3670</td>
    <td class="codeline">  return api.bitsToDouble();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3671</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="codeline"></td>
    <td class="lineNumber">3672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="codeline">/// Integer bit is explicit in this format.  Intel hardware (387 and later)</td>
    <td class="lineNumber">3673</td>
    <td class="codeline">/// Integer bit is explicit in this format.  Intel hardware (387 and later)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="codeline">/// does not support these bit patterns:</td>
    <td class="lineNumber">3674</td>
    <td class="codeline">/// does not support these bit patterns:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="codeline">///  exponent = all 1's, integer bit 0, significand 0 ("pseudoinfinity")</td>
    <td class="lineNumber">3675</td>
    <td class="codeline">///  exponent = all 1's, integer bit 0, significand 0 ("pseudoinfinity")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="codeline">///  exponent = all 1's, integer bit 0, significand nonzero ("pseudoNaN")</td>
    <td class="lineNumber">3676</td>
    <td class="codeline">///  exponent = all 1's, integer bit 0, significand nonzero ("pseudoNaN")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="codeline">///  exponent!=0 nor all 1's, integer bit 0 ("unnormal")</td>
    <td class="lineNumber">3677</td>
    <td class="codeline">///  exponent!=0 nor all 1's, integer bit 0 ("unnormal")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="codeline">///  exponent = 0, integer bit 1 ("pseudodenormal")</td>
    <td class="lineNumber">3678</td>
    <td class="codeline">///  exponent = 0, integer bit 1 ("pseudodenormal")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="codeline">/// At the moment, the first three are treated as NaNs, the last one as Normal.</td>
    <td class="lineNumber">3679</td>
    <td class="codeline">/// At the moment, the first three are treated as NaNs, the last one as Normal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="codeline">void IEEEFloat::initFromF80LongDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">3680</td>
    <td class="codeline">void IEEEFloat::initFromF80LongDoubleAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="codeline">  uint64_t i1 = api.getRawData()[0];</td>
    <td class="lineNumber">3681</td>
    <td class="codeline">  uint64_t i1 = api.getRawData()[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="codeline">  uint64_t i2 = api.getRawData()[1];</td>
    <td class="lineNumber">3682</td>
    <td class="codeline">  uint64_t i2 = api.getRawData()[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="codeline">  uint64_t myexponent = (i2 & 0x7fff);</td>
    <td class="lineNumber">3683</td>
    <td class="codeline">  uint64_t myexponent = (i2 & 0x7fff);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="codeline">  uint64_t mysignificand = i1;</td>
    <td class="lineNumber">3684</td>
    <td class="codeline">  uint64_t mysignificand = i1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="codeline">  uint8_t myintegerbit = mysignificand >> 63;</td>
    <td class="lineNumber">3685</td>
    <td class="codeline">  uint8_t myintegerbit = mysignificand >> 63;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="codeline"></td>
    <td class="lineNumber">3686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="codeline">  initialize(&semX87DoubleExtended);</td>
    <td class="lineNumber">3687</td>
    <td class="codeline">  initialize(&semX87DoubleExtended);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="codeline">  assert(partCount()==2);</td>
    <td class="lineNumber">3688</td>
    <td class="codeline">  assert(partCount()==2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="codeline"></td>
    <td class="lineNumber">3689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="codeline">  sign = static_cast<unsigned int>(i2>>15);</td>
    <td class="lineNumber">3690</td>
    <td class="codeline">  sign = static_cast<unsigned int>(i2>>15);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="codeline">  if (myexponent == 0 && mysignificand == 0) {</td>
    <td class="lineNumber">3691</td>
    <td class="codeline">  if (myexponent == 0 && mysignificand == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="codeline">    makeZero(sign);</td>
    <td class="lineNumber">3692</td>
    <td class="codeline">    makeZero(sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="codeline">  } else if (myexponent==0x7fff && mysignificand==0x8000000000000000ULL) {</td>
    <td class="lineNumber">3693</td>
    <td class="codeline">  } else if (myexponent==0x7fff && mysignificand==0x8000000000000000ULL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="codeline">    makeInf(sign);</td>
    <td class="lineNumber">3694</td>
    <td class="codeline">    makeInf(sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="codeline">  } else if ((myexponent == 0x7fff && mysignificand != 0x8000000000000000ULL) ||</td>
    <td class="lineNumber">3695</td>
    <td class="codeline">  } else if ((myexponent == 0x7fff && mysignificand != 0x8000000000000000ULL) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="codeline">             (myexponent != 0x7fff && myexponent != 0 && myintegerbit == 0)) {</td>
    <td class="lineNumber">3696</td>
    <td class="codeline">             (myexponent != 0x7fff && myexponent != 0 && myintegerbit == 0)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="codeline">    category = fcNaN;</td>
    <td class="lineNumber">3697</td>
    <td class="codeline">    category = fcNaN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="codeline">    exponent = exponentNaN();</td>
    <td class="lineNumber">3698</td>
    <td class="codeline">    exponent = exponentNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class="codeline">    significandParts()[0] = mysignificand;</td>
    <td class="lineNumber">3699</td>
    <td class="codeline">    significandParts()[0] = mysignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="codeline">    significandParts()[1] = 0;</td>
    <td class="lineNumber">3700</td>
    <td class="codeline">    significandParts()[1] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3701</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="codeline">    category = fcNormal;</td>
    <td class="lineNumber">3702</td>
    <td class="codeline">    category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="codeline">    exponent = myexponent - 16383;</td>
    <td class="lineNumber">3703</td>
    <td class="codeline">    exponent = myexponent - 16383;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="codeline">    significandParts()[0] = mysignificand;</td>
    <td class="lineNumber">3704</td>
    <td class="codeline">    significandParts()[0] = mysignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="codeline">    significandParts()[1] = 0;</td>
    <td class="lineNumber">3705</td>
    <td class="codeline">    significandParts()[1] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="codeline">    if (myexponent==0)          // denormal</td>
    <td class="lineNumber">3706</td>
    <td class="codeline">    if (myexponent==0)          // denormal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="codeline">      exponent = -16382;</td>
    <td class="lineNumber">3707</td>
    <td class="codeline">      exponent = -16382;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3708</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3709</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="codeline"></td>
    <td class="lineNumber">3710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="codeline">void IEEEFloat::initFromPPCDoubleDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">3711</td>
    <td class="codeline">void IEEEFloat::initFromPPCDoubleDoubleAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="codeline">  uint64_t i1 = api.getRawData()[0];</td>
    <td class="lineNumber">3712</td>
    <td class="codeline">  uint64_t i1 = api.getRawData()[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="codeline">  uint64_t i2 = api.getRawData()[1];</td>
    <td class="lineNumber">3713</td>
    <td class="codeline">  uint64_t i2 = api.getRawData()[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="codeline">  opStatus fs;</td>
    <td class="lineNumber">3714</td>
    <td class="codeline">  opStatus fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="codeline">  bool losesInfo;</td>
    <td class="lineNumber">3715</td>
    <td class="codeline">  bool losesInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="codeline"></td>
    <td class="lineNumber">3716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="codeline">  // Get the first double and convert to our format.</td>
    <td class="lineNumber">3717</td>
    <td class="codeline">  // Get the first double and convert to our format.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="codeline">  initFromDoubleAPInt(APInt(64, i1));</td>
    <td class="lineNumber">3718</td>
    <td class="codeline">  initFromDoubleAPInt(APInt(64, i1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="codeline">  fs = convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">3719</td>
    <td class="codeline">  fs = convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">3720</td>
    <td class="codeline">  assert(fs == opOK && !losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="codeline">  (void)fs;</td>
    <td class="lineNumber">3721</td>
    <td class="codeline">  (void)fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="codeline"></td>
    <td class="lineNumber">3722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="codeline">  // Unless we have a special case, add in second double.</td>
    <td class="lineNumber">3723</td>
    <td class="codeline">  // Unless we have a special case, add in second double.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">3724</td>
    <td class="codeline">  if (isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="codeline">    IEEEFloat v(semIEEEdouble, APInt(64, i2));</td>
    <td class="lineNumber">3725</td>
    <td class="codeline">    IEEEFloat v(semIEEEdouble, APInt(64, i2));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="codeline">    fs = v.convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">3726</td>
    <td class="codeline">    fs = v.convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="codeline">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">3727</td>
    <td class="codeline">    assert(fs == opOK && !losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="codeline">    (void)fs;</td>
    <td class="lineNumber">3728</td>
    <td class="codeline">    (void)fs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="codeline"></td>
    <td class="lineNumber">3729</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="codeline">    add(v, rmNearestTiesToEven);</td>
    <td class="lineNumber">3730</td>
    <td class="codeline">    add(v, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3731</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3732</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="codeline"></td>
    <td class="lineNumber">3733</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="codeline">template <const fltSemantics &S></td>
    <td class="lineNumber">3734</td>
    <td class="codeline">template <const fltSemantics &S></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="codeline">void IEEEFloat::initFromIEEEAPInt(const APInt &api) {</td>
    <td class="lineNumber">3735</td>
    <td class="codeline">void IEEEFloat::initFromIEEEAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="codeline">  assert(api.getBitWidth() == S.sizeInBits);</td>
    <td class="lineNumber">3736</td>
    <td class="codeline">  assert(api.getBitWidth() == S.sizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="codeline">  constexpr integerPart integer_bit = integerPart{1}</td>
    <td class="lineNumber">3737</td>
    <td class="codeline">  constexpr integerPart integer_bit = integerPart{1}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="codeline">                                      << ((S.precision - 1) % integerPartWidth);</td>
    <td class="lineNumber">3738</td>
    <td class="codeline">                                      << ((S.precision - 1) % integerPartWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="codeline">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td class="lineNumber">3739</td>
    <td class="codeline">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="codeline">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td class="lineNumber">3740</td>
    <td class="codeline">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="codeline">  constexpr unsigned int stored_significand_parts =</td>
    <td class="lineNumber">3741</td>
    <td class="codeline">  constexpr unsigned int stored_significand_parts =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="codeline">      partCountForBits(trailing_significand_bits);</td>
    <td class="lineNumber">3742</td>
    <td class="codeline">      partCountForBits(trailing_significand_bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="codeline">  constexpr unsigned int exponent_bits =</td>
    <td class="lineNumber">3743</td>
    <td class="codeline">  constexpr unsigned int exponent_bits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="codeline">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td class="lineNumber">3744</td>
    <td class="codeline">      S.sizeInBits - 1 - trailing_significand_bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="codeline">  static_assert(exponent_bits < 64);</td>
    <td class="lineNumber">3745</td>
    <td class="codeline">  static_assert(exponent_bits < 64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="codeline">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td class="lineNumber">3746</td>
    <td class="codeline">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="codeline">  constexpr int bias = -(S.minExponent - 1);</td>
    <td class="lineNumber">3747</td>
    <td class="codeline">  constexpr int bias = -(S.minExponent - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="codeline"></td>
    <td class="lineNumber">3748</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="codeline">  // Copy the bits of the significand. We need to clear out the exponent and</td>
    <td class="lineNumber">3749</td>
    <td class="codeline">  // Copy the bits of the significand. We need to clear out the exponent and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="codeline">  // sign bit in the last word.</td>
    <td class="lineNumber">3750</td>
    <td class="codeline">  // sign bit in the last word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="codeline">  std::array<integerPart, stored_significand_parts> mysignificand;</td>
    <td class="lineNumber">3751</td>
    <td class="codeline">  std::array<integerPart, stored_significand_parts> mysignificand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="codeline">  std::copy_n(api.getRawData(), mysignificand.size(), mysignificand.begin());</td>
    <td class="lineNumber">3752</td>
    <td class="codeline">  std::copy_n(api.getRawData(), mysignificand.size(), mysignificand.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="codeline">  if constexpr (significand_mask != 0) {</td>
    <td class="lineNumber">3753</td>
    <td class="codeline">  if constexpr (significand_mask != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="codeline">    mysignificand[mysignificand.size() - 1] &= significand_mask;</td>
    <td class="lineNumber">3754</td>
    <td class="codeline">    mysignificand[mysignificand.size() - 1] &= significand_mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3755</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="codeline"></td>
    <td class="lineNumber">3756</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="codeline">  // We assume the last word holds the sign bit, the exponent, and potentially</td>
    <td class="lineNumber">3757</td>
    <td class="codeline">  // We assume the last word holds the sign bit, the exponent, and potentially</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="codeline">  // some of the trailing significand field.</td>
    <td class="lineNumber">3758</td>
    <td class="codeline">  // some of the trailing significand field.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="codeline">  uint64_t last_word = api.getRawData()[api.getNumWords() - 1];</td>
    <td class="lineNumber">3759</td>
    <td class="codeline">  uint64_t last_word = api.getRawData()[api.getNumWords() - 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="codeline">  uint64_t myexponent =</td>
    <td class="lineNumber">3760</td>
    <td class="codeline">  uint64_t myexponent =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="codeline">      (last_word >> (trailing_significand_bits % 64)) & exponent_mask;</td>
    <td class="lineNumber">3761</td>
    <td class="codeline">      (last_word >> (trailing_significand_bits % 64)) & exponent_mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="codeline"></td>
    <td class="lineNumber">3762</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="codeline">  initialize(&S);</td>
    <td class="lineNumber">3763</td>
    <td class="codeline">  initialize(&S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="codeline">  assert(partCount() == mysignificand.size());</td>
    <td class="lineNumber">3764</td>
    <td class="codeline">  assert(partCount() == mysignificand.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class="codeline"></td>
    <td class="lineNumber">3765</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="codeline">  sign = static_cast<unsigned int>(last_word >> ((S.sizeInBits - 1) % 64));</td>
    <td class="lineNumber">3766</td>
    <td class="codeline">  sign = static_cast<unsigned int>(last_word >> ((S.sizeInBits - 1) % 64));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class="codeline"></td>
    <td class="lineNumber">3767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="codeline">  bool all_zero_significand =</td>
    <td class="lineNumber">3768</td>
    <td class="codeline">  bool all_zero_significand =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="codeline">      llvm::all_of(mysignificand, [](integerPart bits) { return bits == 0; });</td>
    <td class="lineNumber">3769</td>
    <td class="codeline">      llvm::all_of(mysignificand, [](integerPart bits) { return bits == 0; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class="codeline"></td>
    <td class="lineNumber">3770</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="codeline">  bool is_zero = myexponent == 0 && all_zero_significand;</td>
    <td class="lineNumber">3771</td>
    <td class="codeline">  bool is_zero = myexponent == 0 && all_zero_significand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class="codeline"></td>
    <td class="lineNumber">3772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="codeline">  if constexpr (S.nonFiniteBehavior == fltNonfiniteBehavior::IEEE754) {</td>
    <td class="lineNumber">3773</td>
    <td class="codeline">  if constexpr (S.nonFiniteBehavior == fltNonfiniteBehavior::IEEE754) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="codeline">    if (myexponent - bias == ::exponentInf(S) && all_zero_significand) {</td>
    <td class="lineNumber">3774</td>
    <td class="codeline">    if (myexponent - bias == ::exponentInf(S) && all_zero_significand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="codeline">      makeInf(sign);</td>
    <td class="lineNumber">3775</td>
    <td class="codeline">      makeInf(sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">3776</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3777</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3778</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="codeline"></td>
    <td class="lineNumber">3779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="codeline">  bool is_nan = false;</td>
    <td class="lineNumber">3780</td>
    <td class="codeline">  bool is_nan = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class="codeline"></td>
    <td class="lineNumber">3781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="codeline">  if constexpr (S.nanEncoding == fltNanEncoding::IEEE) {</td>
    <td class="lineNumber">3782</td>
    <td class="codeline">  if constexpr (S.nanEncoding == fltNanEncoding::IEEE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="codeline">    is_nan = myexponent - bias == ::exponentNaN(S) && !all_zero_significand;</td>
    <td class="lineNumber">3783</td>
    <td class="codeline">    is_nan = myexponent - bias == ::exponentNaN(S) && !all_zero_significand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="codeline">  } else if constexpr (S.nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td class="lineNumber">3784</td>
    <td class="codeline">  } else if constexpr (S.nanEncoding == fltNanEncoding::AllOnes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="codeline">    bool all_ones_significand =</td>
    <td class="lineNumber">3785</td>
    <td class="codeline">    bool all_ones_significand =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="codeline">        std::all_of(mysignificand.begin(), mysignificand.end() - 1,</td>
    <td class="lineNumber">3786</td>
    <td class="codeline">        std::all_of(mysignificand.begin(), mysignificand.end() - 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="codeline">                    [](integerPart bits) { return bits == ~integerPart{0}; }) &&</td>
    <td class="lineNumber">3787</td>
    <td class="codeline">                    [](integerPart bits) { return bits == ~integerPart{0}; }) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class="codeline">        (!significand_mask ||</td>
    <td class="lineNumber">3788</td>
    <td class="codeline">        (!significand_mask ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="codeline">         mysignificand[mysignificand.size() - 1] == significand_mask);</td>
    <td class="lineNumber">3789</td>
    <td class="codeline">         mysignificand[mysignificand.size() - 1] == significand_mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="codeline">    is_nan = myexponent - bias == ::exponentNaN(S) && all_ones_significand;</td>
    <td class="lineNumber">3790</td>
    <td class="codeline">    is_nan = myexponent - bias == ::exponentNaN(S) && all_ones_significand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="codeline">  } else if constexpr (S.nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">3791</td>
    <td class="codeline">  } else if constexpr (S.nanEncoding == fltNanEncoding::NegativeZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="codeline">    is_nan = is_zero && sign;</td>
    <td class="lineNumber">3792</td>
    <td class="codeline">    is_nan = is_zero && sign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3793</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="codeline"></td>
    <td class="lineNumber">3794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="codeline">  if (is_nan) {</td>
    <td class="lineNumber">3795</td>
    <td class="codeline">  if (is_nan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="codeline">    category = fcNaN;</td>
    <td class="lineNumber">3796</td>
    <td class="codeline">    category = fcNaN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="codeline">    exponent = ::exponentNaN(S);</td>
    <td class="lineNumber">3797</td>
    <td class="codeline">    exponent = ::exponentNaN(S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="codeline">    std::copy_n(mysignificand.begin(), mysignificand.size(),</td>
    <td class="lineNumber">3798</td>
    <td class="codeline">    std::copy_n(mysignificand.begin(), mysignificand.size(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="codeline">                significandParts());</td>
    <td class="lineNumber">3799</td>
    <td class="codeline">                significandParts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">3800</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3801</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="codeline"></td>
    <td class="lineNumber">3802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="codeline">  if (is_zero) {</td>
    <td class="lineNumber">3803</td>
    <td class="codeline">  if (is_zero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="codeline">    makeZero(sign);</td>
    <td class="lineNumber">3804</td>
    <td class="codeline">    makeZero(sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">3805</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3806</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="codeline"></td>
    <td class="lineNumber">3807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">3808</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="codeline">  exponent = myexponent - bias;</td>
    <td class="lineNumber">3809</td>
    <td class="codeline">  exponent = myexponent - bias;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="codeline">  std::copy_n(mysignificand.begin(), mysignificand.size(), significandParts());</td>
    <td class="lineNumber">3810</td>
    <td class="codeline">  std::copy_n(mysignificand.begin(), mysignificand.size(), significandParts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="codeline">  if (myexponent == 0) // denormal</td>
    <td class="lineNumber">3811</td>
    <td class="codeline">  if (myexponent == 0) // denormal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="codeline">    exponent = S.minExponent;</td>
    <td class="lineNumber">3812</td>
    <td class="codeline">    exponent = S.minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">3813</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="codeline">    significandParts()[mysignificand.size()-1] |= integer_bit; // integer bit</td>
    <td class="lineNumber">3814</td>
    <td class="codeline">    significandParts()[mysignificand.size()-1] |= integer_bit; // integer bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3815</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="codeline"></td>
    <td class="lineNumber">3816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="codeline">void IEEEFloat::initFromQuadrupleAPInt(const APInt &api) {</td>
    <td class="lineNumber">3817</td>
    <td class="codeline">void IEEEFloat::initFromQuadrupleAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEquad>(api);</td>
    <td class="lineNumber">3818</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEquad>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3819</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="codeline"></td>
    <td class="lineNumber">3820</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="codeline">void IEEEFloat::initFromDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">3821</td>
    <td class="codeline">void IEEEFloat::initFromDoubleAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEdouble>(api);</td>
    <td class="lineNumber">3822</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEdouble>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3823</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class="codeline"></td>
    <td class="lineNumber">3824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="codeline">void IEEEFloat::initFromFloatAPInt(const APInt &api) {</td>
    <td class="lineNumber">3825</td>
    <td class="codeline">void IEEEFloat::initFromFloatAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEsingle>(api);</td>
    <td class="lineNumber">3826</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEsingle>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3827</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="codeline"></td>
    <td class="lineNumber">3828</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="codeline">void IEEEFloat::initFromBFloatAPInt(const APInt &api) {</td>
    <td class="lineNumber">3829</td>
    <td class="codeline">void IEEEFloat::initFromBFloatAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="codeline">  initFromIEEEAPInt<semBFloat>(api);</td>
    <td class="lineNumber">3830</td>
    <td class="codeline">  initFromIEEEAPInt<semBFloat>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3831</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class="codeline"></td>
    <td class="lineNumber">3832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="codeline">void IEEEFloat::initFromHalfAPInt(const APInt &api) {</td>
    <td class="lineNumber">3833</td>
    <td class="codeline">void IEEEFloat::initFromHalfAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEhalf>(api);</td>
    <td class="lineNumber">3834</td>
    <td class="codeline">  initFromIEEEAPInt<semIEEEhalf>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3835</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="codeline"></td>
    <td class="lineNumber">3836</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E5M2APInt(const APInt &api) {</td>
    <td class="lineNumber">3837</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E5M2APInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E5M2>(api);</td>
    <td class="lineNumber">3838</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E5M2>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3839</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="codeline"></td>
    <td class="lineNumber">3840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E5M2FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">3841</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E5M2FNUZAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E5M2FNUZ>(api);</td>
    <td class="lineNumber">3842</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E5M2FNUZ>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3843</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="codeline"></td>
    <td class="lineNumber">3844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E4M3FNAPInt(const APInt &api) {</td>
    <td class="lineNumber">3845</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E4M3FNAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E4M3FN>(api);</td>
    <td class="lineNumber">3846</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E4M3FN>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3847</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="codeline"></td>
    <td class="lineNumber">3848</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E4M3FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">3849</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E4M3FNUZAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E4M3FNUZ>(api);</td>
    <td class="lineNumber">3850</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E4M3FNUZ>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3851</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="codeline"></td>
    <td class="lineNumber">3852</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E4M3B11FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">3853</td>
    <td class="codeline">void IEEEFloat::initFromFloat8E4M3B11FNUZAPInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E4M3B11FNUZ>(api);</td>
    <td class="lineNumber">3854</td>
    <td class="codeline">  initFromIEEEAPInt<semFloat8E4M3B11FNUZ>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3855</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="codeline"></td>
    <td class="lineNumber">3856</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="codeline">void IEEEFloat::initFromFloatTF32APInt(const APInt &api) {</td>
    <td class="lineNumber">3857</td>
    <td class="codeline">void IEEEFloat::initFromFloatTF32APInt(const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="codeline">  initFromIEEEAPInt<semFloatTF32>(api);</td>
    <td class="lineNumber">3858</td>
    <td class="codeline">  initFromIEEEAPInt<semFloatTF32>(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3859</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="codeline"></td>
    <td class="lineNumber">3860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="codeline">/// Treat api as containing the bits of a floating point number.</td>
    <td class="lineNumber">3861</td>
    <td class="codeline">/// Treat api as containing the bits of a floating point number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="codeline">void IEEEFloat::initFromAPInt(const fltSemantics *Sem, const APInt &api) {</td>
    <td class="lineNumber">3862</td>
    <td class="codeline">void IEEEFloat::initFromAPInt(const fltSemantics *Sem, const APInt &api) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="codeline">  assert(api.getBitWidth() == Sem->sizeInBits);</td>
    <td class="lineNumber">3863</td>
    <td class="codeline">  assert(api.getBitWidth() == Sem->sizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class="codeline">  if (Sem == &semIEEEhalf)</td>
    <td class="lineNumber">3864</td>
    <td class="codeline">  if (Sem == &semIEEEhalf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="codeline">    return initFromHalfAPInt(api);</td>
    <td class="lineNumber">3865</td>
    <td class="codeline">    return initFromHalfAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="codeline">  if (Sem == &semBFloat)</td>
    <td class="lineNumber">3866</td>
    <td class="codeline">  if (Sem == &semBFloat)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="codeline">    return initFromBFloatAPInt(api);</td>
    <td class="lineNumber">3867</td>
    <td class="codeline">    return initFromBFloatAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="codeline">  if (Sem == &semIEEEsingle)</td>
    <td class="lineNumber">3868</td>
    <td class="codeline">  if (Sem == &semIEEEsingle)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="codeline">    return initFromFloatAPInt(api);</td>
    <td class="lineNumber">3869</td>
    <td class="codeline">    return initFromFloatAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="codeline">  if (Sem == &semIEEEdouble)</td>
    <td class="lineNumber">3870</td>
    <td class="codeline">  if (Sem == &semIEEEdouble)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="codeline">    return initFromDoubleAPInt(api);</td>
    <td class="lineNumber">3871</td>
    <td class="codeline">    return initFromDoubleAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="codeline">  if (Sem == &semX87DoubleExtended)</td>
    <td class="lineNumber">3872</td>
    <td class="codeline">  if (Sem == &semX87DoubleExtended)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="codeline">    return initFromF80LongDoubleAPInt(api);</td>
    <td class="lineNumber">3873</td>
    <td class="codeline">    return initFromF80LongDoubleAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="codeline">  if (Sem == &semIEEEquad)</td>
    <td class="lineNumber">3874</td>
    <td class="codeline">  if (Sem == &semIEEEquad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="codeline">    return initFromQuadrupleAPInt(api);</td>
    <td class="lineNumber">3875</td>
    <td class="codeline">    return initFromQuadrupleAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="codeline">  if (Sem == &semPPCDoubleDoubleLegacy)</td>
    <td class="lineNumber">3876</td>
    <td class="codeline">  if (Sem == &semPPCDoubleDoubleLegacy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="codeline">    return initFromPPCDoubleDoubleAPInt(api);</td>
    <td class="lineNumber">3877</td>
    <td class="codeline">    return initFromPPCDoubleDoubleAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="codeline">  if (Sem == &semFloat8E5M2)</td>
    <td class="lineNumber">3878</td>
    <td class="codeline">  if (Sem == &semFloat8E5M2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="codeline">    return initFromFloat8E5M2APInt(api);</td>
    <td class="lineNumber">3879</td>
    <td class="codeline">    return initFromFloat8E5M2APInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="codeline">  if (Sem == &semFloat8E5M2FNUZ)</td>
    <td class="lineNumber">3880</td>
    <td class="codeline">  if (Sem == &semFloat8E5M2FNUZ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="codeline">    return initFromFloat8E5M2FNUZAPInt(api);</td>
    <td class="lineNumber">3881</td>
    <td class="codeline">    return initFromFloat8E5M2FNUZAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="codeline">  if (Sem == &semFloat8E4M3FN)</td>
    <td class="lineNumber">3882</td>
    <td class="codeline">  if (Sem == &semFloat8E4M3FN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="codeline">    return initFromFloat8E4M3FNAPInt(api);</td>
    <td class="lineNumber">3883</td>
    <td class="codeline">    return initFromFloat8E4M3FNAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="codeline">  if (Sem == &semFloat8E4M3FNUZ)</td>
    <td class="lineNumber">3884</td>
    <td class="codeline">  if (Sem == &semFloat8E4M3FNUZ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="codeline">    return initFromFloat8E4M3FNUZAPInt(api);</td>
    <td class="lineNumber">3885</td>
    <td class="codeline">    return initFromFloat8E4M3FNUZAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="codeline">  if (Sem == &semFloat8E4M3B11FNUZ)</td>
    <td class="lineNumber">3886</td>
    <td class="codeline">  if (Sem == &semFloat8E4M3B11FNUZ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="codeline">    return initFromFloat8E4M3B11FNUZAPInt(api);</td>
    <td class="lineNumber">3887</td>
    <td class="codeline">    return initFromFloat8E4M3B11FNUZAPInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="codeline">  if (Sem == &semFloatTF32)</td>
    <td class="lineNumber">3888</td>
    <td class="codeline">  if (Sem == &semFloatTF32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="codeline">    return initFromFloatTF32APInt(api);</td>
    <td class="lineNumber">3889</td>
    <td class="codeline">    return initFromFloatTF32APInt(api);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="codeline"></td>
    <td class="lineNumber">3890</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="codeline">  llvm_unreachable(nullptr);</td>
    <td class="lineNumber">3891</td>
    <td class="codeline">  llvm_unreachable(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3892</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="codeline"></td>
    <td class="lineNumber">3893</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="codeline">/// Make this number the largest magnitude normal number in the given</td>
    <td class="lineNumber">3894</td>
    <td class="codeline">/// Make this number the largest magnitude normal number in the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="codeline">/// semantics.</td>
    <td class="lineNumber">3895</td>
    <td class="codeline">/// semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="codeline">void IEEEFloat::makeLargest(bool Negative) {</td>
    <td class="lineNumber">3896</td>
    <td class="codeline">void IEEEFloat::makeLargest(bool Negative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="codeline">  // We want (in interchange format):</td>
    <td class="lineNumber">3897</td>
    <td class="codeline">  // We want (in interchange format):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="codeline">  //   sign = {Negative}</td>
    <td class="lineNumber">3898</td>
    <td class="codeline">  //   sign = {Negative}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="codeline">  //   exponent = 1..10</td>
    <td class="lineNumber">3899</td>
    <td class="codeline">  //   exponent = 1..10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="codeline">  //   significand = 1..1</td>
    <td class="lineNumber">3900</td>
    <td class="codeline">  //   significand = 1..1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">3901</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="codeline">  sign = Negative;</td>
    <td class="lineNumber">3902</td>
    <td class="codeline">  sign = Negative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="codeline">  exponent = semantics->maxExponent;</td>
    <td class="lineNumber">3903</td>
    <td class="codeline">  exponent = semantics->maxExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="codeline"></td>
    <td class="lineNumber">3904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="codeline">  // Use memset to set all but the highest integerPart to all ones.</td>
    <td class="lineNumber">3905</td>
    <td class="codeline">  // Use memset to set all but the highest integerPart to all ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="codeline">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">3906</td>
    <td class="codeline">  integerPart *significand = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="codeline">  unsigned PartCount = partCount();</td>
    <td class="lineNumber">3907</td>
    <td class="codeline">  unsigned PartCount = partCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="codeline">  memset(significand, 0xFF, sizeof(integerPart)*(PartCount - 1));</td>
    <td class="lineNumber">3908</td>
    <td class="codeline">  memset(significand, 0xFF, sizeof(integerPart)*(PartCount - 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="codeline"></td>
    <td class="lineNumber">3909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="codeline">  // Set the high integerPart especially setting all unused top bits for</td>
    <td class="lineNumber">3910</td>
    <td class="codeline">  // Set the high integerPart especially setting all unused top bits for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="codeline">  // internal consistency.</td>
    <td class="lineNumber">3911</td>
    <td class="codeline">  // internal consistency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="codeline">  const unsigned NumUnusedHighBits =</td>
    <td class="lineNumber">3912</td>
    <td class="codeline">  const unsigned NumUnusedHighBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="codeline">    PartCount*integerPartWidth - semantics->precision;</td>
    <td class="lineNumber">3913</td>
    <td class="codeline">    PartCount*integerPartWidth - semantics->precision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="codeline">  significand[PartCount - 1] = (NumUnusedHighBits < integerPartWidth)</td>
    <td class="lineNumber">3914</td>
    <td class="codeline">  significand[PartCount - 1] = (NumUnusedHighBits < integerPartWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="codeline">                                   ? (~integerPart(0) >> NumUnusedHighBits)</td>
    <td class="lineNumber">3915</td>
    <td class="codeline">                                   ? (~integerPart(0) >> NumUnusedHighBits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="codeline">                                   : 0;</td>
    <td class="lineNumber">3916</td>
    <td class="codeline">                                   : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="codeline"></td>
    <td class="lineNumber">3917</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">3918</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td class="lineNumber">3919</td>
    <td class="codeline">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="codeline">    significand[0] &= ~integerPart(1);</td>
    <td class="lineNumber">3920</td>
    <td class="codeline">    significand[0] &= ~integerPart(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3921</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class="codeline"></td>
    <td class="lineNumber">3922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="codeline">/// Make this number the smallest magnitude denormal number in the given</td>
    <td class="lineNumber">3923</td>
    <td class="codeline">/// Make this number the smallest magnitude denormal number in the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="codeline">/// semantics.</td>
    <td class="lineNumber">3924</td>
    <td class="codeline">/// semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="codeline">void IEEEFloat::makeSmallest(bool Negative) {</td>
    <td class="lineNumber">3925</td>
    <td class="codeline">void IEEEFloat::makeSmallest(bool Negative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="codeline">  // We want (in interchange format):</td>
    <td class="lineNumber">3926</td>
    <td class="codeline">  // We want (in interchange format):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="codeline">  //   sign = {Negative}</td>
    <td class="lineNumber">3927</td>
    <td class="codeline">  //   sign = {Negative}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="codeline">  //   exponent = 0..0</td>
    <td class="lineNumber">3928</td>
    <td class="codeline">  //   exponent = 0..0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="codeline">  //   significand = 0..01</td>
    <td class="lineNumber">3929</td>
    <td class="codeline">  //   significand = 0..01</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">3930</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="codeline">  sign = Negative;</td>
    <td class="lineNumber">3931</td>
    <td class="codeline">  sign = Negative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="codeline">  exponent = semantics->minExponent;</td>
    <td class="lineNumber">3932</td>
    <td class="codeline">  exponent = semantics->minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 1, partCount());</td>
    <td class="lineNumber">3933</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 1, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3934</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="codeline"></td>
    <td class="lineNumber">3935</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="codeline">void IEEEFloat::makeSmallestNormalized(bool Negative) {</td>
    <td class="lineNumber">3936</td>
    <td class="codeline">void IEEEFloat::makeSmallestNormalized(bool Negative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="codeline">  // We want (in interchange format):</td>
    <td class="lineNumber">3937</td>
    <td class="codeline">  // We want (in interchange format):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="codeline">  //   sign = {Negative}</td>
    <td class="lineNumber">3938</td>
    <td class="codeline">  //   sign = {Negative}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="codeline">  //   exponent = 0..0</td>
    <td class="lineNumber">3939</td>
    <td class="codeline">  //   exponent = 0..0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="codeline">  //   significand = 10..0</td>
    <td class="lineNumber">3940</td>
    <td class="codeline">  //   significand = 10..0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class="codeline"></td>
    <td class="lineNumber">3941</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="codeline">  category = fcNormal;</td>
    <td class="lineNumber">3942</td>
    <td class="codeline">  category = fcNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="codeline">  zeroSignificand();</td>
    <td class="lineNumber">3943</td>
    <td class="codeline">  zeroSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="codeline">  sign = Negative;</td>
    <td class="lineNumber">3944</td>
    <td class="codeline">  sign = Negative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="codeline">  exponent = semantics->minExponent;</td>
    <td class="lineNumber">3945</td>
    <td class="codeline">  exponent = semantics->minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="codeline">  APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td class="lineNumber">3946</td>
    <td class="codeline">  APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3947</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="codeline"></td>
    <td class="lineNumber">3948</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &Sem, const APInt &API) {</td>
    <td class="lineNumber">3949</td>
    <td class="codeline">IEEEFloat::IEEEFloat(const fltSemantics &Sem, const APInt &API) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="codeline">  initFromAPInt(&Sem, API);</td>
    <td class="lineNumber">3950</td>
    <td class="codeline">  initFromAPInt(&Sem, API);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3951</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class="codeline"></td>
    <td class="lineNumber">3952</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="codeline">IEEEFloat::IEEEFloat(float f) {</td>
    <td class="lineNumber">3953</td>
    <td class="codeline">IEEEFloat::IEEEFloat(float f) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="codeline">  initFromAPInt(&semIEEEsingle, APInt::floatToBits(f));</td>
    <td class="lineNumber">3954</td>
    <td class="codeline">  initFromAPInt(&semIEEEsingle, APInt::floatToBits(f));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3955</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="codeline"></td>
    <td class="lineNumber">3956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="codeline">IEEEFloat::IEEEFloat(double d) {</td>
    <td class="lineNumber">3957</td>
    <td class="codeline">IEEEFloat::IEEEFloat(double d) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="codeline">  initFromAPInt(&semIEEEdouble, APInt::doubleToBits(d));</td>
    <td class="lineNumber">3958</td>
    <td class="codeline">  initFromAPInt(&semIEEEdouble, APInt::doubleToBits(d));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3959</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class="codeline"></td>
    <td class="lineNumber">3960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">3961</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="codeline">  void append(SmallVectorImpl<char> &Buffer, StringRef Str) {</td>
    <td class="lineNumber">3962</td>
    <td class="codeline">  void append(SmallVectorImpl<char> &Buffer, StringRef Str) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="codeline">    Buffer.append(Str.begin(), Str.end());</td>
    <td class="lineNumber">3963</td>
    <td class="codeline">    Buffer.append(Str.begin(), Str.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3964</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class="codeline"></td>
    <td class="lineNumber">3965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="codeline">  /// Removes data from the given significand until it is no more</td>
    <td class="lineNumber">3966</td>
    <td class="codeline">  /// Removes data from the given significand until it is no more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class="codeline">  /// precise than is required for the desired precision.</td>
    <td class="lineNumber">3967</td>
    <td class="codeline">  /// precise than is required for the desired precision.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="codeline">  void AdjustToPrecision(APInt &significand,</td>
    <td class="lineNumber">3968</td>
    <td class="codeline">  void AdjustToPrecision(APInt &significand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="codeline">                         int &exp, unsigned FormatPrecision) {</td>
    <td class="lineNumber">3969</td>
    <td class="codeline">                         int &exp, unsigned FormatPrecision) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="codeline">    unsigned bits = significand.getActiveBits();</td>
    <td class="lineNumber">3970</td>
    <td class="codeline">    unsigned bits = significand.getActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="codeline"></td>
    <td class="lineNumber">3971</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="codeline">    // 196/59 is a very slight overestimate of lg_2(10).</td>
    <td class="lineNumber">3972</td>
    <td class="codeline">    // 196/59 is a very slight overestimate of lg_2(10).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="codeline">    unsigned bitsRequired = (FormatPrecision * 196 + 58) / 59;</td>
    <td class="lineNumber">3973</td>
    <td class="codeline">    unsigned bitsRequired = (FormatPrecision * 196 + 58) / 59;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="codeline"></td>
    <td class="lineNumber">3974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="codeline">    if (bits <= bitsRequired) return;</td>
    <td class="lineNumber">3975</td>
    <td class="codeline">    if (bits <= bitsRequired) return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class="codeline"></td>
    <td class="lineNumber">3976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="codeline">    unsigned tensRemovable = (bits - bitsRequired) * 59 / 196;</td>
    <td class="lineNumber">3977</td>
    <td class="codeline">    unsigned tensRemovable = (bits - bitsRequired) * 59 / 196;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="codeline">    if (!tensRemovable) return;</td>
    <td class="lineNumber">3978</td>
    <td class="codeline">    if (!tensRemovable) return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class="codeline"></td>
    <td class="lineNumber">3979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="codeline">    exp += tensRemovable;</td>
    <td class="lineNumber">3980</td>
    <td class="codeline">    exp += tensRemovable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="codeline"></td>
    <td class="lineNumber">3981</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="codeline">    APInt divisor(significand.getBitWidth(), 1);</td>
    <td class="lineNumber">3982</td>
    <td class="codeline">    APInt divisor(significand.getBitWidth(), 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="codeline">    APInt powten(significand.getBitWidth(), 10);</td>
    <td class="lineNumber">3983</td>
    <td class="codeline">    APInt powten(significand.getBitWidth(), 10);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="codeline">    while (true) {</td>
    <td class="lineNumber">3984</td>
    <td class="codeline">    while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="codeline">      if (tensRemovable & 1)</td>
    <td class="lineNumber">3985</td>
    <td class="codeline">      if (tensRemovable & 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="codeline">        divisor *= powten;</td>
    <td class="lineNumber">3986</td>
    <td class="codeline">        divisor *= powten;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="codeline">      tensRemovable >>= 1;</td>
    <td class="lineNumber">3987</td>
    <td class="codeline">      tensRemovable >>= 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="codeline">      if (!tensRemovable) break;</td>
    <td class="lineNumber">3988</td>
    <td class="codeline">      if (!tensRemovable) break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="codeline">      powten *= powten;</td>
    <td class="lineNumber">3989</td>
    <td class="codeline">      powten *= powten;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3990</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="codeline"></td>
    <td class="lineNumber">3991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="codeline">    significand = significand.udiv(divisor);</td>
    <td class="lineNumber">3992</td>
    <td class="codeline">    significand = significand.udiv(divisor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="codeline"></td>
    <td class="lineNumber">3993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="codeline">    // Truncate the significand down to its active bit count.</td>
    <td class="lineNumber">3994</td>
    <td class="codeline">    // Truncate the significand down to its active bit count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class="codeline">    significand = significand.trunc(significand.getActiveBits());</td>
    <td class="lineNumber">3995</td>
    <td class="codeline">    significand = significand.trunc(significand.getActiveBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3996</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="codeline"></td>
    <td class="lineNumber">3997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="codeline"></td>
    <td class="lineNumber">3998</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="codeline">  void AdjustToPrecision(SmallVectorImpl<char> &buffer,</td>
    <td class="lineNumber">3999</td>
    <td class="codeline">  void AdjustToPrecision(SmallVectorImpl<char> &buffer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="codeline">                         int &exp, unsigned FormatPrecision) {</td>
    <td class="lineNumber">4000</td>
    <td class="codeline">                         int &exp, unsigned FormatPrecision) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="codeline">    unsigned N = buffer.size();</td>
    <td class="lineNumber">4001</td>
    <td class="codeline">    unsigned N = buffer.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class="codeline">    if (N <= FormatPrecision) return;</td>
    <td class="lineNumber">4002</td>
    <td class="codeline">    if (N <= FormatPrecision) return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="codeline"></td>
    <td class="lineNumber">4003</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="codeline">    // The most significant figures are the last ones in the buffer.</td>
    <td class="lineNumber">4004</td>
    <td class="codeline">    // The most significant figures are the last ones in the buffer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="codeline">    unsigned FirstSignificant = N - FormatPrecision;</td>
    <td class="lineNumber">4005</td>
    <td class="codeline">    unsigned FirstSignificant = N - FormatPrecision;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="codeline"></td>
    <td class="lineNumber">4006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="codeline">    // Round.</td>
    <td class="lineNumber">4007</td>
    <td class="codeline">    // Round.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="codeline">    // FIXME: this probably shouldn't use 'round half up'.</td>
    <td class="lineNumber">4008</td>
    <td class="codeline">    // FIXME: this probably shouldn't use 'round half up'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class="codeline"></td>
    <td class="lineNumber">4009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="codeline">    // Rounding down is just a truncation, except we also want to drop</td>
    <td class="lineNumber">4010</td>
    <td class="codeline">    // Rounding down is just a truncation, except we also want to drop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="codeline">    // trailing zeros from the new result.</td>
    <td class="lineNumber">4011</td>
    <td class="codeline">    // trailing zeros from the new result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="codeline">    if (buffer[FirstSignificant - 1] < '5') {</td>
    <td class="lineNumber">4012</td>
    <td class="codeline">    if (buffer[FirstSignificant - 1] < '5') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class="codeline">      while (FirstSignificant < N && buffer[FirstSignificant] == '0')</td>
    <td class="lineNumber">4013</td>
    <td class="codeline">      while (FirstSignificant < N && buffer[FirstSignificant] == '0')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="codeline">        FirstSignificant++;</td>
    <td class="lineNumber">4014</td>
    <td class="codeline">        FirstSignificant++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="codeline"></td>
    <td class="lineNumber">4015</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="codeline">      exp += FirstSignificant;</td>
    <td class="lineNumber">4016</td>
    <td class="codeline">      exp += FirstSignificant;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="codeline">      buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td class="lineNumber">4017</td>
    <td class="codeline">      buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">4018</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4019</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class="codeline"></td>
    <td class="lineNumber">4020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="codeline">    // Rounding up requires a decimal add-with-carry.  If we continue</td>
    <td class="lineNumber">4021</td>
    <td class="codeline">    // Rounding up requires a decimal add-with-carry.  If we continue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="codeline">    // the carry, the newly-introduced zeros will just be truncated.</td>
    <td class="lineNumber">4022</td>
    <td class="codeline">    // the carry, the newly-introduced zeros will just be truncated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="codeline">    for (unsigned I = FirstSignificant; I != N; ++I) {</td>
    <td class="lineNumber">4023</td>
    <td class="codeline">    for (unsigned I = FirstSignificant; I != N; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="codeline">      if (buffer[I] == '9') {</td>
    <td class="lineNumber">4024</td>
    <td class="codeline">      if (buffer[I] == '9') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="codeline">        FirstSignificant++;</td>
    <td class="lineNumber">4025</td>
    <td class="codeline">        FirstSignificant++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">4026</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="codeline">        buffer[I]++;</td>
    <td class="lineNumber">4027</td>
    <td class="codeline">        buffer[I]++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">4028</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4029</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4030</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="codeline"></td>
    <td class="lineNumber">4031</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="codeline">    // If we carried through, we have exactly one digit of precision.</td>
    <td class="lineNumber">4032</td>
    <td class="codeline">    // If we carried through, we have exactly one digit of precision.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="codeline">    if (FirstSignificant == N) {</td>
    <td class="lineNumber">4033</td>
    <td class="codeline">    if (FirstSignificant == N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="codeline">      exp += FirstSignificant;</td>
    <td class="lineNumber">4034</td>
    <td class="codeline">      exp += FirstSignificant;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="codeline">      buffer.clear();</td>
    <td class="lineNumber">4035</td>
    <td class="codeline">      buffer.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="codeline">      buffer.push_back('1');</td>
    <td class="lineNumber">4036</td>
    <td class="codeline">      buffer.push_back('1');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">4037</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4038</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class="codeline"></td>
    <td class="lineNumber">4039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="codeline">    exp += FirstSignificant;</td>
    <td class="lineNumber">4040</td>
    <td class="codeline">    exp += FirstSignificant;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="codeline">    buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td class="lineNumber">4041</td>
    <td class="codeline">    buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4042</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">4043</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="codeline"></td>
    <td class="lineNumber">4044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="codeline">void IEEEFloat::toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,</td>
    <td class="lineNumber">4045</td>
    <td class="codeline">void IEEEFloat::toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="codeline">                         unsigned FormatMaxPadding, bool TruncateZero) const {</td>
    <td class="lineNumber">4046</td>
    <td class="codeline">                         unsigned FormatMaxPadding, bool TruncateZero) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="codeline">  switch (category) {</td>
    <td class="lineNumber">4047</td>
    <td class="codeline">  switch (category) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="codeline">  case fcInfinity:</td>
    <td class="lineNumber">4048</td>
    <td class="codeline">  case fcInfinity:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="codeline">    if (isNegative())</td>
    <td class="lineNumber">4049</td>
    <td class="codeline">    if (isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="codeline">      return append(Str, "-Inf");</td>
    <td class="lineNumber">4050</td>
    <td class="codeline">      return append(Str, "-Inf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">4051</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="codeline">      return append(Str, "+Inf");</td>
    <td class="lineNumber">4052</td>
    <td class="codeline">      return append(Str, "+Inf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="codeline"></td>
    <td class="lineNumber">4053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="codeline">  case fcNaN: return append(Str, "NaN");</td>
    <td class="lineNumber">4054</td>
    <td class="codeline">  case fcNaN: return append(Str, "NaN");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class="codeline"></td>
    <td class="lineNumber">4055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="codeline">  case fcZero:</td>
    <td class="lineNumber">4056</td>
    <td class="codeline">  case fcZero:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="codeline">    if (isNegative())</td>
    <td class="lineNumber">4057</td>
    <td class="codeline">    if (isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="codeline">      Str.push_back('-');</td>
    <td class="lineNumber">4058</td>
    <td class="codeline">      Str.push_back('-');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="codeline"></td>
    <td class="lineNumber">4059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="codeline">    if (!FormatMaxPadding) {</td>
    <td class="lineNumber">4060</td>
    <td class="codeline">    if (!FormatMaxPadding) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="codeline">      if (TruncateZero)</td>
    <td class="lineNumber">4061</td>
    <td class="codeline">      if (TruncateZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="codeline">        append(Str, "0.0E+0");</td>
    <td class="lineNumber">4062</td>
    <td class="codeline">        append(Str, "0.0E+0");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="codeline">      else {</td>
    <td class="lineNumber">4063</td>
    <td class="codeline">      else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="codeline">        append(Str, "0.0");</td>
    <td class="lineNumber">4064</td>
    <td class="codeline">        append(Str, "0.0");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="codeline">        if (FormatPrecision > 1)</td>
    <td class="lineNumber">4065</td>
    <td class="codeline">        if (FormatPrecision > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="codeline">          Str.append(FormatPrecision - 1, '0');</td>
    <td class="lineNumber">4066</td>
    <td class="codeline">          Str.append(FormatPrecision - 1, '0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="codeline">        append(Str, "e+00");</td>
    <td class="lineNumber">4067</td>
    <td class="codeline">        append(Str, "e+00");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4068</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">4069</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="codeline">      Str.push_back('0');</td>
    <td class="lineNumber">4070</td>
    <td class="codeline">      Str.push_back('0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">4071</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="codeline"></td>
    <td class="lineNumber">4072</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="codeline">  case fcNormal:</td>
    <td class="lineNumber">4073</td>
    <td class="codeline">  case fcNormal:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">4074</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4075</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="codeline"></td>
    <td class="lineNumber">4076</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="codeline">  if (isNegative())</td>
    <td class="lineNumber">4077</td>
    <td class="codeline">  if (isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="codeline">    Str.push_back('-');</td>
    <td class="lineNumber">4078</td>
    <td class="codeline">    Str.push_back('-');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="codeline"></td>
    <td class="lineNumber">4079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="codeline">  // Decompose the number into an APInt and an exponent.</td>
    <td class="lineNumber">4080</td>
    <td class="codeline">  // Decompose the number into an APInt and an exponent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="codeline">  int exp = exponent - ((int) semantics->precision - 1);</td>
    <td class="lineNumber">4081</td>
    <td class="codeline">  int exp = exponent - ((int) semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="codeline">  APInt significand(</td>
    <td class="lineNumber">4082</td>
    <td class="codeline">  APInt significand(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="codeline">      semantics->precision,</td>
    <td class="lineNumber">4083</td>
    <td class="codeline">      semantics->precision,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="codeline">      ArrayRef(significandParts(), partCountForBits(semantics->precision)));</td>
    <td class="lineNumber">4084</td>
    <td class="codeline">      ArrayRef(significandParts(), partCountForBits(semantics->precision)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="codeline"></td>
    <td class="lineNumber">4085</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="codeline">  // Set FormatPrecision if zero.  We want to do this before we</td>
    <td class="lineNumber">4086</td>
    <td class="codeline">  // Set FormatPrecision if zero.  We want to do this before we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="codeline">  // truncate trailing zeros, as those are part of the precision.</td>
    <td class="lineNumber">4087</td>
    <td class="codeline">  // truncate trailing zeros, as those are part of the precision.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="codeline">  if (!FormatPrecision) {</td>
    <td class="lineNumber">4088</td>
    <td class="codeline">  if (!FormatPrecision) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="codeline">    // We use enough digits so the number can be round-tripped back to an</td>
    <td class="lineNumber">4089</td>
    <td class="codeline">    // We use enough digits so the number can be round-tripped back to an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="codeline">    // APFloat. The formula comes from "How to Print Floating-Point Numbers</td>
    <td class="lineNumber">4090</td>
    <td class="codeline">    // APFloat. The formula comes from "How to Print Floating-Point Numbers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="codeline">    // Accurately" by Steele and White.</td>
    <td class="lineNumber">4091</td>
    <td class="codeline">    // Accurately" by Steele and White.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="codeline">    // FIXME: Using a formula based purely on the precision is conservative;</td>
    <td class="lineNumber">4092</td>
    <td class="codeline">    // FIXME: Using a formula based purely on the precision is conservative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="codeline">    // we can print fewer digits depending on the actual value being printed.</td>
    <td class="lineNumber">4093</td>
    <td class="codeline">    // we can print fewer digits depending on the actual value being printed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="codeline"></td>
    <td class="lineNumber">4094</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="codeline">    // FormatPrecision = 2 + floor(significandBits / lg_2(10))</td>
    <td class="lineNumber">4095</td>
    <td class="codeline">    // FormatPrecision = 2 + floor(significandBits / lg_2(10))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="codeline">    FormatPrecision = 2 + semantics->precision * 59 / 196;</td>
    <td class="lineNumber">4096</td>
    <td class="codeline">    FormatPrecision = 2 + semantics->precision * 59 / 196;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4097</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="codeline"></td>
    <td class="lineNumber">4098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="codeline">  // Ignore trailing binary zeros.</td>
    <td class="lineNumber">4099</td>
    <td class="codeline">  // Ignore trailing binary zeros.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="codeline">  int trailingZeros = significand.countr_zero();</td>
    <td class="lineNumber">4100</td>
    <td class="codeline">  int trailingZeros = significand.countr_zero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="codeline">  exp += trailingZeros;</td>
    <td class="lineNumber">4101</td>
    <td class="codeline">  exp += trailingZeros;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="codeline">  significand.lshrInPlace(trailingZeros);</td>
    <td class="lineNumber">4102</td>
    <td class="codeline">  significand.lshrInPlace(trailingZeros);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class="codeline"></td>
    <td class="lineNumber">4103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="codeline">  // Change the exponent from 2^e to 10^e.</td>
    <td class="lineNumber">4104</td>
    <td class="codeline">  // Change the exponent from 2^e to 10^e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="codeline">  if (exp == 0) {</td>
    <td class="lineNumber">4105</td>
    <td class="codeline">  if (exp == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="codeline">    // Nothing to do.</td>
    <td class="lineNumber">4106</td>
    <td class="codeline">    // Nothing to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="codeline">  } else if (exp > 0) {</td>
    <td class="lineNumber">4107</td>
    <td class="codeline">  } else if (exp > 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="codeline">    // Just shift left.</td>
    <td class="lineNumber">4108</td>
    <td class="codeline">    // Just shift left.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="codeline">    significand = significand.zext(semantics->precision + exp);</td>
    <td class="lineNumber">4109</td>
    <td class="codeline">    significand = significand.zext(semantics->precision + exp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="codeline">    significand <<= exp;</td>
    <td class="lineNumber">4110</td>
    <td class="codeline">    significand <<= exp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="codeline">    exp = 0;</td>
    <td class="lineNumber">4111</td>
    <td class="codeline">    exp = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="codeline">  } else { /* exp < 0 */</td>
    <td class="lineNumber">4112</td>
    <td class="codeline">  } else { /* exp < 0 */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="codeline">    int texp = -exp;</td>
    <td class="lineNumber">4113</td>
    <td class="codeline">    int texp = -exp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="codeline"></td>
    <td class="lineNumber">4114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="codeline">    // We transform this using the identity:</td>
    <td class="lineNumber">4115</td>
    <td class="codeline">    // We transform this using the identity:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="codeline">    //   (N)(2^-e) == (N)(5^e)(10^-e)</td>
    <td class="lineNumber">4116</td>
    <td class="codeline">    //   (N)(2^-e) == (N)(5^e)(10^-e)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="codeline">    // This means we have to multiply N (the significand) by 5^e.</td>
    <td class="lineNumber">4117</td>
    <td class="codeline">    // This means we have to multiply N (the significand) by 5^e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="codeline">    // To avoid overflow, we have to operate on numbers large</td>
    <td class="lineNumber">4118</td>
    <td class="codeline">    // To avoid overflow, we have to operate on numbers large</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="codeline">    // enough to store N * 5^e:</td>
    <td class="lineNumber">4119</td>
    <td class="codeline">    // enough to store N * 5^e:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="codeline">    //   log2(N * 5^e) == log2(N) + e * log2(5)</td>
    <td class="lineNumber">4120</td>
    <td class="codeline">    //   log2(N * 5^e) == log2(N) + e * log2(5)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="codeline">    //                 <= semantics->precision + e * 137 / 59</td>
    <td class="lineNumber">4121</td>
    <td class="codeline">    //                 <= semantics->precision + e * 137 / 59</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="codeline">    //   (log_2(5) ~ 2.321928 < 2.322034 ~ 137/59)</td>
    <td class="lineNumber">4122</td>
    <td class="codeline">    //   (log_2(5) ~ 2.321928 < 2.322034 ~ 137/59)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="codeline"></td>
    <td class="lineNumber">4123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="codeline">    unsigned precision = semantics->precision + (137 * texp + 136) / 59;</td>
    <td class="lineNumber">4124</td>
    <td class="codeline">    unsigned precision = semantics->precision + (137 * texp + 136) / 59;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="codeline"></td>
    <td class="lineNumber">4125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="codeline">    // Multiply significand by 5^e.</td>
    <td class="lineNumber">4126</td>
    <td class="codeline">    // Multiply significand by 5^e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="codeline">    //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)</td>
    <td class="lineNumber">4127</td>
    <td class="codeline">    //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="codeline">    significand = significand.zext(precision);</td>
    <td class="lineNumber">4128</td>
    <td class="codeline">    significand = significand.zext(precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="codeline">    APInt five_to_the_i(precision, 5);</td>
    <td class="lineNumber">4129</td>
    <td class="codeline">    APInt five_to_the_i(precision, 5);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="codeline">    while (true) {</td>
    <td class="lineNumber">4130</td>
    <td class="codeline">    while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="codeline">      if (texp & 1) significand *= five_to_the_i;</td>
    <td class="lineNumber">4131</td>
    <td class="codeline">      if (texp & 1) significand *= five_to_the_i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class="codeline"></td>
    <td class="lineNumber">4132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="codeline">      texp >>= 1;</td>
    <td class="lineNumber">4133</td>
    <td class="codeline">      texp >>= 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="codeline">      if (!texp) break;</td>
    <td class="lineNumber">4134</td>
    <td class="codeline">      if (!texp) break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="codeline">      five_to_the_i *= five_to_the_i;</td>
    <td class="lineNumber">4135</td>
    <td class="codeline">      five_to_the_i *= five_to_the_i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4136</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4137</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="codeline"></td>
    <td class="lineNumber">4138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="codeline">  AdjustToPrecision(significand, exp, FormatPrecision);</td>
    <td class="lineNumber">4139</td>
    <td class="codeline">  AdjustToPrecision(significand, exp, FormatPrecision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="codeline"></td>
    <td class="lineNumber">4140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="codeline">  SmallVector<char, 256> buffer;</td>
    <td class="lineNumber">4141</td>
    <td class="codeline">  SmallVector<char, 256> buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="codeline"></td>
    <td class="lineNumber">4142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="codeline">  // Fill the buffer.</td>
    <td class="lineNumber">4143</td>
    <td class="codeline">  // Fill the buffer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="codeline">  unsigned precision = significand.getBitWidth();</td>
    <td class="lineNumber">4144</td>
    <td class="codeline">  unsigned precision = significand.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="codeline">  if (precision < 4) {</td>
    <td class="lineNumber">4145</td>
    <td class="codeline">  if (precision < 4) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="codeline">    // We need enough precision to store the value 10.</td>
    <td class="lineNumber">4146</td>
    <td class="codeline">    // We need enough precision to store the value 10.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="codeline">    precision = 4;</td>
    <td class="lineNumber">4147</td>
    <td class="codeline">    precision = 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="codeline">    significand = significand.zext(precision);</td>
    <td class="lineNumber">4148</td>
    <td class="codeline">    significand = significand.zext(precision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4149</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="codeline">  APInt ten(precision, 10);</td>
    <td class="lineNumber">4150</td>
    <td class="codeline">  APInt ten(precision, 10);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="codeline">  APInt digit(precision, 0);</td>
    <td class="lineNumber">4151</td>
    <td class="codeline">  APInt digit(precision, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="codeline"></td>
    <td class="lineNumber">4152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="codeline">  bool inTrail = true;</td>
    <td class="lineNumber">4153</td>
    <td class="codeline">  bool inTrail = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="codeline">  while (significand != 0) {</td>
    <td class="lineNumber">4154</td>
    <td class="codeline">  while (significand != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="codeline">    // digit <- significand % 10</td>
    <td class="lineNumber">4155</td>
    <td class="codeline">    // digit <- significand % 10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="codeline">    // significand <- significand / 10</td>
    <td class="lineNumber">4156</td>
    <td class="codeline">    // significand <- significand / 10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="codeline">    APInt::udivrem(significand, ten, significand, digit);</td>
    <td class="lineNumber">4157</td>
    <td class="codeline">    APInt::udivrem(significand, ten, significand, digit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="codeline"></td>
    <td class="lineNumber">4158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="codeline">    unsigned d = digit.getZExtValue();</td>
    <td class="lineNumber">4159</td>
    <td class="codeline">    unsigned d = digit.getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class="codeline"></td>
    <td class="lineNumber">4160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="codeline">    // Drop trailing zeros.</td>
    <td class="lineNumber">4161</td>
    <td class="codeline">    // Drop trailing zeros.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="codeline">    if (inTrail && !d) exp++;</td>
    <td class="lineNumber">4162</td>
    <td class="codeline">    if (inTrail && !d) exp++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="codeline">    else {</td>
    <td class="lineNumber">4163</td>
    <td class="codeline">    else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="codeline">      buffer.push_back((char) ('0' + d));</td>
    <td class="lineNumber">4164</td>
    <td class="codeline">      buffer.push_back((char) ('0' + d));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="codeline">      inTrail = false;</td>
    <td class="lineNumber">4165</td>
    <td class="codeline">      inTrail = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4166</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4167</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class="codeline"></td>
    <td class="lineNumber">4168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="codeline">  assert(!buffer.empty() && "no characters in buffer!");</td>
    <td class="lineNumber">4169</td>
    <td class="codeline">  assert(!buffer.empty() && "no characters in buffer!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="codeline"></td>
    <td class="lineNumber">4170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="codeline">  // Drop down to FormatPrecision.</td>
    <td class="lineNumber">4171</td>
    <td class="codeline">  // Drop down to FormatPrecision.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="codeline">  // TODO: don't do more precise calculations above than are required.</td>
    <td class="lineNumber">4172</td>
    <td class="codeline">  // TODO: don't do more precise calculations above than are required.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="codeline">  AdjustToPrecision(buffer, exp, FormatPrecision);</td>
    <td class="lineNumber">4173</td>
    <td class="codeline">  AdjustToPrecision(buffer, exp, FormatPrecision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="codeline"></td>
    <td class="lineNumber">4174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="codeline">  unsigned NDigits = buffer.size();</td>
    <td class="lineNumber">4175</td>
    <td class="codeline">  unsigned NDigits = buffer.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="codeline"></td>
    <td class="lineNumber">4176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="codeline">  // Check whether we should use scientific notation.</td>
    <td class="lineNumber">4177</td>
    <td class="codeline">  // Check whether we should use scientific notation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="codeline">  bool FormatScientific;</td>
    <td class="lineNumber">4178</td>
    <td class="codeline">  bool FormatScientific;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="codeline">  if (!FormatMaxPadding)</td>
    <td class="lineNumber">4179</td>
    <td class="codeline">  if (!FormatMaxPadding)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="codeline">    FormatScientific = true;</td>
    <td class="lineNumber">4180</td>
    <td class="codeline">    FormatScientific = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">4181</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="codeline">    if (exp >= 0) {</td>
    <td class="lineNumber">4182</td>
    <td class="codeline">    if (exp >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="codeline">      // 765e3 --> 765000</td>
    <td class="lineNumber">4183</td>
    <td class="codeline">      // 765e3 --> 765000</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="codeline">      //              ^^^</td>
    <td class="lineNumber">4184</td>
    <td class="codeline">      //              ^^^</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="codeline">      // But we shouldn't make the number look more precise than it is.</td>
    <td class="lineNumber">4185</td>
    <td class="codeline">      // But we shouldn't make the number look more precise than it is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="codeline">      FormatScientific = ((unsigned) exp > FormatMaxPadding ||</td>
    <td class="lineNumber">4186</td>
    <td class="codeline">      FormatScientific = ((unsigned) exp > FormatMaxPadding ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="codeline">                          NDigits + (unsigned) exp > FormatPrecision);</td>
    <td class="lineNumber">4187</td>
    <td class="codeline">                          NDigits + (unsigned) exp > FormatPrecision);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">4188</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="codeline">      // Power of the most significant digit.</td>
    <td class="lineNumber">4189</td>
    <td class="codeline">      // Power of the most significant digit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="codeline">      int MSD = exp + (int) (NDigits - 1);</td>
    <td class="lineNumber">4190</td>
    <td class="codeline">      int MSD = exp + (int) (NDigits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="codeline">      if (MSD >= 0) {</td>
    <td class="lineNumber">4191</td>
    <td class="codeline">      if (MSD >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="codeline">        // 765e-2 == 7.65</td>
    <td class="lineNumber">4192</td>
    <td class="codeline">        // 765e-2 == 7.65</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="codeline">        FormatScientific = false;</td>
    <td class="lineNumber">4193</td>
    <td class="codeline">        FormatScientific = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">4194</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="codeline">        // 765e-5 == 0.00765</td>
    <td class="lineNumber">4195</td>
    <td class="codeline">        // 765e-5 == 0.00765</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="codeline">        //           ^ ^^</td>
    <td class="lineNumber">4196</td>
    <td class="codeline">        //           ^ ^^</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="codeline">        FormatScientific = ((unsigned) -MSD) > FormatMaxPadding;</td>
    <td class="lineNumber">4197</td>
    <td class="codeline">        FormatScientific = ((unsigned) -MSD) > FormatMaxPadding;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4198</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4199</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4200</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="codeline"></td>
    <td class="lineNumber">4201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="codeline">  // Scientific formatting is pretty straightforward.</td>
    <td class="lineNumber">4202</td>
    <td class="codeline">  // Scientific formatting is pretty straightforward.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="codeline">  if (FormatScientific) {</td>
    <td class="lineNumber">4203</td>
    <td class="codeline">  if (FormatScientific) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="codeline">    exp += (NDigits - 1);</td>
    <td class="lineNumber">4204</td>
    <td class="codeline">    exp += (NDigits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="codeline"></td>
    <td class="lineNumber">4205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="codeline">    Str.push_back(buffer[NDigits-1]);</td>
    <td class="lineNumber">4206</td>
    <td class="codeline">    Str.push_back(buffer[NDigits-1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="codeline">    Str.push_back('.');</td>
    <td class="lineNumber">4207</td>
    <td class="codeline">    Str.push_back('.');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="codeline">    if (NDigits == 1 && TruncateZero)</td>
    <td class="lineNumber">4208</td>
    <td class="codeline">    if (NDigits == 1 && TruncateZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="codeline">      Str.push_back('0');</td>
    <td class="lineNumber">4209</td>
    <td class="codeline">      Str.push_back('0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">4210</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="codeline">      for (unsigned I = 1; I != NDigits; ++I)</td>
    <td class="lineNumber">4211</td>
    <td class="codeline">      for (unsigned I = 1; I != NDigits; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="codeline">        Str.push_back(buffer[NDigits-1-I]);</td>
    <td class="lineNumber">4212</td>
    <td class="codeline">        Str.push_back(buffer[NDigits-1-I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="codeline">    // Fill with zeros up to FormatPrecision.</td>
    <td class="lineNumber">4213</td>
    <td class="codeline">    // Fill with zeros up to FormatPrecision.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="codeline">    if (!TruncateZero && FormatPrecision > NDigits - 1)</td>
    <td class="lineNumber">4214</td>
    <td class="codeline">    if (!TruncateZero && FormatPrecision > NDigits - 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="codeline">      Str.append(FormatPrecision - NDigits + 1, '0');</td>
    <td class="lineNumber">4215</td>
    <td class="codeline">      Str.append(FormatPrecision - NDigits + 1, '0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="codeline">    // For !TruncateZero we use lower 'e'.</td>
    <td class="lineNumber">4216</td>
    <td class="codeline">    // For !TruncateZero we use lower 'e'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="codeline">    Str.push_back(TruncateZero ? 'E' : 'e');</td>
    <td class="lineNumber">4217</td>
    <td class="codeline">    Str.push_back(TruncateZero ? 'E' : 'e');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="codeline"></td>
    <td class="lineNumber">4218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="codeline">    Str.push_back(exp >= 0 ? '+' : '-');</td>
    <td class="lineNumber">4219</td>
    <td class="codeline">    Str.push_back(exp >= 0 ? '+' : '-');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="codeline">    if (exp < 0) exp = -exp;</td>
    <td class="lineNumber">4220</td>
    <td class="codeline">    if (exp < 0) exp = -exp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="codeline">    SmallVector<char, 6> expbuf;</td>
    <td class="lineNumber">4221</td>
    <td class="codeline">    SmallVector<char, 6> expbuf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">4222</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="codeline">      expbuf.push_back((char) ('0' + (exp % 10)));</td>
    <td class="lineNumber">4223</td>
    <td class="codeline">      expbuf.push_back((char) ('0' + (exp % 10)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class="codeline">      exp /= 10;</td>
    <td class="lineNumber">4224</td>
    <td class="codeline">      exp /= 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="codeline">    } while (exp);</td>
    <td class="lineNumber">4225</td>
    <td class="codeline">    } while (exp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="codeline">    // Exponent always at least two digits if we do not truncate zeros.</td>
    <td class="lineNumber">4226</td>
    <td class="codeline">    // Exponent always at least two digits if we do not truncate zeros.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="codeline">    if (!TruncateZero && expbuf.size() < 2)</td>
    <td class="lineNumber">4227</td>
    <td class="codeline">    if (!TruncateZero && expbuf.size() < 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="codeline">      expbuf.push_back('0');</td>
    <td class="lineNumber">4228</td>
    <td class="codeline">      expbuf.push_back('0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="codeline">    for (unsigned I = 0, E = expbuf.size(); I != E; ++I)</td>
    <td class="lineNumber">4229</td>
    <td class="codeline">    for (unsigned I = 0, E = expbuf.size(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="codeline">      Str.push_back(expbuf[E-1-I]);</td>
    <td class="lineNumber">4230</td>
    <td class="codeline">      Str.push_back(expbuf[E-1-I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">4231</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4232</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="codeline"></td>
    <td class="lineNumber">4233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="codeline">  // Non-scientific, positive exponents.</td>
    <td class="lineNumber">4234</td>
    <td class="codeline">  // Non-scientific, positive exponents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="codeline">  if (exp >= 0) {</td>
    <td class="lineNumber">4235</td>
    <td class="codeline">  if (exp >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="codeline">    for (unsigned I = 0; I != NDigits; ++I)</td>
    <td class="lineNumber">4236</td>
    <td class="codeline">    for (unsigned I = 0; I != NDigits; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="codeline">      Str.push_back(buffer[NDigits-1-I]);</td>
    <td class="lineNumber">4237</td>
    <td class="codeline">      Str.push_back(buffer[NDigits-1-I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="codeline">    for (unsigned I = 0; I != (unsigned) exp; ++I)</td>
    <td class="lineNumber">4238</td>
    <td class="codeline">    for (unsigned I = 0; I != (unsigned) exp; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="codeline">      Str.push_back('0');</td>
    <td class="lineNumber">4239</td>
    <td class="codeline">      Str.push_back('0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">4240</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4241</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="codeline"></td>
    <td class="lineNumber">4242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="codeline">  // Non-scientific, negative exponents.</td>
    <td class="lineNumber">4243</td>
    <td class="codeline">  // Non-scientific, negative exponents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="codeline"></td>
    <td class="lineNumber">4244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="codeline">  // The number of digits to the left of the decimal point.</td>
    <td class="lineNumber">4245</td>
    <td class="codeline">  // The number of digits to the left of the decimal point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="codeline">  int NWholeDigits = exp + (int) NDigits;</td>
    <td class="lineNumber">4246</td>
    <td class="codeline">  int NWholeDigits = exp + (int) NDigits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="codeline"></td>
    <td class="lineNumber">4247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="codeline">  unsigned I = 0;</td>
    <td class="lineNumber">4248</td>
    <td class="codeline">  unsigned I = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="codeline">  if (NWholeDigits > 0) {</td>
    <td class="lineNumber">4249</td>
    <td class="codeline">  if (NWholeDigits > 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="codeline">    for (; I != (unsigned) NWholeDigits; ++I)</td>
    <td class="lineNumber">4250</td>
    <td class="codeline">    for (; I != (unsigned) NWholeDigits; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="codeline">      Str.push_back(buffer[NDigits-I-1]);</td>
    <td class="lineNumber">4251</td>
    <td class="codeline">      Str.push_back(buffer[NDigits-I-1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="codeline">    Str.push_back('.');</td>
    <td class="lineNumber">4252</td>
    <td class="codeline">    Str.push_back('.');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">4253</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="codeline">    unsigned NZeros = 1 + (unsigned) -NWholeDigits;</td>
    <td class="lineNumber">4254</td>
    <td class="codeline">    unsigned NZeros = 1 + (unsigned) -NWholeDigits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="codeline"></td>
    <td class="lineNumber">4255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="codeline">    Str.push_back('0');</td>
    <td class="lineNumber">4256</td>
    <td class="codeline">    Str.push_back('0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="codeline">    Str.push_back('.');</td>
    <td class="lineNumber">4257</td>
    <td class="codeline">    Str.push_back('.');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="codeline">    for (unsigned Z = 1; Z != NZeros; ++Z)</td>
    <td class="lineNumber">4258</td>
    <td class="codeline">    for (unsigned Z = 1; Z != NZeros; ++Z)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="codeline">      Str.push_back('0');</td>
    <td class="lineNumber">4259</td>
    <td class="codeline">      Str.push_back('0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4260</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="codeline"></td>
    <td class="lineNumber">4261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="codeline">  for (; I != NDigits; ++I)</td>
    <td class="lineNumber">4262</td>
    <td class="codeline">  for (; I != NDigits; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="codeline">    Str.push_back(buffer[NDigits-I-1]);</td>
    <td class="lineNumber">4263</td>
    <td class="codeline">    Str.push_back(buffer[NDigits-I-1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4264</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class="codeline"></td>
    <td class="lineNumber">4265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="codeline">bool IEEEFloat::getExactInverse(APFloat *inv) const {</td>
    <td class="lineNumber">4266</td>
    <td class="codeline">bool IEEEFloat::getExactInverse(APFloat *inv) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="codeline">  // Special floats and denormals have no exact inverse.</td>
    <td class="lineNumber">4267</td>
    <td class="codeline">  // Special floats and denormals have no exact inverse.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="codeline">  if (!isFiniteNonZero())</td>
    <td class="lineNumber">4268</td>
    <td class="codeline">  if (!isFiniteNonZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4269</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="codeline"></td>
    <td class="lineNumber">4270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="codeline">  // Check that the number is a power of two by making sure that only the</td>
    <td class="lineNumber">4271</td>
    <td class="codeline">  // Check that the number is a power of two by making sure that only the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="codeline">  // integer bit is set in the significand.</td>
    <td class="lineNumber">4272</td>
    <td class="codeline">  // integer bit is set in the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="codeline">  if (significandLSB() != semantics->precision - 1)</td>
    <td class="lineNumber">4273</td>
    <td class="codeline">  if (significandLSB() != semantics->precision - 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4274</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="codeline"></td>
    <td class="lineNumber">4275</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="codeline">  // Get the inverse.</td>
    <td class="lineNumber">4276</td>
    <td class="codeline">  // Get the inverse.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="codeline">  IEEEFloat reciprocal(*semantics, 1ULL);</td>
    <td class="lineNumber">4277</td>
    <td class="codeline">  IEEEFloat reciprocal(*semantics, 1ULL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="codeline">  if (reciprocal.divide(*this, rmNearestTiesToEven) != opOK)</td>
    <td class="lineNumber">4278</td>
    <td class="codeline">  if (reciprocal.divide(*this, rmNearestTiesToEven) != opOK)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4279</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="codeline"></td>
    <td class="lineNumber">4280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="codeline">  // Avoid multiplication with a denormal, it is not safe on all platforms and</td>
    <td class="lineNumber">4281</td>
    <td class="codeline">  // Avoid multiplication with a denormal, it is not safe on all platforms and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="codeline">  // may be slower than a normal division.</td>
    <td class="lineNumber">4282</td>
    <td class="codeline">  // may be slower than a normal division.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="codeline">  if (reciprocal.isDenormal())</td>
    <td class="lineNumber">4283</td>
    <td class="codeline">  if (reciprocal.isDenormal())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4284</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class="codeline"></td>
    <td class="lineNumber">4285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="codeline">  assert(reciprocal.isFiniteNonZero() &&</td>
    <td class="lineNumber">4286</td>
    <td class="codeline">  assert(reciprocal.isFiniteNonZero() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="codeline">         reciprocal.significandLSB() == reciprocal.semantics->precision - 1);</td>
    <td class="lineNumber">4287</td>
    <td class="codeline">         reciprocal.significandLSB() == reciprocal.semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="codeline"></td>
    <td class="lineNumber">4288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="codeline">  if (inv)</td>
    <td class="lineNumber">4289</td>
    <td class="codeline">  if (inv)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="codeline">    *inv = APFloat(reciprocal, *semantics);</td>
    <td class="lineNumber">4290</td>
    <td class="codeline">    *inv = APFloat(reciprocal, *semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="codeline"></td>
    <td class="lineNumber">4291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">4292</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4293</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class="codeline"></td>
    <td class="lineNumber">4294</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="codeline">bool IEEEFloat::isSignaling() const {</td>
    <td class="lineNumber">4295</td>
    <td class="codeline">bool IEEEFloat::isSignaling() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="codeline">  if (!isNaN())</td>
    <td class="lineNumber">4296</td>
    <td class="codeline">  if (!isNaN())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4297</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">4298</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4299</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class="codeline"></td>
    <td class="lineNumber">4300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="codeline">  // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the</td>
    <td class="lineNumber">4301</td>
    <td class="codeline">  // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="codeline">  // first bit of the trailing significand being 0.</td>
    <td class="lineNumber">4302</td>
    <td class="codeline">  // first bit of the trailing significand being 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="codeline">  return !APInt::tcExtractBit(significandParts(), semantics->precision - 2);</td>
    <td class="lineNumber">4303</td>
    <td class="codeline">  return !APInt::tcExtractBit(significandParts(), semantics->precision - 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4304</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="codeline"></td>
    <td class="lineNumber">4305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="codeline">/// IEEE-754R 2008 5.3.1: nextUp/nextDown.</td>
    <td class="lineNumber">4306</td>
    <td class="codeline">/// IEEE-754R 2008 5.3.1: nextUp/nextDown.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4307</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="codeline">/// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with</td>
    <td class="lineNumber">4308</td>
    <td class="codeline">/// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="codeline">/// appropriate sign switching before/after the computation.</td>
    <td class="lineNumber">4309</td>
    <td class="codeline">/// appropriate sign switching before/after the computation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::next(bool nextDown) {</td>
    <td class="lineNumber">4310</td>
    <td class="codeline">IEEEFloat::opStatus IEEEFloat::next(bool nextDown) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="codeline">  // If we are performing nextDown, swap sign so we have -x.</td>
    <td class="lineNumber">4311</td>
    <td class="codeline">  // If we are performing nextDown, swap sign so we have -x.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="codeline">  if (nextDown)</td>
    <td class="lineNumber">4312</td>
    <td class="codeline">  if (nextDown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="codeline">    changeSign();</td>
    <td class="lineNumber">4313</td>
    <td class="codeline">    changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="codeline"></td>
    <td class="lineNumber">4314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="codeline">  // Compute nextUp(x)</td>
    <td class="lineNumber">4315</td>
    <td class="codeline">  // Compute nextUp(x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="codeline">  opStatus result = opOK;</td>
    <td class="lineNumber">4316</td>
    <td class="codeline">  opStatus result = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class="codeline"></td>
    <td class="lineNumber">4317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="codeline">  // Handle each float category separately.</td>
    <td class="lineNumber">4318</td>
    <td class="codeline">  // Handle each float category separately.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="codeline">  switch (category) {</td>
    <td class="lineNumber">4319</td>
    <td class="codeline">  switch (category) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class="codeline">  case fcInfinity:</td>
    <td class="lineNumber">4320</td>
    <td class="codeline">  case fcInfinity:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="codeline">    // nextUp(+inf) = +inf</td>
    <td class="lineNumber">4321</td>
    <td class="codeline">    // nextUp(+inf) = +inf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="codeline">    if (!isNegative())</td>
    <td class="lineNumber">4322</td>
    <td class="codeline">    if (!isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">4323</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="codeline">    // nextUp(-inf) = -getLargest()</td>
    <td class="lineNumber">4324</td>
    <td class="codeline">    // nextUp(-inf) = -getLargest()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="codeline">    makeLargest(true);</td>
    <td class="lineNumber">4325</td>
    <td class="codeline">    makeLargest(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">4326</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="codeline">  case fcNaN:</td>
    <td class="lineNumber">4327</td>
    <td class="codeline">  case fcNaN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="codeline">    // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.</td>
    <td class="lineNumber">4328</td>
    <td class="codeline">    // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="codeline">    // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not</td>
    <td class="lineNumber">4329</td>
    <td class="codeline">    // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="codeline">    //                     change the payload.</td>
    <td class="lineNumber">4330</td>
    <td class="codeline">    //                     change the payload.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="codeline">    if (isSignaling()) {</td>
    <td class="lineNumber">4331</td>
    <td class="codeline">    if (isSignaling()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="codeline">      result = opInvalidOp;</td>
    <td class="lineNumber">4332</td>
    <td class="codeline">      result = opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="codeline">      // For consistency, propagate the sign of the sNaN to the qNaN.</td>
    <td class="lineNumber">4333</td>
    <td class="codeline">      // For consistency, propagate the sign of the sNaN to the qNaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="codeline">      makeNaN(false, isNegative(), nullptr);</td>
    <td class="lineNumber">4334</td>
    <td class="codeline">      makeNaN(false, isNegative(), nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4335</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">4336</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="codeline">  case fcZero:</td>
    <td class="lineNumber">4337</td>
    <td class="codeline">  case fcZero:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="codeline">    // nextUp(pm 0) = +getSmallest()</td>
    <td class="lineNumber">4338</td>
    <td class="codeline">    // nextUp(pm 0) = +getSmallest()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="codeline">    makeSmallest(false);</td>
    <td class="lineNumber">4339</td>
    <td class="codeline">    makeSmallest(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">4340</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="codeline">  case fcNormal:</td>
    <td class="lineNumber">4341</td>
    <td class="codeline">  case fcNormal:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="codeline">    // nextUp(-getSmallest()) = -0</td>
    <td class="lineNumber">4342</td>
    <td class="codeline">    // nextUp(-getSmallest()) = -0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="codeline">    if (isSmallest() && isNegative()) {</td>
    <td class="lineNumber">4343</td>
    <td class="codeline">    if (isSmallest() && isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="codeline">      APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">4344</td>
    <td class="codeline">      APInt::tcSet(significandParts(), 0, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="codeline">      category = fcZero;</td>
    <td class="lineNumber">4345</td>
    <td class="codeline">      category = fcZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="codeline">      exponent = 0;</td>
    <td class="lineNumber">4346</td>
    <td class="codeline">      exponent = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="codeline">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">4347</td>
    <td class="codeline">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="codeline">        sign = false;</td>
    <td class="lineNumber">4348</td>
    <td class="codeline">        sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">4349</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4350</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="codeline"></td>
    <td class="lineNumber">4351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="codeline">    if (isLargest() && !isNegative()) {</td>
    <td class="lineNumber">4352</td>
    <td class="codeline">    if (isLargest() && !isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="codeline">      if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">4353</td>
    <td class="codeline">      if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="codeline">        // nextUp(getLargest()) == NAN</td>
    <td class="lineNumber">4354</td>
    <td class="codeline">        // nextUp(getLargest()) == NAN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="codeline">        makeNaN();</td>
    <td class="lineNumber">4355</td>
    <td class="codeline">        makeNaN();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">4356</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">4357</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="codeline">        // nextUp(getLargest()) == INFINITY</td>
    <td class="lineNumber">4358</td>
    <td class="codeline">        // nextUp(getLargest()) == INFINITY</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="codeline">        APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">4359</td>
    <td class="codeline">        APInt::tcSet(significandParts(), 0, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="codeline">        category = fcInfinity;</td>
    <td class="lineNumber">4360</td>
    <td class="codeline">        category = fcInfinity;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="codeline">        exponent = semantics->maxExponent + 1;</td>
    <td class="lineNumber">4361</td>
    <td class="codeline">        exponent = semantics->maxExponent + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">4362</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4363</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4364</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class="codeline"></td>
    <td class="lineNumber">4365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="codeline">    // nextUp(normal) == normal + inc.</td>
    <td class="lineNumber">4366</td>
    <td class="codeline">    // nextUp(normal) == normal + inc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="codeline">    if (isNegative()) {</td>
    <td class="lineNumber">4367</td>
    <td class="codeline">    if (isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="codeline">      // If we are negative, we need to decrement the significand.</td>
    <td class="lineNumber">4368</td>
    <td class="codeline">      // If we are negative, we need to decrement the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="codeline"></td>
    <td class="lineNumber">4369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="codeline">      // We only cross a binade boundary that requires adjusting the exponent</td>
    <td class="lineNumber">4370</td>
    <td class="codeline">      // We only cross a binade boundary that requires adjusting the exponent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="codeline">      // if:</td>
    <td class="lineNumber">4371</td>
    <td class="codeline">      // if:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="codeline">      //   1. exponent != semantics->minExponent. This implies we are not in the</td>
    <td class="lineNumber">4372</td>
    <td class="codeline">      //   1. exponent != semantics->minExponent. This implies we are not in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="codeline">      //   smallest binade or are dealing with denormals.</td>
    <td class="lineNumber">4373</td>
    <td class="codeline">      //   smallest binade or are dealing with denormals.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="codeline">      //   2. Our significand excluding the integral bit is all zeros.</td>
    <td class="lineNumber">4374</td>
    <td class="codeline">      //   2. Our significand excluding the integral bit is all zeros.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="codeline">      bool WillCrossBinadeBoundary =</td>
    <td class="lineNumber">4375</td>
    <td class="codeline">      bool WillCrossBinadeBoundary =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="codeline">        exponent != semantics->minExponent && isSignificandAllZeros();</td>
    <td class="lineNumber">4376</td>
    <td class="codeline">        exponent != semantics->minExponent && isSignificandAllZeros();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class="codeline"></td>
    <td class="lineNumber">4377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="codeline">      // Decrement the significand.</td>
    <td class="lineNumber">4378</td>
    <td class="codeline">      // Decrement the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">4379</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="codeline">      // We always do this since:</td>
    <td class="lineNumber">4380</td>
    <td class="codeline">      // We always do this since:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="codeline">      //   1. If we are dealing with a non-binade decrement, by definition we</td>
    <td class="lineNumber">4381</td>
    <td class="codeline">      //   1. If we are dealing with a non-binade decrement, by definition we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="codeline">      //   just decrement the significand.</td>
    <td class="lineNumber">4382</td>
    <td class="codeline">      //   just decrement the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="codeline">      //   2. If we are dealing with a normal -> normal binade decrement, since</td>
    <td class="lineNumber">4383</td>
    <td class="codeline">      //   2. If we are dealing with a normal -> normal binade decrement, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="codeline">      //   we have an explicit integral bit the fact that all bits but the</td>
    <td class="lineNumber">4384</td>
    <td class="codeline">      //   we have an explicit integral bit the fact that all bits but the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="codeline">      //   integral bit are zero implies that subtracting one will yield a</td>
    <td class="lineNumber">4385</td>
    <td class="codeline">      //   integral bit are zero implies that subtracting one will yield a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class="codeline">      //   significand with 0 integral bit and 1 in all other spots. Thus we</td>
    <td class="lineNumber">4386</td>
    <td class="codeline">      //   significand with 0 integral bit and 1 in all other spots. Thus we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="codeline">      //   must just adjust the exponent and set the integral bit to 1.</td>
    <td class="lineNumber">4387</td>
    <td class="codeline">      //   must just adjust the exponent and set the integral bit to 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="codeline">      //   3. If we are dealing with a normal -> denormal binade decrement,</td>
    <td class="lineNumber">4388</td>
    <td class="codeline">      //   3. If we are dealing with a normal -> denormal binade decrement,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="codeline">      //   since we set the integral bit to 0 when we represent denormals, we</td>
    <td class="lineNumber">4389</td>
    <td class="codeline">      //   since we set the integral bit to 0 when we represent denormals, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="codeline">      //   just decrement the significand.</td>
    <td class="lineNumber">4390</td>
    <td class="codeline">      //   just decrement the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class="codeline">      integerPart *Parts = significandParts();</td>
    <td class="lineNumber">4391</td>
    <td class="codeline">      integerPart *Parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="codeline">      APInt::tcDecrement(Parts, partCount());</td>
    <td class="lineNumber">4392</td>
    <td class="codeline">      APInt::tcDecrement(Parts, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="codeline"></td>
    <td class="lineNumber">4393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="codeline">      if (WillCrossBinadeBoundary) {</td>
    <td class="lineNumber">4394</td>
    <td class="codeline">      if (WillCrossBinadeBoundary) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="codeline">        // Our result is a normal number. Do the following:</td>
    <td class="lineNumber">4395</td>
    <td class="codeline">        // Our result is a normal number. Do the following:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="codeline">        // 1. Set the integral bit to 1.</td>
    <td class="lineNumber">4396</td>
    <td class="codeline">        // 1. Set the integral bit to 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="codeline">        // 2. Decrement the exponent.</td>
    <td class="lineNumber">4397</td>
    <td class="codeline">        // 2. Decrement the exponent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="codeline">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td class="lineNumber">4398</td>
    <td class="codeline">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="codeline">        exponent--;</td>
    <td class="lineNumber">4399</td>
    <td class="codeline">        exponent--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4400</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">4401</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="codeline">      // If we are positive, we need to increment the significand.</td>
    <td class="lineNumber">4402</td>
    <td class="codeline">      // If we are positive, we need to increment the significand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="codeline"></td>
    <td class="lineNumber">4403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="codeline">      // We only cross a binade boundary that requires adjusting the exponent if</td>
    <td class="lineNumber">4404</td>
    <td class="codeline">      // We only cross a binade boundary that requires adjusting the exponent if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="codeline">      // the input is not a denormal and all of said input's significand bits</td>
    <td class="lineNumber">4405</td>
    <td class="codeline">      // the input is not a denormal and all of said input's significand bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="codeline">      // are set. If all of said conditions are true: clear the significand, set</td>
    <td class="lineNumber">4406</td>
    <td class="codeline">      // are set. If all of said conditions are true: clear the significand, set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="codeline">      // the integral bit to 1, and increment the exponent. If we have a</td>
    <td class="lineNumber">4407</td>
    <td class="codeline">      // the integral bit to 1, and increment the exponent. If we have a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="codeline">      // denormal always increment since moving denormals and the numbers in the</td>
    <td class="lineNumber">4408</td>
    <td class="codeline">      // denormal always increment since moving denormals and the numbers in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="codeline">      // smallest normal binade have the same exponent in our representation.</td>
    <td class="lineNumber">4409</td>
    <td class="codeline">      // smallest normal binade have the same exponent in our representation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="codeline">      bool WillCrossBinadeBoundary = !isDenormal() && isSignificandAllOnes();</td>
    <td class="lineNumber">4410</td>
    <td class="codeline">      bool WillCrossBinadeBoundary = !isDenormal() && isSignificandAllOnes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class="codeline"></td>
    <td class="lineNumber">4411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="codeline">      if (WillCrossBinadeBoundary) {</td>
    <td class="lineNumber">4412</td>
    <td class="codeline">      if (WillCrossBinadeBoundary) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="codeline">        integerPart *Parts = significandParts();</td>
    <td class="lineNumber">4413</td>
    <td class="codeline">        integerPart *Parts = significandParts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="codeline">        APInt::tcSet(Parts, 0, partCount());</td>
    <td class="lineNumber">4414</td>
    <td class="codeline">        APInt::tcSet(Parts, 0, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="codeline">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td class="lineNumber">4415</td>
    <td class="codeline">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="codeline">        assert(exponent != semantics->maxExponent &&</td>
    <td class="lineNumber">4416</td>
    <td class="codeline">        assert(exponent != semantics->maxExponent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="codeline">               "We can not increment an exponent beyond the maxExponent allowed"</td>
    <td class="lineNumber">4417</td>
    <td class="codeline">               "We can not increment an exponent beyond the maxExponent allowed"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="codeline">               " by the given floating point semantics.");</td>
    <td class="lineNumber">4418</td>
    <td class="codeline">               " by the given floating point semantics.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="codeline">        exponent++;</td>
    <td class="lineNumber">4419</td>
    <td class="codeline">        exponent++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">4420</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="codeline">        incrementSignificand();</td>
    <td class="lineNumber">4421</td>
    <td class="codeline">        incrementSignificand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4422</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4423</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">4424</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4425</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class="codeline"></td>
    <td class="lineNumber">4426</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="codeline">  // If we are performing nextDown, swap sign so we have -nextUp(-x)</td>
    <td class="lineNumber">4427</td>
    <td class="codeline">  // If we are performing nextDown, swap sign so we have -nextUp(-x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="codeline">  if (nextDown)</td>
    <td class="lineNumber">4428</td>
    <td class="codeline">  if (nextDown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="codeline">    changeSign();</td>
    <td class="lineNumber">4429</td>
    <td class="codeline">    changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="codeline"></td>
    <td class="lineNumber">4430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="codeline">  return result;</td>
    <td class="lineNumber">4431</td>
    <td class="codeline">  return result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4432</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="codeline"></td>
    <td class="lineNumber">4433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="codeline">APFloatBase::ExponentType IEEEFloat::exponentNaN() const {</td>
    <td class="lineNumber">4434</td>
    <td class="codeline">APFloatBase::ExponentType IEEEFloat::exponentNaN() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="codeline">  return ::exponentNaN(*semantics);</td>
    <td class="lineNumber">4435</td>
    <td class="codeline">  return ::exponentNaN(*semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4436</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="codeline"></td>
    <td class="lineNumber">4437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="codeline">APFloatBase::ExponentType IEEEFloat::exponentInf() const {</td>
    <td class="lineNumber">4438</td>
    <td class="codeline">APFloatBase::ExponentType IEEEFloat::exponentInf() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="codeline">  return ::exponentInf(*semantics);</td>
    <td class="lineNumber">4439</td>
    <td class="codeline">  return ::exponentInf(*semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4440</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class="codeline"></td>
    <td class="lineNumber">4441</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="codeline">APFloatBase::ExponentType IEEEFloat::exponentZero() const {</td>
    <td class="lineNumber">4442</td>
    <td class="codeline">APFloatBase::ExponentType IEEEFloat::exponentZero() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="codeline">  return ::exponentZero(*semantics);</td>
    <td class="lineNumber">4443</td>
    <td class="codeline">  return ::exponentZero(*semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4444</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="codeline"></td>
    <td class="lineNumber">4445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="codeline">void IEEEFloat::makeInf(bool Negative) {</td>
    <td class="lineNumber">4446</td>
    <td class="codeline">void IEEEFloat::makeInf(bool Negative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">4447</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="codeline">    // There is no Inf, so make NaN instead.</td>
    <td class="lineNumber">4448</td>
    <td class="codeline">    // There is no Inf, so make NaN instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="codeline">    makeNaN(false, Negative);</td>
    <td class="lineNumber">4449</td>
    <td class="codeline">    makeNaN(false, Negative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">4450</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4451</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="codeline">  category = fcInfinity;</td>
    <td class="lineNumber">4452</td>
    <td class="codeline">  category = fcInfinity;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="codeline">  sign = Negative;</td>
    <td class="lineNumber">4453</td>
    <td class="codeline">  sign = Negative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="codeline">  exponent = exponentInf();</td>
    <td class="lineNumber">4454</td>
    <td class="codeline">  exponent = exponentInf();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">4455</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 0, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4456</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="codeline"></td>
    <td class="lineNumber">4457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="codeline">void IEEEFloat::makeZero(bool Negative) {</td>
    <td class="lineNumber">4458</td>
    <td class="codeline">void IEEEFloat::makeZero(bool Negative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="codeline">  category = fcZero;</td>
    <td class="lineNumber">4459</td>
    <td class="codeline">  category = fcZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="codeline">  sign = Negative;</td>
    <td class="lineNumber">4460</td>
    <td class="codeline">  sign = Negative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="codeline">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">4461</td>
    <td class="codeline">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="codeline">    // Merge negative zero to positive because 0b10000...000 is used for NaN</td>
    <td class="lineNumber">4462</td>
    <td class="codeline">    // Merge negative zero to positive because 0b10000...000 is used for NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="codeline">    sign = false;</td>
    <td class="lineNumber">4463</td>
    <td class="codeline">    sign = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4464</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="codeline">  exponent = exponentZero();</td>
    <td class="lineNumber">4465</td>
    <td class="codeline">  exponent = exponentZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">4466</td>
    <td class="codeline">  APInt::tcSet(significandParts(), 0, partCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4467</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="codeline"></td>
    <td class="lineNumber">4468</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="codeline">void IEEEFloat::makeQuiet() {</td>
    <td class="lineNumber">4469</td>
    <td class="codeline">void IEEEFloat::makeQuiet() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="codeline">  assert(isNaN());</td>
    <td class="lineNumber">4470</td>
    <td class="codeline">  assert(isNaN());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior != fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">4471</td>
    <td class="codeline">  if (semantics->nonFiniteBehavior != fltNonfiniteBehavior::NanOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="codeline">    APInt::tcSetBit(significandParts(), semantics->precision - 2);</td>
    <td class="lineNumber">4472</td>
    <td class="codeline">    APInt::tcSetBit(significandParts(), semantics->precision - 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4473</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="codeline"></td>
    <td class="lineNumber">4474</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="codeline">int ilogb(const IEEEFloat &Arg) {</td>
    <td class="lineNumber">4475</td>
    <td class="codeline">int ilogb(const IEEEFloat &Arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="codeline">  if (Arg.isNaN())</td>
    <td class="lineNumber">4476</td>
    <td class="codeline">  if (Arg.isNaN())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="codeline">    return IEEEFloat::IEK_NaN;</td>
    <td class="lineNumber">4477</td>
    <td class="codeline">    return IEEEFloat::IEK_NaN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="codeline">  if (Arg.isZero())</td>
    <td class="lineNumber">4478</td>
    <td class="codeline">  if (Arg.isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="codeline">    return IEEEFloat::IEK_Zero;</td>
    <td class="lineNumber">4479</td>
    <td class="codeline">    return IEEEFloat::IEK_Zero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="codeline">  if (Arg.isInfinity())</td>
    <td class="lineNumber">4480</td>
    <td class="codeline">  if (Arg.isInfinity())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="codeline">    return IEEEFloat::IEK_Inf;</td>
    <td class="lineNumber">4481</td>
    <td class="codeline">    return IEEEFloat::IEK_Inf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="codeline">  if (!Arg.isDenormal())</td>
    <td class="lineNumber">4482</td>
    <td class="codeline">  if (!Arg.isDenormal())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="codeline">    return Arg.exponent;</td>
    <td class="lineNumber">4483</td>
    <td class="codeline">    return Arg.exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="codeline"></td>
    <td class="lineNumber">4484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="codeline">  IEEEFloat Normalized(Arg);</td>
    <td class="lineNumber">4485</td>
    <td class="codeline">  IEEEFloat Normalized(Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="codeline">  int SignificandBits = Arg.getSemantics().precision - 1;</td>
    <td class="lineNumber">4486</td>
    <td class="codeline">  int SignificandBits = Arg.getSemantics().precision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class="codeline"></td>
    <td class="lineNumber">4487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="codeline">  Normalized.exponent += SignificandBits;</td>
    <td class="lineNumber">4488</td>
    <td class="codeline">  Normalized.exponent += SignificandBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="codeline">  Normalized.normalize(IEEEFloat::rmNearestTiesToEven, lfExactlyZero);</td>
    <td class="lineNumber">4489</td>
    <td class="codeline">  Normalized.normalize(IEEEFloat::rmNearestTiesToEven, lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="codeline">  return Normalized.exponent - SignificandBits;</td>
    <td class="lineNumber">4490</td>
    <td class="codeline">  return Normalized.exponent - SignificandBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4491</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="codeline"></td>
    <td class="lineNumber">4492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="codeline">IEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode RoundingMode) {</td>
    <td class="lineNumber">4493</td>
    <td class="codeline">IEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode RoundingMode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="codeline">  auto MaxExp = X.getSemantics().maxExponent;</td>
    <td class="lineNumber">4494</td>
    <td class="codeline">  auto MaxExp = X.getSemantics().maxExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="codeline">  auto MinExp = X.getSemantics().minExponent;</td>
    <td class="lineNumber">4495</td>
    <td class="codeline">  auto MinExp = X.getSemantics().minExponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class="codeline"></td>
    <td class="lineNumber">4496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="codeline">  // If Exp is wildly out-of-scale, simply adding it to X.exponent will</td>
    <td class="lineNumber">4497</td>
    <td class="codeline">  // If Exp is wildly out-of-scale, simply adding it to X.exponent will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="codeline">  // overflow; clamp it to a safe range before adding, but ensure that the range</td>
    <td class="lineNumber">4498</td>
    <td class="codeline">  // overflow; clamp it to a safe range before adding, but ensure that the range</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="codeline">  // is large enough that the clamp does not change the result. The range we</td>
    <td class="lineNumber">4499</td>
    <td class="codeline">  // is large enough that the clamp does not change the result. The range we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="codeline">  // need to support is the difference between the largest possible exponent and</td>
    <td class="lineNumber">4500</td>
    <td class="codeline">  // need to support is the difference between the largest possible exponent and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="codeline">  // the normalized exponent of half the smallest denormal.</td>
    <td class="lineNumber">4501</td>
    <td class="codeline">  // the normalized exponent of half the smallest denormal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class="codeline"></td>
    <td class="lineNumber">4502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="codeline">  int SignificandBits = X.getSemantics().precision - 1;</td>
    <td class="lineNumber">4503</td>
    <td class="codeline">  int SignificandBits = X.getSemantics().precision - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="codeline">  int MaxIncrement = MaxExp - (MinExp - SignificandBits) + 1;</td>
    <td class="lineNumber">4504</td>
    <td class="codeline">  int MaxIncrement = MaxExp - (MinExp - SignificandBits) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="codeline"></td>
    <td class="lineNumber">4505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="codeline">  // Clamp to one past the range ends to let normalize handle overlflow.</td>
    <td class="lineNumber">4506</td>
    <td class="codeline">  // Clamp to one past the range ends to let normalize handle overlflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="codeline">  X.exponent += std::clamp(Exp, -MaxIncrement - 1, MaxIncrement);</td>
    <td class="lineNumber">4507</td>
    <td class="codeline">  X.exponent += std::clamp(Exp, -MaxIncrement - 1, MaxIncrement);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="codeline">  X.normalize(RoundingMode, lfExactlyZero);</td>
    <td class="lineNumber">4508</td>
    <td class="codeline">  X.normalize(RoundingMode, lfExactlyZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="codeline">  if (X.isNaN())</td>
    <td class="lineNumber">4509</td>
    <td class="codeline">  if (X.isNaN())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="codeline">    X.makeQuiet();</td>
    <td class="lineNumber">4510</td>
    <td class="codeline">    X.makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="codeline">  return X;</td>
    <td class="lineNumber">4511</td>
    <td class="codeline">  return X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4512</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class="codeline"></td>
    <td class="lineNumber">4513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="codeline">IEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM) {</td>
    <td class="lineNumber">4514</td>
    <td class="codeline">IEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="codeline">  Exp = ilogb(Val);</td>
    <td class="lineNumber">4515</td>
    <td class="codeline">  Exp = ilogb(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class="codeline"></td>
    <td class="lineNumber">4516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="codeline">  // Quiet signalling nans.</td>
    <td class="lineNumber">4517</td>
    <td class="codeline">  // Quiet signalling nans.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="codeline">  if (Exp == IEEEFloat::IEK_NaN) {</td>
    <td class="lineNumber">4518</td>
    <td class="codeline">  if (Exp == IEEEFloat::IEK_NaN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="codeline">    IEEEFloat Quiet(Val);</td>
    <td class="lineNumber">4519</td>
    <td class="codeline">    IEEEFloat Quiet(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="codeline">    Quiet.makeQuiet();</td>
    <td class="lineNumber">4520</td>
    <td class="codeline">    Quiet.makeQuiet();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="codeline">    return Quiet;</td>
    <td class="lineNumber">4521</td>
    <td class="codeline">    return Quiet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4522</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="codeline"></td>
    <td class="lineNumber">4523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="codeline">  if (Exp == IEEEFloat::IEK_Inf)</td>
    <td class="lineNumber">4524</td>
    <td class="codeline">  if (Exp == IEEEFloat::IEK_Inf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="codeline">    return Val;</td>
    <td class="lineNumber">4525</td>
    <td class="codeline">    return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="codeline"></td>
    <td class="lineNumber">4526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="codeline">  // 1 is added because frexp is defined to return a normalized fraction in</td>
    <td class="lineNumber">4527</td>
    <td class="codeline">  // 1 is added because frexp is defined to return a normalized fraction in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="codeline">  // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).</td>
    <td class="lineNumber">4528</td>
    <td class="codeline">  // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="codeline">  Exp = Exp == IEEEFloat::IEK_Zero ? 0 : Exp + 1;</td>
    <td class="lineNumber">4529</td>
    <td class="codeline">  Exp = Exp == IEEEFloat::IEK_Zero ? 0 : Exp + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="codeline">  return scalbn(Val, -Exp, RM);</td>
    <td class="lineNumber">4530</td>
    <td class="codeline">  return scalbn(Val, -Exp, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4531</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="codeline"></td>
    <td class="lineNumber">4532</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S)</td>
    <td class="lineNumber">4533</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="codeline">    : Semantics(&S),</td>
    <td class="lineNumber">4534</td>
    <td class="codeline">    : Semantics(&S),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="codeline">      Floats(new APFloat[2]{APFloat(semIEEEdouble), APFloat(semIEEEdouble)}) {</td>
    <td class="lineNumber">4535</td>
    <td class="codeline">      Floats(new APFloat[2]{APFloat(semIEEEdouble), APFloat(semIEEEdouble)}) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">4536</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4537</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="codeline"></td>
    <td class="lineNumber">4538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, uninitializedTag)</td>
    <td class="lineNumber">4539</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, uninitializedTag)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="codeline">    : Semantics(&S),</td>
    <td class="lineNumber">4540</td>
    <td class="codeline">    : Semantics(&S),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="codeline">      Floats(new APFloat[2]{APFloat(semIEEEdouble, uninitialized),</td>
    <td class="lineNumber">4541</td>
    <td class="codeline">      Floats(new APFloat[2]{APFloat(semIEEEdouble, uninitialized),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="codeline">                            APFloat(semIEEEdouble, uninitialized)}) {</td>
    <td class="lineNumber">4542</td>
    <td class="codeline">                            APFloat(semIEEEdouble, uninitialized)}) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">4543</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4544</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="codeline"></td>
    <td class="lineNumber">4545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, integerPart I)</td>
    <td class="lineNumber">4546</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, integerPart I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="codeline">    : Semantics(&S), Floats(new APFloat[2]{APFloat(semIEEEdouble, I),</td>
    <td class="lineNumber">4547</td>
    <td class="codeline">    : Semantics(&S), Floats(new APFloat[2]{APFloat(semIEEEdouble, I),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="codeline">                                           APFloat(semIEEEdouble)}) {</td>
    <td class="lineNumber">4548</td>
    <td class="codeline">                                           APFloat(semIEEEdouble)}) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">4549</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4550</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="codeline"></td>
    <td class="lineNumber">4551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, const APInt &I)</td>
    <td class="lineNumber">4552</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, const APInt &I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="codeline">    : Semantics(&S),</td>
    <td class="lineNumber">4553</td>
    <td class="codeline">    : Semantics(&S),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="codeline">      Floats(new APFloat[2]{</td>
    <td class="lineNumber">4554</td>
    <td class="codeline">      Floats(new APFloat[2]{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="codeline">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[0])),</td>
    <td class="lineNumber">4555</td>
    <td class="codeline">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[0])),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="codeline">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[1]))}) {</td>
    <td class="lineNumber">4556</td>
    <td class="codeline">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[1]))}) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">4557</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4558</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="codeline"></td>
    <td class="lineNumber">4559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, APFloat &&First,</td>
    <td class="lineNumber">4560</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, APFloat &&First,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="codeline">                             APFloat &&Second)</td>
    <td class="lineNumber">4561</td>
    <td class="codeline">                             APFloat &&Second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class="codeline">    : Semantics(&S),</td>
    <td class="lineNumber">4562</td>
    <td class="codeline">    : Semantics(&S),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="codeline">      Floats(new APFloat[2]{std::move(First), std::move(Second)}) {</td>
    <td class="lineNumber">4563</td>
    <td class="codeline">      Floats(new APFloat[2]{std::move(First), std::move(Second)}) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">4564</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="codeline">  assert(&Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4565</td>
    <td class="codeline">  assert(&Floats[0].getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="codeline">  assert(&Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4566</td>
    <td class="codeline">  assert(&Floats[1].getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4567</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="codeline"></td>
    <td class="lineNumber">4568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const DoubleAPFloat &RHS)</td>
    <td class="lineNumber">4569</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(const DoubleAPFloat &RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="codeline">    : Semantics(RHS.Semantics),</td>
    <td class="lineNumber">4570</td>
    <td class="codeline">    : Semantics(RHS.Semantics),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="codeline">      Floats(RHS.Floats ? new APFloat[2]{APFloat(RHS.Floats[0]),</td>
    <td class="lineNumber">4571</td>
    <td class="codeline">      Floats(RHS.Floats ? new APFloat[2]{APFloat(RHS.Floats[0]),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="codeline">                                         APFloat(RHS.Floats[1])}</td>
    <td class="lineNumber">4572</td>
    <td class="codeline">                                         APFloat(RHS.Floats[1])}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="codeline">                        : nullptr) {</td>
    <td class="lineNumber">4573</td>
    <td class="codeline">                        : nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">4574</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4575</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="codeline"></td>
    <td class="lineNumber">4576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(DoubleAPFloat &&RHS)</td>
    <td class="lineNumber">4577</td>
    <td class="codeline">DoubleAPFloat::DoubleAPFloat(DoubleAPFloat &&RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="codeline">    : Semantics(RHS.Semantics), Floats(std::move(RHS.Floats)) {</td>
    <td class="lineNumber">4578</td>
    <td class="codeline">    : Semantics(RHS.Semantics), Floats(std::move(RHS.Floats)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="codeline">  RHS.Semantics = &semBogus;</td>
    <td class="lineNumber">4579</td>
    <td class="codeline">  RHS.Semantics = &semBogus;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">4580</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4581</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class="codeline"></td>
    <td class="lineNumber">4582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="codeline">DoubleAPFloat &DoubleAPFloat::operator=(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">4583</td>
    <td class="codeline">DoubleAPFloat &DoubleAPFloat::operator=(const DoubleAPFloat &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="codeline">  if (Semantics == RHS.Semantics && RHS.Floats) {</td>
    <td class="lineNumber">4584</td>
    <td class="codeline">  if (Semantics == RHS.Semantics && RHS.Floats) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="codeline">    Floats[0] = RHS.Floats[0];</td>
    <td class="lineNumber">4585</td>
    <td class="codeline">    Floats[0] = RHS.Floats[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="codeline">    Floats[1] = RHS.Floats[1];</td>
    <td class="lineNumber">4586</td>
    <td class="codeline">    Floats[1] = RHS.Floats[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="codeline">  } else if (this != &RHS) {</td>
    <td class="lineNumber">4587</td>
    <td class="codeline">  } else if (this != &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="codeline">    this->~DoubleAPFloat();</td>
    <td class="lineNumber">4588</td>
    <td class="codeline">    this->~DoubleAPFloat();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="codeline">    new (this) DoubleAPFloat(RHS);</td>
    <td class="lineNumber">4589</td>
    <td class="codeline">    new (this) DoubleAPFloat(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4590</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">4591</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4592</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="codeline"></td>
    <td class="lineNumber">4593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="codeline">// Implement addition, subtraction, multiplication and division based on:</td>
    <td class="lineNumber">4594</td>
    <td class="codeline">// Implement addition, subtraction, multiplication and division based on:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="codeline">// "Software for Doubled-Precision Floating-Point Computations",</td>
    <td class="lineNumber">4595</td>
    <td class="codeline">// "Software for Doubled-Precision Floating-Point Computations",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="codeline">// by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.</td>
    <td class="lineNumber">4596</td>
    <td class="codeline">// by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::addImpl(const APFloat &a, const APFloat &aa,</td>
    <td class="lineNumber">4597</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::addImpl(const APFloat &a, const APFloat &aa,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="codeline">                                         const APFloat &c, const APFloat &cc,</td>
    <td class="lineNumber">4598</td>
    <td class="codeline">                                         const APFloat &c, const APFloat &cc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="codeline">                                         roundingMode RM) {</td>
    <td class="lineNumber">4599</td>
    <td class="codeline">                                         roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="codeline">  int Status = opOK;</td>
    <td class="lineNumber">4600</td>
    <td class="codeline">  int Status = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="codeline">  APFloat z = a;</td>
    <td class="lineNumber">4601</td>
    <td class="codeline">  APFloat z = a;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="codeline">  Status |= z.add(c, RM);</td>
    <td class="lineNumber">4602</td>
    <td class="codeline">  Status |= z.add(c, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="codeline">  if (!z.isFinite()) {</td>
    <td class="lineNumber">4603</td>
    <td class="codeline">  if (!z.isFinite()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="codeline">    if (!z.isInfinity()) {</td>
    <td class="lineNumber">4604</td>
    <td class="codeline">    if (!z.isInfinity()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="codeline">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">4605</td>
    <td class="codeline">      Floats[0] = std::move(z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4606</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="codeline">      return (opStatus)Status;</td>
    <td class="lineNumber">4607</td>
    <td class="codeline">      return (opStatus)Status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4608</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="codeline">    Status = opOK;</td>
    <td class="lineNumber">4609</td>
    <td class="codeline">    Status = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="codeline">    auto AComparedToC = a.compareAbsoluteValue(c);</td>
    <td class="lineNumber">4610</td>
    <td class="codeline">    auto AComparedToC = a.compareAbsoluteValue(c);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="codeline">    z = cc;</td>
    <td class="lineNumber">4611</td>
    <td class="codeline">    z = cc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="codeline">    Status |= z.add(aa, RM);</td>
    <td class="lineNumber">4612</td>
    <td class="codeline">    Status |= z.add(aa, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="codeline">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td class="lineNumber">4613</td>
    <td class="codeline">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="codeline">      // z = cc + aa + c + a;</td>
    <td class="lineNumber">4614</td>
    <td class="codeline">      // z = cc + aa + c + a;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="codeline">      Status |= z.add(c, RM);</td>
    <td class="lineNumber">4615</td>
    <td class="codeline">      Status |= z.add(c, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="codeline">      Status |= z.add(a, RM);</td>
    <td class="lineNumber">4616</td>
    <td class="codeline">      Status |= z.add(a, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">4617</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="codeline">      // z = cc + aa + a + c;</td>
    <td class="lineNumber">4618</td>
    <td class="codeline">      // z = cc + aa + a + c;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="codeline">      Status |= z.add(a, RM);</td>
    <td class="lineNumber">4619</td>
    <td class="codeline">      Status |= z.add(a, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="codeline">      Status |= z.add(c, RM);</td>
    <td class="lineNumber">4620</td>
    <td class="codeline">      Status |= z.add(c, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4621</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="codeline">    if (!z.isFinite()) {</td>
    <td class="lineNumber">4622</td>
    <td class="codeline">    if (!z.isFinite()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="codeline">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">4623</td>
    <td class="codeline">      Floats[0] = std::move(z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4624</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="codeline">      return (opStatus)Status;</td>
    <td class="lineNumber">4625</td>
    <td class="codeline">      return (opStatus)Status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4626</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="codeline">    Floats[0] = z;</td>
    <td class="lineNumber">4627</td>
    <td class="codeline">    Floats[0] = z;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="codeline">    APFloat zz = aa;</td>
    <td class="lineNumber">4628</td>
    <td class="codeline">    APFloat zz = aa;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="codeline">    Status |= zz.add(cc, RM);</td>
    <td class="lineNumber">4629</td>
    <td class="codeline">    Status |= zz.add(cc, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="codeline">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td class="lineNumber">4630</td>
    <td class="codeline">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="codeline">      // Floats[1] = a - z + c + zz;</td>
    <td class="lineNumber">4631</td>
    <td class="codeline">      // Floats[1] = a - z + c + zz;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="codeline">      Floats[1] = a;</td>
    <td class="lineNumber">4632</td>
    <td class="codeline">      Floats[1] = a;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="codeline">      Status |= Floats[1].subtract(z, RM);</td>
    <td class="lineNumber">4633</td>
    <td class="codeline">      Status |= Floats[1].subtract(z, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="codeline">      Status |= Floats[1].add(c, RM);</td>
    <td class="lineNumber">4634</td>
    <td class="codeline">      Status |= Floats[1].add(c, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="codeline">      Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">4635</td>
    <td class="codeline">      Status |= Floats[1].add(zz, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">4636</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="codeline">      // Floats[1] = c - z + a + zz;</td>
    <td class="lineNumber">4637</td>
    <td class="codeline">      // Floats[1] = c - z + a + zz;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="codeline">      Floats[1] = c;</td>
    <td class="lineNumber">4638</td>
    <td class="codeline">      Floats[1] = c;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="codeline">      Status |= Floats[1].subtract(z, RM);</td>
    <td class="lineNumber">4639</td>
    <td class="codeline">      Status |= Floats[1].subtract(z, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="codeline">      Status |= Floats[1].add(a, RM);</td>
    <td class="lineNumber">4640</td>
    <td class="codeline">      Status |= Floats[1].add(a, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="codeline">      Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">4641</td>
    <td class="codeline">      Status |= Floats[1].add(zz, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4642</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">4643</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="codeline">    // q = a - z;</td>
    <td class="lineNumber">4644</td>
    <td class="codeline">    // q = a - z;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="codeline">    APFloat q = a;</td>
    <td class="lineNumber">4645</td>
    <td class="codeline">    APFloat q = a;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="codeline">    Status |= q.subtract(z, RM);</td>
    <td class="lineNumber">4646</td>
    <td class="codeline">    Status |= q.subtract(z, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="codeline"></td>
    <td class="lineNumber">4647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="codeline">    // zz = q + c + (a - (q + z)) + aa + cc;</td>
    <td class="lineNumber">4648</td>
    <td class="codeline">    // zz = q + c + (a - (q + z)) + aa + cc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="codeline">    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.</td>
    <td class="lineNumber">4649</td>
    <td class="codeline">    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="codeline">    auto zz = q;</td>
    <td class="lineNumber">4650</td>
    <td class="codeline">    auto zz = q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="codeline">    Status |= zz.add(c, RM);</td>
    <td class="lineNumber">4651</td>
    <td class="codeline">    Status |= zz.add(c, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="codeline">    Status |= q.add(z, RM);</td>
    <td class="lineNumber">4652</td>
    <td class="codeline">    Status |= q.add(z, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="codeline">    Status |= q.subtract(a, RM);</td>
    <td class="lineNumber">4653</td>
    <td class="codeline">    Status |= q.subtract(a, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="codeline">    q.changeSign();</td>
    <td class="lineNumber">4654</td>
    <td class="codeline">    q.changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="codeline">    Status |= zz.add(q, RM);</td>
    <td class="lineNumber">4655</td>
    <td class="codeline">    Status |= zz.add(q, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="codeline">    Status |= zz.add(aa, RM);</td>
    <td class="lineNumber">4656</td>
    <td class="codeline">    Status |= zz.add(aa, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="codeline">    Status |= zz.add(cc, RM);</td>
    <td class="lineNumber">4657</td>
    <td class="codeline">    Status |= zz.add(cc, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="codeline">    if (zz.isZero() && !zz.isNegative()) {</td>
    <td class="lineNumber">4658</td>
    <td class="codeline">    if (zz.isZero() && !zz.isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="codeline">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">4659</td>
    <td class="codeline">      Floats[0] = std::move(z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4660</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="codeline">      return opOK;</td>
    <td class="lineNumber">4661</td>
    <td class="codeline">      return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4662</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="codeline">    Floats[0] = z;</td>
    <td class="lineNumber">4663</td>
    <td class="codeline">    Floats[0] = z;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="codeline">    Status |= Floats[0].add(zz, RM);</td>
    <td class="lineNumber">4664</td>
    <td class="codeline">    Status |= Floats[0].add(zz, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="codeline">    if (!Floats[0].isFinite()) {</td>
    <td class="lineNumber">4665</td>
    <td class="codeline">    if (!Floats[0].isFinite()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4666</td>
    <td class="codeline">      Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="codeline">      return (opStatus)Status;</td>
    <td class="lineNumber">4667</td>
    <td class="codeline">      return (opStatus)Status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4668</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="codeline">    Floats[1] = std::move(z);</td>
    <td class="lineNumber">4669</td>
    <td class="codeline">    Floats[1] = std::move(z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="codeline">    Status |= Floats[1].subtract(Floats[0], RM);</td>
    <td class="lineNumber">4670</td>
    <td class="codeline">    Status |= Floats[1].subtract(Floats[0], RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="codeline">    Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">4671</td>
    <td class="codeline">    Status |= Floats[1].add(zz, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4672</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="codeline">  return (opStatus)Status;</td>
    <td class="lineNumber">4673</td>
    <td class="codeline">  return (opStatus)Status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4674</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="codeline"></td>
    <td class="lineNumber">4675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::addWithSpecial(const DoubleAPFloat &LHS,</td>
    <td class="lineNumber">4676</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::addWithSpecial(const DoubleAPFloat &LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="codeline">                                                const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">4677</td>
    <td class="codeline">                                                const DoubleAPFloat &RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="codeline">                                                DoubleAPFloat &Out,</td>
    <td class="lineNumber">4678</td>
    <td class="codeline">                                                DoubleAPFloat &Out,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="codeline">                                                roundingMode RM) {</td>
    <td class="lineNumber">4679</td>
    <td class="codeline">                                                roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="codeline">  if (LHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">4680</td>
    <td class="codeline">  if (LHS.getCategory() == fcNaN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="codeline">    Out = LHS;</td>
    <td class="lineNumber">4681</td>
    <td class="codeline">    Out = LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4682</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4683</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="codeline">  if (RHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">4684</td>
    <td class="codeline">  if (RHS.getCategory() == fcNaN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="codeline">    Out = RHS;</td>
    <td class="lineNumber">4685</td>
    <td class="codeline">    Out = RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4686</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4687</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="codeline">  if (LHS.getCategory() == fcZero) {</td>
    <td class="lineNumber">4688</td>
    <td class="codeline">  if (LHS.getCategory() == fcZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="codeline">    Out = RHS;</td>
    <td class="lineNumber">4689</td>
    <td class="codeline">    Out = RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4690</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4691</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="codeline">  if (RHS.getCategory() == fcZero) {</td>
    <td class="lineNumber">4692</td>
    <td class="codeline">  if (RHS.getCategory() == fcZero) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="codeline">    Out = LHS;</td>
    <td class="lineNumber">4693</td>
    <td class="codeline">    Out = LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4694</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4695</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="codeline">  if (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcInfinity &&</td>
    <td class="lineNumber">4696</td>
    <td class="codeline">  if (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcInfinity &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="codeline">      LHS.isNegative() != RHS.isNegative()) {</td>
    <td class="lineNumber">4697</td>
    <td class="codeline">      LHS.isNegative() != RHS.isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="codeline">    Out.makeNaN(false, Out.isNegative(), nullptr);</td>
    <td class="lineNumber">4698</td>
    <td class="codeline">    Out.makeNaN(false, Out.isNegative(), nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="codeline">    return opInvalidOp;</td>
    <td class="lineNumber">4699</td>
    <td class="codeline">    return opInvalidOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4700</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="codeline">  if (LHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">4701</td>
    <td class="codeline">  if (LHS.getCategory() == fcInfinity) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="codeline">    Out = LHS;</td>
    <td class="lineNumber">4702</td>
    <td class="codeline">    Out = LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4703</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4704</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="codeline">  if (RHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">4705</td>
    <td class="codeline">  if (RHS.getCategory() == fcInfinity) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="codeline">    Out = RHS;</td>
    <td class="lineNumber">4706</td>
    <td class="codeline">    Out = RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4707</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4708</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="codeline">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal);</td>
    <td class="lineNumber">4709</td>
    <td class="codeline">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="codeline"></td>
    <td class="lineNumber">4710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="codeline">  APFloat A(LHS.Floats[0]), AA(LHS.Floats[1]), C(RHS.Floats[0]),</td>
    <td class="lineNumber">4711</td>
    <td class="codeline">  APFloat A(LHS.Floats[0]), AA(LHS.Floats[1]), C(RHS.Floats[0]),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="codeline">      CC(RHS.Floats[1]);</td>
    <td class="lineNumber">4712</td>
    <td class="codeline">      CC(RHS.Floats[1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="codeline">  assert(&A.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4713</td>
    <td class="codeline">  assert(&A.getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="codeline">  assert(&AA.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4714</td>
    <td class="codeline">  assert(&AA.getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="codeline">  assert(&C.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4715</td>
    <td class="codeline">  assert(&C.getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="codeline">  assert(&CC.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4716</td>
    <td class="codeline">  assert(&CC.getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="codeline">  assert(&Out.Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4717</td>
    <td class="codeline">  assert(&Out.Floats[0].getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="codeline">  assert(&Out.Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">4718</td>
    <td class="codeline">  assert(&Out.Floats[1].getSemantics() == &semIEEEdouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="codeline">  return Out.addImpl(A, AA, C, CC, RM);</td>
    <td class="lineNumber">4719</td>
    <td class="codeline">  return Out.addImpl(A, AA, C, CC, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4720</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="codeline"></td>
    <td class="lineNumber">4721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::add(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">4722</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::add(const DoubleAPFloat &RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="codeline">                                     roundingMode RM) {</td>
    <td class="lineNumber">4723</td>
    <td class="codeline">                                     roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="codeline">  return addWithSpecial(*this, RHS, *this, RM);</td>
    <td class="lineNumber">4724</td>
    <td class="codeline">  return addWithSpecial(*this, RHS, *this, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4725</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class="codeline"></td>
    <td class="lineNumber">4726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::subtract(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">4727</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::subtract(const DoubleAPFloat &RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="codeline">                                          roundingMode RM) {</td>
    <td class="lineNumber">4728</td>
    <td class="codeline">                                          roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="codeline">  changeSign();</td>
    <td class="lineNumber">4729</td>
    <td class="codeline">  changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="codeline">  auto Ret = add(RHS, RM);</td>
    <td class="lineNumber">4730</td>
    <td class="codeline">  auto Ret = add(RHS, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="codeline">  changeSign();</td>
    <td class="lineNumber">4731</td>
    <td class="codeline">  changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4732</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4733</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class="codeline"></td>
    <td class="lineNumber">4734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::multiply(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">4735</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::multiply(const DoubleAPFloat &RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="codeline">                                          APFloat::roundingMode RM) {</td>
    <td class="lineNumber">4736</td>
    <td class="codeline">                                          APFloat::roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="codeline">  const auto &LHS = *this;</td>
    <td class="lineNumber">4737</td>
    <td class="codeline">  const auto &LHS = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="codeline">  auto &Out = *this;</td>
    <td class="lineNumber">4738</td>
    <td class="codeline">  auto &Out = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="codeline">  /* Interesting observation: For special categories, finding the lowest</td>
    <td class="lineNumber">4739</td>
    <td class="codeline">  /* Interesting observation: For special categories, finding the lowest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="codeline">     common ancestor of the following layered graph gives the correct</td>
    <td class="lineNumber">4740</td>
    <td class="codeline">     common ancestor of the following layered graph gives the correct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="codeline">     return category:</td>
    <td class="lineNumber">4741</td>
    <td class="codeline">     return category:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class="codeline"></td>
    <td class="lineNumber">4742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="codeline">        NaN</td>
    <td class="lineNumber">4743</td>
    <td class="codeline">        NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="codeline">       /   \</td>
    <td class="lineNumber">4744</td>
    <td class="codeline">       /   \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="codeline">     Zero  Inf</td>
    <td class="lineNumber">4745</td>
    <td class="codeline">     Zero  Inf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="codeline">       \   /</td>
    <td class="lineNumber">4746</td>
    <td class="codeline">       \   /</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="codeline">       Normal</td>
    <td class="lineNumber">4747</td>
    <td class="codeline">       Normal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="codeline"></td>
    <td class="lineNumber">4748</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="codeline">     e.g. NaN * NaN = NaN</td>
    <td class="lineNumber">4749</td>
    <td class="codeline">     e.g. NaN * NaN = NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class="codeline">          Zero * Inf = NaN</td>
    <td class="lineNumber">4750</td>
    <td class="codeline">          Zero * Inf = NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="codeline">          Normal * Zero = Zero</td>
    <td class="lineNumber">4751</td>
    <td class="codeline">          Normal * Zero = Zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="codeline">          Normal * Inf = Inf</td>
    <td class="lineNumber">4752</td>
    <td class="codeline">          Normal * Inf = Inf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="codeline">  */</td>
    <td class="lineNumber">4753</td>
    <td class="codeline">  */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="codeline">  if (LHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">4754</td>
    <td class="codeline">  if (LHS.getCategory() == fcNaN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="codeline">    Out = LHS;</td>
    <td class="lineNumber">4755</td>
    <td class="codeline">    Out = LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4756</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4757</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="codeline">  if (RHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">4758</td>
    <td class="codeline">  if (RHS.getCategory() == fcNaN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="codeline">    Out = RHS;</td>
    <td class="lineNumber">4759</td>
    <td class="codeline">    Out = RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4760</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4761</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="codeline">  if ((LHS.getCategory() == fcZero && RHS.getCategory() == fcInfinity) ||</td>
    <td class="lineNumber">4762</td>
    <td class="codeline">  if ((LHS.getCategory() == fcZero && RHS.getCategory() == fcInfinity) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="codeline">      (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcZero)) {</td>
    <td class="lineNumber">4763</td>
    <td class="codeline">      (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcZero)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="codeline">    Out.makeNaN(false, false, nullptr);</td>
    <td class="lineNumber">4764</td>
    <td class="codeline">    Out.makeNaN(false, false, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4765</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4766</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="codeline">  if (LHS.getCategory() == fcZero || LHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">4767</td>
    <td class="codeline">  if (LHS.getCategory() == fcZero || LHS.getCategory() == fcInfinity) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="codeline">    Out = LHS;</td>
    <td class="lineNumber">4768</td>
    <td class="codeline">    Out = LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4769</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4770</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="codeline">  if (RHS.getCategory() == fcZero || RHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">4771</td>
    <td class="codeline">  if (RHS.getCategory() == fcZero || RHS.getCategory() == fcInfinity) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="codeline">    Out = RHS;</td>
    <td class="lineNumber">4772</td>
    <td class="codeline">    Out = RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">4773</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4774</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="codeline">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal &&</td>
    <td class="lineNumber">4775</td>
    <td class="codeline">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="codeline">         "Special cases not handled exhaustively");</td>
    <td class="lineNumber">4776</td>
    <td class="codeline">         "Special cases not handled exhaustively");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="codeline"></td>
    <td class="lineNumber">4777</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="codeline">  int Status = opOK;</td>
    <td class="lineNumber">4778</td>
    <td class="codeline">  int Status = opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="codeline">  APFloat A = Floats[0], B = Floats[1], C = RHS.Floats[0], D = RHS.Floats[1];</td>
    <td class="lineNumber">4779</td>
    <td class="codeline">  APFloat A = Floats[0], B = Floats[1], C = RHS.Floats[0], D = RHS.Floats[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="codeline">  // t = a * c</td>
    <td class="lineNumber">4780</td>
    <td class="codeline">  // t = a * c</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="codeline">  APFloat T = A;</td>
    <td class="lineNumber">4781</td>
    <td class="codeline">  APFloat T = A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="codeline">  Status |= T.multiply(C, RM);</td>
    <td class="lineNumber">4782</td>
    <td class="codeline">  Status |= T.multiply(C, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="codeline">  if (!T.isFiniteNonZero()) {</td>
    <td class="lineNumber">4783</td>
    <td class="codeline">  if (!T.isFiniteNonZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="codeline">    Floats[0] = T;</td>
    <td class="lineNumber">4784</td>
    <td class="codeline">    Floats[0] = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="codeline">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4785</td>
    <td class="codeline">    Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="codeline">    return (opStatus)Status;</td>
    <td class="lineNumber">4786</td>
    <td class="codeline">    return (opStatus)Status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4787</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="codeline"></td>
    <td class="lineNumber">4788</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="codeline">  // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).</td>
    <td class="lineNumber">4789</td>
    <td class="codeline">  // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="codeline">  APFloat Tau = A;</td>
    <td class="lineNumber">4790</td>
    <td class="codeline">  APFloat Tau = A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="codeline">  T.changeSign();</td>
    <td class="lineNumber">4791</td>
    <td class="codeline">  T.changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="codeline">  Status |= Tau.fusedMultiplyAdd(C, T, RM);</td>
    <td class="lineNumber">4792</td>
    <td class="codeline">  Status |= Tau.fusedMultiplyAdd(C, T, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="codeline">  T.changeSign();</td>
    <td class="lineNumber">4793</td>
    <td class="codeline">  T.changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="codeline">  {</td>
    <td class="lineNumber">4794</td>
    <td class="codeline">  {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="codeline">    // v = a * d</td>
    <td class="lineNumber">4795</td>
    <td class="codeline">    // v = a * d</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="codeline">    APFloat V = A;</td>
    <td class="lineNumber">4796</td>
    <td class="codeline">    APFloat V = A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="codeline">    Status |= V.multiply(D, RM);</td>
    <td class="lineNumber">4797</td>
    <td class="codeline">    Status |= V.multiply(D, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="codeline">    // w = b * c</td>
    <td class="lineNumber">4798</td>
    <td class="codeline">    // w = b * c</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="codeline">    APFloat W = B;</td>
    <td class="lineNumber">4799</td>
    <td class="codeline">    APFloat W = B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="codeline">    Status |= W.multiply(C, RM);</td>
    <td class="lineNumber">4800</td>
    <td class="codeline">    Status |= W.multiply(C, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="codeline">    Status |= V.add(W, RM);</td>
    <td class="lineNumber">4801</td>
    <td class="codeline">    Status |= V.add(W, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="codeline">    // tau += v + w</td>
    <td class="lineNumber">4802</td>
    <td class="codeline">    // tau += v + w</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="codeline">    Status |= Tau.add(V, RM);</td>
    <td class="lineNumber">4803</td>
    <td class="codeline">    Status |= Tau.add(V, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4804</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="codeline">  // u = t + tau</td>
    <td class="lineNumber">4805</td>
    <td class="codeline">  // u = t + tau</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="codeline">  APFloat U = T;</td>
    <td class="lineNumber">4806</td>
    <td class="codeline">  APFloat U = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="codeline">  Status |= U.add(Tau, RM);</td>
    <td class="lineNumber">4807</td>
    <td class="codeline">  Status |= U.add(Tau, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class="codeline"></td>
    <td class="lineNumber">4808</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="codeline">  Floats[0] = U;</td>
    <td class="lineNumber">4809</td>
    <td class="codeline">  Floats[0] = U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="codeline">  if (!U.isFinite()) {</td>
    <td class="lineNumber">4810</td>
    <td class="codeline">  if (!U.isFinite()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="codeline">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4811</td>
    <td class="codeline">    Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">4812</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="codeline">    // Floats[1] = (t - u) + tau</td>
    <td class="lineNumber">4813</td>
    <td class="codeline">    // Floats[1] = (t - u) + tau</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="codeline">    Status |= T.subtract(U, RM);</td>
    <td class="lineNumber">4814</td>
    <td class="codeline">    Status |= T.subtract(U, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="codeline">    Status |= T.add(Tau, RM);</td>
    <td class="lineNumber">4815</td>
    <td class="codeline">    Status |= T.add(Tau, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="codeline">    Floats[1] = T;</td>
    <td class="lineNumber">4816</td>
    <td class="codeline">    Floats[1] = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4817</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="codeline">  return (opStatus)Status;</td>
    <td class="lineNumber">4818</td>
    <td class="codeline">  return (opStatus)Status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4819</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="codeline"></td>
    <td class="lineNumber">4820</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::divide(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">4821</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::divide(const DoubleAPFloat &RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="codeline">                                        APFloat::roundingMode RM) {</td>
    <td class="lineNumber">4822</td>
    <td class="codeline">                                        APFloat::roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4823</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">4824</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="codeline">  auto Ret =</td>
    <td class="lineNumber">4825</td>
    <td class="codeline">  auto Ret =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="codeline">      Tmp.divide(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()), RM);</td>
    <td class="lineNumber">4826</td>
    <td class="codeline">      Tmp.divide(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()), RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4827</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4828</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4829</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="codeline"></td>
    <td class="lineNumber">4830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::remainder(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">4831</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::remainder(const DoubleAPFloat &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4832</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">4833</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="codeline">  auto Ret =</td>
    <td class="lineNumber">4834</td>
    <td class="codeline">  auto Ret =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="codeline">      Tmp.remainder(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td class="lineNumber">4835</td>
    <td class="codeline">      Tmp.remainder(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4836</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4837</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4838</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class="codeline"></td>
    <td class="lineNumber">4839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::mod(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">4840</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::mod(const DoubleAPFloat &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4841</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">4842</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="codeline">  auto Ret = Tmp.mod(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td class="lineNumber">4843</td>
    <td class="codeline">  auto Ret = Tmp.mod(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4844</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4845</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4846</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class="codeline"></td>
    <td class="lineNumber">4847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="codeline">APFloat::opStatus</td>
    <td class="lineNumber">4848</td>
    <td class="codeline">APFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="codeline">DoubleAPFloat::fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,</td>
    <td class="lineNumber">4849</td>
    <td class="codeline">DoubleAPFloat::fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="codeline">                                const DoubleAPFloat &Addend,</td>
    <td class="lineNumber">4850</td>
    <td class="codeline">                                const DoubleAPFloat &Addend,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="codeline">                                APFloat::roundingMode RM) {</td>
    <td class="lineNumber">4851</td>
    <td class="codeline">                                APFloat::roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4852</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">4853</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="codeline">  auto Ret = Tmp.fusedMultiplyAdd(</td>
    <td class="lineNumber">4854</td>
    <td class="codeline">  auto Ret = Tmp.fusedMultiplyAdd(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="codeline">      APFloat(semPPCDoubleDoubleLegacy, Multiplicand.bitcastToAPInt()),</td>
    <td class="lineNumber">4855</td>
    <td class="codeline">      APFloat(semPPCDoubleDoubleLegacy, Multiplicand.bitcastToAPInt()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="codeline">      APFloat(semPPCDoubleDoubleLegacy, Addend.bitcastToAPInt()), RM);</td>
    <td class="lineNumber">4856</td>
    <td class="codeline">      APFloat(semPPCDoubleDoubleLegacy, Addend.bitcastToAPInt()), RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4857</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4858</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4859</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="codeline"></td>
    <td class="lineNumber">4860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::roundToIntegral(APFloat::roundingMode RM) {</td>
    <td class="lineNumber">4861</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::roundToIntegral(APFloat::roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4862</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">4863</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="codeline">  auto Ret = Tmp.roundToIntegral(RM);</td>
    <td class="lineNumber">4864</td>
    <td class="codeline">  auto Ret = Tmp.roundToIntegral(RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4865</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4866</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4867</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="codeline"></td>
    <td class="lineNumber">4868</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="codeline">void DoubleAPFloat::changeSign() {</td>
    <td class="lineNumber">4869</td>
    <td class="codeline">void DoubleAPFloat::changeSign() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="codeline">  Floats[0].changeSign();</td>
    <td class="lineNumber">4870</td>
    <td class="codeline">  Floats[0].changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="codeline">  Floats[1].changeSign();</td>
    <td class="lineNumber">4871</td>
    <td class="codeline">  Floats[1].changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4872</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="codeline"></td>
    <td class="lineNumber">4873</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="codeline">APFloat::cmpResult</td>
    <td class="lineNumber">4874</td>
    <td class="codeline">APFloat::cmpResult</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="codeline">DoubleAPFloat::compareAbsoluteValue(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">4875</td>
    <td class="codeline">DoubleAPFloat::compareAbsoluteValue(const DoubleAPFloat &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="codeline">  auto Result = Floats[0].compareAbsoluteValue(RHS.Floats[0]);</td>
    <td class="lineNumber">4876</td>
    <td class="codeline">  auto Result = Floats[0].compareAbsoluteValue(RHS.Floats[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="codeline">  if (Result != cmpEqual)</td>
    <td class="lineNumber">4877</td>
    <td class="codeline">  if (Result != cmpEqual)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="codeline">    return Result;</td>
    <td class="lineNumber">4878</td>
    <td class="codeline">    return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="codeline">  Result = Floats[1].compareAbsoluteValue(RHS.Floats[1]);</td>
    <td class="lineNumber">4879</td>
    <td class="codeline">  Result = Floats[1].compareAbsoluteValue(RHS.Floats[1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="codeline">  if (Result == cmpLessThan || Result == cmpGreaterThan) {</td>
    <td class="lineNumber">4880</td>
    <td class="codeline">  if (Result == cmpLessThan || Result == cmpGreaterThan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="codeline">    auto Against = Floats[0].isNegative() ^ Floats[1].isNegative();</td>
    <td class="lineNumber">4881</td>
    <td class="codeline">    auto Against = Floats[0].isNegative() ^ Floats[1].isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="codeline">    auto RHSAgainst = RHS.Floats[0].isNegative() ^ RHS.Floats[1].isNegative();</td>
    <td class="lineNumber">4882</td>
    <td class="codeline">    auto RHSAgainst = RHS.Floats[0].isNegative() ^ RHS.Floats[1].isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="codeline">    if (Against && !RHSAgainst)</td>
    <td class="lineNumber">4883</td>
    <td class="codeline">    if (Against && !RHSAgainst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="codeline">      return cmpLessThan;</td>
    <td class="lineNumber">4884</td>
    <td class="codeline">      return cmpLessThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="codeline">    if (!Against && RHSAgainst)</td>
    <td class="lineNumber">4885</td>
    <td class="codeline">    if (!Against && RHSAgainst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="codeline">      return cmpGreaterThan;</td>
    <td class="lineNumber">4886</td>
    <td class="codeline">      return cmpGreaterThan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="codeline">    if (!Against && !RHSAgainst)</td>
    <td class="lineNumber">4887</td>
    <td class="codeline">    if (!Against && !RHSAgainst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="codeline">      return Result;</td>
    <td class="lineNumber">4888</td>
    <td class="codeline">      return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="codeline">    if (Against && RHSAgainst)</td>
    <td class="lineNumber">4889</td>
    <td class="codeline">    if (Against && RHSAgainst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="codeline">      return (cmpResult)(cmpLessThan + cmpGreaterThan - Result);</td>
    <td class="lineNumber">4890</td>
    <td class="codeline">      return (cmpResult)(cmpLessThan + cmpGreaterThan - Result);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4891</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">4892</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4893</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="codeline"></td>
    <td class="lineNumber">4894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="codeline">APFloat::fltCategory DoubleAPFloat::getCategory() const {</td>
    <td class="lineNumber">4895</td>
    <td class="codeline">APFloat::fltCategory DoubleAPFloat::getCategory() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="codeline">  return Floats[0].getCategory();</td>
    <td class="lineNumber">4896</td>
    <td class="codeline">  return Floats[0].getCategory();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4897</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="codeline"></td>
    <td class="lineNumber">4898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="codeline">bool DoubleAPFloat::isNegative() const { return Floats[0].isNegative(); }</td>
    <td class="lineNumber">4899</td>
    <td class="codeline">bool DoubleAPFloat::isNegative() const { return Floats[0].isNegative(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="codeline"></td>
    <td class="lineNumber">4900</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="codeline">void DoubleAPFloat::makeInf(bool Neg) {</td>
    <td class="lineNumber">4901</td>
    <td class="codeline">void DoubleAPFloat::makeInf(bool Neg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="codeline">  Floats[0].makeInf(Neg);</td>
    <td class="lineNumber">4902</td>
    <td class="codeline">  Floats[0].makeInf(Neg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4903</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4904</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="codeline"></td>
    <td class="lineNumber">4905</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="codeline">void DoubleAPFloat::makeZero(bool Neg) {</td>
    <td class="lineNumber">4906</td>
    <td class="codeline">void DoubleAPFloat::makeZero(bool Neg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="codeline">  Floats[0].makeZero(Neg);</td>
    <td class="lineNumber">4907</td>
    <td class="codeline">  Floats[0].makeZero(Neg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4908</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4909</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="codeline"></td>
    <td class="lineNumber">4910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="codeline">void DoubleAPFloat::makeLargest(bool Neg) {</td>
    <td class="lineNumber">4911</td>
    <td class="codeline">void DoubleAPFloat::makeLargest(bool Neg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4912</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="codeline">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x7fefffffffffffffull));</td>
    <td class="lineNumber">4913</td>
    <td class="codeline">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x7fefffffffffffffull));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="codeline">  Floats[1] = APFloat(semIEEEdouble, APInt(64, 0x7c8ffffffffffffeull));</td>
    <td class="lineNumber">4914</td>
    <td class="codeline">  Floats[1] = APFloat(semIEEEdouble, APInt(64, 0x7c8ffffffffffffeull));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="codeline">  if (Neg)</td>
    <td class="lineNumber">4915</td>
    <td class="codeline">  if (Neg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="codeline">    changeSign();</td>
    <td class="lineNumber">4916</td>
    <td class="codeline">    changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4917</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="codeline"></td>
    <td class="lineNumber">4918</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="codeline">void DoubleAPFloat::makeSmallest(bool Neg) {</td>
    <td class="lineNumber">4919</td>
    <td class="codeline">void DoubleAPFloat::makeSmallest(bool Neg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4920</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="codeline">  Floats[0].makeSmallest(Neg);</td>
    <td class="lineNumber">4921</td>
    <td class="codeline">  Floats[0].makeSmallest(Neg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4922</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4923</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class="codeline"></td>
    <td class="lineNumber">4924</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="codeline">void DoubleAPFloat::makeSmallestNormalized(bool Neg) {</td>
    <td class="lineNumber">4925</td>
    <td class="codeline">void DoubleAPFloat::makeSmallestNormalized(bool Neg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4926</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="codeline">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x0360000000000000ull));</td>
    <td class="lineNumber">4927</td>
    <td class="codeline">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x0360000000000000ull));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="codeline">  if (Neg)</td>
    <td class="lineNumber">4928</td>
    <td class="codeline">  if (Neg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="codeline">    Floats[0].changeSign();</td>
    <td class="lineNumber">4929</td>
    <td class="codeline">    Floats[0].changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4930</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4931</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="codeline"></td>
    <td class="lineNumber">4932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="codeline">void DoubleAPFloat::makeNaN(bool SNaN, bool Neg, const APInt *fill) {</td>
    <td class="lineNumber">4933</td>
    <td class="codeline">void DoubleAPFloat::makeNaN(bool SNaN, bool Neg, const APInt *fill) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="codeline">  Floats[0].makeNaN(SNaN, Neg, fill);</td>
    <td class="lineNumber">4934</td>
    <td class="codeline">  Floats[0].makeNaN(SNaN, Neg, fill);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">4935</td>
    <td class="codeline">  Floats[1].makeZero(/* Neg = */ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4936</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class="codeline"></td>
    <td class="lineNumber">4937</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="codeline">APFloat::cmpResult DoubleAPFloat::compare(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">4938</td>
    <td class="codeline">APFloat::cmpResult DoubleAPFloat::compare(const DoubleAPFloat &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="codeline">  auto Result = Floats[0].compare(RHS.Floats[0]);</td>
    <td class="lineNumber">4939</td>
    <td class="codeline">  auto Result = Floats[0].compare(RHS.Floats[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="codeline">  // |Float[0]| > |Float[1]|</td>
    <td class="lineNumber">4940</td>
    <td class="codeline">  // |Float[0]| > |Float[1]|</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="codeline">  if (Result == APFloat::cmpEqual)</td>
    <td class="lineNumber">4941</td>
    <td class="codeline">  if (Result == APFloat::cmpEqual)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="codeline">    return Floats[1].compare(RHS.Floats[1]);</td>
    <td class="lineNumber">4942</td>
    <td class="codeline">    return Floats[1].compare(RHS.Floats[1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">4943</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4944</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="codeline"></td>
    <td class="lineNumber">4945</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="codeline">bool DoubleAPFloat::bitwiseIsEqual(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">4946</td>
    <td class="codeline">bool DoubleAPFloat::bitwiseIsEqual(const DoubleAPFloat &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="codeline">  return Floats[0].bitwiseIsEqual(RHS.Floats[0]) &&</td>
    <td class="lineNumber">4947</td>
    <td class="codeline">  return Floats[0].bitwiseIsEqual(RHS.Floats[0]) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="codeline">         Floats[1].bitwiseIsEqual(RHS.Floats[1]);</td>
    <td class="lineNumber">4948</td>
    <td class="codeline">         Floats[1].bitwiseIsEqual(RHS.Floats[1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4949</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class="codeline"></td>
    <td class="lineNumber">4950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="codeline">hash_code hash_value(const DoubleAPFloat &Arg) {</td>
    <td class="lineNumber">4951</td>
    <td class="codeline">hash_code hash_value(const DoubleAPFloat &Arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="codeline">  if (Arg.Floats)</td>
    <td class="lineNumber">4952</td>
    <td class="codeline">  if (Arg.Floats)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="codeline">    return hash_combine(hash_value(Arg.Floats[0]), hash_value(Arg.Floats[1]));</td>
    <td class="lineNumber">4953</td>
    <td class="codeline">    return hash_combine(hash_value(Arg.Floats[0]), hash_value(Arg.Floats[1]));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="codeline">  return hash_combine(Arg.Semantics);</td>
    <td class="lineNumber">4954</td>
    <td class="codeline">  return hash_combine(Arg.Semantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4955</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class="codeline"></td>
    <td class="lineNumber">4956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="codeline">APInt DoubleAPFloat::bitcastToAPInt() const {</td>
    <td class="lineNumber">4957</td>
    <td class="codeline">APInt DoubleAPFloat::bitcastToAPInt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4958</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="codeline">  uint64_t Data[] = {</td>
    <td class="lineNumber">4959</td>
    <td class="codeline">  uint64_t Data[] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="codeline">      Floats[0].bitcastToAPInt().getRawData()[0],</td>
    <td class="lineNumber">4960</td>
    <td class="codeline">      Floats[0].bitcastToAPInt().getRawData()[0],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="codeline">      Floats[1].bitcastToAPInt().getRawData()[0],</td>
    <td class="lineNumber">4961</td>
    <td class="codeline">      Floats[1].bitcastToAPInt().getRawData()[0],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4962</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="codeline">  return APInt(128, 2, Data);</td>
    <td class="lineNumber">4963</td>
    <td class="codeline">  return APInt(128, 2, Data);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4964</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class="codeline"></td>
    <td class="lineNumber">4965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="codeline">Expected<APFloat::opStatus> DoubleAPFloat::convertFromString(StringRef S,</td>
    <td class="lineNumber">4966</td>
    <td class="codeline">Expected<APFloat::opStatus> DoubleAPFloat::convertFromString(StringRef S,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="codeline">                                                             roundingMode RM) {</td>
    <td class="lineNumber">4967</td>
    <td class="codeline">                                                             roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4968</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">4969</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="codeline">  auto Ret = Tmp.convertFromString(S, RM);</td>
    <td class="lineNumber">4970</td>
    <td class="codeline">  auto Ret = Tmp.convertFromString(S, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4971</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4972</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4973</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class="codeline"></td>
    <td class="lineNumber">4974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::next(bool nextDown) {</td>
    <td class="lineNumber">4975</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::next(bool nextDown) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4976</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">4977</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="codeline">  auto Ret = Tmp.next(nextDown);</td>
    <td class="lineNumber">4978</td>
    <td class="codeline">  auto Ret = Tmp.next(nextDown);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4979</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4980</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4981</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="codeline"></td>
    <td class="lineNumber">4982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="codeline">APFloat::opStatus</td>
    <td class="lineNumber">4983</td>
    <td class="codeline">APFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="codeline">DoubleAPFloat::convertToInteger(MutableArrayRef<integerPart> Input,</td>
    <td class="lineNumber">4984</td>
    <td class="codeline">DoubleAPFloat::convertToInteger(MutableArrayRef<integerPart> Input,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="codeline">                                unsigned int Width, bool IsSigned,</td>
    <td class="lineNumber">4985</td>
    <td class="codeline">                                unsigned int Width, bool IsSigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="codeline">                                roundingMode RM, bool *IsExact) const {</td>
    <td class="lineNumber">4986</td>
    <td class="codeline">                                roundingMode RM, bool *IsExact) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4987</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="codeline">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">4988</td>
    <td class="codeline">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="codeline">      .convertToInteger(Input, Width, IsSigned, RM, IsExact);</td>
    <td class="lineNumber">4989</td>
    <td class="codeline">      .convertToInteger(Input, Width, IsSigned, RM, IsExact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4990</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="codeline"></td>
    <td class="lineNumber">4991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::convertFromAPInt(const APInt &Input,</td>
    <td class="lineNumber">4992</td>
    <td class="codeline">APFloat::opStatus DoubleAPFloat::convertFromAPInt(const APInt &Input,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="codeline">                                                  bool IsSigned,</td>
    <td class="lineNumber">4993</td>
    <td class="codeline">                                                  bool IsSigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="codeline">                                                  roundingMode RM) {</td>
    <td class="lineNumber">4994</td>
    <td class="codeline">                                                  roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">4995</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">4996</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="codeline">  auto Ret = Tmp.convertFromAPInt(Input, IsSigned, RM);</td>
    <td class="lineNumber">4997</td>
    <td class="codeline">  auto Ret = Tmp.convertFromAPInt(Input, IsSigned, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">4998</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">4999</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5000</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="codeline"></td>
    <td class="lineNumber">5001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="codeline">APFloat::opStatus</td>
    <td class="lineNumber">5002</td>
    <td class="codeline">APFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="codeline">DoubleAPFloat::convertFromSignExtendedInteger(const integerPart *Input,</td>
    <td class="lineNumber">5003</td>
    <td class="codeline">DoubleAPFloat::convertFromSignExtendedInteger(const integerPart *Input,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="codeline">                                              unsigned int InputSize,</td>
    <td class="lineNumber">5004</td>
    <td class="codeline">                                              unsigned int InputSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="codeline">                                              bool IsSigned, roundingMode RM) {</td>
    <td class="lineNumber">5005</td>
    <td class="codeline">                                              bool IsSigned, roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5006</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">5007</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="codeline">  auto Ret = Tmp.convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td class="lineNumber">5008</td>
    <td class="codeline">  auto Ret = Tmp.convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">5009</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">5010</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5011</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="codeline"></td>
    <td class="lineNumber">5012</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="codeline">APFloat::opStatus</td>
    <td class="lineNumber">5013</td>
    <td class="codeline">APFloat::opStatus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="codeline">DoubleAPFloat::convertFromZeroExtendedInteger(const integerPart *Input,</td>
    <td class="lineNumber">5014</td>
    <td class="codeline">DoubleAPFloat::convertFromZeroExtendedInteger(const integerPart *Input,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="codeline">                                              unsigned int InputSize,</td>
    <td class="lineNumber">5015</td>
    <td class="codeline">                                              unsigned int InputSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="codeline">                                              bool IsSigned, roundingMode RM) {</td>
    <td class="lineNumber">5016</td>
    <td class="codeline">                                              bool IsSigned, roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5017</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">5018</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="codeline">  auto Ret = Tmp.convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td class="lineNumber">5019</td>
    <td class="codeline">  auto Ret = Tmp.convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">5020</td>
    <td class="codeline">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">5021</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5022</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="codeline"></td>
    <td class="lineNumber">5023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="codeline">unsigned int DoubleAPFloat::convertToHexString(char *DST,</td>
    <td class="lineNumber">5024</td>
    <td class="codeline">unsigned int DoubleAPFloat::convertToHexString(char *DST,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class="codeline">                                               unsigned int HexDigits,</td>
    <td class="lineNumber">5025</td>
    <td class="codeline">                                               unsigned int HexDigits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="codeline">                                               bool UpperCase,</td>
    <td class="lineNumber">5026</td>
    <td class="codeline">                                               bool UpperCase,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="codeline">                                               roundingMode RM) const {</td>
    <td class="lineNumber">5027</td>
    <td class="codeline">                                               roundingMode RM) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5028</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="codeline">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">5029</td>
    <td class="codeline">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="codeline">      .convertToHexString(DST, HexDigits, UpperCase, RM);</td>
    <td class="lineNumber">5030</td>
    <td class="codeline">      .convertToHexString(DST, HexDigits, UpperCase, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5031</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="codeline"></td>
    <td class="lineNumber">5032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class="codeline">bool DoubleAPFloat::isDenormal() const {</td>
    <td class="lineNumber">5033</td>
    <td class="codeline">bool DoubleAPFloat::isDenormal() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="codeline">  return getCategory() == fcNormal &&</td>
    <td class="lineNumber">5034</td>
    <td class="codeline">  return getCategory() == fcNormal &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="codeline">         (Floats[0].isDenormal() || Floats[1].isDenormal() ||</td>
    <td class="lineNumber">5035</td>
    <td class="codeline">         (Floats[0].isDenormal() || Floats[1].isDenormal() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="codeline">          // (double)(Hi + Lo) == Hi defines a normal number.</td>
    <td class="lineNumber">5036</td>
    <td class="codeline">          // (double)(Hi + Lo) == Hi defines a normal number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="codeline">          Floats[0] != Floats[0] + Floats[1]);</td>
    <td class="lineNumber">5037</td>
    <td class="codeline">          Floats[0] != Floats[0] + Floats[1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5038</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="codeline"></td>
    <td class="lineNumber">5039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="codeline">bool DoubleAPFloat::isSmallest() const {</td>
    <td class="lineNumber">5040</td>
    <td class="codeline">bool DoubleAPFloat::isSmallest() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="codeline">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">5041</td>
    <td class="codeline">  if (getCategory() != fcNormal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">5042</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="codeline">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">5043</td>
    <td class="codeline">  DoubleAPFloat Tmp(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="codeline">  Tmp.makeSmallest(this->isNegative());</td>
    <td class="lineNumber">5044</td>
    <td class="codeline">  Tmp.makeSmallest(this->isNegative());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="codeline">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">5045</td>
    <td class="codeline">  return Tmp.compare(*this) == cmpEqual;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5046</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="codeline"></td>
    <td class="lineNumber">5047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="codeline">bool DoubleAPFloat::isSmallestNormalized() const {</td>
    <td class="lineNumber">5048</td>
    <td class="codeline">bool DoubleAPFloat::isSmallestNormalized() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="codeline">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">5049</td>
    <td class="codeline">  if (getCategory() != fcNormal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">5050</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class="codeline"></td>
    <td class="lineNumber">5051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="codeline">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">5052</td>
    <td class="codeline">  DoubleAPFloat Tmp(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="codeline">  Tmp.makeSmallestNormalized(this->isNegative());</td>
    <td class="lineNumber">5053</td>
    <td class="codeline">  Tmp.makeSmallestNormalized(this->isNegative());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="codeline">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">5054</td>
    <td class="codeline">  return Tmp.compare(*this) == cmpEqual;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5055</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="codeline"></td>
    <td class="lineNumber">5056</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="codeline">bool DoubleAPFloat::isLargest() const {</td>
    <td class="lineNumber">5057</td>
    <td class="codeline">bool DoubleAPFloat::isLargest() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="codeline">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">5058</td>
    <td class="codeline">  if (getCategory() != fcNormal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">5059</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="codeline">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">5060</td>
    <td class="codeline">  DoubleAPFloat Tmp(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="codeline">  Tmp.makeLargest(this->isNegative());</td>
    <td class="lineNumber">5061</td>
    <td class="codeline">  Tmp.makeLargest(this->isNegative());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="codeline">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">5062</td>
    <td class="codeline">  return Tmp.compare(*this) == cmpEqual;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5063</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="codeline"></td>
    <td class="lineNumber">5064</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="codeline">bool DoubleAPFloat::isInteger() const {</td>
    <td class="lineNumber">5065</td>
    <td class="codeline">bool DoubleAPFloat::isInteger() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5066</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="codeline">  return Floats[0].isInteger() && Floats[1].isInteger();</td>
    <td class="lineNumber">5067</td>
    <td class="codeline">  return Floats[0].isInteger() && Floats[1].isInteger();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5068</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class="codeline"></td>
    <td class="lineNumber">5069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="codeline">void DoubleAPFloat::toString(SmallVectorImpl<char> &Str,</td>
    <td class="lineNumber">5070</td>
    <td class="codeline">void DoubleAPFloat::toString(SmallVectorImpl<char> &Str,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="codeline">                             unsigned FormatPrecision,</td>
    <td class="lineNumber">5071</td>
    <td class="codeline">                             unsigned FormatPrecision,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="codeline">                             unsigned FormatMaxPadding,</td>
    <td class="lineNumber">5072</td>
    <td class="codeline">                             unsigned FormatMaxPadding,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="codeline">                             bool TruncateZero) const {</td>
    <td class="lineNumber">5073</td>
    <td class="codeline">                             bool TruncateZero) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5074</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="codeline">  APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">5075</td>
    <td class="codeline">  APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="codeline">      .toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero);</td>
    <td class="lineNumber">5076</td>
    <td class="codeline">      .toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5077</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class="codeline"></td>
    <td class="lineNumber">5078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="codeline">bool DoubleAPFloat::getExactInverse(APFloat *inv) const {</td>
    <td class="lineNumber">5079</td>
    <td class="codeline">bool DoubleAPFloat::getExactInverse(APFloat *inv) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5080</td>
    <td class="codeline">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">5081</td>
    <td class="codeline">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="codeline">  if (!inv)</td>
    <td class="lineNumber">5082</td>
    <td class="codeline">  if (!inv)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="codeline">    return Tmp.getExactInverse(nullptr);</td>
    <td class="lineNumber">5083</td>
    <td class="codeline">    return Tmp.getExactInverse(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="codeline">  APFloat Inv(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">5084</td>
    <td class="codeline">  APFloat Inv(semPPCDoubleDoubleLegacy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="codeline">  auto Ret = Tmp.getExactInverse(&Inv);</td>
    <td class="lineNumber">5085</td>
    <td class="codeline">  auto Ret = Tmp.getExactInverse(&Inv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="codeline">  *inv = APFloat(semPPCDoubleDouble, Inv.bitcastToAPInt());</td>
    <td class="lineNumber">5086</td>
    <td class="codeline">  *inv = APFloat(semPPCDoubleDouble, Inv.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">5087</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5088</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class="codeline"></td>
    <td class="lineNumber">5089</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="codeline">DoubleAPFloat scalbn(const DoubleAPFloat &Arg, int Exp,</td>
    <td class="lineNumber">5090</td>
    <td class="codeline">DoubleAPFloat scalbn(const DoubleAPFloat &Arg, int Exp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="codeline">                     APFloat::roundingMode RM) {</td>
    <td class="lineNumber">5091</td>
    <td class="codeline">                     APFloat::roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="codeline">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5092</td>
    <td class="codeline">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="codeline">  return DoubleAPFloat(semPPCDoubleDouble, scalbn(Arg.Floats[0], Exp, RM),</td>
    <td class="lineNumber">5093</td>
    <td class="codeline">  return DoubleAPFloat(semPPCDoubleDouble, scalbn(Arg.Floats[0], Exp, RM),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="codeline">                       scalbn(Arg.Floats[1], Exp, RM));</td>
    <td class="lineNumber">5094</td>
    <td class="codeline">                       scalbn(Arg.Floats[1], Exp, RM));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5095</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="codeline"></td>
    <td class="lineNumber">5096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="codeline">DoubleAPFloat frexp(const DoubleAPFloat &Arg, int &Exp,</td>
    <td class="lineNumber">5097</td>
    <td class="codeline">DoubleAPFloat frexp(const DoubleAPFloat &Arg, int &Exp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="codeline">                    APFloat::roundingMode RM) {</td>
    <td class="lineNumber">5098</td>
    <td class="codeline">                    APFloat::roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="codeline">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">5099</td>
    <td class="codeline">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="codeline">  APFloat First = frexp(Arg.Floats[0], Exp, RM);</td>
    <td class="lineNumber">5100</td>
    <td class="codeline">  APFloat First = frexp(Arg.Floats[0], Exp, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="codeline">  APFloat Second = Arg.Floats[1];</td>
    <td class="lineNumber">5101</td>
    <td class="codeline">  APFloat Second = Arg.Floats[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="codeline">  if (Arg.getCategory() == APFloat::fcNormal)</td>
    <td class="lineNumber">5102</td>
    <td class="codeline">  if (Arg.getCategory() == APFloat::fcNormal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="codeline">    Second = scalbn(Second, -Exp, RM);</td>
    <td class="lineNumber">5103</td>
    <td class="codeline">    Second = scalbn(Second, -Exp, RM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="codeline">  return DoubleAPFloat(semPPCDoubleDouble, std::move(First), std::move(Second));</td>
    <td class="lineNumber">5104</td>
    <td class="codeline">  return DoubleAPFloat(semPPCDoubleDouble, std::move(First), std::move(Second));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5105</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="codeline"></td>
    <td class="lineNumber">5106</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">5107</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class="codeline"></td>
    <td class="lineNumber">5108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="codeline">APFloat::Storage::Storage(IEEEFloat F, const fltSemantics &Semantics) {</td>
    <td class="lineNumber">5109</td>
    <td class="codeline">APFloat::Storage::Storage(IEEEFloat F, const fltSemantics &Semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="codeline">  if (usesLayout<IEEEFloat>(Semantics)) {</td>
    <td class="lineNumber">5110</td>
    <td class="codeline">  if (usesLayout<IEEEFloat>(Semantics)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="codeline">    new (&IEEE) IEEEFloat(std::move(F));</td>
    <td class="lineNumber">5111</td>
    <td class="codeline">    new (&IEEE) IEEEFloat(std::move(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">5112</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5113</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class="codeline">  if (usesLayout<DoubleAPFloat>(Semantics)) {</td>
    <td class="lineNumber">5114</td>
    <td class="codeline">  if (usesLayout<DoubleAPFloat>(Semantics)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="codeline">    const fltSemantics& S = F.getSemantics();</td>
    <td class="lineNumber">5115</td>
    <td class="codeline">    const fltSemantics& S = F.getSemantics();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="codeline">    new (&Double)</td>
    <td class="lineNumber">5116</td>
    <td class="codeline">    new (&Double)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="codeline">        DoubleAPFloat(Semantics, APFloat(std::move(F), S),</td>
    <td class="lineNumber">5117</td>
    <td class="codeline">        DoubleAPFloat(Semantics, APFloat(std::move(F), S),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="codeline">                      APFloat(semIEEEdouble));</td>
    <td class="lineNumber">5118</td>
    <td class="codeline">                      APFloat(semIEEEdouble));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">5119</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5120</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="codeline">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">5121</td>
    <td class="codeline">  llvm_unreachable("Unexpected semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5122</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="codeline"></td>
    <td class="lineNumber">5123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="codeline">Expected<APFloat::opStatus> APFloat::convertFromString(StringRef Str,</td>
    <td class="lineNumber">5124</td>
    <td class="codeline">Expected<APFloat::opStatus> APFloat::convertFromString(StringRef Str,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="codeline">                                                       roundingMode RM) {</td>
    <td class="lineNumber">5125</td>
    <td class="codeline">                                                       roundingMode RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="codeline">  APFLOAT_DISPATCH_ON_SEMANTICS(convertFromString(Str, RM));</td>
    <td class="lineNumber">5126</td>
    <td class="codeline">  APFLOAT_DISPATCH_ON_SEMANTICS(convertFromString(Str, RM));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5127</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="codeline"></td>
    <td class="lineNumber">5128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="codeline">hash_code hash_value(const APFloat &Arg) {</td>
    <td class="lineNumber">5129</td>
    <td class="codeline">hash_code hash_value(const APFloat &Arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="codeline">  if (APFloat::usesLayout<detail::IEEEFloat>(Arg.getSemantics()))</td>
    <td class="lineNumber">5130</td>
    <td class="codeline">  if (APFloat::usesLayout<detail::IEEEFloat>(Arg.getSemantics()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="codeline">    return hash_value(Arg.U.IEEE);</td>
    <td class="lineNumber">5131</td>
    <td class="codeline">    return hash_value(Arg.U.IEEE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="codeline">  if (APFloat::usesLayout<detail::DoubleAPFloat>(Arg.getSemantics()))</td>
    <td class="lineNumber">5132</td>
    <td class="codeline">  if (APFloat::usesLayout<detail::DoubleAPFloat>(Arg.getSemantics()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="codeline">    return hash_value(Arg.U.Double);</td>
    <td class="lineNumber">5133</td>
    <td class="codeline">    return hash_value(Arg.U.Double);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="codeline">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">5134</td>
    <td class="codeline">  llvm_unreachable("Unexpected semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5135</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class="codeline"></td>
    <td class="lineNumber">5136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="codeline">APFloat::APFloat(const fltSemantics &Semantics, StringRef S)</td>
    <td class="lineNumber">5137</td>
    <td class="codeline">APFloat::APFloat(const fltSemantics &Semantics, StringRef S)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="codeline">    : APFloat(Semantics) {</td>
    <td class="lineNumber">5138</td>
    <td class="codeline">    : APFloat(Semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="codeline">  auto StatusOrErr = convertFromString(S, rmNearestTiesToEven);</td>
    <td class="lineNumber">5139</td>
    <td class="codeline">  auto StatusOrErr = convertFromString(S, rmNearestTiesToEven);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="codeline">  assert(StatusOrErr && "Invalid floating point representation");</td>
    <td class="lineNumber">5140</td>
    <td class="codeline">  assert(StatusOrErr && "Invalid floating point representation");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="codeline">  consumeError(StatusOrErr.takeError());</td>
    <td class="lineNumber">5141</td>
    <td class="codeline">  consumeError(StatusOrErr.takeError());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5142</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="codeline"></td>
    <td class="lineNumber">5143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="codeline">FPClassTest APFloat::classify() const {</td>
    <td class="lineNumber">5144</td>
    <td class="codeline">FPClassTest APFloat::classify() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class="codeline">  if (isZero())</td>
    <td class="lineNumber">5145</td>
    <td class="codeline">  if (isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="codeline">    return isNegative() ? fcNegZero : fcPosZero;</td>
    <td class="lineNumber">5146</td>
    <td class="codeline">    return isNegative() ? fcNegZero : fcPosZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="codeline">  if (isNormal())</td>
    <td class="lineNumber">5147</td>
    <td class="codeline">  if (isNormal())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="codeline">    return isNegative() ? fcNegNormal : fcPosNormal;</td>
    <td class="lineNumber">5148</td>
    <td class="codeline">    return isNegative() ? fcNegNormal : fcPosNormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="codeline">  if (isDenormal())</td>
    <td class="lineNumber">5149</td>
    <td class="codeline">  if (isDenormal())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="codeline">    return isNegative() ? fcNegSubnormal : fcPosSubnormal;</td>
    <td class="lineNumber">5150</td>
    <td class="codeline">    return isNegative() ? fcNegSubnormal : fcPosSubnormal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="codeline">  if (isInfinity())</td>
    <td class="lineNumber">5151</td>
    <td class="codeline">  if (isInfinity())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="codeline">    return isNegative() ? fcNegInf : fcPosInf;</td>
    <td class="lineNumber">5152</td>
    <td class="codeline">    return isNegative() ? fcNegInf : fcPosInf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="codeline">  assert(isNaN() && "Other class of FP constant");</td>
    <td class="lineNumber">5153</td>
    <td class="codeline">  assert(isNaN() && "Other class of FP constant");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="codeline">  return isSignaling() ? fcSNan : fcQNan;</td>
    <td class="lineNumber">5154</td>
    <td class="codeline">  return isSignaling() ? fcSNan : fcQNan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5155</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class="codeline"></td>
    <td class="lineNumber">5156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="codeline">APFloat::opStatus APFloat::convert(const fltSemantics &ToSemantics,</td>
    <td class="lineNumber">5157</td>
    <td class="codeline">APFloat::opStatus APFloat::convert(const fltSemantics &ToSemantics,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="codeline">                                   roundingMode RM, bool *losesInfo) {</td>
    <td class="lineNumber">5158</td>
    <td class="codeline">                                   roundingMode RM, bool *losesInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="codeline">  if (&getSemantics() == &ToSemantics) {</td>
    <td class="lineNumber">5159</td>
    <td class="codeline">  if (&getSemantics() == &ToSemantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="codeline">    *losesInfo = false;</td>
    <td class="lineNumber">5160</td>
    <td class="codeline">    *losesInfo = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="codeline">    return opOK;</td>
    <td class="lineNumber">5161</td>
    <td class="codeline">    return opOK;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5162</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class="codeline">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td class="lineNumber">5163</td>
    <td class="codeline">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="codeline">      usesLayout<IEEEFloat>(ToSemantics))</td>
    <td class="lineNumber">5164</td>
    <td class="codeline">      usesLayout<IEEEFloat>(ToSemantics))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="codeline">    return U.IEEE.convert(ToSemantics, RM, losesInfo);</td>
    <td class="lineNumber">5165</td>
    <td class="codeline">    return U.IEEE.convert(ToSemantics, RM, losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="codeline">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td class="lineNumber">5166</td>
    <td class="codeline">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="codeline">      usesLayout<DoubleAPFloat>(ToSemantics)) {</td>
    <td class="lineNumber">5167</td>
    <td class="codeline">      usesLayout<DoubleAPFloat>(ToSemantics)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="codeline">    assert(&ToSemantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">5168</td>
    <td class="codeline">    assert(&ToSemantics == &semPPCDoubleDouble);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="codeline">    auto Ret = U.IEEE.convert(semPPCDoubleDoubleLegacy, RM, losesInfo);</td>
    <td class="lineNumber">5169</td>
    <td class="codeline">    auto Ret = U.IEEE.convert(semPPCDoubleDoubleLegacy, RM, losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="codeline">    *this = APFloat(ToSemantics, U.IEEE.bitcastToAPInt());</td>
    <td class="lineNumber">5170</td>
    <td class="codeline">    *this = APFloat(ToSemantics, U.IEEE.bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class="codeline">    return Ret;</td>
    <td class="lineNumber">5171</td>
    <td class="codeline">    return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5172</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="codeline">  if (usesLayout<DoubleAPFloat>(getSemantics()) &&</td>
    <td class="lineNumber">5173</td>
    <td class="codeline">  if (usesLayout<DoubleAPFloat>(getSemantics()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="codeline">      usesLayout<IEEEFloat>(ToSemantics)) {</td>
    <td class="lineNumber">5174</td>
    <td class="codeline">      usesLayout<IEEEFloat>(ToSemantics)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class="codeline">    auto Ret = getIEEE().convert(ToSemantics, RM, losesInfo);</td>
    <td class="lineNumber">5175</td>
    <td class="codeline">    auto Ret = getIEEE().convert(ToSemantics, RM, losesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="codeline">    *this = APFloat(std::move(getIEEE()), ToSemantics);</td>
    <td class="lineNumber">5176</td>
    <td class="codeline">    *this = APFloat(std::move(getIEEE()), ToSemantics);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="codeline">    return Ret;</td>
    <td class="lineNumber">5177</td>
    <td class="codeline">    return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5178</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="codeline">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">5179</td>
    <td class="codeline">  llvm_unreachable("Unexpected semantics");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5180</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class="codeline"></td>
    <td class="lineNumber">5181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="codeline">APFloat APFloat::getAllOnesValue(const fltSemantics &Semantics) {</td>
    <td class="lineNumber">5182</td>
    <td class="codeline">APFloat APFloat::getAllOnesValue(const fltSemantics &Semantics) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="codeline">  return APFloat(Semantics, APInt::getAllOnes(Semantics.sizeInBits));</td>
    <td class="lineNumber">5183</td>
    <td class="codeline">  return APFloat(Semantics, APInt::getAllOnes(Semantics.sizeInBits));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5184</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="codeline"></td>
    <td class="lineNumber">5185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="codeline">void APFloat::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">5186</td>
    <td class="codeline">void APFloat::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="codeline">  SmallVector<char, 16> Buffer;</td>
    <td class="lineNumber">5187</td>
    <td class="codeline">  SmallVector<char, 16> Buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="codeline">  toString(Buffer);</td>
    <td class="lineNumber">5188</td>
    <td class="codeline">  toString(Buffer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="codeline">  OS << Buffer << "\n";</td>
    <td class="lineNumber">5189</td>
    <td class="codeline">  OS << Buffer << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5190</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class="codeline"></td>
    <td class="lineNumber">5191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">5192</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="codeline">LLVM_DUMP_METHOD void APFloat::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">5193</td>
    <td class="codeline">LLVM_DUMP_METHOD void APFloat::dump() const { print(dbgs()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">5194</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class="codeline"></td>
    <td class="lineNumber">5195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="codeline">void APFloat::Profile(FoldingSetNodeID &NID) const {</td>
    <td class="lineNumber">5196</td>
    <td class="codeline">void APFloat::Profile(FoldingSetNodeID &NID) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="codeline">  NID.Add(bitcastToAPInt());</td>
    <td class="lineNumber">5197</td>
    <td class="codeline">  NID.Add(bitcastToAPInt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5198</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="codeline"></td>
    <td class="lineNumber">5199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="codeline">/* Same as convertToInteger(integerPart*, ...), except the result is returned in</td>
    <td class="lineNumber">5200</td>
    <td class="codeline">/* Same as convertToInteger(integerPart*, ...), except the result is returned in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="codeline">   an APSInt, whose initial bit-width and signed-ness are used to determine the</td>
    <td class="lineNumber">5201</td>
    <td class="codeline">   an APSInt, whose initial bit-width and signed-ness are used to determine the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="codeline">   precision of the conversion.</td>
    <td class="lineNumber">5202</td>
    <td class="codeline">   precision of the conversion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="codeline"> */</td>
    <td class="lineNumber">5203</td>
    <td class="codeline"> */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="codeline">APFloat::opStatus APFloat::convertToInteger(APSInt &result,</td>
    <td class="lineNumber">5204</td>
    <td class="codeline">APFloat::opStatus APFloat::convertToInteger(APSInt &result,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class="codeline">                                            roundingMode rounding_mode,</td>
    <td class="lineNumber">5205</td>
    <td class="codeline">                                            roundingMode rounding_mode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5206</td>
    <td class="codeline">                                            bool *isExact) const {</td>
    <td class="lineNumber">5206</td>
    <td class="codeline">                                            bool *isExact) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5207</td>
    <td class="codeline">  unsigned bitWidth = result.getBitWidth();</td>
    <td class="lineNumber">5207</td>
    <td class="codeline">  unsigned bitWidth = result.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5208</td>
    <td class="codeline">  SmallVector<uint64_t, 4> parts(result.getNumWords());</td>
    <td class="lineNumber">5208</td>
    <td class="codeline">  SmallVector<uint64_t, 4> parts(result.getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5209</td>
    <td class="codeline">  opStatus status = convertToInteger(parts, bitWidth, result.isSigned(),</td>
    <td class="lineNumber">5209</td>
    <td class="codeline">  opStatus status = convertToInteger(parts, bitWidth, result.isSigned(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5210</td>
    <td class="codeline">                                     rounding_mode, isExact);</td>
    <td class="lineNumber">5210</td>
    <td class="codeline">                                     rounding_mode, isExact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5211</td>
    <td class="codeline">  // Keeps the original signed-ness.</td>
    <td class="lineNumber">5211</td>
    <td class="codeline">  // Keeps the original signed-ness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5212</td>
    <td class="codeline">  result = APInt(bitWidth, parts);</td>
    <td class="lineNumber">5212</td>
    <td class="codeline">  result = APInt(bitWidth, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5213</td>
    <td class="codeline">  return status;</td>
    <td class="lineNumber">5213</td>
    <td class="codeline">  return status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5214</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5214</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5215</td>
    <td class="codeline"></td>
    <td class="lineNumber">5215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5216</td>
    <td class="codeline">double APFloat::convertToDouble() const {</td>
    <td class="lineNumber">5216</td>
    <td class="codeline">double APFloat::convertToDouble() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5217</td>
    <td class="codeline">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEdouble)</td>
    <td class="lineNumber">5217</td>
    <td class="codeline">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEdouble)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5218</td>
    <td class="codeline">    return getIEEE().convertToDouble();</td>
    <td class="lineNumber">5218</td>
    <td class="codeline">    return getIEEE().convertToDouble();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5219</td>
    <td class="codeline">  assert(getSemantics().isRepresentableBy(semIEEEdouble) &&</td>
    <td class="lineNumber">5219</td>
    <td class="codeline">  assert(getSemantics().isRepresentableBy(semIEEEdouble) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5220</td>
    <td class="codeline">         "Float semantics is not representable by IEEEdouble");</td>
    <td class="lineNumber">5220</td>
    <td class="codeline">         "Float semantics is not representable by IEEEdouble");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5221</td>
    <td class="codeline">  APFloat Temp = *this;</td>
    <td class="lineNumber">5221</td>
    <td class="codeline">  APFloat Temp = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5222</td>
    <td class="codeline">  bool LosesInfo;</td>
    <td class="lineNumber">5222</td>
    <td class="codeline">  bool LosesInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5223</td>
    <td class="codeline">  opStatus St = Temp.convert(semIEEEdouble, rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">5223</td>
    <td class="codeline">  opStatus St = Temp.convert(semIEEEdouble, rmNearestTiesToEven, &LosesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5224</td>
    <td class="codeline">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td class="lineNumber">5224</td>
    <td class="codeline">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5225</td>
    <td class="codeline">  (void)St;</td>
    <td class="lineNumber">5225</td>
    <td class="codeline">  (void)St;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5226</td>
    <td class="codeline">  return Temp.getIEEE().convertToDouble();</td>
    <td class="lineNumber">5226</td>
    <td class="codeline">  return Temp.getIEEE().convertToDouble();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5227</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5227</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5228</td>
    <td class="codeline"></td>
    <td class="lineNumber">5228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5229</td>
    <td class="codeline">float APFloat::convertToFloat() const {</td>
    <td class="lineNumber">5229</td>
    <td class="codeline">float APFloat::convertToFloat() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5230</td>
    <td class="codeline">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEsingle)</td>
    <td class="lineNumber">5230</td>
    <td class="codeline">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEsingle)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5231</td>
    <td class="codeline">    return getIEEE().convertToFloat();</td>
    <td class="lineNumber">5231</td>
    <td class="codeline">    return getIEEE().convertToFloat();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5232</td>
    <td class="codeline">  assert(getSemantics().isRepresentableBy(semIEEEsingle) &&</td>
    <td class="lineNumber">5232</td>
    <td class="codeline">  assert(getSemantics().isRepresentableBy(semIEEEsingle) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5233</td>
    <td class="codeline">         "Float semantics is not representable by IEEEsingle");</td>
    <td class="lineNumber">5233</td>
    <td class="codeline">         "Float semantics is not representable by IEEEsingle");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5234</td>
    <td class="codeline">  APFloat Temp = *this;</td>
    <td class="lineNumber">5234</td>
    <td class="codeline">  APFloat Temp = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5235</td>
    <td class="codeline">  bool LosesInfo;</td>
    <td class="lineNumber">5235</td>
    <td class="codeline">  bool LosesInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5236</td>
    <td class="codeline">  opStatus St = Temp.convert(semIEEEsingle, rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">5236</td>
    <td class="codeline">  opStatus St = Temp.convert(semIEEEsingle, rmNearestTiesToEven, &LosesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5237</td>
    <td class="codeline">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td class="lineNumber">5237</td>
    <td class="codeline">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5238</td>
    <td class="codeline">  (void)St;</td>
    <td class="lineNumber">5238</td>
    <td class="codeline">  (void)St;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5239</td>
    <td class="codeline">  return Temp.getIEEE().convertToFloat();</td>
    <td class="lineNumber">5239</td>
    <td class="codeline">  return Temp.getIEEE().convertToFloat();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5240</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5240</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5241</td>
    <td class="codeline"></td>
    <td class="lineNumber">5241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5242</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">5242</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5243</td>
    <td class="codeline"></td>
    <td class="lineNumber">5243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5244</td>
    <td class="codeline">#undef APFLOAT_DISPATCH_ON_SEMANTICS</td>
    <td class="lineNumber">5244</td>
    <td class="codeline">#undef APFLOAT_DISPATCH_ON_SEMANTICS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5245</td>
    <td class="codeline"></td>
    <td class="lineNumber">5245</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- APFloat.cpp - Implement APFloat class -----------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- APFloat.cpp - Implement APFloat class -----------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements a class to represent arbitrary precision floating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements a class to represent arbitrary precision floating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// point values and provide a variety of arithmetic operations on them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// point values and provide a variety of arithmetic operations on them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/APSInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/APSInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/FloatingPointMode.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/FloatingPointMode.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/StringExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/StringExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/Error.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/Error.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <cstring></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <cstring></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <limits.h></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <limits.h></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">  do {                                                                         \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">  do {                                                                         \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">    if (usesLayout<IEEEFloat>(getSemantics()))                                 \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">    if (usesLayout<IEEEFloat>(getSemantics()))                                 \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">      return U.IEEE.METHOD_CALL;                                               \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">      return U.IEEE.METHOD_CALL;                                               \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">      return U.Double.METHOD_CALL;                                             \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">      return U.Double.METHOD_CALL;                                             \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">    llvm_unreachable("Unexpected semantics");                                  \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">    llvm_unreachable("Unexpected semantics");                                  \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">  } while (false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">  } while (false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">/// A macro used to combine two fcCategory enums into one key which can be used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">/// A macro used to combine two fcCategory enums into one key which can be used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">/// in a switch statement to classify how the interaction of two APFloat's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">/// in a switch statement to classify how the interaction of two APFloat's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">/// categories affects an operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">/// categories affects an operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">/// TODO: If clang source code is ever allowed to use constexpr in its own</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">/// TODO: If clang source code is ever allowed to use constexpr in its own</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">/// codebase, change this into a static inline function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">/// codebase, change this into a static inline function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#define PackCategoriesIntoKey(_lhs, _rhs) ((_lhs) * 4 + (_rhs))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#define PackCategoriesIntoKey(_lhs, _rhs) ((_lhs) * 4 + (_rhs))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">/* Assumed in hexadecimal significand parsing, and conversion to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">/* Assumed in hexadecimal significand parsing, and conversion to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">   hexadecimal strings.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">   hexadecimal strings.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">static_assert(APFloatBase::integerPartWidth % 4 == 0, "Part width must be divisible by 4!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">static_assert(APFloatBase::integerPartWidth % 4 == 0, "Part width must be divisible by 4!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">// How the nonfinite values Inf and NaN are represented.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">// How the nonfinite values Inf and NaN are represented.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">enum class fltNonfiniteBehavior {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">enum class fltNonfiniteBehavior {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">  // Represents standard IEEE 754 behavior. A value is nonfinite if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">  // Represents standard IEEE 754 behavior. A value is nonfinite if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">  // exponent field is all 1s. In such cases, a value is Inf if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">  // exponent field is all 1s. In such cases, a value is Inf if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">  // significand bits are all zero, and NaN otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">  // significand bits are all zero, and NaN otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">  IEEE754,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">  IEEE754,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">  // This behavior is present in the Float8ExMyFN* types (Float8E4M3FN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">  // This behavior is present in the Float8ExMyFN* types (Float8E4M3FN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">  // Float8E5M2FNUZ, Float8E4M3FNUZ, and Float8E4M3B11FNUZ). There is no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">  // Float8E5M2FNUZ, Float8E4M3FNUZ, and Float8E4M3B11FNUZ). There is no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">  // representation for Inf, and operations that would ordinarily produce Inf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">  // representation for Inf, and operations that would ordinarily produce Inf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">  // produce NaN instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">  // produce NaN instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">  // The details of the NaN representation(s) in this form are determined by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">  // The details of the NaN representation(s) in this form are determined by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  // `fltNanEncoding` enum. We treat all NaNs as quiet, as the available</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  // `fltNanEncoding` enum. We treat all NaNs as quiet, as the available</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">  // encodings do not distinguish between signalling and quiet NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">  // encodings do not distinguish between signalling and quiet NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">  NanOnly,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">  NanOnly,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">// How NaN values are represented. This is curently only used in combination</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">// How NaN values are represented. This is curently only used in combination</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">// with fltNonfiniteBehavior::NanOnly, and using a variant other than IEEE</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">// with fltNonfiniteBehavior::NanOnly, and using a variant other than IEEE</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">// while having IEEE non-finite behavior is liable to lead to unexpected</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">// while having IEEE non-finite behavior is liable to lead to unexpected</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">// results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">// results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">enum class fltNanEncoding {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">enum class fltNanEncoding {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">  // Represents the standard IEEE behavior where a value is NaN if its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">  // Represents the standard IEEE behavior where a value is NaN if its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  // exponent is all 1s and the significand is non-zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  // exponent is all 1s and the significand is non-zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  IEEE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  IEEE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  // Represents the behavior in the Float8E4M3 floating point type where NaN is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  // Represents the behavior in the Float8E4M3 floating point type where NaN is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  // represented by having the exponent and mantissa set to all 1s.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  // represented by having the exponent and mantissa set to all 1s.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  // This behavior matches the FP8 E4M3 type described in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  // This behavior matches the FP8 E4M3 type described in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  // https://arxiv.org/abs/2209.05433. We treat both signed and unsigned NaNs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  // https://arxiv.org/abs/2209.05433. We treat both signed and unsigned NaNs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  // as non-signalling, although the paper does not state whether the NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  // as non-signalling, although the paper does not state whether the NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  // values are signalling or not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  // values are signalling or not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  AllOnes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  AllOnes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  // Represents the behavior in Float8E{5,4}E{2,3}FNUZ floating point types</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  // Represents the behavior in Float8E{5,4}E{2,3}FNUZ floating point types</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  // where NaN is represented by a sign bit of 1 and all 0s in the exponent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  // where NaN is represented by a sign bit of 1 and all 0s in the exponent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  // and mantissa (i.e. the negative zero encoding in a IEEE float). Since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  // and mantissa (i.e. the negative zero encoding in a IEEE float). Since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  // there is only one NaN value, it is treated as quiet NaN. This matches the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  // there is only one NaN value, it is treated as quiet NaN. This matches the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  // behavior described in https://arxiv.org/abs/2206.02915 .</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  // behavior described in https://arxiv.org/abs/2206.02915 .</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  NegativeZero,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  NegativeZero,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">/* Represents floating point arithmetic semantics.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">/* Represents floating point arithmetic semantics.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">struct fltSemantics {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">struct fltSemantics {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  /* The largest E such that 2^E is representable; this matches the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  /* The largest E such that 2^E is representable; this matches the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">     definition of IEEE 754.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">     definition of IEEE 754.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  APFloatBase::ExponentType maxExponent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  APFloatBase::ExponentType maxExponent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  /* The smallest E such that 2^E is a normalized number; this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  /* The smallest E such that 2^E is a normalized number; this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">     matches the definition of IEEE 754.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">     matches the definition of IEEE 754.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  APFloatBase::ExponentType minExponent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  APFloatBase::ExponentType minExponent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  /* Number of bits in the significand.  This includes the integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  /* Number of bits in the significand.  This includes the integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">     bit.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">     bit.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  unsigned int precision;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  unsigned int precision;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  /* Number of bits actually used in the semantics. */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  /* Number of bits actually used in the semantics. */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  unsigned int sizeInBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  unsigned int sizeInBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">  fltNonfiniteBehavior nonFiniteBehavior = fltNonfiniteBehavior::IEEE754;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">  fltNonfiniteBehavior nonFiniteBehavior = fltNonfiniteBehavior::IEEE754;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  fltNanEncoding nanEncoding = fltNanEncoding::IEEE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  fltNanEncoding nanEncoding = fltNanEncoding::IEEE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  // Returns true if any number described by this semantics can be precisely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  // Returns true if any number described by this semantics can be precisely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  // represented by the specified semantics. Does not take into account</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  // represented by the specified semantics. Does not take into account</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  // the value of fltNonfiniteBehavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  // the value of fltNonfiniteBehavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  bool isRepresentableBy(const fltSemantics &S) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  bool isRepresentableBy(const fltSemantics &S) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">    return maxExponent <= S.maxExponent && minExponent >= S.minExponent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">    return maxExponent <= S.maxExponent && minExponent >= S.minExponent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">           precision <= S.precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">           precision <= S.precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEhalf = {15, -14, 11, 16};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEhalf = {15, -14, 11, 16};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">static constexpr fltSemantics semBFloat = {127, -126, 8, 16};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">static constexpr fltSemantics semBFloat = {127, -126, 8, 16};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEsingle = {127, -126, 24, 32};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEsingle = {127, -126, 24, 32};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEdouble = {1023, -1022, 53, 64};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEdouble = {1023, -1022, 53, 64};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEquad = {16383, -16382, 113, 128};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">static constexpr fltSemantics semIEEEquad = {16383, -16382, 113, 128};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E5M2 = {15, -14, 3, 8};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E5M2 = {15, -14, 3, 8};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E5M2FNUZ = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E5M2FNUZ = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">    15, -15, 3, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">    15, -15, 3, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E4M3FN = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E4M3FN = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">    8, -6, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::AllOnes};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">    8, -6, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::AllOnes};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E4M3FNUZ = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E4M3FNUZ = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">    7, -7, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">    7, -7, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E4M3B11FNUZ = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">static constexpr fltSemantics semFloat8E4M3B11FNUZ = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">    4, -10, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">    4, -10, 4, 8, fltNonfiniteBehavior::NanOnly, fltNanEncoding::NegativeZero};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">static constexpr fltSemantics semFloatTF32 = {127, -126, 11, 19};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">static constexpr fltSemantics semFloatTF32 = {127, -126, 11, 19};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">static constexpr fltSemantics semX87DoubleExtended = {16383, -16382, 64, 80};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">static constexpr fltSemantics semX87DoubleExtended = {16383, -16382, 64, 80};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">static constexpr fltSemantics semBogus = {0, 0, 0, 0};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">static constexpr fltSemantics semBogus = {0, 0, 0, 0};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">/* The IBM double-double semantics. Such a number consists of a pair of IEEE</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">/* The IBM double-double semantics. Such a number consists of a pair of IEEE</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">   64-bit doubles (Hi, Lo), where |Hi| > |Lo|, and if normal,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">   64-bit doubles (Hi, Lo), where |Hi| > |Lo|, and if normal,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">   (double)(Hi + Lo) == Hi. The numeric value it's modeling is Hi + Lo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">   (double)(Hi + Lo) == Hi. The numeric value it's modeling is Hi + Lo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">   Therefore it has two 53-bit mantissa parts that aren't necessarily adjacent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">   Therefore it has two 53-bit mantissa parts that aren't necessarily adjacent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">   to each other, and two 11-bit exponents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">   to each other, and two 11-bit exponents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">   Note: we need to make the value different from semBogus as otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">   Note: we need to make the value different from semBogus as otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">   an unsafe optimization may collapse both values to a single address,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">   an unsafe optimization may collapse both values to a single address,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">   and we heavily rely on them having distinct addresses.             */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">   and we heavily rely on them having distinct addresses.             */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">static constexpr fltSemantics semPPCDoubleDouble = {-1, 0, 0, 128};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">static constexpr fltSemantics semPPCDoubleDouble = {-1, 0, 0, 128};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">/* These are legacy semantics for the fallback, inaccrurate implementation of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">/* These are legacy semantics for the fallback, inaccrurate implementation of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">   IBM double-double, if the accurate semPPCDoubleDouble doesn't handle the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">   IBM double-double, if the accurate semPPCDoubleDouble doesn't handle the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">   operation. It's equivalent to having an IEEE number with consecutive 106</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">   operation. It's equivalent to having an IEEE number with consecutive 106</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">   bits of mantissa and 11 bits of exponent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">   bits of mantissa and 11 bits of exponent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">   It's not equivalent to IBM double-double. For example, a legit IBM</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">   It's not equivalent to IBM double-double. For example, a legit IBM</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">   double-double, 1 + epsilon:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">   double-double, 1 + epsilon:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">     1 + epsilon = 1 + (1 >> 1076)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">     1 + epsilon = 1 + (1 >> 1076)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">   is not representable by a consecutive 106 bits of mantissa.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">   is not representable by a consecutive 106 bits of mantissa.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">   Currently, these semantics are used in the following way:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">   Currently, these semantics are used in the following way:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">     semPPCDoubleDouble -> (IEEEdouble, IEEEdouble) -></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">     semPPCDoubleDouble -> (IEEEdouble, IEEEdouble) -></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">     (64-bit APInt, 64-bit APInt) -> (128-bit APInt) -></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">     (64-bit APInt, 64-bit APInt) -> (128-bit APInt) -></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">     semPPCDoubleDoubleLegacy -> IEEE operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">     semPPCDoubleDoubleLegacy -> IEEE operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">   We use bitcastToAPInt() to get the bit representation (in APInt) of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">   We use bitcastToAPInt() to get the bit representation (in APInt) of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">   underlying IEEEdouble, then use the APInt constructor to construct the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">   underlying IEEEdouble, then use the APInt constructor to construct the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">   legacy IEEE float.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">   legacy IEEE float.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">   TODO: Implement all operations in semPPCDoubleDouble, and delete these</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">   TODO: Implement all operations in semPPCDoubleDouble, and delete these</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">   semantics.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">   semantics.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">static constexpr fltSemantics semPPCDoubleDoubleLegacy = {1023, -1022 + 53,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">static constexpr fltSemantics semPPCDoubleDoubleLegacy = {1023, -1022 + 53,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">                                                          53 + 53, 128};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">                                                          53 + 53, 128};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">const llvm::fltSemantics &APFloatBase::EnumToSemantics(Semantics S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">const llvm::fltSemantics &APFloatBase::EnumToSemantics(Semantics S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  switch (S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  switch (S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  case S_IEEEhalf:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  case S_IEEEhalf:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">    return IEEEhalf();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">    return IEEEhalf();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  case S_BFloat:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  case S_BFloat:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    return BFloat();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    return BFloat();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  case S_IEEEsingle:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  case S_IEEEsingle:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">    return IEEEsingle();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">    return IEEEsingle();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  case S_IEEEdouble:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  case S_IEEEdouble:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    return IEEEdouble();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    return IEEEdouble();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  case S_IEEEquad:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  case S_IEEEquad:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">    return IEEEquad();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">    return IEEEquad();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  case S_PPCDoubleDouble:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  case S_PPCDoubleDouble:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    return PPCDoubleDouble();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    return PPCDoubleDouble();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  case S_Float8E5M2:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  case S_Float8E5M2:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    return Float8E5M2();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    return Float8E5M2();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  case S_Float8E5M2FNUZ:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  case S_Float8E5M2FNUZ:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">    return Float8E5M2FNUZ();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">    return Float8E5M2FNUZ();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  case S_Float8E4M3FN:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  case S_Float8E4M3FN:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    return Float8E4M3FN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    return Float8E4M3FN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  case S_Float8E4M3FNUZ:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  case S_Float8E4M3FNUZ:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">    return Float8E4M3FNUZ();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">    return Float8E4M3FNUZ();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  case S_Float8E4M3B11FNUZ:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  case S_Float8E4M3B11FNUZ:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">    return Float8E4M3B11FNUZ();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">    return Float8E4M3B11FNUZ();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  case S_FloatTF32:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  case S_FloatTF32:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">    return FloatTF32();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">    return FloatTF32();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  case S_x87DoubleExtended:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  case S_x87DoubleExtended:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    return x87DoubleExtended();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    return x87DoubleExtended();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  llvm_unreachable("Unrecognised floating semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  llvm_unreachable("Unrecognised floating semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">APFloatBase::Semantics</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">APFloatBase::Semantics</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">APFloatBase::SemanticsToEnum(const llvm::fltSemantics &Sem) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">APFloatBase::SemanticsToEnum(const llvm::fltSemantics &Sem) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  if (&Sem == &llvm::APFloat::IEEEhalf())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  if (&Sem == &llvm::APFloat::IEEEhalf())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">    return S_IEEEhalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">    return S_IEEEhalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::BFloat())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::BFloat())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">    return S_BFloat;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">    return S_BFloat;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::IEEEsingle())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::IEEEsingle())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    return S_IEEEsingle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    return S_IEEEsingle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::IEEEdouble())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::IEEEdouble())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">    return S_IEEEdouble;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">    return S_IEEEdouble;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::IEEEquad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::IEEEquad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    return S_IEEEquad;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    return S_IEEEquad;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::PPCDoubleDouble())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::PPCDoubleDouble())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">    return S_PPCDoubleDouble;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">    return S_PPCDoubleDouble;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E5M2())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E5M2())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">    return S_Float8E5M2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">    return S_Float8E5M2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E5M2FNUZ())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E5M2FNUZ())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">    return S_Float8E5M2FNUZ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">    return S_Float8E5M2FNUZ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E4M3FN())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E4M3FN())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    return S_Float8E4M3FN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    return S_Float8E4M3FN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E4M3FNUZ())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E4M3FNUZ())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    return S_Float8E4M3FNUZ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    return S_Float8E4M3FNUZ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E4M3B11FNUZ())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::Float8E4M3B11FNUZ())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">    return S_Float8E4M3B11FNUZ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">    return S_Float8E4M3B11FNUZ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::FloatTF32())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::FloatTF32())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    return S_FloatTF32;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    return S_FloatTF32;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::x87DoubleExtended())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  else if (&Sem == &llvm::APFloat::x87DoubleExtended())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    return S_x87DoubleExtended;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    return S_x87DoubleExtended;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">    llvm_unreachable("Unknown floating semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">    llvm_unreachable("Unknown floating semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">const fltSemantics &APFloatBase::IEEEhalf() { return semIEEEhalf; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">const fltSemantics &APFloatBase::IEEEhalf() { return semIEEEhalf; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">const fltSemantics &APFloatBase::BFloat() { return semBFloat; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">const fltSemantics &APFloatBase::BFloat() { return semBFloat; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">const fltSemantics &APFloatBase::IEEEsingle() { return semIEEEsingle; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">const fltSemantics &APFloatBase::IEEEsingle() { return semIEEEsingle; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine coveredLine">const fltSemantics &APFloatBase::IEEEdouble() { return semIEEEdouble; }</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">250</td>
    <td class="codeLine coveredLine">const fltSemantics &APFloatBase::IEEEdouble() { return semIEEEdouble; }</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">const fltSemantics &APFloatBase::IEEEquad() { return semIEEEquad; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">const fltSemantics &APFloatBase::IEEEquad() { return semIEEEquad; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine coveredLine">const fltSemantics &APFloatBase::PPCDoubleDouble() {</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">252</td>
    <td class="codeLine coveredLine">const fltSemantics &APFloatBase::PPCDoubleDouble() {</td>
    <td class="lineNumber">56</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine coveredLine">  return semPPCDoubleDouble;</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">253</td>
    <td class="codeLine coveredLine">  return semPPCDoubleDouble;</td>
    <td class="lineNumber">56</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E5M2() { return semFloat8E5M2; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E5M2() { return semFloat8E5M2; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E5M2FNUZ() { return semFloat8E5M2FNUZ; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E5M2FNUZ() { return semFloat8E5M2FNUZ; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E4M3FN() { return semFloat8E4M3FN; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E4M3FN() { return semFloat8E4M3FN; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E4M3FNUZ() { return semFloat8E4M3FNUZ; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E4M3FNUZ() { return semFloat8E4M3FNUZ; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E4M3B11FNUZ() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Float8E4M3B11FNUZ() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  return semFloat8E4M3B11FNUZ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  return semFloat8E4M3B11FNUZ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">const fltSemantics &APFloatBase::FloatTF32() { return semFloatTF32; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">const fltSemantics &APFloatBase::FloatTF32() { return semFloatTF32; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">const fltSemantics &APFloatBase::x87DoubleExtended() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">const fltSemantics &APFloatBase::x87DoubleExtended() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  return semX87DoubleExtended;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  return semX87DoubleExtended;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Bogus() { return semBogus; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">const fltSemantics &APFloatBase::Bogus() { return semBogus; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmNearestTiesToEven;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmNearestTiesToEven;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmTowardPositive;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmTowardPositive;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmTowardNegative;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmTowardNegative;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmTowardZero;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmTowardZero;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmNearestTiesToAway;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">constexpr RoundingMode APFloatBase::rmNearestTiesToAway;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">/* A tight upper bound on number of parts required to hold the value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">/* A tight upper bound on number of parts required to hold the value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">   pow(5, power) is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">   pow(5, power) is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">     power * 815 / (351 * integerPartWidth) + 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">     power * 815 / (351 * integerPartWidth) + 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">   However, whilst the result may require only this many parts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">   However, whilst the result may require only this many parts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">   because we are multiplying two values to get it, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">   because we are multiplying two values to get it, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">   multiplication may require an extra part with the excess part</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">   multiplication may require an extra part with the excess part</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">   being zero (consider the trivial case of 1 * 1, tcFullMultiply</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">   being zero (consider the trivial case of 1 * 1, tcFullMultiply</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">   requires two parts to hold the single-part result).  So we add an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">   requires two parts to hold the single-part result).  So we add an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">   extra one to guarantee enough space whilst multiplying.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">   extra one to guarantee enough space whilst multiplying.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">const unsigned int maxExponent = 16383;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">const unsigned int maxExponent = 16383;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">const unsigned int maxPrecision = 113;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">const unsigned int maxPrecision = 113;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">const unsigned int maxPowerOfFiveExponent = maxExponent + maxPrecision - 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">const unsigned int maxPowerOfFiveExponent = maxExponent + maxPrecision - 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">const unsigned int maxPowerOfFiveParts =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">const unsigned int maxPowerOfFiveParts =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    2 +</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    2 +</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    ((maxPowerOfFiveExponent * 815) / (351 * APFloatBase::integerPartWidth));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    ((maxPowerOfFiveExponent * 815) / (351 * APFloatBase::integerPartWidth));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">unsigned int APFloatBase::semanticsPrecision(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">unsigned int APFloatBase::semanticsPrecision(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  return semantics.precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  return semantics.precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">APFloatBase::semanticsMaxExponent(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">APFloatBase::semanticsMaxExponent(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  return semantics.maxExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  return semantics.maxExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">APFloatBase::semanticsMinExponent(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">APFloatBase::semanticsMinExponent(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  return semantics.minExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  return semantics.minExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">unsigned int APFloatBase::semanticsSizeInBits(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">unsigned int APFloatBase::semanticsSizeInBits(const fltSemantics &semantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  return semantics.sizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  return semantics.sizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">unsigned int APFloatBase::semanticsIntSizeInBits(const fltSemantics &semantics,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">unsigned int APFloatBase::semanticsIntSizeInBits(const fltSemantics &semantics,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">                                                 bool isSigned) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">                                                 bool isSigned) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  // The max FP value is pow(2, MaxExponent) * (1 + MaxFraction), so we need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  // The max FP value is pow(2, MaxExponent) * (1 + MaxFraction), so we need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  // at least one more bit than the MaxExponent to hold the max FP value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  // at least one more bit than the MaxExponent to hold the max FP value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  unsigned int MinBitWidth = semanticsMaxExponent(semantics) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  unsigned int MinBitWidth = semanticsMaxExponent(semantics) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  // Extra sign bit needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  // Extra sign bit needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  if (isSigned)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  if (isSigned)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    ++MinBitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    ++MinBitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  return MinBitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  return MinBitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">bool APFloatBase::isRepresentableAsNormalIn(const fltSemantics &Src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">bool APFloatBase::isRepresentableAsNormalIn(const fltSemantics &Src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">                                            const fltSemantics &Dst) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">                                            const fltSemantics &Dst) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  // Exponent range must be larger.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  // Exponent range must be larger.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  if (Src.maxExponent >= Dst.maxExponent || Src.minExponent <= Dst.minExponent)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  if (Src.maxExponent >= Dst.maxExponent || Src.minExponent <= Dst.minExponent)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  // If the mantissa is long enough, the result value could still be denormal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  // If the mantissa is long enough, the result value could still be denormal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  // with a larger exponent range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  // with a larger exponent range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  // FIXME: This condition is probably not accurate but also shouldn't be a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  // FIXME: This condition is probably not accurate but also shouldn't be a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  // practical concern with existing types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  // practical concern with existing types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  return Dst.precision >= Src.precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  return Dst.precision >= Src.precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">unsigned APFloatBase::getSizeInBits(const fltSemantics &Sem) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">unsigned APFloatBase::getSizeInBits(const fltSemantics &Sem) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  return Sem.sizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  return Sem.sizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine coveredLine">exponentZero(const fltSemantics &semantics) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">336</td>
    <td class="codeLine coveredLine">exponentZero(const fltSemantics &semantics) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine coveredLine">  return semantics.minExponent - 1;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">337</td>
    <td class="codeLine coveredLine">  return semantics.minExponent - 1;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine coveredLine">exponentInf(const fltSemantics &semantics) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">341</td>
    <td class="codeLine coveredLine">exponentInf(const fltSemantics &semantics) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine coveredLine">  return semantics.maxExponent + 1;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">342</td>
    <td class="codeLine coveredLine">  return semantics.maxExponent + 1;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">static constexpr APFloatBase::ExponentType</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine coveredLine">exponentNaN(const fltSemantics &semantics) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">346</td>
    <td class="codeLine coveredLine">exponentNaN(const fltSemantics &semantics) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine coveredLine">  if (semantics.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">347</td>
    <td class="codeLine coveredLine">  if (semantics.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    if (semantics.nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    if (semantics.nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">      return exponentZero(semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">      return exponentZero(semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">    return semantics.maxExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">    return semantics.maxExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine coveredLine">  return semantics.maxExponent + 1;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">352</td>
    <td class="codeLine coveredLine">  return semantics.maxExponent + 1;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">/* A bunch of private, handy routines.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">/* A bunch of private, handy routines.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">static inline Error createError(const Twine &Err) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">static inline Error createError(const Twine &Err) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  return make_error<StringError>(Err, inconvertibleErrorCode());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  return make_error<StringError>(Err, inconvertibleErrorCode());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine coveredLine">static constexpr inline unsigned int partCountForBits(unsigned int bits) {</td>
    <td class="lineNumber">273</td>
    <td class="lineNumber">361</td>
    <td class="codeLine coveredLine">static constexpr inline unsigned int partCountForBits(unsigned int bits) {</td>
    <td class="lineNumber">196</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine coveredLine">  return ((bits) + APFloatBase::integerPartWidth - 1) / APFloatBase::integerPartWidth;</td>
    <td class="lineNumber">273</td>
    <td class="lineNumber">362</td>
    <td class="codeLine coveredLine">  return ((bits) + APFloatBase::integerPartWidth - 1) / APFloatBase::integerPartWidth;</td>
    <td class="lineNumber">196</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">/* Returns 0U-9U.  Return values >= 10U are not digits.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">/* Returns 0U-9U.  Return values >= 10U are not digits.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">static inline unsigned int</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">static inline unsigned int</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">decDigitValue(unsigned int c)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">decDigitValue(unsigned int c)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  return c - '0';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  return c - '0';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">/* Return the value of a decimal exponent of the form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">/* Return the value of a decimal exponent of the form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">   [+-]ddddddd.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">   [+-]ddddddd.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">   If the exponent overflows, returns a large exponent with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">   If the exponent overflows, returns a large exponent with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">   appropriate sign.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">   appropriate sign.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">static Expected<int> readExponent(StringRef::iterator begin,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">static Expected<int> readExponent(StringRef::iterator begin,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">                                  StringRef::iterator end) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">                                  StringRef::iterator end) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  bool isNegative;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  bool isNegative;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  unsigned int absExponent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  unsigned int absExponent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  const unsigned int overlargeExponent = 24000;  /* FIXME.  */</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  const unsigned int overlargeExponent = 24000;  /* FIXME.  */</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  StringRef::iterator p = begin;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  StringRef::iterator p = begin;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  // Treat no exponent as 0 to match binutils</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  // Treat no exponent as 0 to match binutils</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  if (p == end || ((*p == '-' || *p == '+') && (p + 1) == end)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  if (p == end || ((*p == '-' || *p == '+') && (p + 1) == end)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  isNegative = (*p == '-');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  isNegative = (*p == '-');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    if (p == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    if (p == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">      return createError("Exponent has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">      return createError("Exponent has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  absExponent = decDigitValue(*p++);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  absExponent = decDigitValue(*p++);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  if (absExponent >= 10U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  if (absExponent >= 10U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">    return createError("Invalid character in exponent");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">    return createError("Invalid character in exponent");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  for (; p != end; ++p) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  for (; p != end; ++p) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">    unsigned int value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">    unsigned int value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    value = decDigitValue(*p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    value = decDigitValue(*p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    if (value >= 10U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    if (value >= 10U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">      return createError("Invalid character in exponent");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">      return createError("Invalid character in exponent");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    absExponent = absExponent * 10U + value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    absExponent = absExponent * 10U + value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">    if (absExponent >= overlargeExponent) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">    if (absExponent >= overlargeExponent) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">      absExponent = overlargeExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">      absExponent = overlargeExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  if (isNegative)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  if (isNegative)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    return -(int) absExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    return -(int) absExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">    return (int) absExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">    return (int) absExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">/* This is ugly and needs cleaning up, but I don't immediately see</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">/* This is ugly and needs cleaning up, but I don't immediately see</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">   how whilst remaining safe.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">   how whilst remaining safe.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">static Expected<int> totalExponent(StringRef::iterator p,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">static Expected<int> totalExponent(StringRef::iterator p,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">                                   StringRef::iterator end,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">                                   StringRef::iterator end,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">                                   int exponentAdjustment) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">                                   int exponentAdjustment) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  int unsignedExponent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  int unsignedExponent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  bool negative, overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  bool negative, overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  int exponent = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  int exponent = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  if (p == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  if (p == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">    return createError("Exponent has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">    return createError("Exponent has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  negative = *p == '-';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  negative = *p == '-';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">    if (p == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">    if (p == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">      return createError("Exponent has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">      return createError("Exponent has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  unsignedExponent = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  unsignedExponent = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  overflow = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  overflow = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  for (; p != end; ++p) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  for (; p != end; ++p) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">    unsigned int value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">    unsigned int value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">    value = decDigitValue(*p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">    value = decDigitValue(*p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    if (value >= 10U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    if (value >= 10U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">      return createError("Invalid character in exponent");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">      return createError("Invalid character in exponent");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">    unsignedExponent = unsignedExponent * 10 + value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">    unsignedExponent = unsignedExponent * 10 + value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">    if (unsignedExponent > 32767) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">    if (unsignedExponent > 32767) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">      overflow = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">      overflow = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  if (exponentAdjustment > 32767 || exponentAdjustment < -32768)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  if (exponentAdjustment > 32767 || exponentAdjustment < -32768)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">    overflow = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">    overflow = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  if (!overflow) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  if (!overflow) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">    exponent = unsignedExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">    exponent = unsignedExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    if (negative)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    if (negative)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">      exponent = -exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">      exponent = -exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">    exponent += exponentAdjustment;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">    exponent += exponentAdjustment;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">    if (exponent > 32767 || exponent < -32768)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">    if (exponent > 32767 || exponent < -32768)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">      overflow = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">      overflow = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  if (overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  if (overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">    exponent = negative ? -32768: 32767;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">    exponent = negative ? -32768: 32767;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  return exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  return exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">static Expected<StringRef::iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">static Expected<StringRef::iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">skipLeadingZeroesAndAnyDot(StringRef::iterator begin, StringRef::iterator end,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">skipLeadingZeroesAndAnyDot(StringRef::iterator begin, StringRef::iterator end,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">                           StringRef::iterator *dot) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">                           StringRef::iterator *dot) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  StringRef::iterator p = begin;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  StringRef::iterator p = begin;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  *dot = end;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  *dot = end;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  while (p != end && *p == '0')</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  while (p != end && *p == '0')</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  if (p != end && *p == '.') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  if (p != end && *p == '.') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">    *dot = p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">    *dot = p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">    if (end - begin == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">    if (end - begin == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">      return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">      return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">    while (p != end && *p == '0')</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    while (p != end && *p == '0')</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">      p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">      p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  return p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  return p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">/* Given a normal decimal floating point number of the form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">/* Given a normal decimal floating point number of the form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">     dddd.dddd[eE][+-]ddd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">     dddd.dddd[eE][+-]ddd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">   where the decimal point and exponent are optional, fill out the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">   where the decimal point and exponent are optional, fill out the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">   structure D.  Exponent is appropriate if the significand is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">   structure D.  Exponent is appropriate if the significand is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">   treated as an integer, and normalizedExponent if the significand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">   treated as an integer, and normalizedExponent if the significand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">   is taken to have the decimal point after a single leading</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">   is taken to have the decimal point after a single leading</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">   non-zero digit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">   non-zero digit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">   If the value is zero, V->firstSigDigit points to a non-digit, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">   If the value is zero, V->firstSigDigit points to a non-digit, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">   the return exponent is zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">   the return exponent is zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">*/</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">*/</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">struct decimalInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">struct decimalInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  const char *firstSigDigit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  const char *firstSigDigit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  const char *lastSigDigit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  const char *lastSigDigit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  int exponent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  int exponent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  int normalizedExponent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  int normalizedExponent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">static Error interpretDecimal(StringRef::iterator begin,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">static Error interpretDecimal(StringRef::iterator begin,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">                              StringRef::iterator end, decimalInfo *D) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">                              StringRef::iterator end, decimalInfo *D) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  StringRef::iterator dot = end;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  StringRef::iterator dot = end;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  if (!PtrOrErr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  if (!PtrOrErr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">    return PtrOrErr.takeError();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">    return PtrOrErr.takeError();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  StringRef::iterator p = *PtrOrErr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  StringRef::iterator p = *PtrOrErr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  D->firstSigDigit = p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  D->firstSigDigit = p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  D->exponent = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  D->exponent = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  D->normalizedExponent = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  D->normalizedExponent = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  for (; p != end; ++p) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  for (; p != end; ++p) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    if (*p == '.') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    if (*p == '.') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">      if (dot != end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">      if (dot != end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">        return createError("String contains multiple dots");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">        return createError("String contains multiple dots");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">      dot = p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">      dot = p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">      if (p == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">      if (p == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">    if (decDigitValue(*p) >= 10U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">    if (decDigitValue(*p) >= 10U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  if (p != end) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  if (p != end) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    if (*p != 'e' && *p != 'E')</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    if (*p != 'e' && *p != 'E')</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">      return createError("Invalid character in significand");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">      return createError("Invalid character in significand");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">    if (p == begin)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">    if (p == begin)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">      return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">      return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">    if (dot != end && p - begin == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">    if (dot != end && p - begin == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">      return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">      return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">    /* p points to the first non-digit in the string */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">    /* p points to the first non-digit in the string */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">    auto ExpOrErr = readExponent(p + 1, end);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">    auto ExpOrErr = readExponent(p + 1, end);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">    if (!ExpOrErr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">    if (!ExpOrErr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">      return ExpOrErr.takeError();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">      return ExpOrErr.takeError();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">    D->exponent = *ExpOrErr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">    D->exponent = *ExpOrErr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">    /* Implied decimal point?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">    /* Implied decimal point?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">    if (dot == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">    if (dot == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">      dot = p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">      dot = p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">  /* If number is all zeroes accept any exponent.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">  /* If number is all zeroes accept any exponent.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">  if (p != D->firstSigDigit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">  if (p != D->firstSigDigit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    /* Drop insignificant trailing zeroes.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    /* Drop insignificant trailing zeroes.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">    if (p != begin) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">    if (p != begin) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">      do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">      do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">        do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">        do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">          p--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">          p--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">        while (p != begin && *p == '0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">        while (p != begin && *p == '0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">      while (p != begin && *p == '.');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">      while (p != begin && *p == '.');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">    /* Adjust the exponents for any decimal point.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">    /* Adjust the exponents for any decimal point.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">    D->exponent += static_cast<APFloat::ExponentType>((dot - p) - (dot > p));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">    D->exponent += static_cast<APFloat::ExponentType>((dot - p) - (dot > p));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    D->normalizedExponent = (D->exponent +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    D->normalizedExponent = (D->exponent +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">              static_cast<APFloat::ExponentType>((p - D->firstSigDigit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">              static_cast<APFloat::ExponentType>((p - D->firstSigDigit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">                                      - (dot > D->firstSigDigit && dot < p)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">                                      - (dot > D->firstSigDigit && dot < p)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  D->lastSigDigit = p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  D->lastSigDigit = p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  return Error::success();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  return Error::success();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">/* Return the trailing fraction of a hexadecimal number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">/* Return the trailing fraction of a hexadecimal number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">   DIGITVALUE is the first hex digit of the fraction, P points to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">   DIGITVALUE is the first hex digit of the fraction, P points to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">   the next digit.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">   the next digit.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">static Expected<lostFraction></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">static Expected<lostFraction></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">trailingHexadecimalFraction(StringRef::iterator p, StringRef::iterator end,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">trailingHexadecimalFraction(StringRef::iterator p, StringRef::iterator end,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">                            unsigned int digitValue) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">                            unsigned int digitValue) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  unsigned int hexDigit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  unsigned int hexDigit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">  /* If the first trailing digit isn't 0 or 8 we can work out the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">  /* If the first trailing digit isn't 0 or 8 we can work out the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">     fraction immediately.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">     fraction immediately.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  if (digitValue > 8)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  if (digitValue > 8)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    return lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    return lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  else if (digitValue < 8 && digitValue > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  else if (digitValue < 8 && digitValue > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    return lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    return lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  // Otherwise we need to find the first non-zero digit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  // Otherwise we need to find the first non-zero digit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  while (p != end && (*p == '0' || *p == '.'))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  while (p != end && (*p == '0' || *p == '.'))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  if (p == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  if (p == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">    return createError("Invalid trailing hexadecimal fraction!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">    return createError("Invalid trailing hexadecimal fraction!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  hexDigit = hexDigitValue(*p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  hexDigit = hexDigitValue(*p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  /* If we ran off the end it is exactly zero or one-half, otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  /* If we ran off the end it is exactly zero or one-half, otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">     a little more.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">     a little more.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  if (hexDigit == UINT_MAX)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  if (hexDigit == UINT_MAX)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    return digitValue == 0 ? lfExactlyZero: lfExactlyHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    return digitValue == 0 ? lfExactlyZero: lfExactlyHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">    return digitValue == 0 ? lfLessThanHalf: lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">    return digitValue == 0 ? lfLessThanHalf: lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">/* Return the fraction lost were a bignum truncated losing the least</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">/* Return the fraction lost were a bignum truncated losing the least</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">   significant BITS bits.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">   significant BITS bits.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">static lostFraction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">static lostFraction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">lostFractionThroughTruncation(const APFloatBase::integerPart *parts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">lostFractionThroughTruncation(const APFloatBase::integerPart *parts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">                              unsigned int partCount,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">                              unsigned int partCount,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">                              unsigned int bits)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">                              unsigned int bits)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  unsigned int lsb;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  unsigned int lsb;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">  lsb = APInt::tcLSB(parts, partCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">  lsb = APInt::tcLSB(parts, partCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  /* Note this is guaranteed true if bits == 0, or LSB == UINT_MAX.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  /* Note this is guaranteed true if bits == 0, or LSB == UINT_MAX.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  if (bits <= lsb)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  if (bits <= lsb)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">    return lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">    return lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  if (bits == lsb + 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  if (bits == lsb + 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    return lfExactlyHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    return lfExactlyHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  if (bits <= partCount * APFloatBase::integerPartWidth &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  if (bits <= partCount * APFloatBase::integerPartWidth &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">      APInt::tcExtractBit(parts, bits - 1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">      APInt::tcExtractBit(parts, bits - 1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">    return lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">    return lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  return lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  return lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">/* Shift DST right BITS bits noting lost fraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">/* Shift DST right BITS bits noting lost fraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">static lostFraction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">static lostFraction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">shiftRight(APFloatBase::integerPart *dst, unsigned int parts, unsigned int bits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">shiftRight(APFloatBase::integerPart *dst, unsigned int parts, unsigned int bits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  lost_fraction = lostFractionThroughTruncation(dst, parts, bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  lost_fraction = lostFractionThroughTruncation(dst, parts, bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  APInt::tcShiftRight(dst, parts, bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  APInt::tcShiftRight(dst, parts, bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">/* Combine the effect of two lost fractions.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">/* Combine the effect of two lost fractions.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">static lostFraction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">static lostFraction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">combineLostFractions(lostFraction moreSignificant,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">combineLostFractions(lostFraction moreSignificant,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">                     lostFraction lessSignificant)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">                     lostFraction lessSignificant)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  if (lessSignificant != lfExactlyZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  if (lessSignificant != lfExactlyZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    if (moreSignificant == lfExactlyZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    if (moreSignificant == lfExactlyZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">      moreSignificant = lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">      moreSignificant = lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    else if (moreSignificant == lfExactlyHalf)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    else if (moreSignificant == lfExactlyHalf)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">      moreSignificant = lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">      moreSignificant = lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  return moreSignificant;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  return moreSignificant;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">/* The error from the true value, in half-ulps, on multiplying two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">/* The error from the true value, in half-ulps, on multiplying two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">   floating point numbers, which differ from the value they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">   floating point numbers, which differ from the value they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">   approximate by at most HUE1 and HUE2 half-ulps, is strictly less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">   approximate by at most HUE1 and HUE2 half-ulps, is strictly less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">   than the returned value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">   than the returned value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">   See "How to Read Floating Point Numbers Accurately" by William D</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">   See "How to Read Floating Point Numbers Accurately" by William D</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">   Clinger.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">   Clinger.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">static unsigned int</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">static unsigned int</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">HUerrBound(bool inexactMultiply, unsigned int HUerr1, unsigned int HUerr2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">HUerrBound(bool inexactMultiply, unsigned int HUerr1, unsigned int HUerr2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  assert(HUerr1 < 2 || HUerr2 < 2 || (HUerr1 + HUerr2 < 8));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  assert(HUerr1 < 2 || HUerr2 < 2 || (HUerr1 + HUerr2 < 8));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  if (HUerr1 + HUerr2 == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  if (HUerr1 + HUerr2 == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    return inexactMultiply * 2;  /* <= inexactMultiply half-ulps.  */</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    return inexactMultiply * 2;  /* <= inexactMultiply half-ulps.  */</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">    return inexactMultiply + 2 * (HUerr1 + HUerr2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">    return inexactMultiply + 2 * (HUerr1 + HUerr2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">/* The number of ulps from the boundary (zero, or half if ISNEAREST)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">/* The number of ulps from the boundary (zero, or half if ISNEAREST)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">   when the least significant BITS are truncated.  BITS cannot be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">   when the least significant BITS are truncated.  BITS cannot be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">   zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">   zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">static APFloatBase::integerPart</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">static APFloatBase::integerPart</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">ulpsFromBoundary(const APFloatBase::integerPart *parts, unsigned int bits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">ulpsFromBoundary(const APFloatBase::integerPart *parts, unsigned int bits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">                 bool isNearest) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">                 bool isNearest) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  unsigned int count, partBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  unsigned int count, partBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  APFloatBase::integerPart part, boundary;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  APFloatBase::integerPart part, boundary;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  assert(bits != 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  assert(bits != 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  bits--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  bits--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  count = bits / APFloatBase::integerPartWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  count = bits / APFloatBase::integerPartWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  partBits = bits % APFloatBase::integerPartWidth + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  partBits = bits % APFloatBase::integerPartWidth + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  part = parts[count] & (~(APFloatBase::integerPart) 0 >> (APFloatBase::integerPartWidth - partBits));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  part = parts[count] & (~(APFloatBase::integerPart) 0 >> (APFloatBase::integerPartWidth - partBits));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  if (isNearest)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  if (isNearest)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">    boundary = (APFloatBase::integerPart) 1 << (partBits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">    boundary = (APFloatBase::integerPart) 1 << (partBits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    boundary = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    boundary = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  if (count == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  if (count == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    if (part - boundary <= boundary - part)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    if (part - boundary <= boundary - part)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">      return part - boundary;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">      return part - boundary;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">      return boundary - part;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">      return boundary - part;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  if (part == boundary) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  if (part == boundary) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">    while (--count)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">    while (--count)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">      if (parts[count])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">      if (parts[count])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    return parts[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    return parts[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  } else if (part == boundary - 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  } else if (part == boundary - 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">    while (--count)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">    while (--count)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">      if (~parts[count])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">      if (~parts[count])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">        return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">    return -parts[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">    return -parts[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">  return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">  return ~(APFloatBase::integerPart) 0; /* A lot.  */</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">/* Place pow(5, power) in DST, and return the number of parts used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">/* Place pow(5, power) in DST, and return the number of parts used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">   DST must be at least one part larger than size of the answer.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">   DST must be at least one part larger than size of the answer.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">static unsigned int</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">static unsigned int</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">powerOf5(APFloatBase::integerPart *dst, unsigned int power) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">powerOf5(APFloatBase::integerPart *dst, unsigned int power) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  static const APFloatBase::integerPart firstEightPowers[] = { 1, 5, 25, 125, 625, 3125, 15625, 78125 };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  static const APFloatBase::integerPart firstEightPowers[] = { 1, 5, 25, 125, 625, 3125, 15625, 78125 };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  APFloatBase::integerPart pow5s[maxPowerOfFiveParts * 2 + 5];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  APFloatBase::integerPart pow5s[maxPowerOfFiveParts * 2 + 5];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  pow5s[0] = 78125 * 5;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  pow5s[0] = 78125 * 5;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  unsigned int partsCount[16] = { 1 };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  unsigned int partsCount[16] = { 1 };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  APFloatBase::integerPart scratch[maxPowerOfFiveParts], *p1, *p2, *pow5;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  APFloatBase::integerPart scratch[maxPowerOfFiveParts], *p1, *p2, *pow5;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">  unsigned int result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">  unsigned int result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  assert(power <= maxExponent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  assert(power <= maxExponent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  p1 = dst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  p1 = dst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  p2 = scratch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  p2 = scratch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">  *p1 = firstEightPowers[power & 7];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">  *p1 = firstEightPowers[power & 7];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  power >>= 3;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  power >>= 3;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  result = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  result = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  pow5 = pow5s;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  pow5 = pow5s;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  for (unsigned int n = 0; power; power >>= 1, n++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  for (unsigned int n = 0; power; power >>= 1, n++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    unsigned int pc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    unsigned int pc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    pc = partsCount[n];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    pc = partsCount[n];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    /* Calculate pow(5,pow(2,n+3)) if we haven't yet.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    /* Calculate pow(5,pow(2,n+3)) if we haven't yet.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">    if (pc == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">    if (pc == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">      pc = partsCount[n - 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">      pc = partsCount[n - 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">      APInt::tcFullMultiply(pow5, pow5 - pc, pow5 - pc, pc, pc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">      APInt::tcFullMultiply(pow5, pow5 - pc, pow5 - pc, pc, pc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">      pc *= 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">      pc *= 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">      if (pow5[pc - 1] == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">      if (pow5[pc - 1] == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">        pc--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">        pc--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">      partsCount[n] = pc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">      partsCount[n] = pc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">    if (power & 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">    if (power & 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">      APFloatBase::integerPart *tmp;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">      APFloatBase::integerPart *tmp;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">      APInt::tcFullMultiply(p2, p1, pow5, result, pc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">      APInt::tcFullMultiply(p2, p1, pow5, result, pc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">      result += pc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">      result += pc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">      if (p2[result - 1] == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">      if (p2[result - 1] == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">        result--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">        result--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">      /* Now result is in p1 with partsCount parts and p2 is scratch</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">      /* Now result is in p1 with partsCount parts and p2 is scratch</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">         space.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">         space.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">      tmp = p1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">      tmp = p1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">      p1 = p2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">      p1 = p2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">      p2 = tmp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">      p2 = tmp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    pow5 += pc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    pow5 += pc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  if (p1 != dst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  if (p1 != dst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">    APInt::tcAssign(dst, p1, result);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">    APInt::tcAssign(dst, p1, result);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">/* Zero at the end to avoid modular arithmetic when adding one; used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">/* Zero at the end to avoid modular arithmetic when adding one; used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">   when rounding up during hexadecimal output.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">   when rounding up during hexadecimal output.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">static const char hexDigitsLower[] = "0123456789abcdef0";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">static const char hexDigitsLower[] = "0123456789abcdef0";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">static const char hexDigitsUpper[] = "0123456789ABCDEF0";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">static const char hexDigitsUpper[] = "0123456789ABCDEF0";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">static const char infinityL[] = "infinity";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">static const char infinityL[] = "infinity";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">static const char infinityU[] = "INFINITY";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">static const char infinityU[] = "INFINITY";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">static const char NaNL[] = "nan";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">static const char NaNL[] = "nan";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">static const char NaNU[] = "NAN";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">static const char NaNU[] = "NAN";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">/* Write out an integerPart in hexadecimal, starting with the most</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">/* Write out an integerPart in hexadecimal, starting with the most</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">   significant nibble.  Write out exactly COUNT hexdigits, return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">   significant nibble.  Write out exactly COUNT hexdigits, return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">   COUNT.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">   COUNT.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">static unsigned int</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">static unsigned int</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">partAsHex (char *dst, APFloatBase::integerPart part, unsigned int count,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">partAsHex (char *dst, APFloatBase::integerPart part, unsigned int count,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">           const char *hexDigitChars)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">           const char *hexDigitChars)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  unsigned int result = count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  unsigned int result = count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  assert(count != 0 && count <= APFloatBase::integerPartWidth / 4);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  assert(count != 0 && count <= APFloatBase::integerPartWidth / 4);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  part >>= (APFloatBase::integerPartWidth - 4 * count);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  part >>= (APFloatBase::integerPartWidth - 4 * count);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  while (count--) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  while (count--) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    dst[count] = hexDigitChars[part & 0xf];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    dst[count] = hexDigitChars[part & 0xf];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">    part >>= 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">    part >>= 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">/* Write out an unsigned decimal integer.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">/* Write out an unsigned decimal integer.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">static char *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">static char *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">writeUnsignedDecimal (char *dst, unsigned int n)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">writeUnsignedDecimal (char *dst, unsigned int n)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  char buff[40], *p;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  char buff[40], *p;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  p = buff;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  p = buff;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">    *p++ = '0' + n % 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">    *p++ = '0' + n % 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  while (n /= 10);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  while (n /= 10);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">    *dst++ = *--p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">    *dst++ = *--p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  while (p != buff);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  while (p != buff);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  return dst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  return dst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">/* Write out a signed decimal integer.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">/* Write out a signed decimal integer.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">static char *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">static char *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">writeSignedDecimal (char *dst, int value)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">writeSignedDecimal (char *dst, int value)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  if (value < 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  if (value < 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">    *dst++ = '-';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">    *dst++ = '-';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">    dst = writeUnsignedDecimal(dst, -(unsigned) value);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">    dst = writeUnsignedDecimal(dst, -(unsigned) value);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">    dst = writeUnsignedDecimal(dst, value);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">    dst = writeUnsignedDecimal(dst, value);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  return dst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  return dst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">/* Constructors.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">/* Constructors.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine coveredLine">void IEEEFloat::initialize(const fltSemantics *ourSemantics) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">850</td>
    <td class="codeLine coveredLine">void IEEEFloat::initialize(const fltSemantics *ourSemantics) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">  unsigned int count;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">  unsigned int count;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine coveredLine">  semantics = ourSemantics;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">853</td>
    <td class="codeLine coveredLine">  semantics = ourSemantics;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine coveredLine">  count = partCount();</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">854</td>
    <td class="codeLine coveredLine">  count = partCount();</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine coveredLine">  if (count > 1)</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">855</td>
    <td class="codeLine coveredLine">  if (count > 1)</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    significand.parts = new integerPart[count];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    significand.parts = new integerPart[count];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">857</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine coveredLine">void IEEEFloat::freeSignificand() {</td>
    <td class="lineNumber">117</td>
    <td class="lineNumber">859</td>
    <td class="codeLine coveredLine">void IEEEFloat::freeSignificand() {</td>
    <td class="lineNumber">84</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine coveredLine">  if (needsCleanup())</td>
    <td class="lineNumber">117</td>
    <td class="lineNumber">860</td>
    <td class="codeLine coveredLine">  if (needsCleanup())</td>
    <td class="lineNumber">84</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">    delete [] significand.parts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">    delete [] significand.parts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">117</td>
    <td class="lineNumber">862</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">84</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">void IEEEFloat::assign(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">void IEEEFloat::assign(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  sign = rhs.sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  sign = rhs.sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  category = rhs.category;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  category = rhs.category;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  exponent = rhs.exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  exponent = rhs.exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  if (isFiniteNonZero() || category == fcNaN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  if (isFiniteNonZero() || category == fcNaN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">    copySignificand(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">    copySignificand(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">void IEEEFloat::copySignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">void IEEEFloat::copySignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  assert(isFiniteNonZero() || category == fcNaN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  assert(isFiniteNonZero() || category == fcNaN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  assert(rhs.partCount() >= partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  assert(rhs.partCount() >= partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  APInt::tcAssign(significandParts(), rhs.significandParts(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  APInt::tcAssign(significandParts(), rhs.significandParts(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">                  partCount());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">                  partCount());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">/* Make this number a NaN, with an arbitrary but deterministic value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">/* Make this number a NaN, with an arbitrary but deterministic value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">   for the significand.  If double or longer, this is a signalling NaN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">   for the significand.  If double or longer, this is a signalling NaN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">   which may not be ideal.  If float, this is QNaN(0).  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">   which may not be ideal.  If float, this is QNaN(0).  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">void IEEEFloat::makeNaN(bool SNaN, bool Negative, const APInt *fill) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">void IEEEFloat::makeNaN(bool SNaN, bool Negative, const APInt *fill) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  category = fcNaN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  category = fcNaN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  exponent = exponentNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  exponent = exponentNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  unsigned numParts = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  unsigned numParts = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  APInt fill_storage;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  APInt fill_storage;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    // Finite-only types do not distinguish signalling and quiet NaN, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    // Finite-only types do not distinguish signalling and quiet NaN, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    // make them all signalling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    // make them all signalling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">    SNaN = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">    SNaN = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">      sign = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">      sign = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">      fill_storage = APInt::getZero(semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">      fill_storage = APInt::getZero(semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">      fill_storage = APInt::getAllOnes(semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">      fill_storage = APInt::getAllOnes(semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">    fill = &fill_storage;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">    fill = &fill_storage;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  // Set the significand bits to the fill.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  // Set the significand bits to the fill.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  if (!fill || fill->getNumWords() < numParts)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  if (!fill || fill->getNumWords() < numParts)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">    APInt::tcSet(significand, 0, numParts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">    APInt::tcSet(significand, 0, numParts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  if (fill) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  if (fill) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">    APInt::tcAssign(significand, fill->getRawData(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">    APInt::tcAssign(significand, fill->getRawData(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">                    std::min(fill->getNumWords(), numParts));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">                    std::min(fill->getNumWords(), numParts));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">    // Zero out the excess bits of the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">    // Zero out the excess bits of the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">    unsigned bitsToPreserve = semantics->precision - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">    unsigned bitsToPreserve = semantics->precision - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">    unsigned part = bitsToPreserve / 64;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">    unsigned part = bitsToPreserve / 64;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">    bitsToPreserve %= 64;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">    bitsToPreserve %= 64;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">    significand[part] &= ((1ULL << bitsToPreserve) - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">    significand[part] &= ((1ULL << bitsToPreserve) - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">    for (part++; part != numParts; ++part)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">    for (part++; part != numParts; ++part)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">      significand[part] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">      significand[part] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">  unsigned QNaNBit = semantics->precision - 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">  unsigned QNaNBit = semantics->precision - 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  if (SNaN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  if (SNaN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">    // We always have to clear the QNaN bit to make it an SNaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">    // We always have to clear the QNaN bit to make it an SNaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">    APInt::tcClearBit(significand, QNaNBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">    APInt::tcClearBit(significand, QNaNBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    // If there are no bits set in the payload, we have to set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    // If there are no bits set in the payload, we have to set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">    // *something* to make it a NaN instead of an infinity;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">    // *something* to make it a NaN instead of an infinity;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">    // conventionally, this is the next bit down from the QNaN bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">    // conventionally, this is the next bit down from the QNaN bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">    if (APInt::tcIsZero(significand, numParts))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">    if (APInt::tcIsZero(significand, numParts))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">      APInt::tcSetBit(significand, QNaNBit - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">      APInt::tcSetBit(significand, QNaNBit - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">  } else if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">  } else if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">    // The only NaN is a quiet NaN, and it has no bits sets in the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">    // The only NaN is a quiet NaN, and it has no bits sets in the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    // Do nothing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    // Do nothing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">    // We always have to set the QNaN bit to make it a QNaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">    // We always have to set the QNaN bit to make it a QNaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">    APInt::tcSetBit(significand, QNaNBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">    APInt::tcSetBit(significand, QNaNBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  // For x87 extended precision, we want to make a NaN, not a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  // For x87 extended precision, we want to make a NaN, not a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">  // pseudo-NaN.  Maybe we should expose the ability to make</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">  // pseudo-NaN.  Maybe we should expose the ability to make</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  // pseudo-NaNs?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  // pseudo-NaNs?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  if (semantics == &semX87DoubleExtended)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  if (semantics == &semX87DoubleExtended)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    APInt::tcSetBit(significand, QNaNBit + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    APInt::tcSetBit(significand, QNaNBit + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">IEEEFloat &IEEEFloat::operator=(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">IEEEFloat &IEEEFloat::operator=(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  if (this != &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  if (this != &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">    if (semantics != rhs.semantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">    if (semantics != rhs.semantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">      freeSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">      freeSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">      initialize(rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">      initialize(rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine coveredLine">IEEEFloat &IEEEFloat::operator=(IEEEFloat &&rhs) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">961</td>
    <td class="codeLine coveredLine">IEEEFloat &IEEEFloat::operator=(IEEEFloat &&rhs) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine coveredLine">  freeSignificand();</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">962</td>
    <td class="codeLine coveredLine">  freeSignificand();</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine coveredLine">  semantics = rhs.semantics;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">964</td>
    <td class="codeLine coveredLine">  semantics = rhs.semantics;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine coveredLine">  significand = rhs.significand;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">965</td>
    <td class="codeLine coveredLine">  significand = rhs.significand;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine coveredLine">  exponent = rhs.exponent;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">966</td>
    <td class="codeLine coveredLine">  exponent = rhs.exponent;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine coveredLine">  category = rhs.category;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">967</td>
    <td class="codeLine coveredLine">  category = rhs.category;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine coveredLine">  sign = rhs.sign;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">968</td>
    <td class="codeLine coveredLine">  sign = rhs.sign;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine coveredLine">  rhs.semantics = &semBogus;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">970</td>
    <td class="codeLine coveredLine">  rhs.semantics = &semBogus;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine coveredLine">  return *this;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">971</td>
    <td class="codeLine coveredLine">  return *this;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">bool IEEEFloat::isDenormal() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">bool IEEEFloat::isDenormal() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  return isFiniteNonZero() && (exponent == semantics->minExponent) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  return isFiniteNonZero() && (exponent == semantics->minExponent) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">         (APInt::tcExtractBit(significandParts(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">         (APInt::tcExtractBit(significandParts(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">                              semantics->precision - 1) == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">                              semantics->precision - 1) == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">bool IEEEFloat::isSmallest() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">bool IEEEFloat::isSmallest() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  // The smallest number by magnitude in our format will be the smallest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  // The smallest number by magnitude in our format will be the smallest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  // denormal, i.e. the floating point number with exponent being minimum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  // denormal, i.e. the floating point number with exponent being minimum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  // exponent and significand bitwise equal to 1 (i.e. with MSB equal to 0).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  // exponent and significand bitwise equal to 1 (i.e. with MSB equal to 0).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  return isFiniteNonZero() && exponent == semantics->minExponent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  return isFiniteNonZero() && exponent == semantics->minExponent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">    significandMSB() == 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">    significandMSB() == 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">bool IEEEFloat::isSmallestNormalized() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">bool IEEEFloat::isSmallestNormalized() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  return getCategory() == fcNormal && exponent == semantics->minExponent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  return getCategory() == fcNormal && exponent == semantics->minExponent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">         isSignificandAllZerosExceptMSB();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">         isSignificandAllZerosExceptMSB();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllOnes() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllOnes() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">  // Test if the significand excluding the integral bit is all ones. This allows</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">  // Test if the significand excluding the integral bit is all ones. This allows</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  // us to test for binade boundaries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  // us to test for binade boundaries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    if (~Parts[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    if (~Parts[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  // Set the unused high bits to all ones when we compare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  // Set the unused high bits to all ones when we compare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  const integerPart HighBitFill =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  const integerPart HighBitFill =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">    ~integerPart(0) << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">    ~integerPart(0) << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  if (~(Parts[PartCount - 1] | HighBitFill))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  if (~(Parts[PartCount - 1] | HighBitFill))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllOnesExceptLSB() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllOnesExceptLSB() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  // Test if the significand excluding the integral bit is all ones except for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  // Test if the significand excluding the integral bit is all ones except for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  // the least significant bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  // the least significant bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  if (Parts[0] & 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  if (Parts[0] & 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">    if (~Parts[i] & ~unsigned{!i})</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">    if (~Parts[i] & ~unsigned{!i})</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  // Set the unused high bits to all ones when we compare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  // Set the unused high bits to all ones when we compare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  assert(NumHighBits <= integerPartWidth && NumHighBits > 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">         "Can not have more high bits to fill than integerPartWidth");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  const integerPart HighBitFill = ~integerPart(0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  const integerPart HighBitFill = ~integerPart(0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">                                  << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">                                  << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  if (~(Parts[PartCount - 1] | HighBitFill | 0x1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  if (~(Parts[PartCount - 1] | HighBitFill | 0x1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllZeros() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllZeros() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // Test if the significand excluding the integral bit is all zeros. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // Test if the significand excluding the integral bit is all zeros. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  // allows us to test for binade boundaries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  // allows us to test for binade boundaries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">    if (Parts[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">    if (Parts[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  // Compute how many bits are used in the final word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  // Compute how many bits are used in the final word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">    PartCount*integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  assert(NumHighBits < integerPartWidth && "Can not have more high bits to "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  assert(NumHighBits < integerPartWidth && "Can not have more high bits to "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">         "clear than integerPartWidth");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">         "clear than integerPartWidth");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  const integerPart HighBitMask = ~integerPart(0) >> NumHighBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  const integerPart HighBitMask = ~integerPart(0) >> NumHighBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  if (Parts[PartCount - 1] & HighBitMask)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  if (Parts[PartCount - 1] & HighBitMask)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllZerosExceptMSB() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">bool IEEEFloat::isSignificandAllZerosExceptMSB() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  const integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  const unsigned PartCount = partCountForBits(semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">  for (unsigned i = 0; i < PartCount - 1; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">    if (Parts[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">    if (Parts[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">  const unsigned NumHighBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">      PartCount * integerPartWidth - semantics->precision + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  return Parts[PartCount - 1] == integerPart(1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  return Parts[PartCount - 1] == integerPart(1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">                                     << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">                                     << (integerPartWidth - NumHighBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">bool IEEEFloat::isLargest() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">bool IEEEFloat::isLargest() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">    // The largest number by magnitude in our format will be the floating point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">    // The largest number by magnitude in our format will be the floating point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">    // number with maximum exponent and with significand that is all ones except</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">    // number with maximum exponent and with significand that is all ones except</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    // the LSB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    // the LSB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">           isSignificandAllOnesExceptLSB();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">           isSignificandAllOnesExceptLSB();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">    // The largest number by magnitude in our format will be the floating point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">    // The largest number by magnitude in our format will be the floating point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">    // number with maximum exponent and with significand that is all ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">    // number with maximum exponent and with significand that is all ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">    return isFiniteNonZero() && exponent == semantics->maxExponent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">           isSignificandAllOnes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">           isSignificandAllOnes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">bool IEEEFloat::isInteger() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">bool IEEEFloat::isInteger() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  // This could be made more efficient; I'm going for obviously correct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  // This could be made more efficient; I'm going for obviously correct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">  if (!isFinite()) return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">  if (!isFinite()) return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">  IEEEFloat truncated = *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">  IEEEFloat truncated = *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  truncated.roundToIntegral(rmTowardZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  truncated.roundToIntegral(rmTowardZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  return compare(truncated) == cmpEqual;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  return compare(truncated) == cmpEqual;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">bool IEEEFloat::bitwiseIsEqual(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">bool IEEEFloat::bitwiseIsEqual(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  if (this == &rhs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  if (this == &rhs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  if (semantics != rhs.semantics ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  if (semantics != rhs.semantics ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">      category != rhs.category ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">      category != rhs.category ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">      sign != rhs.sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">      sign != rhs.sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  if (category==fcZero || category==fcInfinity)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  if (category==fcZero || category==fcInfinity)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  if (isFiniteNonZero() && exponent != rhs.exponent)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  if (isFiniteNonZero() && exponent != rhs.exponent)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  return std::equal(significandParts(), significandParts() + partCount(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  return std::equal(significandParts(), significandParts() + partCount(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">                    rhs.significandParts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">                    rhs.significandParts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, integerPart value) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, integerPart value) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  initialize(&ourSemantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  initialize(&ourSemantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">  sign = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">  sign = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  zeroSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  zeroSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  exponent = ourSemantics.precision - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  exponent = ourSemantics.precision - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  significandParts()[0] = value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  significandParts()[0] = value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  normalize(rmNearestTiesToEven, lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  normalize(rmNearestTiesToEven, lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">  initialize(&ourSemantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">  initialize(&ourSemantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">  makeZero(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">  makeZero(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">// Delegate to the previous constructor, because later copy constructor may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">// Delegate to the previous constructor, because later copy constructor may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">// actually inspects category, which can't be garbage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">// actually inspects category, which can't be garbage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, uninitializedTag tag)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &ourSemantics, uninitializedTag tag)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">    : IEEEFloat(ourSemantics) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">    : IEEEFloat(ourSemantics) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  initialize(rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  initialize(rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">  assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">  assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine coveredLine">IEEEFloat::IEEEFloat(IEEEFloat &&rhs) : semantics(&semBogus) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine coveredLine">IEEEFloat::IEEEFloat(IEEEFloat &&rhs) : semantics(&semBogus) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine coveredLine">  *this = std::move(rhs);</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine coveredLine">  *this = std::move(rhs);</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine coveredLine">IEEEFloat::~IEEEFloat() { freeSignificand(); }</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine coveredLine">IEEEFloat::~IEEEFloat() { freeSignificand(); }</td>
    <td class="lineNumber">56</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine coveredLine">unsigned int IEEEFloat::partCount() const {</td>
    <td class="lineNumber">273</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine coveredLine">unsigned int IEEEFloat::partCount() const {</td>
    <td class="lineNumber">196</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine coveredLine">  return partCountForBits(semantics->precision + 1);</td>
    <td class="lineNumber">273</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine coveredLine">  return partCountForBits(semantics->precision + 1);</td>
    <td class="lineNumber">196</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">const IEEEFloat::integerPart *IEEEFloat::significandParts() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">const IEEEFloat::integerPart *IEEEFloat::significandParts() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  return const_cast<IEEEFloat *>(this)->significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  return const_cast<IEEEFloat *>(this)->significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine coveredLine">IEEEFloat::integerPart *IEEEFloat::significandParts() {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine coveredLine">IEEEFloat::integerPart *IEEEFloat::significandParts() {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine coveredLine">  if (partCount() > 1)</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine coveredLine">  if (partCount() > 1)</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">    return significand.parts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">    return significand.parts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine coveredLine">    return &significand.part;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine coveredLine">    return &significand.part;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">void IEEEFloat::zeroSignificand() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">void IEEEFloat::zeroSignificand() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">/* Increment an fcNormal floating point number's significand.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">/* Increment an fcNormal floating point number's significand.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">void IEEEFloat::incrementSignificand() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">void IEEEFloat::incrementSignificand() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  integerPart carry;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  integerPart carry;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  carry = APInt::tcIncrement(significandParts(), partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  carry = APInt::tcIncrement(significandParts(), partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  /* Our callers should never cause us to overflow.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  /* Our callers should never cause us to overflow.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">  assert(carry == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">  assert(carry == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">  (void)carry;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">  (void)carry;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">/* Add the significand of the RHS.  Returns the carry flag.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">/* Add the significand of the RHS.  Returns the carry flag.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">IEEEFloat::integerPart IEEEFloat::addSignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">IEEEFloat::integerPart IEEEFloat::addSignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  integerPart *parts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  integerPart *parts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">  parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">  parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  assert(exponent == rhs.exponent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  assert(exponent == rhs.exponent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  return APInt::tcAdd(parts, rhs.significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  return APInt::tcAdd(parts, rhs.significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">/* Subtract the significand of the RHS with a borrow flag.  Returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">/* Subtract the significand of the RHS with a borrow flag.  Returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">   the borrow flag.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">   the borrow flag.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">IEEEFloat::integerPart IEEEFloat::subtractSignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">IEEEFloat::integerPart IEEEFloat::subtractSignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">                                                      integerPart borrow) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">                                                      integerPart borrow) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  integerPart *parts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  integerPart *parts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  assert(exponent == rhs.exponent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  assert(exponent == rhs.exponent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  return APInt::tcSubtract(parts, rhs.significandParts(), borrow,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  return APInt::tcSubtract(parts, rhs.significandParts(), borrow,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">                           partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">                           partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">/* Multiply the significand of the RHS.  If ADDEND is non-NULL, add it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">/* Multiply the significand of the RHS.  If ADDEND is non-NULL, add it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">   on to the full-precision result of the multiplication.  Returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">   on to the full-precision result of the multiplication.  Returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">   lost fraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">   lost fraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">                                            IEEEFloat addend) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">                                            IEEEFloat addend) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  unsigned int omsb;        // One, not zero, based MSB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  unsigned int omsb;        // One, not zero, based MSB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  unsigned int partsCount, newPartsCount, precision;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  unsigned int partsCount, newPartsCount, precision;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  integerPart *lhsSignificand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  integerPart *lhsSignificand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  integerPart scratch[4];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  integerPart scratch[4];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  integerPart *fullSignificand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  integerPart *fullSignificand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  bool ignored;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  bool ignored;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  precision = semantics->precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  precision = semantics->precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  // Allocate space for twice as many bits as the original significand, plus one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  // Allocate space for twice as many bits as the original significand, plus one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  // extra bit for the addition to overflow into.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  // extra bit for the addition to overflow into.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  newPartsCount = partCountForBits(precision * 2 + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  newPartsCount = partCountForBits(precision * 2 + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  if (newPartsCount > 4)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  if (newPartsCount > 4)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">    fullSignificand = new integerPart[newPartsCount];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">    fullSignificand = new integerPart[newPartsCount];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">    fullSignificand = scratch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">    fullSignificand = scratch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  lhsSignificand = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  lhsSignificand = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  partsCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  partsCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  APInt::tcFullMultiply(fullSignificand, lhsSignificand,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  APInt::tcFullMultiply(fullSignificand, lhsSignificand,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">                        rhs.significandParts(), partsCount, partsCount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">                        rhs.significandParts(), partsCount, partsCount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  exponent += rhs.exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  exponent += rhs.exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  // Assume the operands involved in the multiplication are single-precision</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  // Assume the operands involved in the multiplication are single-precision</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">  // FP, and the two multiplicants are:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">  // FP, and the two multiplicants are:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  //   *this = a23 . a22 ... a0 * 2^e1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  //   *this = a23 . a22 ... a0 * 2^e1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  //     rhs = b23 . b22 ... b0 * 2^e2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  //     rhs = b23 . b22 ... b0 * 2^e2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  // the result of multiplication is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  // the result of multiplication is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  //   *this = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  //   *this = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  // Note that there are three significant bits at the left-hand side of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  // Note that there are three significant bits at the left-hand side of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  // radix point: two for the multiplication, and an overflow bit for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  // radix point: two for the multiplication, and an overflow bit for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  // addition (that will always be zero at this point). Move the radix point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  // addition (that will always be zero at this point). Move the radix point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  // toward left by two bits, and adjust exponent accordingly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  // toward left by two bits, and adjust exponent accordingly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  exponent += 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  exponent += 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  if (addend.isNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  if (addend.isNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">    // The intermediate result of the multiplication has "2 * precision"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">    // The intermediate result of the multiplication has "2 * precision"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">    // signicant bit; adjust the addend to be consistent with mul result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">    // signicant bit; adjust the addend to be consistent with mul result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">    Significand savedSignificand = significand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">    Significand savedSignificand = significand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">    const fltSemantics *savedSemantics = semantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">    const fltSemantics *savedSemantics = semantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">    fltSemantics extendedSemantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">    fltSemantics extendedSemantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    opStatus status;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    opStatus status;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">    unsigned int extendedPrecision;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">    unsigned int extendedPrecision;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    // Normalize our MSB to one below the top bit to allow for overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    // Normalize our MSB to one below the top bit to allow for overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    extendedPrecision = 2 * precision + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    extendedPrecision = 2 * precision + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">    if (omsb != extendedPrecision - 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">    if (omsb != extendedPrecision - 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">      assert(extendedPrecision > omsb);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">      assert(extendedPrecision > omsb);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">      APInt::tcShiftLeft(fullSignificand, newPartsCount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">      APInt::tcShiftLeft(fullSignificand, newPartsCount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">                         (extendedPrecision - 1) - omsb);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">                         (extendedPrecision - 1) - omsb);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">      exponent -= (extendedPrecision - 1) - omsb;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">      exponent -= (extendedPrecision - 1) - omsb;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">    /* Create new semantics.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">    /* Create new semantics.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">    extendedSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">    extendedSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    extendedSemantics.precision = extendedPrecision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    extendedSemantics.precision = extendedPrecision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">    if (newPartsCount == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">    if (newPartsCount == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">      significand.part = fullSignificand[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">      significand.part = fullSignificand[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">      significand.parts = fullSignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">      significand.parts = fullSignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">    semantics = &extendedSemantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">    semantics = &extendedSemantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">    // Make a copy so we can convert it to the extended semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">    // Make a copy so we can convert it to the extended semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">    // Note that we cannot convert the addend directly, as the extendedSemantics</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">    // Note that we cannot convert the addend directly, as the extendedSemantics</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">    // is a local variable (which we take a reference to).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">    // is a local variable (which we take a reference to).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">    IEEEFloat extendedAddend(addend);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">    IEEEFloat extendedAddend(addend);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">    status = extendedAddend.convert(extendedSemantics, rmTowardZero, &ignored);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">    status = extendedAddend.convert(extendedSemantics, rmTowardZero, &ignored);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    assert(status == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    assert(status == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    (void)status;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    (void)status;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">    // Shift the significand of the addend right by one bit. This guarantees</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">    // Shift the significand of the addend right by one bit. This guarantees</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // that the high bit of the significand is zero (same as fullSignificand),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // that the high bit of the significand is zero (same as fullSignificand),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // so the addition will overflow (if it does overflow at all) into the top bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // so the addition will overflow (if it does overflow at all) into the top bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">    lost_fraction = extendedAddend.shiftSignificandRight(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">    lost_fraction = extendedAddend.shiftSignificandRight(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    assert(lost_fraction == lfExactlyZero &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    assert(lost_fraction == lfExactlyZero &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">           "Lost precision while shifting addend for fused-multiply-add.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">           "Lost precision while shifting addend for fused-multiply-add.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">    lost_fraction = addOrSubtractSignificand(extendedAddend, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">    lost_fraction = addOrSubtractSignificand(extendedAddend, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">    /* Restore our state.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">    /* Restore our state.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">    if (newPartsCount == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">    if (newPartsCount == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">      fullSignificand[0] = significand.part;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">      fullSignificand[0] = significand.part;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">    significand = savedSignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">    significand = savedSignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">    semantics = savedSemantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">    semantics = savedSemantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">    omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">    omsb = APInt::tcMSB(fullSignificand, newPartsCount) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  // Convert the result having "2 * precision" significant-bits back to the one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  // Convert the result having "2 * precision" significant-bits back to the one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  // having "precision" significant-bits. First, move the radix point from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  // having "precision" significant-bits. First, move the radix point from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  // poision "2*precision - 1" to "precision - 1". The exponent need to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  // poision "2*precision - 1" to "precision - 1". The exponent need to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  // adjusted by "2*precision - 1" - "precision - 1" = "precision".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  // adjusted by "2*precision - 1" - "precision - 1" = "precision".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  exponent -= precision + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  exponent -= precision + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  // In case MSB resides at the left-hand side of radix point, shift the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  // In case MSB resides at the left-hand side of radix point, shift the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  // mantissa right by some amount to make sure the MSB reside right before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  // mantissa right by some amount to make sure the MSB reside right before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  // the radix point (i.e. "MSB . rest-significant-bits").</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  // the radix point (i.e. "MSB . rest-significant-bits").</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  // Note that the result is not normalized when "omsb < precision". So, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  // Note that the result is not normalized when "omsb < precision". So, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  // caller needs to call IEEEFloat::normalize() if normalized value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  // caller needs to call IEEEFloat::normalize() if normalized value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  // expected.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  // expected.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">  if (omsb > precision) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">  if (omsb > precision) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    unsigned int bits, significantParts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    unsigned int bits, significantParts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">    lostFraction lf;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">    lostFraction lf;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">    bits = omsb - precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">    bits = omsb - precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">    significantParts = partCountForBits(omsb);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">    significantParts = partCountForBits(omsb);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">    lf = shiftRight(fullSignificand, significantParts, bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">    lf = shiftRight(fullSignificand, significantParts, bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">    exponent += bits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">    exponent += bits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  APInt::tcAssign(lhsSignificand, fullSignificand, partsCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  APInt::tcAssign(lhsSignificand, fullSignificand, partsCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">  if (newPartsCount > 4)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">  if (newPartsCount > 4)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">    delete [] fullSignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">    delete [] fullSignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">lostFraction IEEEFloat::multiplySignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  return multiplySignificand(rhs, IEEEFloat(*semantics));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  return multiplySignificand(rhs, IEEEFloat(*semantics));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">/* Multiply the significands of LHS and RHS to DST.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">/* Multiply the significands of LHS and RHS to DST.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">lostFraction IEEEFloat::divideSignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">lostFraction IEEEFloat::divideSignificand(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  unsigned int bit, i, partsCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  unsigned int bit, i, partsCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  const integerPart *rhsSignificand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  const integerPart *rhsSignificand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  integerPart *lhsSignificand, *dividend, *divisor;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  integerPart *lhsSignificand, *dividend, *divisor;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  integerPart scratch[4];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  integerPart scratch[4];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">  lhsSignificand = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">  lhsSignificand = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">  rhsSignificand = rhs.significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">  rhsSignificand = rhs.significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">  partsCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">  partsCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">  if (partsCount > 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">  if (partsCount > 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">    dividend = new integerPart[partsCount * 2];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">    dividend = new integerPart[partsCount * 2];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    dividend = scratch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    dividend = scratch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">  divisor = dividend + partsCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">  divisor = dividend + partsCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  /* Copy the dividend and divisor as they will be modified in-place.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  /* Copy the dividend and divisor as they will be modified in-place.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  for (i = 0; i < partsCount; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  for (i = 0; i < partsCount; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">    dividend[i] = lhsSignificand[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">    dividend[i] = lhsSignificand[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    divisor[i] = rhsSignificand[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    divisor[i] = rhsSignificand[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    lhsSignificand[i] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    lhsSignificand[i] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">  exponent -= rhs.exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">  exponent -= rhs.exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  unsigned int precision = semantics->precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  unsigned int precision = semantics->precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">  /* Normalize the divisor.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">  /* Normalize the divisor.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">  bit = precision - APInt::tcMSB(divisor, partsCount) - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">  bit = precision - APInt::tcMSB(divisor, partsCount) - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">  if (bit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">  if (bit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">    exponent += bit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">    exponent += bit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    APInt::tcShiftLeft(divisor, partsCount, bit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    APInt::tcShiftLeft(divisor, partsCount, bit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /* Normalize the dividend.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /* Normalize the dividend.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">  bit = precision - APInt::tcMSB(dividend, partsCount) - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">  bit = precision - APInt::tcMSB(dividend, partsCount) - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">  if (bit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">  if (bit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">    exponent -= bit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">    exponent -= bit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">    APInt::tcShiftLeft(dividend, partsCount, bit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">    APInt::tcShiftLeft(dividend, partsCount, bit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  /* Ensure the dividend >= divisor initially for the loop below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  /* Ensure the dividend >= divisor initially for the loop below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">     Incidentally, this means that the division loop below is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">     Incidentally, this means that the division loop below is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">     guaranteed to set the integer bit to one.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">     guaranteed to set the integer bit to one.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  if (APInt::tcCompare(dividend, divisor, partsCount) < 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  if (APInt::tcCompare(dividend, divisor, partsCount) < 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">    exponent--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">    exponent--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">    assert(APInt::tcCompare(dividend, divisor, partsCount) >= 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">    assert(APInt::tcCompare(dividend, divisor, partsCount) >= 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">  /* Long division.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">  /* Long division.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">  for (bit = precision; bit; bit -= 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">  for (bit = precision; bit; bit -= 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    if (APInt::tcCompare(dividend, divisor, partsCount) >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    if (APInt::tcCompare(dividend, divisor, partsCount) >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">      APInt::tcSubtract(dividend, divisor, 0, partsCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">      APInt::tcSubtract(dividend, divisor, 0, partsCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">      APInt::tcSetBit(lhsSignificand, bit - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">      APInt::tcSetBit(lhsSignificand, bit - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">    APInt::tcShiftLeft(dividend, partsCount, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">  /* Figure out the lost fraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">  /* Figure out the lost fraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">  int cmp = APInt::tcCompare(dividend, divisor, partsCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">  int cmp = APInt::tcCompare(dividend, divisor, partsCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">  if (cmp > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">  if (cmp > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">    lost_fraction = lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">    lost_fraction = lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">  else if (cmp == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">  else if (cmp == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    lost_fraction = lfExactlyHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    lost_fraction = lfExactlyHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">  else if (APInt::tcIsZero(dividend, partsCount))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">  else if (APInt::tcIsZero(dividend, partsCount))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">    lost_fraction = lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">    lost_fraction = lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">  if (partsCount > 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">  if (partsCount > 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">    delete [] dividend;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">    delete [] dividend;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">unsigned int IEEEFloat::significandMSB() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">unsigned int IEEEFloat::significandMSB() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">  return APInt::tcMSB(significandParts(), partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">  return APInt::tcMSB(significandParts(), partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">unsigned int IEEEFloat::significandLSB() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">unsigned int IEEEFloat::significandLSB() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">  return APInt::tcLSB(significandParts(), partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">  return APInt::tcLSB(significandParts(), partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">/* Note that a zero result is NOT normalized to fcZero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">/* Note that a zero result is NOT normalized to fcZero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">lostFraction IEEEFloat::shiftSignificandRight(unsigned int bits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">lostFraction IEEEFloat::shiftSignificandRight(unsigned int bits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">  /* Our exponent should not overflow.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">  /* Our exponent should not overflow.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">  assert((ExponentType) (exponent + bits) >= exponent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">  assert((ExponentType) (exponent + bits) >= exponent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  exponent += bits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  exponent += bits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  return shiftRight(significandParts(), partCount(), bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  return shiftRight(significandParts(), partCount(), bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">/* Shift the significand left BITS bits, subtract BITS from its exponent.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">/* Shift the significand left BITS bits, subtract BITS from its exponent.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">void IEEEFloat::shiftSignificandLeft(unsigned int bits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">void IEEEFloat::shiftSignificandLeft(unsigned int bits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  assert(bits < semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  assert(bits < semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">  if (bits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">  if (bits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">    unsigned int partsCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">    unsigned int partsCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">    APInt::tcShiftLeft(significandParts(), partsCount, bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">    APInt::tcShiftLeft(significandParts(), partsCount, bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">    exponent -= bits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">    exponent -= bits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">    assert(!APInt::tcIsZero(significandParts(), partsCount));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">    assert(!APInt::tcIsZero(significandParts(), partsCount));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">IEEEFloat::cmpResult</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">IEEEFloat::cmpResult</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">IEEEFloat::compareAbsoluteValue(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">IEEEFloat::compareAbsoluteValue(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  int compare;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  int compare;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  assert(isFiniteNonZero());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  assert(isFiniteNonZero());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  assert(rhs.isFiniteNonZero());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  assert(rhs.isFiniteNonZero());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  compare = exponent - rhs.exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  compare = exponent - rhs.exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">  /* If exponents are equal, do an unsigned bignum comparison of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">  /* If exponents are equal, do an unsigned bignum comparison of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">     significands.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">     significands.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  if (compare == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  if (compare == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">    compare = APInt::tcCompare(significandParts(), rhs.significandParts(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">    compare = APInt::tcCompare(significandParts(), rhs.significandParts(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">                               partCount());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">                               partCount());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  if (compare > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  if (compare > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">    return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">    return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">  else if (compare < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">  else if (compare < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">    return cmpLessThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">    return cmpLessThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">    return cmpEqual;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">    return cmpEqual;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">/* Set the least significant BITS bits of a bignum, clear the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">/* Set the least significant BITS bits of a bignum, clear the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">   rest.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">   rest.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">static void tcSetLeastSignificantBits(APInt::WordType *dst, unsigned parts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">static void tcSetLeastSignificantBits(APInt::WordType *dst, unsigned parts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">                                      unsigned bits) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">                                      unsigned bits) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  unsigned i = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  unsigned i = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  while (bits > APInt::APINT_BITS_PER_WORD) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  while (bits > APInt::APINT_BITS_PER_WORD) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">    dst[i++] = ~(APInt::WordType)0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">    dst[i++] = ~(APInt::WordType)0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">    bits -= APInt::APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">    bits -= APInt::APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  if (bits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  if (bits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">    dst[i++] = ~(APInt::WordType)0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">    dst[i++] = ~(APInt::WordType)0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">  while (i < parts)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">  while (i < parts)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">    dst[i++] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">    dst[i++] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">/* Handle overflow.  Sign is preserved.  We either become infinity or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">/* Handle overflow.  Sign is preserved.  We either become infinity or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">   the largest finite number.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">   the largest finite number.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::handleOverflow(roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::handleOverflow(roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  /* Infinity?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  /* Infinity?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  if (rounding_mode == rmNearestTiesToEven ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  if (rounding_mode == rmNearestTiesToEven ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">      rounding_mode == rmNearestTiesToAway ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">      rounding_mode == rmNearestTiesToAway ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">      (rounding_mode == rmTowardPositive && !sign) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">      (rounding_mode == rmTowardPositive && !sign) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">      (rounding_mode == rmTowardNegative && sign)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">      (rounding_mode == rmTowardNegative && sign)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">      makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">      makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">      category = fcInfinity;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">      category = fcInfinity;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">    return (opStatus) (opOverflow | opInexact);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">    return (opStatus) (opOverflow | opInexact);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">  /* Otherwise we become the largest finite number.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">  /* Otherwise we become the largest finite number.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">  exponent = semantics->maxExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">  exponent = semantics->maxExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">  tcSetLeastSignificantBits(significandParts(), partCount(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">  tcSetLeastSignificantBits(significandParts(), partCount(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">                            semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">                            semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    APInt::tcClearBit(significandParts(), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    APInt::tcClearBit(significandParts(), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">  return opInexact;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">  return opInexact;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">/* Returns TRUE if, when truncating the current number, with BIT the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">/* Returns TRUE if, when truncating the current number, with BIT the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">   new LSB, with the given lost fraction and rounding mode, the result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">   new LSB, with the given lost fraction and rounding mode, the result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">   would need to be rounded away from zero (i.e., by increasing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">   would need to be rounded away from zero (i.e., by increasing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">   signficand).  This routine must work for fcZero of both signs, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">   signficand).  This routine must work for fcZero of both signs, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">   fcNormal numbers.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">   fcNormal numbers.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">bool IEEEFloat::roundAwayFromZero(roundingMode rounding_mode,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">bool IEEEFloat::roundAwayFromZero(roundingMode rounding_mode,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">                                  lostFraction lost_fraction,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">                                  lostFraction lost_fraction,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">                                  unsigned int bit) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">                                  unsigned int bit) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">  /* NaNs and infinities should not have lost fractions.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">  /* NaNs and infinities should not have lost fractions.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  assert(isFiniteNonZero() || category == fcZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  assert(isFiniteNonZero() || category == fcZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">  /* Current callers never pass this so we don't handle it.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">  /* Current callers never pass this so we don't handle it.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  assert(lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  assert(lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">  switch (rounding_mode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">  switch (rounding_mode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  case rmNearestTiesToAway:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  case rmNearestTiesToAway:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">    return lost_fraction == lfExactlyHalf || lost_fraction == lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">    return lost_fraction == lfExactlyHalf || lost_fraction == lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">  case rmNearestTiesToEven:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">  case rmNearestTiesToEven:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">    if (lost_fraction == lfMoreThanHalf)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">    if (lost_fraction == lfMoreThanHalf)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">    /* Our zeroes don't have a significand to test.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">    /* Our zeroes don't have a significand to test.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">    if (lost_fraction == lfExactlyHalf && category != fcZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">    if (lost_fraction == lfExactlyHalf && category != fcZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">      return APInt::tcExtractBit(significandParts(), bit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">      return APInt::tcExtractBit(significandParts(), bit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  case rmTowardZero:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  case rmTowardZero:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">  case rmTowardPositive:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">  case rmTowardPositive:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">    return !sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">    return !sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">  case rmTowardNegative:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">  case rmTowardNegative:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">    return sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">    return sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">  llvm_unreachable("Invalid rounding mode found");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">  llvm_unreachable("Invalid rounding mode found");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::normalize(roundingMode rounding_mode,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::normalize(roundingMode rounding_mode,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">                                         lostFraction lost_fraction) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">                                         lostFraction lost_fraction) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">  unsigned int omsb;                /* One, not zero, based MSB.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">  unsigned int omsb;                /* One, not zero, based MSB.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">  int exponentChange;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">  int exponentChange;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  if (!isFiniteNonZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  if (!isFiniteNonZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">  /* Before rounding normalize the exponent of fcNormal numbers.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">  /* Before rounding normalize the exponent of fcNormal numbers.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">  omsb = significandMSB() + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">  omsb = significandMSB() + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">  if (omsb) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">  if (omsb) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">    /* OMSB is numbered from 1.  We want to place it in the integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">    /* OMSB is numbered from 1.  We want to place it in the integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">       bit numbered PRECISION if possible, with a compensating change in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">       bit numbered PRECISION if possible, with a compensating change in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">       the exponent.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">       the exponent.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">    exponentChange = omsb - semantics->precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">    exponentChange = omsb - semantics->precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">    /* If the resulting exponent is too high, overflow according to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">    /* If the resulting exponent is too high, overflow according to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">       the rounding mode.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">       the rounding mode.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">    if (exponent + exponentChange > semantics->maxExponent)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">    if (exponent + exponentChange > semantics->maxExponent)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">      return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">      return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    /* Subnormal numbers have exponent minExponent, and their MSB</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    /* Subnormal numbers have exponent minExponent, and their MSB</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">       is forced based on that.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">       is forced based on that.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">    if (exponent + exponentChange < semantics->minExponent)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">    if (exponent + exponentChange < semantics->minExponent)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">      exponentChange = semantics->minExponent - exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">      exponentChange = semantics->minExponent - exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">    /* Shifting left is easy as we don't lose precision.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">    /* Shifting left is easy as we don't lose precision.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">    if (exponentChange < 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">    if (exponentChange < 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">      assert(lost_fraction == lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">      assert(lost_fraction == lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">      shiftSignificandLeft(-exponentChange);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">      shiftSignificandLeft(-exponentChange);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">      return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">      return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">    if (exponentChange > 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">    if (exponentChange > 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">      lostFraction lf;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">      lostFraction lf;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">      /* Shift right and capture any new lost fraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">      /* Shift right and capture any new lost fraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">      lf = shiftSignificandRight(exponentChange);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">      lf = shiftSignificandRight(exponentChange);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">      lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">      lost_fraction = combineLostFractions(lf, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">      /* Keep OMSB up-to-date.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">      /* Keep OMSB up-to-date.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">      if (omsb > (unsigned) exponentChange)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">      if (omsb > (unsigned) exponentChange)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">        omsb -= exponentChange;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">        omsb -= exponentChange;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">        omsb = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">        omsb = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">  // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">  // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">  // represented by negative zero, then it is a valid finite value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">  // represented by negative zero, then it is a valid finite value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">      exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">      exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">    return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">    return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">  /* Now round the number according to rounding_mode given the lost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">  /* Now round the number according to rounding_mode given the lost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">     fraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">     fraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">  /* As specified in IEEE 754, since we do not trap we do not report</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">  /* As specified in IEEE 754, since we do not trap we do not report</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">     underflow for exact results.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">     underflow for exact results.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">  if (lost_fraction == lfExactlyZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">  if (lost_fraction == lfExactlyZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">    /* Canonicalize zeroes.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">    /* Canonicalize zeroes.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">    if (omsb == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">    if (omsb == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">      category = fcZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">      category = fcZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">        sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">        sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  /* Increment the significand if we're rounding away from zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  /* Increment the significand if we're rounding away from zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  if (roundAwayFromZero(rounding_mode, lost_fraction, 0)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  if (roundAwayFromZero(rounding_mode, lost_fraction, 0)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">    if (omsb == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">    if (omsb == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">      exponent = semantics->minExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">      exponent = semantics->minExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">    incrementSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">    incrementSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">    omsb = significandMSB() + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">    omsb = significandMSB() + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">    /* Did the significand increment overflow?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">    /* Did the significand increment overflow?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">    if (omsb == (unsigned) semantics->precision + 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">    if (omsb == (unsigned) semantics->precision + 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">      /* Renormalize by incrementing the exponent and shifting our</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">      /* Renormalize by incrementing the exponent and shifting our</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">         significand right one.  However if we already have the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">         significand right one.  However if we already have the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">         maximum exponent we overflow to infinity.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">         maximum exponent we overflow to infinity.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">      if (exponent == semantics->maxExponent)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">      if (exponent == semantics->maxExponent)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">        // Invoke overflow handling with a rounding mode that will guarantee</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">        // Invoke overflow handling with a rounding mode that will guarantee</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">        // that the result gets turned into the correct infinity representation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">        // that the result gets turned into the correct infinity representation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">        // This is needed instead of just setting the category to infinity to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">        // This is needed instead of just setting the category to infinity to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">        // account for 8-bit floating point types that have no inf, only NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">        // account for 8-bit floating point types that have no inf, only NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">        return handleOverflow(sign ? rmTowardNegative : rmTowardPositive);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">        return handleOverflow(sign ? rmTowardNegative : rmTowardPositive);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">      shiftSignificandRight(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">      shiftSignificandRight(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">      return opInexact;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">      return opInexact;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">    // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">    // The all-ones values is an overflow if NaN is all ones. If NaN is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">    // represented by negative zero, then it is a valid finite value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">    // represented by negative zero, then it is a valid finite value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">        semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">        semantics->nanEncoding == fltNanEncoding::AllOnes &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">        exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">        exponent == semantics->maxExponent && isSignificandAllOnes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">      return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">      return handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  /* The normal case - we were and are not denormal, and any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  /* The normal case - we were and are not denormal, and any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">     significand increment above didn't overflow.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">     significand increment above didn't overflow.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">  if (omsb == semantics->precision)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">  if (omsb == semantics->precision)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">    return opInexact;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">    return opInexact;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  /* We have a non-zero denormal.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  /* We have a non-zero denormal.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">  assert(omsb < semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">  assert(omsb < semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">  /* Canonicalize zeroes.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">  /* Canonicalize zeroes.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  if (omsb == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  if (omsb == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  /* The fcZero case is a denormal that underflowed to zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  /* The fcZero case is a denormal that underflowed to zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">  return (opStatus) (opUnderflow | opInexact);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">  return (opStatus) (opUnderflow | opInexact);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::addOrSubtractSpecials(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::addOrSubtractSpecials(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">                                                     bool subtract) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">                                                     bool subtract) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">    category = fcInfinity;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">    category = fcInfinity;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">    sign = rhs.sign ^ subtract;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">    sign = rhs.sign ^ subtract;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">    sign = rhs.sign ^ subtract;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">    sign = rhs.sign ^ subtract;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">    /* Sign depends on rounding mode; handled by caller.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">    /* Sign depends on rounding mode; handled by caller.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">    /* Differently signed infinities can only be validly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">    /* Differently signed infinities can only be validly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">       subtracted.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">       subtracted.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">    if (((sign ^ rhs.sign)!=0) != subtract) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">    if (((sign ^ rhs.sign)!=0) != subtract) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">      makeNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">      makeNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">    return opDivByZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">    return opDivByZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">/* Add or subtract two normal numbers.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">/* Add or subtract two normal numbers.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">lostFraction IEEEFloat::addOrSubtractSignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">lostFraction IEEEFloat::addOrSubtractSignificand(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">                                                 bool subtract) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">                                                 bool subtract) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">  integerPart carry;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">  integerPart carry;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">  int bits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">  int bits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">  /* Determine if the operation on the absolute values is effectively</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">  /* Determine if the operation on the absolute values is effectively</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">     an addition or subtraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">     an addition or subtraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  subtract ^= static_cast<bool>(sign ^ rhs.sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  subtract ^= static_cast<bool>(sign ^ rhs.sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">  /* Are we bigger exponent-wise than the RHS?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">  /* Are we bigger exponent-wise than the RHS?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">  bits = exponent - rhs.exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">  bits = exponent - rhs.exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">  /* Subtraction is more subtle than one might naively expect.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">  /* Subtraction is more subtle than one might naively expect.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">  if (subtract) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">  if (subtract) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    IEEEFloat temp_rhs(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    IEEEFloat temp_rhs(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    if (bits == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    if (bits == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">      lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">      lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">    else if (bits > 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">    else if (bits > 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">      lost_fraction = temp_rhs.shiftSignificandRight(bits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">      lost_fraction = temp_rhs.shiftSignificandRight(bits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">      shiftSignificandLeft(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">      shiftSignificandLeft(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">      lost_fraction = shiftSignificandRight(-bits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">      lost_fraction = shiftSignificandRight(-bits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">      temp_rhs.shiftSignificandLeft(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">      temp_rhs.shiftSignificandLeft(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">    // Should we reverse the subtraction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">    // Should we reverse the subtraction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">    if (compareAbsoluteValue(temp_rhs) == cmpLessThan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">    if (compareAbsoluteValue(temp_rhs) == cmpLessThan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">      carry = temp_rhs.subtractSignificand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">      carry = temp_rhs.subtractSignificand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">        (*this, lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">        (*this, lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">      copySignificand(temp_rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">      copySignificand(temp_rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">      sign = !sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">      sign = !sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">      carry = subtractSignificand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">      carry = subtractSignificand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">        (temp_rhs, lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">        (temp_rhs, lost_fraction != lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">    /* Invert the lost fraction - it was on the RHS and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">    /* Invert the lost fraction - it was on the RHS and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">       subtracted.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">       subtracted.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">    if (lost_fraction == lfLessThanHalf)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">    if (lost_fraction == lfLessThanHalf)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">      lost_fraction = lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">      lost_fraction = lfMoreThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">    else if (lost_fraction == lfMoreThanHalf)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">    else if (lost_fraction == lfMoreThanHalf)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">      lost_fraction = lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">      lost_fraction = lfLessThanHalf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">    /* The code above is intended to ensure that no borrow is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">    /* The code above is intended to ensure that no borrow is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">       necessary.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">       necessary.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">    assert(!carry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">    assert(!carry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">    (void)carry;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">    (void)carry;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">    if (bits > 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">    if (bits > 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">      IEEEFloat temp_rhs(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">      IEEEFloat temp_rhs(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">      lost_fraction = temp_rhs.shiftSignificandRight(bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">      lost_fraction = temp_rhs.shiftSignificandRight(bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">      carry = addSignificand(temp_rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">      carry = addSignificand(temp_rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">      lost_fraction = shiftSignificandRight(-bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">      lost_fraction = shiftSignificandRight(-bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">      carry = addSignificand(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">      carry = addSignificand(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">    /* We have a guard bit; generating a carry cannot happen.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">    /* We have a guard bit; generating a carry cannot happen.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">    assert(!carry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">    assert(!carry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">    (void)carry;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">    (void)carry;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  return lost_fraction;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::multiplySpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::multiplySpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">    sign ^= rhs.sign; // restore the original sign</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">    sign ^= rhs.sign; // restore the original sign</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">    category = fcInfinity;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">    category = fcInfinity;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::divideSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::divideSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">    sign ^= rhs.sign; // restore the original sign</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">    sign ^= rhs.sign; // restore the original sign</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">      makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">      makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">      category = fcInfinity;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">      category = fcInfinity;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">    return opDivByZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">    return opDivByZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::modSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::modSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::remainderSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::remainderSpecials(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    assign(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">    [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">    return rhs.isSignaling() ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">    makeNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">    return opDivByZero; // fake status, indicating this is not a special case</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">    return opDivByZero; // fake status, indicating this is not a special case</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">/* Change sign.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">/* Change sign.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">void IEEEFloat::changeSign() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">void IEEEFloat::changeSign() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">  // With NaN-as-negative-zero, neither NaN or negative zero can change</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">  // With NaN-as-negative-zero, neither NaN or negative zero can change</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">  // their signs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">  // their signs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">      (isZero() || isNaN()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">      (isZero() || isNaN()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">  /* Look mummy, this one's easy.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">  /* Look mummy, this one's easy.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">  sign = !sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">  sign = !sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">/* Normalized addition or subtraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">/* Normalized addition or subtraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::addOrSubtract(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::addOrSubtract(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                             roundingMode rounding_mode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                             roundingMode rounding_mode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">                                             bool subtract) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">                                             bool subtract) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  fs = addOrSubtractSpecials(rhs, subtract);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  fs = addOrSubtractSpecials(rhs, subtract);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  /* This return code means it was not a simple case.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  /* This return code means it was not a simple case.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  if (fs == opDivByZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  if (fs == opDivByZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">    lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">    lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    lost_fraction = addOrSubtractSignificand(rhs, subtract);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    lost_fraction = addOrSubtractSignificand(rhs, subtract);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">    /* Can only be zero if we lost no fraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">    /* Can only be zero if we lost no fraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">    assert(category != fcZero || lost_fraction == lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">    assert(category != fcZero || lost_fraction == lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">  /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">  /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">     positive zero unless rounding to minus infinity, except that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">     positive zero unless rounding to minus infinity, except that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">     adding two like-signed zeroes gives that zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">     adding two like-signed zeroes gives that zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  if (category == fcZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  if (category == fcZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">    if (rhs.category != fcZero || (sign == rhs.sign) == subtract)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">    if (rhs.category != fcZero || (sign == rhs.sign) == subtract)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">      sign = (rounding_mode == rmTowardNegative);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">      sign = (rounding_mode == rmTowardNegative);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">    // NaN-in-negative-zero means zeros need to be normalized to +0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">    // NaN-in-negative-zero means zeros need to be normalized to +0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">/* Normalized addition.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">/* Normalized addition.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::add(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::add(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">                                   roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">                                   roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">  return addOrSubtract(rhs, rounding_mode, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">  return addOrSubtract(rhs, rounding_mode, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">/* Normalized subtraction.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">/* Normalized subtraction.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::subtract(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::subtract(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">  return addOrSubtract(rhs, rounding_mode, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">  return addOrSubtract(rhs, rounding_mode, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">/* Normalized multiply.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">/* Normalized multiply.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::multiply(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::multiply(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  sign ^= rhs.sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  sign ^= rhs.sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  fs = multiplySpecials(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  fs = multiplySpecials(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">    lostFraction lost_fraction = multiplySignificand(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">    lostFraction lost_fraction = multiplySignificand(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">/* Normalized divide.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">/* Normalized divide.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::divide(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::divide(const IEEEFloat &rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">                                      roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">                                      roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  sign ^= rhs.sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  sign ^= rhs.sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  fs = divideSpecials(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  fs = divideSpecials(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">  if (isZero() && semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">    lostFraction lost_fraction = divideSignificand(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">    lostFraction lost_fraction = divideSignificand(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">/* Normalized remainder.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">/* Normalized remainder.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::remainder(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::remainder(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">  unsigned int origSign = sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">  unsigned int origSign = sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  // First handle the special cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  // First handle the special cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">  fs = remainderSpecials(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">  fs = remainderSpecials(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  if (fs != opDivByZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  if (fs != opDivByZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">    return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">    return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  fs = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  fs = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  // Make sure the current value is less than twice the denom. If the addition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  // Make sure the current value is less than twice the denom. If the addition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  // did not succeed (an overflow has happened), which means that the finite</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  // did not succeed (an overflow has happened), which means that the finite</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  // value we currently posses must be less than twice the denom (as we are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  // value we currently posses must be less than twice the denom (as we are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  // using the same semantics).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  // using the same semantics).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  IEEEFloat P2 = rhs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  IEEEFloat P2 = rhs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  if (P2.add(rhs, rmNearestTiesToEven) == opOK) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  if (P2.add(rhs, rmNearestTiesToEven) == opOK) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">    fs = mod(P2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">    fs = mod(P2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // Lets work with absolute numbers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // Lets work with absolute numbers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">  IEEEFloat P = rhs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">  IEEEFloat P = rhs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  P.sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  P.sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">  sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">  sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">  // To calculate the remainder we use the following scheme.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">  // To calculate the remainder we use the following scheme.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">  // The remainder is defained as follows:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">  // The remainder is defained as follows:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">  // remainder = numer - rquot * denom = x - r * p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">  // remainder = numer - rquot * denom = x - r * p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  // Where r is the result of: x/p, rounded toward the nearest integral value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  // Where r is the result of: x/p, rounded toward the nearest integral value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">  // (with halfway cases rounded toward the even number).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">  // (with halfway cases rounded toward the even number).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">  // Currently, (after x mod 2p):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">  // Currently, (after x mod 2p):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">  // r is the number of 2p's present inside x, which is inherently, an even</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">  // r is the number of 2p's present inside x, which is inherently, an even</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">  // number of p's.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">  // number of p's.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  // We may split the remaining calculation into 4 options:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  // We may split the remaining calculation into 4 options:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">  // - if x == 0.5p then we round to the nearest even number which is 0, and we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">  // - if x == 0.5p then we round to the nearest even number which is 0, and we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">  //   are done as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">  //   are done as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">  // - if 0.5p < x < p then we round to nearest number which is 1, and we have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">  // - if 0.5p < x < p then we round to nearest number which is 1, and we have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">  //   to subtract 1p at least once.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">  //   to subtract 1p at least once.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  // - if x >= p then we must subtract p at least once, as x must be a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  // - if x >= p then we must subtract p at least once, as x must be a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">  //   remainder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">  //   remainder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">  // By now, we were done, or we added 1 to r, which in turn, now an odd number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">  // By now, we were done, or we added 1 to r, which in turn, now an odd number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // We can now split the remaining calculation to the following 3 options:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // We can now split the remaining calculation to the following 3 options:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // - if x < 0.5p then we round to the nearest number with is 0, and are done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  // - if x == 0.5p then we round to the nearest even number. As r is odd, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  // - if x == 0.5p then we round to the nearest even number. As r is odd, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">  //   must round up to the next even number. so we must subtract p once more.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">  //   must round up to the next even number. so we must subtract p once more.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">  // - if x > 0.5p (and inherently x < p) then we must round r up to the next</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">  // - if x > 0.5p (and inherently x < p) then we must round r up to the next</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">  //   integral, and subtract p once more.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">  //   integral, and subtract p once more.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">  // Extend the semantics to prevent an overflow/underflow or inexact result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">  // Extend the semantics to prevent an overflow/underflow or inexact result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">  bool losesInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">  bool losesInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">  fltSemantics extendedSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">  fltSemantics extendedSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">  extendedSemantics.maxExponent++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">  extendedSemantics.maxExponent++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">  extendedSemantics.minExponent--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">  extendedSemantics.minExponent--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  extendedSemantics.precision += 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  extendedSemantics.precision += 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">  IEEEFloat VEx = *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">  IEEEFloat VEx = *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">  fs = VEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">  fs = VEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  IEEEFloat PEx = P;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  IEEEFloat PEx = P;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">  fs = PEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">  fs = PEx.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // It is simpler to work with 2x instead of 0.5p, and we do not need to lose</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // It is simpler to work with 2x instead of 0.5p, and we do not need to lose</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  // any fraction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  // any fraction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">  fs = VEx.add(VEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">  fs = VEx.add(VEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">  if (VEx.compare(PEx) == cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">  if (VEx.compare(PEx) == cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">    fs = subtract(P, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">    fs = subtract(P, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">    // Make VEx = this.add(this), but because we have different semantics, we do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">    // Make VEx = this.add(this), but because we have different semantics, we do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">    // not want to `convert` again, so we just subtract PEx twice (which equals</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">    // not want to `convert` again, so we just subtract PEx twice (which equals</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">    // to the desired value).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">    // to the desired value).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">    fs = VEx.subtract(PEx, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">    assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">    cmpResult result = VEx.compare(PEx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">    cmpResult result = VEx.compare(PEx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">    if (result == cmpGreaterThan || result == cmpEqual) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">    if (result == cmpGreaterThan || result == cmpEqual) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">      fs = subtract(P, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">      fs = subtract(P, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">      assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">      assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">    sign = origSign;    // IEEE754 requires this</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">    sign = origSign;    // IEEE754 requires this</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">      // But some 8-bit floats only have positive 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">      // But some 8-bit floats only have positive 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">    sign ^= origSign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">    sign ^= origSign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">/* Normalized llvm frem (C fmod). */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">/* Normalized llvm frem (C fmod). */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::mod(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::mod(const IEEEFloat &rhs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">  fs = modSpecials(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">  fs = modSpecials(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">  unsigned int origSign = sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">  unsigned int origSign = sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">  while (isFiniteNonZero() && rhs.isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">  while (isFiniteNonZero() && rhs.isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">         compareAbsoluteValue(rhs) != cmpLessThan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">         compareAbsoluteValue(rhs) != cmpLessThan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">    int Exp = ilogb(*this) - ilogb(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">    int Exp = ilogb(*this) - ilogb(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">    IEEEFloat V = scalbn(rhs, Exp, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">    IEEEFloat V = scalbn(rhs, Exp, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">    // V can overflow to NaN with fltNonfiniteBehavior::NanOnly, so explicitly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">    // V can overflow to NaN with fltNonfiniteBehavior::NanOnly, so explicitly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">    // check for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">    // check for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">    if (V.isNaN() || compareAbsoluteValue(V) == cmpLessThan)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">    if (V.isNaN() || compareAbsoluteValue(V) == cmpLessThan)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">      V = scalbn(rhs, Exp - 1, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">      V = scalbn(rhs, Exp - 1, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">    V.sign = sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">    V.sign = sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">    fs = subtract(V, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">    fs = subtract(V, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">    assert(fs==opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">    assert(fs==opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">    sign = origSign; // fmod requires this</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">    sign = origSign; // fmod requires this</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">/* Normalized fused-multiply-add.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">/* Normalized fused-multiply-add.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::fusedMultiplyAdd(const IEEEFloat &multiplicand,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::fusedMultiplyAdd(const IEEEFloat &multiplicand,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">                                                const IEEEFloat &addend,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">                                                const IEEEFloat &addend,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">                                                roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">                                                roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  /* Post-multiplication sign, before addition.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  /* Post-multiplication sign, before addition.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">  sign ^= multiplicand.sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">  sign ^= multiplicand.sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  /* If and only if all arguments are normal do we need to do an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  /* If and only if all arguments are normal do we need to do an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">     extended-precision calculation.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">     extended-precision calculation.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  if (isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  if (isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">      multiplicand.isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">      multiplicand.isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">      addend.isFinite()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">      addend.isFinite()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">    lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">    lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">    lost_fraction = multiplySignificand(multiplicand, addend);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">    lost_fraction = multiplySignificand(multiplicand, addend);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">      fs = (opStatus) (fs | opInexact);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">    /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">    /* If two numbers add (exactly) to zero, IEEE 754 decrees it is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">       positive zero unless rounding to minus infinity, except that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">       positive zero unless rounding to minus infinity, except that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">       adding two like-signed zeroes gives that zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">       adding two like-signed zeroes gives that zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">    if (category == fcZero && !(fs & opUnderflow) && sign != addend.sign) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">    if (category == fcZero && !(fs & opUnderflow) && sign != addend.sign) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">      sign = (rounding_mode == rmTowardNegative);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">      sign = (rounding_mode == rmTowardNegative);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">        sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">        sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">    fs = multiplySpecials(multiplicand);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">    fs = multiplySpecials(multiplicand);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    /* FS can only be opOK or opInvalidOp.  There is no more work</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    /* FS can only be opOK or opInvalidOp.  There is no more work</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">       to do in the latter case.  The IEEE-754R standard says it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">       to do in the latter case.  The IEEE-754R standard says it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">       implementation-defined in this case whether, if ADDEND is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">       implementation-defined in this case whether, if ADDEND is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">       quiet NaN, we raise invalid op; this implementation does so.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">       quiet NaN, we raise invalid op; this implementation does so.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">       If we need to do the addition we can do so with normal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">       If we need to do the addition we can do so with normal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">       precision.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">       precision.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">    if (fs == opOK)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">    if (fs == opOK)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">      fs = addOrSubtract(addend, rounding_mode, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">      fs = addOrSubtract(addend, rounding_mode, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">/* Rounding-mode correct round to integral value.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">/* Rounding-mode correct round to integral value.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::roundToIntegral(roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::roundToIntegral(roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">  if (isInfinity())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">  if (isInfinity())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">    // [IEEE Std 754-2008 6.1]:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">    // [IEEE Std 754-2008 6.1]:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">    // The behavior of infinity in floating-point arithmetic is derived from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">    // The behavior of infinity in floating-point arithmetic is derived from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">    // limiting cases of real arithmetic with operands of arbitrarily</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">    // limiting cases of real arithmetic with operands of arbitrarily</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">    // large magnitude, when such a limit exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">    // large magnitude, when such a limit exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">    // ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">    // ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">    // Operations on infinite operands are usually exact and therefore signal no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">    // Operations on infinite operands are usually exact and therefore signal no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">    // exceptions ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">    // exceptions ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">  if (isNaN()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">  if (isNaN()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">      // Under default exception handling, any operation signaling an invalid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">      // Under default exception handling, any operation signaling an invalid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">      // operation exception and for which a floating-point result is to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">      // operation exception and for which a floating-point result is to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">      // delivered shall deliver a quiet NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">      // delivered shall deliver a quiet NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">      // Signaling NaNs shall be reserved operands that, under default exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">      // Signaling NaNs shall be reserved operands that, under default exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">      // handling, signal the invalid operation exception(see 7.2) for every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">      // handling, signal the invalid operation exception(see 7.2) for every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">      // general-computational and signaling-computational operation except for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">      // general-computational and signaling-computational operation except for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">      // the conversions described in 5.12.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">      // the conversions described in 5.12.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">      // [IEEE Std 754-2008 6.2]:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">      // For an operation with quiet NaN inputs, other than maximum and minimum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">      // For an operation with quiet NaN inputs, other than maximum and minimum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">      // operations, if a floating-point result is to be delivered the result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">      // operations, if a floating-point result is to be delivered the result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">      // shall be a quiet NaN which should be one of the input NaNs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">      // shall be a quiet NaN which should be one of the input NaNs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">      // ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">      // ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">      // Every general-computational and quiet-computational operation involving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">      // Every general-computational and quiet-computational operation involving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">      // one or more input NaNs, none of them signaling, shall signal no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">      // one or more input NaNs, none of them signaling, shall signal no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">      // exception, except fusedMultiplyAdd might signal the invalid operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">      // exception, except fusedMultiplyAdd might signal the invalid operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">      // exception(see 7.2).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">      // exception(see 7.2).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">      return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">      return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">    // [IEEE Std 754-2008 6.3]:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">    // [IEEE Std 754-2008 6.3]:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">    // ... the sign of the result of conversions, the quantize operation, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">    // ... the sign of the result of conversions, the quantize operation, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">    // roundToIntegral operations, and the roundToIntegralExact(see 5.3.1) is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">    // roundToIntegral operations, and the roundToIntegralExact(see 5.3.1) is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">    // the sign of the first or only operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">    // the sign of the first or only operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">  // If the exponent is large enough, we know that this value is already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">  // If the exponent is large enough, we know that this value is already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  // integral, and the arithmetic below would potentially cause it to saturate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  // integral, and the arithmetic below would potentially cause it to saturate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  // to +/-Inf.  Bail out early instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  // to +/-Inf.  Bail out early instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">  if (exponent+1 >= (int)semanticsPrecision(*semantics))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">  if (exponent+1 >= (int)semanticsPrecision(*semantics))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">  // The algorithm here is quite simple: we add 2^(p-1), where p is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">  // The algorithm here is quite simple: we add 2^(p-1), where p is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  // precision of our format, and then subtract it back off again.  The choice</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  // precision of our format, and then subtract it back off again.  The choice</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">  // of rounding modes for the addition/subtraction determines the rounding mode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">  // of rounding modes for the addition/subtraction determines the rounding mode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  // for our integral rounding as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  // for our integral rounding as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">  // NOTE: When the input value is negative, we do subtraction followed by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">  // NOTE: When the input value is negative, we do subtraction followed by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">  // addition instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">  // addition instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">  APInt IntegerConstant(NextPowerOf2(semanticsPrecision(*semantics)), 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">  APInt IntegerConstant(NextPowerOf2(semanticsPrecision(*semantics)), 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">  IntegerConstant <<= semanticsPrecision(*semantics)-1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">  IntegerConstant <<= semanticsPrecision(*semantics)-1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">  IEEEFloat MagicConstant(*semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">  IEEEFloat MagicConstant(*semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  fs = MagicConstant.convertFromAPInt(IntegerConstant, false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  fs = MagicConstant.convertFromAPInt(IntegerConstant, false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">                                      rmNearestTiesToEven);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">                                      rmNearestTiesToEven);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">  assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">  assert(fs == opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  MagicConstant.sign = sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  MagicConstant.sign = sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">  // Preserve the input sign so that we can handle the case of zero result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">  // Preserve the input sign so that we can handle the case of zero result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">  // correctly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">  // correctly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">  bool inputSign = isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">  bool inputSign = isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">  fs = add(MagicConstant, rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">  fs = add(MagicConstant, rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">  // Current value and 'MagicConstant' are both integers, so the result of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">  // Current value and 'MagicConstant' are both integers, so the result of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">  // subtraction is always exact according to Sterbenz' lemma.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">  // subtraction is always exact according to Sterbenz' lemma.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">  subtract(MagicConstant, rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">  subtract(MagicConstant, rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">  // Restore the input sign.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">  // Restore the input sign.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">  if (inputSign != isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">  if (inputSign != isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">/* Comparison requires normalized numbers.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">/* Comparison requires normalized numbers.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">IEEEFloat::cmpResult IEEEFloat::compare(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">IEEEFloat::cmpResult IEEEFloat::compare(const IEEEFloat &rhs) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  cmpResult result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  cmpResult result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">  assert(semantics == rhs.semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">  switch (PackCategoriesIntoKey(category, rhs.category)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">    llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNaN, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNaN):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">    return cmpUnordered;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">    return cmpUnordered;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcZero):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">    if (sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">    if (sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcInfinity):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcNormal):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">    if (rhs.sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">    if (rhs.sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcInfinity, fcInfinity):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">    if (sign == rhs.sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">    if (sign == rhs.sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">      return cmpEqual;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">      return cmpEqual;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">    else if (sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">    else if (sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcZero, fcZero):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">    return cmpEqual;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">    return cmpEqual;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  case PackCategoriesIntoKey(fcNormal, fcNormal):</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">  /* Two normal numbers.  Do they have the same sign?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">  /* Two normal numbers.  Do they have the same sign?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">  if (sign != rhs.sign) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">  if (sign != rhs.sign) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">    if (sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">    if (sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">      result = cmpLessThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">      result = cmpLessThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">      result = cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">      result = cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">    /* Compare absolute values; invert result if negative.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">    /* Compare absolute values; invert result if negative.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">    result = compareAbsoluteValue(rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">    result = compareAbsoluteValue(rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">    if (sign) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">    if (sign) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">      if (result == cmpLessThan)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">      if (result == cmpLessThan)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">        result = cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">        result = cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">      else if (result == cmpGreaterThan)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">      else if (result == cmpGreaterThan)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">        result = cmpLessThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">        result = cmpLessThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">/// IEEEFloat::convert - convert a value of one floating point type to another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">/// IEEEFloat::convert - convert a value of one floating point type to another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">/// The return value corresponds to the IEEE754 exceptions.  *losesInfo</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">/// The return value corresponds to the IEEE754 exceptions.  *losesInfo</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">/// records whether the transformation lost information, i.e. whether</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">/// records whether the transformation lost information, i.e. whether</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">/// converting the result back to the original type will produce the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">/// converting the result back to the original type will produce the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">/// original value (this is almost the same as return value==fsOK, but there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">/// original value (this is almost the same as return value==fsOK, but there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">/// are edge cases where this is not so).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">/// are edge cases where this is not so).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convert(const fltSemantics &toSemantics,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convert(const fltSemantics &toSemantics,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">                                       roundingMode rounding_mode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">                                       roundingMode rounding_mode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">                                       bool *losesInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">                                       bool *losesInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">  lostFraction lostFraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">  lostFraction lostFraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">  unsigned int newPartCount, oldPartCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">  unsigned int newPartCount, oldPartCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">  int shift;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">  int shift;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">  const fltSemantics &fromSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">  const fltSemantics &fromSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  bool is_signaling = isSignaling();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  bool is_signaling = isSignaling();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">  lostFraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">  lostFraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">  newPartCount = partCountForBits(toSemantics.precision + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">  newPartCount = partCountForBits(toSemantics.precision + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  oldPartCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  oldPartCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">  shift = toSemantics.precision - fromSemantics.precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">  shift = toSemantics.precision - fromSemantics.precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">  bool X86SpecialNan = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">  bool X86SpecialNan = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">  if (&fromSemantics == &semX87DoubleExtended &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">  if (&fromSemantics == &semX87DoubleExtended &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">      &toSemantics != &semX87DoubleExtended && category == fcNaN &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">      &toSemantics != &semX87DoubleExtended && category == fcNaN &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">      (!(*significandParts() & 0x8000000000000000ULL) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">      (!(*significandParts() & 0x8000000000000000ULL) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">       !(*significandParts() & 0x4000000000000000ULL))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">       !(*significandParts() & 0x4000000000000000ULL))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">    // x86 has some unusual NaNs which cannot be represented in any other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">    // x86 has some unusual NaNs which cannot be represented in any other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">    // format; note them here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">    // format; note them here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">    X86SpecialNan = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">    X86SpecialNan = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  // If this is a truncation of a denormal number, and the target semantics</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  // If this is a truncation of a denormal number, and the target semantics</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">  // has larger exponent range than the source semantics (this can happen</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">  // has larger exponent range than the source semantics (this can happen</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">  // when truncating from PowerPC double-double to double format), the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">  // when truncating from PowerPC double-double to double format), the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">  // right shift could lose result mantissa bits.  Adjust exponent instead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">  // right shift could lose result mantissa bits.  Adjust exponent instead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">  // of performing excessive shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">  // of performing excessive shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">  // Also do a similar trick in case shifting denormal would produce zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">  // Also do a similar trick in case shifting denormal would produce zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">  // significand as this case isn't handled correctly by normalize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">  // significand as this case isn't handled correctly by normalize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">  if (shift < 0 && isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">  if (shift < 0 && isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">    int omsb = significandMSB() + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">    int omsb = significandMSB() + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">    int exponentChange = omsb - fromSemantics.precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">    int exponentChange = omsb - fromSemantics.precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">    if (exponent + exponentChange < toSemantics.minExponent)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">    if (exponent + exponentChange < toSemantics.minExponent)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">      exponentChange = toSemantics.minExponent - exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">      exponentChange = toSemantics.minExponent - exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">    if (exponentChange < shift)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">    if (exponentChange < shift)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">      exponentChange = shift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">      exponentChange = shift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">    if (exponentChange < 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">    if (exponentChange < 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">      shift -= exponentChange;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">      shift -= exponentChange;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">      exponent += exponentChange;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">      exponent += exponentChange;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">    } else if (omsb <= -shift) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">    } else if (omsb <= -shift) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">      exponentChange = omsb + shift - 1; // leave at least one bit set</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">      exponentChange = omsb + shift - 1; // leave at least one bit set</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">      shift -= exponentChange;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">      shift -= exponentChange;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">      exponent += exponentChange;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">      exponent += exponentChange;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">  // If this is a truncation, perform the shift before we narrow the storage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">  // If this is a truncation, perform the shift before we narrow the storage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">  if (shift < 0 && (isFiniteNonZero() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">  if (shift < 0 && (isFiniteNonZero() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">                    (category == fcNaN && semantics->nonFiniteBehavior !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">                    (category == fcNaN && semantics->nonFiniteBehavior !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">                                              fltNonfiniteBehavior::NanOnly)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">                                              fltNonfiniteBehavior::NanOnly)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">    lostFraction = shiftRight(significandParts(), oldPartCount, -shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">    lostFraction = shiftRight(significandParts(), oldPartCount, -shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">  // Fix the storage so it can hold to new value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">  // Fix the storage so it can hold to new value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">  if (newPartCount > oldPartCount) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">  if (newPartCount > oldPartCount) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">    // The new type requires more storage; make it available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">    // The new type requires more storage; make it available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">    integerPart *newParts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">    integerPart *newParts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">    newParts = new integerPart[newPartCount];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">    newParts = new integerPart[newPartCount];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">    APInt::tcSet(newParts, 0, newPartCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">    APInt::tcSet(newParts, 0, newPartCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">      APInt::tcAssign(newParts, significandParts(), oldPartCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">      APInt::tcAssign(newParts, significandParts(), oldPartCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">    freeSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">    freeSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">    significand.parts = newParts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">    significand.parts = newParts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">  } else if (newPartCount == 1 && oldPartCount != 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">  } else if (newPartCount == 1 && oldPartCount != 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">    // Switch to built-in storage for a single part.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">    // Switch to built-in storage for a single part.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">    integerPart newPart = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">    integerPart newPart = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">    if (isFiniteNonZero() || category==fcNaN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">      newPart = significandParts()[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">      newPart = significandParts()[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">    freeSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">    freeSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">    significand.part = newPart;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">    significand.part = newPart;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">  // Now that we have the right storage, switch the semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">  // Now that we have the right storage, switch the semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">  semantics = &toSemantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">  semantics = &toSemantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">  // If this is an extension, perform the shift now that the storage is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">  // If this is an extension, perform the shift now that the storage is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">  // available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">  // available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">  if (shift > 0 && (isFiniteNonZero() || category==fcNaN))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">  if (shift > 0 && (isFiniteNonZero() || category==fcNaN))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">    APInt::tcShiftLeft(significandParts(), newPartCount, shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">    APInt::tcShiftLeft(significandParts(), newPartCount, shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lostFraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lostFraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">    *losesInfo = (fs != opOK);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">    *losesInfo = (fs != opOK);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">  } else if (category == fcNaN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">  } else if (category == fcNaN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">    if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">      *losesInfo =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">      *losesInfo =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">          fromSemantics.nonFiniteBehavior != fltNonfiniteBehavior::NanOnly;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">          fromSemantics.nonFiniteBehavior != fltNonfiniteBehavior::NanOnly;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">      makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">      makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">      return is_signaling ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">      return is_signaling ? opInvalidOp : opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">    // If NaN is negative zero, we need to create a new NaN to avoid converting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">    // If NaN is negative zero, we need to create a new NaN to avoid converting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">    // NaN to -Inf.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">    // NaN to -Inf.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">    if (fromSemantics.nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">    if (fromSemantics.nanEncoding == fltNanEncoding::NegativeZero &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">        semantics->nanEncoding != fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">        semantics->nanEncoding != fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">      makeNaN(false, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">      makeNaN(false, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">    *losesInfo = lostFraction != lfExactlyZero || X86SpecialNan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">    *losesInfo = lostFraction != lfExactlyZero || X86SpecialNan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">    // For x87 extended precision, we want to make a NaN, not a special NaN if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">    // For x87 extended precision, we want to make a NaN, not a special NaN if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">    // the input wasn't special either.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">    // the input wasn't special either.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">    if (!X86SpecialNan && semantics == &semX87DoubleExtended)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">    if (!X86SpecialNan && semantics == &semX87DoubleExtended)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">      APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">      APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">    // Convert of sNaN creates qNaN and raises an exception (invalid op).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">    // Convert of sNaN creates qNaN and raises an exception (invalid op).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">    // This also guarantees that a sNaN does not become Inf on a truncation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">    // This also guarantees that a sNaN does not become Inf on a truncation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">    // that loses all payload bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">    // that loses all payload bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">    if (is_signaling) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">    if (is_signaling) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">      makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">      fs = opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">      fs = opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">      fs = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">      fs = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine">  } else if (category == fcInfinity &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine">  } else if (category == fcInfinity &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">             semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">             semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">    makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">    makeNaN(false, sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">    *losesInfo = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">    *losesInfo = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">    fs = opInexact;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">    fs = opInexact;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">  } else if (category == fcZero &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">  } else if (category == fcZero &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">             semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">             semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">    // Negative zero loses info, but positive zero doesn't.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">    // Negative zero loses info, but positive zero doesn't.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">    *losesInfo =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">    *losesInfo =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">        fromSemantics.nanEncoding != fltNanEncoding::NegativeZero && sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">        fromSemantics.nanEncoding != fltNanEncoding::NegativeZero && sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">    fs = *losesInfo ? opInexact : opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">    fs = *losesInfo ? opInexact : opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">    // NaN is negative zero means -0 -> +0, which can lose information</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">    // NaN is negative zero means -0 -> +0, which can lose information</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">    *losesInfo = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">    *losesInfo = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">    fs = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">    fs = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">/* Convert a floating point number to an integer according to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">/* Convert a floating point number to an integer according to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">   rounding mode.  If the rounded integer value is out of range this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">   rounding mode.  If the rounded integer value is out of range this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">   returns an invalid operation exception and the contents of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">   returns an invalid operation exception and the contents of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">   destination parts are unspecified.  If the rounded value is in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">   destination parts are unspecified.  If the rounded value is in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">   range but the floating point number is not the exact integer, the C</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">   range but the floating point number is not the exact integer, the C</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">   standard doesn't require an inexact exception to be raised.  IEEE</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">   standard doesn't require an inexact exception to be raised.  IEEE</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">   854 does require it so we do that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">   854 does require it so we do that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">   Note that for conversions to integer type the C standard requires</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">   Note that for conversions to integer type the C standard requires</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">   round-to-zero to always be used.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">   round-to-zero to always be used.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convertToSignExtendedInteger(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convertToSignExtendedInteger(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">    MutableArrayRef<integerPart> parts, unsigned int width, bool isSigned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">    MutableArrayRef<integerPart> parts, unsigned int width, bool isSigned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">    roundingMode rounding_mode, bool *isExact) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">    roundingMode rounding_mode, bool *isExact) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine">  const integerPart *src;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine">  const integerPart *src;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">  unsigned int dstPartsCount, truncatedBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">  unsigned int dstPartsCount, truncatedBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">  *isExact = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">  *isExact = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">  /* Handle the three special cases first.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">  /* Handle the three special cases first.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">  if (category == fcInfinity || category == fcNaN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">  if (category == fcInfinity || category == fcNaN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">  dstPartsCount = partCountForBits(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">  dstPartsCount = partCountForBits(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">  assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">  assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">  if (category == fcZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">  if (category == fcZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">    // Negative zero can't be represented as an int.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">    // Negative zero can't be represented as an int.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine">    *isExact = !sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine">    *isExact = !sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">  src = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">  src = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">  /* Step 1: place our absolute value, with any fraction truncated, in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">  /* Step 1: place our absolute value, with any fraction truncated, in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">     the destination.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">     the destination.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">  if (exponent < 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">  if (exponent < 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">    /* Our absolute value is less than one; truncate everything.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">    /* Our absolute value is less than one; truncate everything.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">    APInt::tcSet(parts.data(), 0, dstPartsCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">    /* For exponent -1 the integer bit represents .5, look at that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">    /* For exponent -1 the integer bit represents .5, look at that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">       For smaller exponents leftmost truncated bit is 0. */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">       For smaller exponents leftmost truncated bit is 0. */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">    truncatedBits = semantics->precision -1U - exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">    truncatedBits = semantics->precision -1U - exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine">    /* We want the most significant (exponent + 1) bits; the rest are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine">    /* We want the most significant (exponent + 1) bits; the rest are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">       truncated.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">       truncated.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">    unsigned int bits = exponent + 1U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">    unsigned int bits = exponent + 1U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">    /* Hopelessly large in magnitude?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">    /* Hopelessly large in magnitude?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine">    if (bits > width)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine">    if (bits > width)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">    if (bits < semantics->precision) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">    if (bits < semantics->precision) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">      /* We truncate (semantics->precision - bits) bits.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">      /* We truncate (semantics->precision - bits) bits.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">      truncatedBits = semantics->precision - bits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">      truncatedBits = semantics->precision - bits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">      APInt::tcExtract(parts.data(), dstPartsCount, src, bits, truncatedBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">      APInt::tcExtract(parts.data(), dstPartsCount, src, bits, truncatedBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">      /* We want at least as many bits as are available.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">      /* We want at least as many bits as are available.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">      APInt::tcExtract(parts.data(), dstPartsCount, src, semantics->precision,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">      APInt::tcExtract(parts.data(), dstPartsCount, src, semantics->precision,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">                       0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">                       0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">      APInt::tcShiftLeft(parts.data(), dstPartsCount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">      APInt::tcShiftLeft(parts.data(), dstPartsCount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">                         bits - semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">                         bits - semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">      truncatedBits = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">      truncatedBits = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">  /* Step 2: work out any lost fraction, and increment the absolute</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">  /* Step 2: work out any lost fraction, and increment the absolute</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">     value if we would round away from zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">     value if we would round away from zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">  if (truncatedBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">  if (truncatedBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine">    lost_fraction = lostFractionThroughTruncation(src, partCount(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine">    lost_fraction = lostFractionThroughTruncation(src, partCount(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">                                                  truncatedBits);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">                                                  truncatedBits);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">    if (lost_fraction != lfExactlyZero &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine">        roundAwayFromZero(rounding_mode, lost_fraction, truncatedBits)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine">        roundAwayFromZero(rounding_mode, lost_fraction, truncatedBits)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">      if (APInt::tcIncrement(parts.data(), dstPartsCount))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">      if (APInt::tcIncrement(parts.data(), dstPartsCount))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">        return opInvalidOp;     /* Overflow.  */</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">        return opInvalidOp;     /* Overflow.  */</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">  /* Step 3: check if we fit in the destination.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">  /* Step 3: check if we fit in the destination.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">  unsigned int omsb = APInt::tcMSB(parts.data(), dstPartsCount) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">  unsigned int omsb = APInt::tcMSB(parts.data(), dstPartsCount) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine">  if (sign) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine">  if (sign) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine">    if (!isSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine">    if (!isSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine">      /* Negative numbers cannot be represented as unsigned.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine">      /* Negative numbers cannot be represented as unsigned.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">      if (omsb != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">      if (omsb != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">        return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">        return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine">      /* It takes omsb bits to represent the unsigned integer value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine">      /* It takes omsb bits to represent the unsigned integer value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">         We lose a bit for the sign, but care is needed as the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">         We lose a bit for the sign, but care is needed as the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine">         maximally negative integer is a special case.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine">         maximally negative integer is a special case.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">      if (omsb == width &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">      if (omsb == width &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine">          APInt::tcLSB(parts.data(), dstPartsCount) + 1 != omsb)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine">          APInt::tcLSB(parts.data(), dstPartsCount) + 1 != omsb)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">        return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">        return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine">      /* This case can happen because of rounding.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine">      /* This case can happen because of rounding.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine">      if (omsb > width)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine">      if (omsb > width)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine">        return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine">        return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine">    APInt::tcNegate (parts.data(), dstPartsCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine">    APInt::tcNegate (parts.data(), dstPartsCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">    if (omsb >= width + !isSigned)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">    if (omsb >= width + !isSigned)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">      return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">  if (lost_fraction == lfExactlyZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">  if (lost_fraction == lfExactlyZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine">    *isExact = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine">    *isExact = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine">    return opInexact;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine">    return opInexact;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">/* Same as convertToSignExtendedInteger, except we provide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">/* Same as convertToSignExtendedInteger, except we provide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine">   deterministic values in case of an invalid operation exception,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine">   deterministic values in case of an invalid operation exception,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine">   namely zero for NaNs and the minimal or maximal value respectively</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine">   namely zero for NaNs and the minimal or maximal value respectively</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">   for underflow or overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">   for underflow or overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">   The *isExact output tells whether the result is exact, in the sense</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">   The *isExact output tells whether the result is exact, in the sense</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine">   that converting it back to the original floating point type produces</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine">   that converting it back to the original floating point type produces</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine">   the original value.  This is almost equivalent to result==opOK,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine">   the original value.  This is almost equivalent to result==opOK,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine">   except for negative zeroes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine">   except for negative zeroes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">*/</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">*/</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine">IEEEFloat::convertToInteger(MutableArrayRef<integerPart> parts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine">IEEEFloat::convertToInteger(MutableArrayRef<integerPart> parts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine">                            unsigned int width, bool isSigned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine">                            unsigned int width, bool isSigned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine">                            roundingMode rounding_mode, bool *isExact) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine">                            roundingMode rounding_mode, bool *isExact) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine">  fs = convertToSignExtendedInteger(parts, width, isSigned, rounding_mode,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine">  fs = convertToSignExtendedInteger(parts, width, isSigned, rounding_mode,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">                                    isExact);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">                                    isExact);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine">  if (fs == opInvalidOp) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine">  if (fs == opInvalidOp) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">    unsigned int bits, dstPartsCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">    unsigned int bits, dstPartsCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine">    dstPartsCount = partCountForBits(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine">    dstPartsCount = partCountForBits(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine">    assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine">    assert(dstPartsCount <= parts.size() && "Integer too big");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">    if (category == fcNaN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">    if (category == fcNaN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine">      bits = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine">      bits = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine">    else if (sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine">    else if (sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">      bits = isSigned;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">      bits = isSigned;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine">      bits = width - isSigned;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine">      bits = width - isSigned;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine">    tcSetLeastSignificantBits(parts.data(), dstPartsCount, bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine">    tcSetLeastSignificantBits(parts.data(), dstPartsCount, bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine">    if (sign && isSigned)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine">    if (sign && isSigned)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine">      APInt::tcShiftLeft(parts.data(), dstPartsCount, width - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine">      APInt::tcShiftLeft(parts.data(), dstPartsCount, width - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeLine">/* Convert an unsigned integer SRC to a floating point number,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2728</td>
    <td class="codeLine">/* Convert an unsigned integer SRC to a floating point number,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeLine">   rounding according to ROUNDING_MODE.  The sign of the floating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2729</td>
    <td class="codeLine">   rounding according to ROUNDING_MODE.  The sign of the floating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeLine">   point number is not modified.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2730</td>
    <td class="codeLine">   point number is not modified.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convertFromUnsignedParts(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2731</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convertFromUnsignedParts(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeLine">    const integerPart *src, unsigned int srcCount, roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2732</td>
    <td class="codeLine">    const integerPart *src, unsigned int srcCount, roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeLine">  unsigned int omsb, precision, dstCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2733</td>
    <td class="codeLine">  unsigned int omsb, precision, dstCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeLine">  integerPart *dst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2734</td>
    <td class="codeLine">  integerPart *dst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2735</td>
    <td class="codeLine">  lostFraction lost_fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2737</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeLine">  omsb = APInt::tcMSB(src, srcCount) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2738</td>
    <td class="codeLine">  omsb = APInt::tcMSB(src, srcCount) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeLine">  dst = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2739</td>
    <td class="codeLine">  dst = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeLine">  dstCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2740</td>
    <td class="codeLine">  dstCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeLine">  precision = semantics->precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2741</td>
    <td class="codeLine">  precision = semantics->precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeLine">  /* We want the most significant PRECISION bits of SRC.  There may not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2743</td>
    <td class="codeLine">  /* We want the most significant PRECISION bits of SRC.  There may not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeLine">     be that many; extract what we can.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2744</td>
    <td class="codeLine">     be that many; extract what we can.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeLine">  if (precision <= omsb) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2745</td>
    <td class="codeLine">  if (precision <= omsb) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeLine">    exponent = omsb - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2746</td>
    <td class="codeLine">    exponent = omsb - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeLine">    lost_fraction = lostFractionThroughTruncation(src, srcCount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2747</td>
    <td class="codeLine">    lost_fraction = lostFractionThroughTruncation(src, srcCount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeLine">                                                  omsb - precision);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2748</td>
    <td class="codeLine">                                                  omsb - precision);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeLine">    APInt::tcExtract(dst, dstCount, src, precision, omsb - precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2749</td>
    <td class="codeLine">    APInt::tcExtract(dst, dstCount, src, precision, omsb - precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2750</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeLine">    exponent = precision - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2751</td>
    <td class="codeLine">    exponent = precision - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeLine">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2752</td>
    <td class="codeLine">    lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeLine">    APInt::tcExtract(dst, dstCount, src, omsb, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2753</td>
    <td class="codeLine">    APInt::tcExtract(dst, dstCount, src, omsb, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeLine">  return normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2756</td>
    <td class="codeLine">  return normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2757</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convertFromAPInt(const APInt &Val, bool isSigned,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2759</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::convertFromAPInt(const APInt &Val, bool isSigned,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeLine">                                                roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2760</td>
    <td class="codeLine">                                                roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeLine">  unsigned int partCount = Val.getNumWords();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2761</td>
    <td class="codeLine">  unsigned int partCount = Val.getNumWords();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeLine">  APInt api = Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2762</td>
    <td class="codeLine">  APInt api = Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeLine">  sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2764</td>
    <td class="codeLine">  sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeLine">  if (isSigned && api.isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2765</td>
    <td class="codeLine">  if (isSigned && api.isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeLine">    sign = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2766</td>
    <td class="codeLine">    sign = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeLine">    api = -api;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2767</td>
    <td class="codeLine">    api = -api;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2768</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeLine">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2770</td>
    <td class="codeLine">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeLine">/* Convert a two's complement integer SRC to a floating point number,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2773</td>
    <td class="codeLine">/* Convert a two's complement integer SRC to a floating point number,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeLine">   rounding according to ROUNDING_MODE.  ISSIGNED is true if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2774</td>
    <td class="codeLine">   rounding according to ROUNDING_MODE.  ISSIGNED is true if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeLine">   integer is signed, in which case it must be sign-extended.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2775</td>
    <td class="codeLine">   integer is signed, in which case it must be sign-extended.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2776</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeLine">IEEEFloat::convertFromSignExtendedInteger(const integerPart *src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2777</td>
    <td class="codeLine">IEEEFloat::convertFromSignExtendedInteger(const integerPart *src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeLine">                                          unsigned int srcCount, bool isSigned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2778</td>
    <td class="codeLine">                                          unsigned int srcCount, bool isSigned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeLine">                                          roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2779</td>
    <td class="codeLine">                                          roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeLine">  opStatus status;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2780</td>
    <td class="codeLine">  opStatus status;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeLine">  if (isSigned &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2782</td>
    <td class="codeLine">  if (isSigned &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeLine">      APInt::tcExtractBit(src, srcCount * integerPartWidth - 1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2783</td>
    <td class="codeLine">      APInt::tcExtractBit(src, srcCount * integerPartWidth - 1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeLine">    integerPart *copy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2784</td>
    <td class="codeLine">    integerPart *copy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeLine">    /* If we're signed and negative negate a copy.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2786</td>
    <td class="codeLine">    /* If we're signed and negative negate a copy.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeLine">    sign = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2787</td>
    <td class="codeLine">    sign = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeLine">    copy = new integerPart[srcCount];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2788</td>
    <td class="codeLine">    copy = new integerPart[srcCount];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeLine">    APInt::tcAssign(copy, src, srcCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2789</td>
    <td class="codeLine">    APInt::tcAssign(copy, src, srcCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeLine">    APInt::tcNegate(copy, srcCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2790</td>
    <td class="codeLine">    APInt::tcNegate(copy, srcCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeLine">    status = convertFromUnsignedParts(copy, srcCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2791</td>
    <td class="codeLine">    status = convertFromUnsignedParts(copy, srcCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeLine">    delete [] copy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2792</td>
    <td class="codeLine">    delete [] copy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2793</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2794</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeLine">    status = convertFromUnsignedParts(src, srcCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2795</td>
    <td class="codeLine">    status = convertFromUnsignedParts(src, srcCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2796</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeLine">  return status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2798</td>
    <td class="codeLine">  return status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2799</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeLine">/* FIXME: should this just take a const APInt reference?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2801</td>
    <td class="codeLine">/* FIXME: should this just take a const APInt reference?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2802</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeLine">IEEEFloat::convertFromZeroExtendedInteger(const integerPart *parts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2803</td>
    <td class="codeLine">IEEEFloat::convertFromZeroExtendedInteger(const integerPart *parts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeLine">                                          unsigned int width, bool isSigned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2804</td>
    <td class="codeLine">                                          unsigned int width, bool isSigned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeLine">                                          roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2805</td>
    <td class="codeLine">                                          roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeLine">  unsigned int partCount = partCountForBits(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2806</td>
    <td class="codeLine">  unsigned int partCount = partCountForBits(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeLine">  APInt api = APInt(width, ArrayRef(parts, partCount));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2807</td>
    <td class="codeLine">  APInt api = APInt(width, ArrayRef(parts, partCount));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeLine">  sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2809</td>
    <td class="codeLine">  sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeLine">  if (isSigned && APInt::tcExtractBit(parts, width - 1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2810</td>
    <td class="codeLine">  if (isSigned && APInt::tcExtractBit(parts, width - 1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeLine">    sign = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2811</td>
    <td class="codeLine">    sign = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeLine">    api = -api;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2812</td>
    <td class="codeLine">    api = -api;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2813</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeLine">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2815</td>
    <td class="codeLine">  return convertFromUnsignedParts(api.getRawData(), partCount, rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2816</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeLine">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2818</td>
    <td class="codeLine">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeLine">IEEEFloat::convertFromHexadecimalString(StringRef s,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2819</td>
    <td class="codeLine">IEEEFloat::convertFromHexadecimalString(StringRef s,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2820</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeLine">  lostFraction lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2821</td>
    <td class="codeLine">  lostFraction lost_fraction = lfExactlyZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2823</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeLine">  zeroSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2824</td>
    <td class="codeLine">  zeroSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeLine">  exponent = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2825</td>
    <td class="codeLine">  exponent = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeLine">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2827</td>
    <td class="codeLine">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeLine">  unsigned partsCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2828</td>
    <td class="codeLine">  unsigned partsCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeLine">  unsigned bitPos = partsCount * integerPartWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2829</td>
    <td class="codeLine">  unsigned bitPos = partsCount * integerPartWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeLine">  bool computedTrailingFraction = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2830</td>
    <td class="codeLine">  bool computedTrailingFraction = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeLine">  // Skip leading zeroes and any (hexa)decimal point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2832</td>
    <td class="codeLine">  // Skip leading zeroes and any (hexa)decimal point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeLine">  StringRef::iterator begin = s.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2833</td>
    <td class="codeLine">  StringRef::iterator begin = s.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeLine">  StringRef::iterator end = s.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2834</td>
    <td class="codeLine">  StringRef::iterator end = s.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeLine">  StringRef::iterator dot;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2835</td>
    <td class="codeLine">  StringRef::iterator dot;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeLine">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2836</td>
    <td class="codeLine">  auto PtrOrErr = skipLeadingZeroesAndAnyDot(begin, end, &dot);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeLine">  if (!PtrOrErr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2837</td>
    <td class="codeLine">  if (!PtrOrErr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeLine">    return PtrOrErr.takeError();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2838</td>
    <td class="codeLine">    return PtrOrErr.takeError();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeLine">  StringRef::iterator p = *PtrOrErr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2839</td>
    <td class="codeLine">  StringRef::iterator p = *PtrOrErr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeLine">  StringRef::iterator firstSignificantDigit = p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2840</td>
    <td class="codeLine">  StringRef::iterator firstSignificantDigit = p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeLine">  while (p != end) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2842</td>
    <td class="codeLine">  while (p != end) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeLine">    integerPart hex_value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2843</td>
    <td class="codeLine">    integerPart hex_value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeLine">    if (*p == '.') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2845</td>
    <td class="codeLine">    if (*p == '.') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeLine">      if (dot != end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2846</td>
    <td class="codeLine">      if (dot != end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeLine">        return createError("String contains multiple dots");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2847</td>
    <td class="codeLine">        return createError("String contains multiple dots");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeLine">      dot = p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2848</td>
    <td class="codeLine">      dot = p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2849</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2850</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeLine">    hex_value = hexDigitValue(*p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2852</td>
    <td class="codeLine">    hex_value = hexDigitValue(*p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeLine">    if (hex_value == UINT_MAX)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2853</td>
    <td class="codeLine">    if (hex_value == UINT_MAX)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2854</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2856</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeLine">    // Store the number while we have space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2858</td>
    <td class="codeLine">    // Store the number while we have space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeLine">    if (bitPos) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2859</td>
    <td class="codeLine">    if (bitPos) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeLine">      bitPos -= 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2860</td>
    <td class="codeLine">      bitPos -= 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeLine">      hex_value <<= bitPos % integerPartWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2861</td>
    <td class="codeLine">      hex_value <<= bitPos % integerPartWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeLine">      significand[bitPos / integerPartWidth] |= hex_value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2862</td>
    <td class="codeLine">      significand[bitPos / integerPartWidth] |= hex_value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeLine">    } else if (!computedTrailingFraction) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2863</td>
    <td class="codeLine">    } else if (!computedTrailingFraction) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeLine">      auto FractOrErr = trailingHexadecimalFraction(p, end, hex_value);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2864</td>
    <td class="codeLine">      auto FractOrErr = trailingHexadecimalFraction(p, end, hex_value);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeLine">      if (!FractOrErr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2865</td>
    <td class="codeLine">      if (!FractOrErr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeLine">        return FractOrErr.takeError();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2866</td>
    <td class="codeLine">        return FractOrErr.takeError();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeLine">      lost_fraction = *FractOrErr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2867</td>
    <td class="codeLine">      lost_fraction = *FractOrErr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeLine">      computedTrailingFraction = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2868</td>
    <td class="codeLine">      computedTrailingFraction = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2869</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2870</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeLine">  /* Hex floats require an exponent but not a hexadecimal point.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2872</td>
    <td class="codeLine">  /* Hex floats require an exponent but not a hexadecimal point.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeLine">  if (p == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2873</td>
    <td class="codeLine">  if (p == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeLine">    return createError("Hex strings require an exponent");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2874</td>
    <td class="codeLine">    return createError("Hex strings require an exponent");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeLine">  if (*p != 'p' && *p != 'P')</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2875</td>
    <td class="codeLine">  if (*p != 'p' && *p != 'P')</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeLine">    return createError("Invalid character in significand");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2876</td>
    <td class="codeLine">    return createError("Invalid character in significand");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeLine">  if (p == begin)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2877</td>
    <td class="codeLine">  if (p == begin)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeLine">    return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2878</td>
    <td class="codeLine">    return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeLine">  if (dot != end && p - begin == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2879</td>
    <td class="codeLine">  if (dot != end && p - begin == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeLine">    return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2880</td>
    <td class="codeLine">    return createError("Significand has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeLine">  /* Ignore the exponent if we are zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2882</td>
    <td class="codeLine">  /* Ignore the exponent if we are zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeLine">  if (p != firstSignificantDigit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2883</td>
    <td class="codeLine">  if (p != firstSignificantDigit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeLine">    int expAdjustment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2884</td>
    <td class="codeLine">    int expAdjustment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeLine">    /* Implicit hexadecimal point?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2886</td>
    <td class="codeLine">    /* Implicit hexadecimal point?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeLine">    if (dot == end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2887</td>
    <td class="codeLine">    if (dot == end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeLine">      dot = p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2888</td>
    <td class="codeLine">      dot = p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeLine">    /* Calculate the exponent adjustment implicit in the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2890</td>
    <td class="codeLine">    /* Calculate the exponent adjustment implicit in the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeLine">       significant digits.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2891</td>
    <td class="codeLine">       significant digits.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeLine">    expAdjustment = static_cast<int>(dot - firstSignificantDigit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2892</td>
    <td class="codeLine">    expAdjustment = static_cast<int>(dot - firstSignificantDigit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeLine">    if (expAdjustment < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2893</td>
    <td class="codeLine">    if (expAdjustment < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeLine">      expAdjustment++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2894</td>
    <td class="codeLine">      expAdjustment++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeLine">    expAdjustment = expAdjustment * 4 - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2895</td>
    <td class="codeLine">    expAdjustment = expAdjustment * 4 - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2896</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeLine">    /* Adjust for writing the significand starting at the most</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2897</td>
    <td class="codeLine">    /* Adjust for writing the significand starting at the most</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeLine">       significant nibble.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2898</td>
    <td class="codeLine">       significant nibble.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeLine">    expAdjustment += semantics->precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2899</td>
    <td class="codeLine">    expAdjustment += semantics->precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeLine">    expAdjustment -= partsCount * integerPartWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2900</td>
    <td class="codeLine">    expAdjustment -= partsCount * integerPartWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeLine">    /* Adjust for the given exponent.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2902</td>
    <td class="codeLine">    /* Adjust for the given exponent.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeLine">    auto ExpOrErr = totalExponent(p + 1, end, expAdjustment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2903</td>
    <td class="codeLine">    auto ExpOrErr = totalExponent(p + 1, end, expAdjustment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeLine">    if (!ExpOrErr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2904</td>
    <td class="codeLine">    if (!ExpOrErr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeLine">      return ExpOrErr.takeError();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2905</td>
    <td class="codeLine">      return ExpOrErr.takeError();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeLine">    exponent = *ExpOrErr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2906</td>
    <td class="codeLine">    exponent = *ExpOrErr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2907</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeLine">  return normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2909</td>
    <td class="codeLine">  return normalize(rounding_mode, lost_fraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2910</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2912</td>
    <td class="codeLine">IEEEFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeLine">IEEEFloat::roundSignificandWithExponent(const integerPart *decSigParts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2913</td>
    <td class="codeLine">IEEEFloat::roundSignificandWithExponent(const integerPart *decSigParts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeLine">                                        unsigned sigPartCount, int exp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2914</td>
    <td class="codeLine">                                        unsigned sigPartCount, int exp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2915</td>
    <td class="codeLine">                                        roundingMode rounding_mode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeLine">  unsigned int parts, pow5PartCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2916</td>
    <td class="codeLine">  unsigned int parts, pow5PartCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeLine">  fltSemantics calcSemantics = { 32767, -32767, 0, 0 };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2917</td>
    <td class="codeLine">  fltSemantics calcSemantics = { 32767, -32767, 0, 0 };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeLine">  integerPart pow5Parts[maxPowerOfFiveParts];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2918</td>
    <td class="codeLine">  integerPart pow5Parts[maxPowerOfFiveParts];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeLine">  bool isNearest;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2919</td>
    <td class="codeLine">  bool isNearest;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeLine">  isNearest = (rounding_mode == rmNearestTiesToEven ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2921</td>
    <td class="codeLine">  isNearest = (rounding_mode == rmNearestTiesToEven ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeLine">               rounding_mode == rmNearestTiesToAway);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2922</td>
    <td class="codeLine">               rounding_mode == rmNearestTiesToAway);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeLine">  parts = partCountForBits(semantics->precision + 11);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2924</td>
    <td class="codeLine">  parts = partCountForBits(semantics->precision + 11);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2925</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeLine">  /* Calculate pow(5, abs(exp)).  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2926</td>
    <td class="codeLine">  /* Calculate pow(5, abs(exp)).  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeLine">  pow5PartCount = powerOf5(pow5Parts, exp >= 0 ? exp: -exp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2927</td>
    <td class="codeLine">  pow5PartCount = powerOf5(pow5Parts, exp >= 0 ? exp: -exp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeLine">  for (;; parts *= 2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2929</td>
    <td class="codeLine">  for (;; parts *= 2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeLine">    opStatus sigStatus, powStatus;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2930</td>
    <td class="codeLine">    opStatus sigStatus, powStatus;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeLine">    unsigned int excessPrecision, truncatedBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2931</td>
    <td class="codeLine">    unsigned int excessPrecision, truncatedBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeLine">    calcSemantics.precision = parts * integerPartWidth - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2933</td>
    <td class="codeLine">    calcSemantics.precision = parts * integerPartWidth - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeLine">    excessPrecision = calcSemantics.precision - semantics->precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2934</td>
    <td class="codeLine">    excessPrecision = calcSemantics.precision - semantics->precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeLine">    truncatedBits = excessPrecision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2935</td>
    <td class="codeLine">    truncatedBits = excessPrecision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeLine">    IEEEFloat decSig(calcSemantics, uninitialized);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2937</td>
    <td class="codeLine">    IEEEFloat decSig(calcSemantics, uninitialized);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeLine">    decSig.makeZero(sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2938</td>
    <td class="codeLine">    decSig.makeZero(sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeLine">    IEEEFloat pow5(calcSemantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2939</td>
    <td class="codeLine">    IEEEFloat pow5(calcSemantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeLine">    sigStatus = decSig.convertFromUnsignedParts(decSigParts, sigPartCount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2941</td>
    <td class="codeLine">    sigStatus = decSig.convertFromUnsignedParts(decSigParts, sigPartCount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeLine">                                                rmNearestTiesToEven);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2942</td>
    <td class="codeLine">                                                rmNearestTiesToEven);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeLine">    powStatus = pow5.convertFromUnsignedParts(pow5Parts, pow5PartCount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2943</td>
    <td class="codeLine">    powStatus = pow5.convertFromUnsignedParts(pow5Parts, pow5PartCount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeLine">                                              rmNearestTiesToEven);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2944</td>
    <td class="codeLine">                                              rmNearestTiesToEven);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeLine">    /* Add exp, as 10^n = 5^n * 2^n.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2945</td>
    <td class="codeLine">    /* Add exp, as 10^n = 5^n * 2^n.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeLine">    decSig.exponent += exp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2946</td>
    <td class="codeLine">    decSig.exponent += exp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeLine">    lostFraction calcLostFraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2948</td>
    <td class="codeLine">    lostFraction calcLostFraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeLine">    integerPart HUerr, HUdistance;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2949</td>
    <td class="codeLine">    integerPart HUerr, HUdistance;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeLine">    unsigned int powHUerr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2950</td>
    <td class="codeLine">    unsigned int powHUerr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeLine">    if (exp >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2952</td>
    <td class="codeLine">    if (exp >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeLine">      /* multiplySignificand leaves the precision-th bit set to 1.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2953</td>
    <td class="codeLine">      /* multiplySignificand leaves the precision-th bit set to 1.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeLine">      calcLostFraction = decSig.multiplySignificand(pow5);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2954</td>
    <td class="codeLine">      calcLostFraction = decSig.multiplySignificand(pow5);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeLine">      powHUerr = powStatus != opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2955</td>
    <td class="codeLine">      powHUerr = powStatus != opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2956</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeLine">      calcLostFraction = decSig.divideSignificand(pow5);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2957</td>
    <td class="codeLine">      calcLostFraction = decSig.divideSignificand(pow5);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeLine">      /* Denormal numbers have less precision.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2958</td>
    <td class="codeLine">      /* Denormal numbers have less precision.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeLine">      if (decSig.exponent < semantics->minExponent) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2959</td>
    <td class="codeLine">      if (decSig.exponent < semantics->minExponent) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeLine">        excessPrecision += (semantics->minExponent - decSig.exponent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2960</td>
    <td class="codeLine">        excessPrecision += (semantics->minExponent - decSig.exponent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeLine">        truncatedBits = excessPrecision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2961</td>
    <td class="codeLine">        truncatedBits = excessPrecision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeLine">        if (excessPrecision > calcSemantics.precision)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2962</td>
    <td class="codeLine">        if (excessPrecision > calcSemantics.precision)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeLine">          excessPrecision = calcSemantics.precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2963</td>
    <td class="codeLine">          excessPrecision = calcSemantics.precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2964</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeLine">      /* Extra half-ulp lost in reciprocal of exponent.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2965</td>
    <td class="codeLine">      /* Extra half-ulp lost in reciprocal of exponent.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeLine">      powHUerr = (powStatus == opOK && calcLostFraction == lfExactlyZero) ? 0:2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2966</td>
    <td class="codeLine">      powHUerr = (powStatus == opOK && calcLostFraction == lfExactlyZero) ? 0:2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2967</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeLine">    /* Both multiplySignificand and divideSignificand return the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2969</td>
    <td class="codeLine">    /* Both multiplySignificand and divideSignificand return the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeLine">       result with the integer bit set.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2970</td>
    <td class="codeLine">       result with the integer bit set.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeLine">    assert(APInt::tcExtractBit</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2971</td>
    <td class="codeLine">    assert(APInt::tcExtractBit</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeLine">           (decSig.significandParts(), calcSemantics.precision - 1) == 1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2972</td>
    <td class="codeLine">           (decSig.significandParts(), calcSemantics.precision - 1) == 1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeLine">    HUerr = HUerrBound(calcLostFraction != lfExactlyZero, sigStatus != opOK,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2974</td>
    <td class="codeLine">    HUerr = HUerrBound(calcLostFraction != lfExactlyZero, sigStatus != opOK,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeLine">                       powHUerr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2975</td>
    <td class="codeLine">                       powHUerr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeLine">    HUdistance = 2 * ulpsFromBoundary(decSig.significandParts(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2976</td>
    <td class="codeLine">    HUdistance = 2 * ulpsFromBoundary(decSig.significandParts(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeLine">                                      excessPrecision, isNearest);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2977</td>
    <td class="codeLine">                                      excessPrecision, isNearest);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeLine">    /* Are we guaranteed to round correctly if we truncate?  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2979</td>
    <td class="codeLine">    /* Are we guaranteed to round correctly if we truncate?  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeLine">    if (HUdistance >= HUerr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2980</td>
    <td class="codeLine">    if (HUdistance >= HUerr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeLine">      APInt::tcExtract(significandParts(), partCount(), decSig.significandParts(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2981</td>
    <td class="codeLine">      APInt::tcExtract(significandParts(), partCount(), decSig.significandParts(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeLine">                       calcSemantics.precision - excessPrecision,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2982</td>
    <td class="codeLine">                       calcSemantics.precision - excessPrecision,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeLine">                       excessPrecision);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2983</td>
    <td class="codeLine">                       excessPrecision);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeLine">      /* Take the exponent of decSig.  If we tcExtract-ed less bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2984</td>
    <td class="codeLine">      /* Take the exponent of decSig.  If we tcExtract-ed less bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeLine">         above we must adjust our exponent to compensate for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2985</td>
    <td class="codeLine">         above we must adjust our exponent to compensate for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeLine">         implicit right shift.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2986</td>
    <td class="codeLine">         implicit right shift.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeLine">      exponent = (decSig.exponent + semantics->precision</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2987</td>
    <td class="codeLine">      exponent = (decSig.exponent + semantics->precision</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeLine">                  - (calcSemantics.precision - excessPrecision));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2988</td>
    <td class="codeLine">                  - (calcSemantics.precision - excessPrecision));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeLine">      calcLostFraction = lostFractionThroughTruncation(decSig.significandParts(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2989</td>
    <td class="codeLine">      calcLostFraction = lostFractionThroughTruncation(decSig.significandParts(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeLine">                                                       decSig.partCount(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2990</td>
    <td class="codeLine">                                                       decSig.partCount(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeLine">                                                       truncatedBits);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2991</td>
    <td class="codeLine">                                                       truncatedBits);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeLine">      return normalize(rounding_mode, calcLostFraction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2992</td>
    <td class="codeLine">      return normalize(rounding_mode, calcLostFraction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2993</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2994</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2995</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeLine">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2997</td>
    <td class="codeLine">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeLine">IEEEFloat::convertFromDecimalString(StringRef str, roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2998</td>
    <td class="codeLine">IEEEFloat::convertFromDecimalString(StringRef str, roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeLine">  decimalInfo D;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2999</td>
    <td class="codeLine">  decimalInfo D;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3000</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeLine">  /* Scan the text.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3002</td>
    <td class="codeLine">  /* Scan the text.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3003</td>
    <td class="codeLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeLine">  if (Error Err = interpretDecimal(p, str.end(), &D))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3004</td>
    <td class="codeLine">  if (Error Err = interpretDecimal(p, str.end(), &D))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeLine">    return std::move(Err);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3005</td>
    <td class="codeLine">    return std::move(Err);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeLine">  /* Handle the quick cases.  First the case of no significant digits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3007</td>
    <td class="codeLine">  /* Handle the quick cases.  First the case of no significant digits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeLine">     i.e. zero, and then exponents that are obviously too large or too</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3008</td>
    <td class="codeLine">     i.e. zero, and then exponents that are obviously too large or too</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeLine">     small.  Writing L for log 10 / log 2, a number d.ddddd*10^exp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3009</td>
    <td class="codeLine">     small.  Writing L for log 10 / log 2, a number d.ddddd*10^exp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeLine">     definitely overflows if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3010</td>
    <td class="codeLine">     definitely overflows if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeLine">           (exp - 1) * L >= maxExponent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3012</td>
    <td class="codeLine">           (exp - 1) * L >= maxExponent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeLine">     and definitely underflows to zero where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3014</td>
    <td class="codeLine">     and definitely underflows to zero where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeLine">           (exp + 1) * L <= minExponent - precision</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3016</td>
    <td class="codeLine">           (exp + 1) * L <= minExponent - precision</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeLine">     With integer arithmetic the tightest bounds for L are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3018</td>
    <td class="codeLine">     With integer arithmetic the tightest bounds for L are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeLine">           93/28 < L < 196/59            [ numerator <= 256 ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3020</td>
    <td class="codeLine">           93/28 < L < 196/59            [ numerator <= 256 ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeLine">           42039/12655 < L < 28738/8651  [ numerator <= 65536 ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3021</td>
    <td class="codeLine">           42039/12655 < L < 28738/8651  [ numerator <= 65536 ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeLine">  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3022</td>
    <td class="codeLine">  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeLine">  // Test if we have a zero number allowing for strings with no null terminators</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3024</td>
    <td class="codeLine">  // Test if we have a zero number allowing for strings with no null terminators</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeLine">  // and zero decimals with non-zero exponents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3025</td>
    <td class="codeLine">  // and zero decimals with non-zero exponents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3026</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeLine">  // We computed firstSigDigit by ignoring all zeros and dots. Thus if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3027</td>
    <td class="codeLine">  // We computed firstSigDigit by ignoring all zeros and dots. Thus if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeLine">  // D->firstSigDigit equals str.end(), every digit must be a zero and there can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3028</td>
    <td class="codeLine">  // D->firstSigDigit equals str.end(), every digit must be a zero and there can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeLine">  // be at most one dot. On the other hand, if we have a zero with a non-zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3029</td>
    <td class="codeLine">  // be at most one dot. On the other hand, if we have a zero with a non-zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeLine">  // exponent, then we know that D.firstSigDigit will be non-numeric.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3030</td>
    <td class="codeLine">  // exponent, then we know that D.firstSigDigit will be non-numeric.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeLine">  if (D.firstSigDigit == str.end() || decDigitValue(*D.firstSigDigit) >= 10U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3031</td>
    <td class="codeLine">  if (D.firstSigDigit == str.end() || decDigitValue(*D.firstSigDigit) >= 10U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3032</td>
    <td class="codeLine">    category = fcZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeLine">    fs = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3033</td>
    <td class="codeLine">    fs = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3034</td>
    <td class="codeLine">    if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3035</td>
    <td class="codeLine">      sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeLine">    /* Check whether the normalized exponent is high enough to overflow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3037</td>
    <td class="codeLine">    /* Check whether the normalized exponent is high enough to overflow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeLine">       max during the log-rebasing in the max-exponent check below. */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3038</td>
    <td class="codeLine">       max during the log-rebasing in the max-exponent check below. */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeLine">  } else if (D.normalizedExponent - 1 > INT_MAX / 42039) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3039</td>
    <td class="codeLine">  } else if (D.normalizedExponent - 1 > INT_MAX / 42039) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeLine">    fs = handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3040</td>
    <td class="codeLine">    fs = handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeLine">  /* If it wasn't, then it also wasn't high enough to overflow max</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3042</td>
    <td class="codeLine">  /* If it wasn't, then it also wasn't high enough to overflow max</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeLine">     during the log-rebasing in the min-exponent check.  Check that it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3043</td>
    <td class="codeLine">     during the log-rebasing in the min-exponent check.  Check that it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeLine">     won't overflow min in either check, then perform the min-exponent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3044</td>
    <td class="codeLine">     won't overflow min in either check, then perform the min-exponent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeLine">     check. */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3045</td>
    <td class="codeLine">     check. */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeLine">  } else if (D.normalizedExponent - 1 < INT_MIN / 42039 ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3046</td>
    <td class="codeLine">  } else if (D.normalizedExponent - 1 < INT_MIN / 42039 ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeLine">             (D.normalizedExponent + 1) * 28738 <=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3047</td>
    <td class="codeLine">             (D.normalizedExponent + 1) * 28738 <=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeLine">               8651 * (semantics->minExponent - (int) semantics->precision)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3048</td>
    <td class="codeLine">               8651 * (semantics->minExponent - (int) semantics->precision)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeLine">    /* Underflow to zero and round.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3049</td>
    <td class="codeLine">    /* Underflow to zero and round.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeLine">    category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3050</td>
    <td class="codeLine">    category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeLine">    zeroSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3051</td>
    <td class="codeLine">    zeroSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lfLessThanHalf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3052</td>
    <td class="codeLine">    fs = normalize(rounding_mode, lfLessThanHalf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeLine">  /* We can finally safely perform the max-exponent check. */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3054</td>
    <td class="codeLine">  /* We can finally safely perform the max-exponent check. */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeLine">  } else if ((D.normalizedExponent - 1) * 42039</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3055</td>
    <td class="codeLine">  } else if ((D.normalizedExponent - 1) * 42039</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeLine">             >= 12655 * semantics->maxExponent) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3056</td>
    <td class="codeLine">             >= 12655 * semantics->maxExponent) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeLine">    /* Overflow and round.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3057</td>
    <td class="codeLine">    /* Overflow and round.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeLine">    fs = handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3058</td>
    <td class="codeLine">    fs = handleOverflow(rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3059</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeLine">    integerPart *decSignificand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3060</td>
    <td class="codeLine">    integerPart *decSignificand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeLine">    unsigned int partCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3061</td>
    <td class="codeLine">    unsigned int partCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeLine">    /* A tight upper bound on number of bits required to hold an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3063</td>
    <td class="codeLine">    /* A tight upper bound on number of bits required to hold an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeLine">       N-digit decimal integer is N * 196 / 59.  Allocate enough space</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3064</td>
    <td class="codeLine">       N-digit decimal integer is N * 196 / 59.  Allocate enough space</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeLine">       to hold the full significand, and an extra part required by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3065</td>
    <td class="codeLine">       to hold the full significand, and an extra part required by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeLine">       tcMultiplyPart.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3066</td>
    <td class="codeLine">       tcMultiplyPart.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeLine">    partCount = static_cast<unsigned int>(D.lastSigDigit - D.firstSigDigit) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3067</td>
    <td class="codeLine">    partCount = static_cast<unsigned int>(D.lastSigDigit - D.firstSigDigit) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeLine">    partCount = partCountForBits(1 + 196 * partCount / 59);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3068</td>
    <td class="codeLine">    partCount = partCountForBits(1 + 196 * partCount / 59);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeLine">    decSignificand = new integerPart[partCount + 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3069</td>
    <td class="codeLine">    decSignificand = new integerPart[partCount + 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeLine">    partCount = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3070</td>
    <td class="codeLine">    partCount = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeLine">    /* Convert to binary efficiently - we do almost all multiplication</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3072</td>
    <td class="codeLine">    /* Convert to binary efficiently - we do almost all multiplication</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeLine">       in an integerPart.  When this would overflow do we do a single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3073</td>
    <td class="codeLine">       in an integerPart.  When this would overflow do we do a single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeLine">       bignum multiplication, and then revert again to multiplication</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3074</td>
    <td class="codeLine">       bignum multiplication, and then revert again to multiplication</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeLine">       in an integerPart.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3075</td>
    <td class="codeLine">       in an integerPart.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3076</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeLine">      integerPart decValue, val, multiplier;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3077</td>
    <td class="codeLine">      integerPart decValue, val, multiplier;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeLine">      val = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3079</td>
    <td class="codeLine">      val = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeLine">      multiplier = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3080</td>
    <td class="codeLine">      multiplier = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeLine">      do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3082</td>
    <td class="codeLine">      do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeLine">        if (*p == '.') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3083</td>
    <td class="codeLine">        if (*p == '.') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeLine">          p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3084</td>
    <td class="codeLine">          p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeLine">          if (p == str.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3085</td>
    <td class="codeLine">          if (p == str.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeLine">            break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3086</td>
    <td class="codeLine">            break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3087</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3088</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeLine">        decValue = decDigitValue(*p++);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3089</td>
    <td class="codeLine">        decValue = decDigitValue(*p++);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeLine">        if (decValue >= 10U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3090</td>
    <td class="codeLine">        if (decValue >= 10U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeLine">          delete[] decSignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3091</td>
    <td class="codeLine">          delete[] decSignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeLine">          return createError("Invalid character in significand");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3092</td>
    <td class="codeLine">          return createError("Invalid character in significand");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3093</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeLine">        multiplier *= 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3094</td>
    <td class="codeLine">        multiplier *= 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeLine">        val = val * 10 + decValue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3095</td>
    <td class="codeLine">        val = val * 10 + decValue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeLine">        /* The maximum number that can be multiplied by ten with any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3096</td>
    <td class="codeLine">        /* The maximum number that can be multiplied by ten with any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeLine">           digit added without overflowing an integerPart.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3097</td>
    <td class="codeLine">           digit added without overflowing an integerPart.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeLine">      } while (p <= D.lastSigDigit && multiplier <= (~ (integerPart) 0 - 9) / 10);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3098</td>
    <td class="codeLine">      } while (p <= D.lastSigDigit && multiplier <= (~ (integerPart) 0 - 9) / 10);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeLine">      /* Multiply out the current part.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3100</td>
    <td class="codeLine">      /* Multiply out the current part.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeLine">      APInt::tcMultiplyPart(decSignificand, decSignificand, multiplier, val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3101</td>
    <td class="codeLine">      APInt::tcMultiplyPart(decSignificand, decSignificand, multiplier, val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeLine">                            partCount, partCount + 1, false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3102</td>
    <td class="codeLine">                            partCount, partCount + 1, false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeLine">      /* If we used another part (likely but not guaranteed), increase</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3104</td>
    <td class="codeLine">      /* If we used another part (likely but not guaranteed), increase</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeLine">         the count.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3105</td>
    <td class="codeLine">         the count.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeLine">      if (decSignificand[partCount])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3106</td>
    <td class="codeLine">      if (decSignificand[partCount])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeLine">        partCount++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3107</td>
    <td class="codeLine">        partCount++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeLine">    } while (p <= D.lastSigDigit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3108</td>
    <td class="codeLine">    } while (p <= D.lastSigDigit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeLine">    category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3110</td>
    <td class="codeLine">    category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeLine">    fs = roundSignificandWithExponent(decSignificand, partCount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3111</td>
    <td class="codeLine">    fs = roundSignificandWithExponent(decSignificand, partCount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeLine">                                      D.exponent, rounding_mode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3112</td>
    <td class="codeLine">                                      D.exponent, rounding_mode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeLine">    delete [] decSignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3114</td>
    <td class="codeLine">    delete [] decSignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3115</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3117</td>
    <td class="codeLine">  return fs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3118</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeLine">bool IEEEFloat::convertFromStringSpecials(StringRef str) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3120</td>
    <td class="codeLine">bool IEEEFloat::convertFromStringSpecials(StringRef str) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeLine">  const size_t MIN_NAME_SIZE = 3;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3121</td>
    <td class="codeLine">  const size_t MIN_NAME_SIZE = 3;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeLine">  if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3123</td>
    <td class="codeLine">  if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3124</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeLine">  if (str.equals("inf") || str.equals("INFINITY") || str.equals("+Inf")) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3126</td>
    <td class="codeLine">  if (str.equals("inf") || str.equals("INFINITY") || str.equals("+Inf")) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeLine">    makeInf(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3127</td>
    <td class="codeLine">    makeInf(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3128</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeLine">  bool IsNegative = str.front() == '-';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3131</td>
    <td class="codeLine">  bool IsNegative = str.front() == '-';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeLine">  if (IsNegative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3132</td>
    <td class="codeLine">  if (IsNegative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeLine">    str = str.drop_front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3133</td>
    <td class="codeLine">    str = str.drop_front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeLine">    if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3134</td>
    <td class="codeLine">    if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3135</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeLine">    if (str.equals("inf") || str.equals("INFINITY") || str.equals("Inf")) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3137</td>
    <td class="codeLine">    if (str.equals("inf") || str.equals("INFINITY") || str.equals("Inf")) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeLine">      makeInf(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3138</td>
    <td class="codeLine">      makeInf(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3139</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3140</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3141</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeLine">  // If we have a 's' (or 'S') prefix, then this is a Signaling NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3143</td>
    <td class="codeLine">  // If we have a 's' (or 'S') prefix, then this is a Signaling NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeLine">  bool IsSignaling = str.front() == 's' || str.front() == 'S';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3144</td>
    <td class="codeLine">  bool IsSignaling = str.front() == 's' || str.front() == 'S';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeLine">  if (IsSignaling) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3145</td>
    <td class="codeLine">  if (IsSignaling) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeLine">    str = str.drop_front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3146</td>
    <td class="codeLine">    str = str.drop_front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeLine">    if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3147</td>
    <td class="codeLine">    if (str.size() < MIN_NAME_SIZE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3148</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeLine">  if (str.startswith("nan") || str.startswith("NaN")) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3151</td>
    <td class="codeLine">  if (str.startswith("nan") || str.startswith("NaN")) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeLine">    str = str.drop_front(3);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3152</td>
    <td class="codeLine">    str = str.drop_front(3);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeLine">    // A NaN without payload.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3154</td>
    <td class="codeLine">    // A NaN without payload.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeLine">    if (str.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3155</td>
    <td class="codeLine">    if (str.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeLine">      makeNaN(IsSignaling, IsNegative);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3156</td>
    <td class="codeLine">      makeNaN(IsSignaling, IsNegative);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3157</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3158</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeLine">    // Allow the payload to be inside parentheses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3160</td>
    <td class="codeLine">    // Allow the payload to be inside parentheses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeLine">    if (str.front() == '(') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3161</td>
    <td class="codeLine">    if (str.front() == '(') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeLine">      // Parentheses should be balanced (and not empty).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3162</td>
    <td class="codeLine">      // Parentheses should be balanced (and not empty).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeLine">      if (str.size() <= 2 || str.back() != ')')</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3163</td>
    <td class="codeLine">      if (str.size() <= 2 || str.back() != ')')</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3164</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeLine">      str = str.slice(1, str.size() - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3166</td>
    <td class="codeLine">      str = str.slice(1, str.size() - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3167</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeLine">    // Determine the payload number's radix.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3169</td>
    <td class="codeLine">    // Determine the payload number's radix.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeLine">    unsigned Radix = 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3170</td>
    <td class="codeLine">    unsigned Radix = 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeLine">    if (str[0] == '0') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3171</td>
    <td class="codeLine">    if (str[0] == '0') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeLine">      if (str.size() > 1 && tolower(str[1]) == 'x') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3172</td>
    <td class="codeLine">      if (str.size() > 1 && tolower(str[1]) == 'x') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeLine">        str = str.drop_front(2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3173</td>
    <td class="codeLine">        str = str.drop_front(2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeLine">        Radix = 16;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3174</td>
    <td class="codeLine">        Radix = 16;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3175</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeLine">        Radix = 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3176</td>
    <td class="codeLine">        Radix = 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3177</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeLine">    // Parse the payload and make the NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3179</td>
    <td class="codeLine">    // Parse the payload and make the NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeLine">    APInt Payload;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3180</td>
    <td class="codeLine">    APInt Payload;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeLine">    if (!str.getAsInteger(Radix, Payload)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3181</td>
    <td class="codeLine">    if (!str.getAsInteger(Radix, Payload)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeLine">      makeNaN(IsSignaling, IsNegative, &Payload);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3182</td>
    <td class="codeLine">      makeNaN(IsSignaling, IsNegative, &Payload);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3183</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3184</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3187</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeLine">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3190</td>
    <td class="codeLine">Expected<IEEEFloat::opStatus></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeLine">IEEEFloat::convertFromString(StringRef str, roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3191</td>
    <td class="codeLine">IEEEFloat::convertFromString(StringRef str, roundingMode rounding_mode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeLine">  if (str.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3192</td>
    <td class="codeLine">  if (str.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeLine">    return createError("Invalid string length");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3193</td>
    <td class="codeLine">    return createError("Invalid string length");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeLine">  // Handle special cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3195</td>
    <td class="codeLine">  // Handle special cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeLine">  if (convertFromStringSpecials(str))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3196</td>
    <td class="codeLine">  if (convertFromStringSpecials(str))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3197</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeLine">  /* Handle a leading minus sign.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3199</td>
    <td class="codeLine">  /* Handle a leading minus sign.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3200</td>
    <td class="codeLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeLine">  size_t slen = str.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3201</td>
    <td class="codeLine">  size_t slen = str.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeLine">  sign = *p == '-' ? 1 : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3202</td>
    <td class="codeLine">  sign = *p == '-' ? 1 : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3203</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3204</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeLine">    slen--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3205</td>
    <td class="codeLine">    slen--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeLine">    if (!slen)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3206</td>
    <td class="codeLine">    if (!slen)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeLine">      return createError("String has no digits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3207</td>
    <td class="codeLine">      return createError("String has no digits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeLine">  if (slen >= 2 && p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3210</td>
    <td class="codeLine">  if (slen >= 2 && p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeLine">    if (slen == 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3211</td>
    <td class="codeLine">    if (slen == 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeLine">      return createError("Invalid string");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3212</td>
    <td class="codeLine">      return createError("Invalid string");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeLine">    return convertFromHexadecimalString(StringRef(p + 2, slen - 2),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3213</td>
    <td class="codeLine">    return convertFromHexadecimalString(StringRef(p + 2, slen - 2),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeLine">                                        rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3214</td>
    <td class="codeLine">                                        rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeLine">  return convertFromDecimalString(StringRef(p, slen), rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3217</td>
    <td class="codeLine">  return convertFromDecimalString(StringRef(p, slen), rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3218</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeLine">/* Write out a hexadecimal representation of the floating point value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3220</td>
    <td class="codeLine">/* Write out a hexadecimal representation of the floating point value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeLine">   to DST, which must be of sufficient size, in the C99 form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3221</td>
    <td class="codeLine">   to DST, which must be of sufficient size, in the C99 form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeLine">   [-]0xh.hhhhp[+-]d.  Return the number of characters written,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3222</td>
    <td class="codeLine">   [-]0xh.hhhhp[+-]d.  Return the number of characters written,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeLine">   excluding the terminating NUL.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3223</td>
    <td class="codeLine">   excluding the terminating NUL.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeLine">   If UPPERCASE, the output is in upper case, otherwise in lower case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3225</td>
    <td class="codeLine">   If UPPERCASE, the output is in upper case, otherwise in lower case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeLine">   HEXDIGITS digits appear altogether, rounding the value if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3227</td>
    <td class="codeLine">   HEXDIGITS digits appear altogether, rounding the value if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeLine">   necessary.  If HEXDIGITS is 0, the minimal precision to display the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3228</td>
    <td class="codeLine">   necessary.  If HEXDIGITS is 0, the minimal precision to display the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeLine">   number precisely is used instead.  If nothing would appear after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3229</td>
    <td class="codeLine">   number precisely is used instead.  If nothing would appear after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeLine">   the decimal point it is suppressed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3230</td>
    <td class="codeLine">   the decimal point it is suppressed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeLine">   The decimal exponent is always printed and has at least one digit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3232</td>
    <td class="codeLine">   The decimal exponent is always printed and has at least one digit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeLine">   Zero values display an exponent of zero.  Infinities and NaNs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3233</td>
    <td class="codeLine">   Zero values display an exponent of zero.  Infinities and NaNs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeLine">   appear as "infinity" or "nan" respectively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3234</td>
    <td class="codeLine">   appear as "infinity" or "nan" respectively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeLine">   The above rules are as specified by C99.  There is ambiguity about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3236</td>
    <td class="codeLine">   The above rules are as specified by C99.  There is ambiguity about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeLine">   what the leading hexadecimal digit should be.  This implementation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3237</td>
    <td class="codeLine">   what the leading hexadecimal digit should be.  This implementation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeLine">   uses whatever is necessary so that the exponent is displayed as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3238</td>
    <td class="codeLine">   uses whatever is necessary so that the exponent is displayed as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeLine">   stored.  This implies the exponent will fall within the IEEE format</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3239</td>
    <td class="codeLine">   stored.  This implies the exponent will fall within the IEEE format</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeLine">   range, and the leading hexadecimal digit will be 0 (for denormals),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3240</td>
    <td class="codeLine">   range, and the leading hexadecimal digit will be 0 (for denormals),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeLine">   1 (normal numbers) or 2 (normal numbers rounded-away-from-zero with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3241</td>
    <td class="codeLine">   1 (normal numbers) or 2 (normal numbers rounded-away-from-zero with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeLine">   any other digits zero).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3242</td>
    <td class="codeLine">   any other digits zero).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeLine">*/</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3243</td>
    <td class="codeLine">*/</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeLine">unsigned int IEEEFloat::convertToHexString(char *dst, unsigned int hexDigits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3244</td>
    <td class="codeLine">unsigned int IEEEFloat::convertToHexString(char *dst, unsigned int hexDigits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeLine">                                           bool upperCase,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3245</td>
    <td class="codeLine">                                           bool upperCase,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeLine">                                           roundingMode rounding_mode) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3246</td>
    <td class="codeLine">                                           roundingMode rounding_mode) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeLine">  char *p;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3247</td>
    <td class="codeLine">  char *p;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeLine">  p = dst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3249</td>
    <td class="codeLine">  p = dst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeLine">  if (sign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3250</td>
    <td class="codeLine">  if (sign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeLine">    *dst++ = '-';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3251</td>
    <td class="codeLine">    *dst++ = '-';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeLine">  switch (category) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3253</td>
    <td class="codeLine">  switch (category) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeLine">  case fcInfinity:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3254</td>
    <td class="codeLine">  case fcInfinity:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeLine">    memcpy (dst, upperCase ? infinityU: infinityL, sizeof infinityU - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3255</td>
    <td class="codeLine">    memcpy (dst, upperCase ? infinityU: infinityL, sizeof infinityU - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeLine">    dst += sizeof infinityL - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3256</td>
    <td class="codeLine">    dst += sizeof infinityL - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3257</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeLine">  case fcNaN:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3259</td>
    <td class="codeLine">  case fcNaN:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeLine">    memcpy (dst, upperCase ? NaNU: NaNL, sizeof NaNU - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3260</td>
    <td class="codeLine">    memcpy (dst, upperCase ? NaNU: NaNL, sizeof NaNU - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeLine">    dst += sizeof NaNU - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3261</td>
    <td class="codeLine">    dst += sizeof NaNU - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3262</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeLine">  case fcZero:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3264</td>
    <td class="codeLine">  case fcZero:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeLine">    *dst++ = '0';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3265</td>
    <td class="codeLine">    *dst++ = '0';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeLine">    *dst++ = upperCase ? 'X': 'x';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3266</td>
    <td class="codeLine">    *dst++ = upperCase ? 'X': 'x';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeLine">    *dst++ = '0';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3267</td>
    <td class="codeLine">    *dst++ = '0';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeLine">    if (hexDigits > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3268</td>
    <td class="codeLine">    if (hexDigits > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeLine">      *dst++ = '.';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3269</td>
    <td class="codeLine">      *dst++ = '.';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeLine">      memset (dst, '0', hexDigits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3270</td>
    <td class="codeLine">      memset (dst, '0', hexDigits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeLine">      dst += hexDigits - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3271</td>
    <td class="codeLine">      dst += hexDigits - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3272</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeLine">    *dst++ = upperCase ? 'P': 'p';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3273</td>
    <td class="codeLine">    *dst++ = upperCase ? 'P': 'p';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeLine">    *dst++ = '0';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3274</td>
    <td class="codeLine">    *dst++ = '0';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3275</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeLine">  case fcNormal:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3277</td>
    <td class="codeLine">  case fcNormal:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="codeLine">    dst = convertNormalToHexString (dst, hexDigits, upperCase, rounding_mode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3278</td>
    <td class="codeLine">    dst = convertNormalToHexString (dst, hexDigits, upperCase, rounding_mode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3279</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3280</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="codeLine">  *dst = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3282</td>
    <td class="codeLine">  *dst = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="codeLine">  return static_cast<unsigned int>(dst - p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3284</td>
    <td class="codeLine">  return static_cast<unsigned int>(dst - p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3285</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="codeLine">/* Does the hard work of outputting the correctly rounded hexadecimal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3287</td>
    <td class="codeLine">/* Does the hard work of outputting the correctly rounded hexadecimal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="codeLine">   form of a normal floating point number with the specified number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3288</td>
    <td class="codeLine">   form of a normal floating point number with the specified number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="codeLine">   hexadecimal digits.  If HEXDIGITS is zero the minimum number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3289</td>
    <td class="codeLine">   hexadecimal digits.  If HEXDIGITS is zero the minimum number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="codeLine">   digits necessary to print the value precisely is output.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3290</td>
    <td class="codeLine">   digits necessary to print the value precisely is output.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="codeLine">char *IEEEFloat::convertNormalToHexString(char *dst, unsigned int hexDigits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3291</td>
    <td class="codeLine">char *IEEEFloat::convertNormalToHexString(char *dst, unsigned int hexDigits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="codeLine">                                          bool upperCase,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3292</td>
    <td class="codeLine">                                          bool upperCase,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="codeLine">                                          roundingMode rounding_mode) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3293</td>
    <td class="codeLine">                                          roundingMode rounding_mode) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="codeLine">  unsigned int count, valueBits, shift, partsCount, outputDigits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3294</td>
    <td class="codeLine">  unsigned int count, valueBits, shift, partsCount, outputDigits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="codeLine">  const char *hexDigitChars;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3295</td>
    <td class="codeLine">  const char *hexDigitChars;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="codeLine">  const integerPart *significand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3296</td>
    <td class="codeLine">  const integerPart *significand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="codeLine">  char *p;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3297</td>
    <td class="codeLine">  char *p;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="codeLine">  bool roundUp;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3298</td>
    <td class="codeLine">  bool roundUp;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="codeLine">  *dst++ = '0';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3300</td>
    <td class="codeLine">  *dst++ = '0';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="codeLine">  *dst++ = upperCase ? 'X': 'x';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3301</td>
    <td class="codeLine">  *dst++ = upperCase ? 'X': 'x';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="codeLine">  roundUp = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3303</td>
    <td class="codeLine">  roundUp = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="codeLine">  hexDigitChars = upperCase ? hexDigitsUpper: hexDigitsLower;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3304</td>
    <td class="codeLine">  hexDigitChars = upperCase ? hexDigitsUpper: hexDigitsLower;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="codeLine">  significand = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3306</td>
    <td class="codeLine">  significand = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="codeLine">  partsCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3307</td>
    <td class="codeLine">  partsCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="codeLine">  /* +3 because the first digit only uses the single integer bit, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3309</td>
    <td class="codeLine">  /* +3 because the first digit only uses the single integer bit, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="codeLine">     we have 3 virtual zero most-significant-bits.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3310</td>
    <td class="codeLine">     we have 3 virtual zero most-significant-bits.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="codeLine">  valueBits = semantics->precision + 3;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3311</td>
    <td class="codeLine">  valueBits = semantics->precision + 3;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="codeLine">  shift = integerPartWidth - valueBits % integerPartWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3312</td>
    <td class="codeLine">  shift = integerPartWidth - valueBits % integerPartWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="codeLine">  /* The natural number of digits required ignoring trailing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3314</td>
    <td class="codeLine">  /* The natural number of digits required ignoring trailing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="codeLine">     insignificant zeroes.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3315</td>
    <td class="codeLine">     insignificant zeroes.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="codeLine">  outputDigits = (valueBits - significandLSB () + 3) / 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3316</td>
    <td class="codeLine">  outputDigits = (valueBits - significandLSB () + 3) / 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="codeLine">  /* hexDigits of zero means use the required number for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3318</td>
    <td class="codeLine">  /* hexDigits of zero means use the required number for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="codeLine">     precision.  Otherwise, see if we are truncating.  If we are,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3319</td>
    <td class="codeLine">     precision.  Otherwise, see if we are truncating.  If we are,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="codeLine">     find out if we need to round away from zero.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3320</td>
    <td class="codeLine">     find out if we need to round away from zero.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="codeLine">  if (hexDigits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3321</td>
    <td class="codeLine">  if (hexDigits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="codeLine">    if (hexDigits < outputDigits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3322</td>
    <td class="codeLine">    if (hexDigits < outputDigits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="codeLine">      /* We are dropping non-zero bits, so need to check how to round.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3323</td>
    <td class="codeLine">      /* We are dropping non-zero bits, so need to check how to round.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="codeLine">         "bits" is the number of dropped bits.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3324</td>
    <td class="codeLine">         "bits" is the number of dropped bits.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="codeLine">      unsigned int bits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3325</td>
    <td class="codeLine">      unsigned int bits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="codeLine">      lostFraction fraction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3326</td>
    <td class="codeLine">      lostFraction fraction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="codeLine">      bits = valueBits - hexDigits * 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3328</td>
    <td class="codeLine">      bits = valueBits - hexDigits * 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="codeLine">      fraction = lostFractionThroughTruncation (significand, partsCount, bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3329</td>
    <td class="codeLine">      fraction = lostFractionThroughTruncation (significand, partsCount, bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="codeLine">      roundUp = roundAwayFromZero(rounding_mode, fraction, bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3330</td>
    <td class="codeLine">      roundUp = roundAwayFromZero(rounding_mode, fraction, bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3331</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="codeLine">    outputDigits = hexDigits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3332</td>
    <td class="codeLine">    outputDigits = hexDigits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3333</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="codeLine">  /* Write the digits consecutively, and start writing in the location</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3335</td>
    <td class="codeLine">  /* Write the digits consecutively, and start writing in the location</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="codeLine">     of the hexadecimal point.  We move the most significant digit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3336</td>
    <td class="codeLine">     of the hexadecimal point.  We move the most significant digit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="codeLine">     left and add the hexadecimal point later.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3337</td>
    <td class="codeLine">     left and add the hexadecimal point later.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="codeLine">  p = ++dst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3338</td>
    <td class="codeLine">  p = ++dst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="codeLine">  count = (valueBits + integerPartWidth - 1) / integerPartWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3340</td>
    <td class="codeLine">  count = (valueBits + integerPartWidth - 1) / integerPartWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="codeLine">  while (outputDigits && count) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3342</td>
    <td class="codeLine">  while (outputDigits && count) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="codeLine">    integerPart part;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3343</td>
    <td class="codeLine">    integerPart part;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="codeLine">    /* Put the most significant integerPartWidth bits in "part".  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3345</td>
    <td class="codeLine">    /* Put the most significant integerPartWidth bits in "part".  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="codeLine">    if (--count == partsCount)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3346</td>
    <td class="codeLine">    if (--count == partsCount)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="codeLine">      part = 0;  /* An imaginary higher zero part.  */</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3347</td>
    <td class="codeLine">      part = 0;  /* An imaginary higher zero part.  */</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3348</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="codeLine">      part = significand[count] << shift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3349</td>
    <td class="codeLine">      part = significand[count] << shift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="codeLine">    if (count && shift)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3351</td>
    <td class="codeLine">    if (count && shift)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="codeLine">      part |= significand[count - 1] >> (integerPartWidth - shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3352</td>
    <td class="codeLine">      part |= significand[count - 1] >> (integerPartWidth - shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="codeLine">    /* Convert as much of "part" to hexdigits as we can.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3354</td>
    <td class="codeLine">    /* Convert as much of "part" to hexdigits as we can.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="codeLine">    unsigned int curDigits = integerPartWidth / 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3355</td>
    <td class="codeLine">    unsigned int curDigits = integerPartWidth / 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="codeLine">    if (curDigits > outputDigits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3357</td>
    <td class="codeLine">    if (curDigits > outputDigits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="codeLine">      curDigits = outputDigits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3358</td>
    <td class="codeLine">      curDigits = outputDigits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="codeLine">    dst += partAsHex (dst, part, curDigits, hexDigitChars);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3359</td>
    <td class="codeLine">    dst += partAsHex (dst, part, curDigits, hexDigitChars);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="codeLine">    outputDigits -= curDigits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3360</td>
    <td class="codeLine">    outputDigits -= curDigits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="codeLine">  if (roundUp) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3363</td>
    <td class="codeLine">  if (roundUp) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="codeLine">    char *q = dst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3364</td>
    <td class="codeLine">    char *q = dst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="codeLine">    /* Note that hexDigitChars has a trailing '0'.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3366</td>
    <td class="codeLine">    /* Note that hexDigitChars has a trailing '0'.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3367</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="codeLine">      q--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3368</td>
    <td class="codeLine">      q--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="codeLine">      *q = hexDigitChars[hexDigitValue (*q) + 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3369</td>
    <td class="codeLine">      *q = hexDigitChars[hexDigitValue (*q) + 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="codeLine">    } while (*q == '0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3370</td>
    <td class="codeLine">    } while (*q == '0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="codeLine">    assert(q >= p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3371</td>
    <td class="codeLine">    assert(q >= p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3372</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="codeLine">    /* Add trailing zeroes.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3373</td>
    <td class="codeLine">    /* Add trailing zeroes.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="codeLine">    memset (dst, '0', outputDigits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3374</td>
    <td class="codeLine">    memset (dst, '0', outputDigits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="codeLine">    dst += outputDigits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3375</td>
    <td class="codeLine">    dst += outputDigits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3376</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="codeLine">  /* Move the most significant digit to before the point, and if there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3378</td>
    <td class="codeLine">  /* Move the most significant digit to before the point, and if there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="codeLine">     is something after the decimal point add it.  This must come</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3379</td>
    <td class="codeLine">     is something after the decimal point add it.  This must come</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="codeLine">     after rounding above.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3380</td>
    <td class="codeLine">     after rounding above.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="codeLine">  p[-1] = p[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3381</td>
    <td class="codeLine">  p[-1] = p[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="codeLine">  if (dst -1 == p)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3382</td>
    <td class="codeLine">  if (dst -1 == p)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="codeLine">    dst--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3383</td>
    <td class="codeLine">    dst--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3384</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="codeLine">    p[0] = '.';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3385</td>
    <td class="codeLine">    p[0] = '.';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="codeLine">  /* Finally output the exponent.  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3387</td>
    <td class="codeLine">  /* Finally output the exponent.  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="codeLine">  *dst++ = upperCase ? 'P': 'p';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3388</td>
    <td class="codeLine">  *dst++ = upperCase ? 'P': 'p';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="codeLine">  return writeSignedDecimal (dst, exponent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3390</td>
    <td class="codeLine">  return writeSignedDecimal (dst, exponent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3391</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="codeLine">hash_code hash_value(const IEEEFloat &Arg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3393</td>
    <td class="codeLine">hash_code hash_value(const IEEEFloat &Arg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="codeLine">  if (!Arg.isFiniteNonZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3394</td>
    <td class="codeLine">  if (!Arg.isFiniteNonZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="codeLine">    return hash_combine((uint8_t)Arg.category,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3395</td>
    <td class="codeLine">    return hash_combine((uint8_t)Arg.category,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="codeLine">                        // NaN has no sign, fix it at zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3396</td>
    <td class="codeLine">                        // NaN has no sign, fix it at zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="codeLine">                        Arg.isNaN() ? (uint8_t)0 : (uint8_t)Arg.sign,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3397</td>
    <td class="codeLine">                        Arg.isNaN() ? (uint8_t)0 : (uint8_t)Arg.sign,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="codeLine">                        Arg.semantics->precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3398</td>
    <td class="codeLine">                        Arg.semantics->precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="codeLine">  // Normal floats need their exponent and significand hashed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3400</td>
    <td class="codeLine">  // Normal floats need their exponent and significand hashed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="codeLine">  return hash_combine((uint8_t)Arg.category, (uint8_t)Arg.sign,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3401</td>
    <td class="codeLine">  return hash_combine((uint8_t)Arg.category, (uint8_t)Arg.sign,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="codeLine">                      Arg.semantics->precision, Arg.exponent,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3402</td>
    <td class="codeLine">                      Arg.semantics->precision, Arg.exponent,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="codeLine">                      hash_combine_range(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3403</td>
    <td class="codeLine">                      hash_combine_range(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="codeLine">                        Arg.significandParts(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3404</td>
    <td class="codeLine">                        Arg.significandParts(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="codeLine">                        Arg.significandParts() + Arg.partCount()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3405</td>
    <td class="codeLine">                        Arg.significandParts() + Arg.partCount()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3406</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="codeLine">// Conversion from APFloat to/from host float/double.  It may eventually be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3408</td>
    <td class="codeLine">// Conversion from APFloat to/from host float/double.  It may eventually be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="codeLine">// possible to eliminate these and have everybody deal with APFloats, but that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3409</td>
    <td class="codeLine">// possible to eliminate these and have everybody deal with APFloats, but that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="codeLine">// will take a while.  This approach will not easily extend to long double.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3410</td>
    <td class="codeLine">// will take a while.  This approach will not easily extend to long double.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="codeLine">// Current implementation requires integerPartWidth==64, which is correct at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3411</td>
    <td class="codeLine">// Current implementation requires integerPartWidth==64, which is correct at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="codeLine">// the moment but could be made more general.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3412</td>
    <td class="codeLine">// the moment but could be made more general.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="codeLine">// Denormals have exponent minExponent in APFloat, but minExponent-1 in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3414</td>
    <td class="codeLine">// Denormals have exponent minExponent in APFloat, but minExponent-1 in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="codeLine">// the actual IEEE respresentations.  We compensate for that here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3415</td>
    <td class="codeLine">// the actual IEEE respresentations.  We compensate for that here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="codeLine">APInt IEEEFloat::convertF80LongDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3417</td>
    <td class="codeLine">APInt IEEEFloat::convertF80LongDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3418</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="codeLine">  assert(partCount()==2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3419</td>
    <td class="codeLine">  assert(partCount()==2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="codeLine">  uint64_t myexponent, mysignificand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3421</td>
    <td class="codeLine">  uint64_t myexponent, mysignificand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3423</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="codeLine">    myexponent = exponent+16383; //bias</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3424</td>
    <td class="codeLine">    myexponent = exponent+16383; //bias</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="codeLine">    mysignificand = significandParts()[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3425</td>
    <td class="codeLine">    mysignificand = significandParts()[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="codeLine">    if (myexponent==1 && !(mysignificand & 0x8000000000000000ULL))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3426</td>
    <td class="codeLine">    if (myexponent==1 && !(mysignificand & 0x8000000000000000ULL))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="codeLine">      myexponent = 0;   // denormal</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3427</td>
    <td class="codeLine">      myexponent = 0;   // denormal</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="codeLine">  } else if (category==fcZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3428</td>
    <td class="codeLine">  } else if (category==fcZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="codeLine">    myexponent = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3429</td>
    <td class="codeLine">    myexponent = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="codeLine">    mysignificand = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3430</td>
    <td class="codeLine">    mysignificand = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="codeLine">  } else if (category==fcInfinity) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3431</td>
    <td class="codeLine">  } else if (category==fcInfinity) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="codeLine">    myexponent = 0x7fff;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3432</td>
    <td class="codeLine">    myexponent = 0x7fff;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="codeLine">    mysignificand = 0x8000000000000000ULL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3433</td>
    <td class="codeLine">    mysignificand = 0x8000000000000000ULL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3434</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="codeLine">    assert(category == fcNaN && "Unknown category");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3435</td>
    <td class="codeLine">    assert(category == fcNaN && "Unknown category");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="codeLine">    myexponent = 0x7fff;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3436</td>
    <td class="codeLine">    myexponent = 0x7fff;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="codeLine">    mysignificand = significandParts()[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3437</td>
    <td class="codeLine">    mysignificand = significandParts()[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="codeLine">  uint64_t words[2];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3440</td>
    <td class="codeLine">  uint64_t words[2];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="codeLine">  words[0] = mysignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3441</td>
    <td class="codeLine">  words[0] = mysignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="codeLine">  words[1] =  ((uint64_t)(sign & 1) << 15) |</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3442</td>
    <td class="codeLine">  words[1] =  ((uint64_t)(sign & 1) << 15) |</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="codeLine">              (myexponent & 0x7fffLL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3443</td>
    <td class="codeLine">              (myexponent & 0x7fffLL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="codeLine">  return APInt(80, words);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3444</td>
    <td class="codeLine">  return APInt(80, words);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3445</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="codeLine">APInt IEEEFloat::convertPPCDoubleDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3447</td>
    <td class="codeLine">APInt IEEEFloat::convertPPCDoubleDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3448</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="codeLine">  assert(partCount()==2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3449</td>
    <td class="codeLine">  assert(partCount()==2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="codeLine">  uint64_t words[2];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3451</td>
    <td class="codeLine">  uint64_t words[2];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3452</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class="codeLine">  bool losesInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3453</td>
    <td class="codeLine">  bool losesInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="codeLine">  // Convert number to double.  To avoid spurious underflows, we re-</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3455</td>
    <td class="codeLine">  // Convert number to double.  To avoid spurious underflows, we re-</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="codeLine">  // normalize against the "double" minExponent first, and only *then*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3456</td>
    <td class="codeLine">  // normalize against the "double" minExponent first, and only *then*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="codeLine">  // truncate the mantissa.  The result of that second conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3457</td>
    <td class="codeLine">  // truncate the mantissa.  The result of that second conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="codeLine">  // may be inexact, but should never underflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3458</td>
    <td class="codeLine">  // may be inexact, but should never underflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="codeLine">  // Declare fltSemantics before APFloat that uses it (and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3459</td>
    <td class="codeLine">  // Declare fltSemantics before APFloat that uses it (and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="codeLine">  // saves pointer to it) to ensure correct destruction order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3460</td>
    <td class="codeLine">  // saves pointer to it) to ensure correct destruction order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="codeLine">  fltSemantics extendedSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3461</td>
    <td class="codeLine">  fltSemantics extendedSemantics = *semantics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="codeLine">  extendedSemantics.minExponent = semIEEEdouble.minExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3462</td>
    <td class="codeLine">  extendedSemantics.minExponent = semIEEEdouble.minExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="codeLine">  IEEEFloat extended(*this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3463</td>
    <td class="codeLine">  IEEEFloat extended(*this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="codeLine">  fs = extended.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3464</td>
    <td class="codeLine">  fs = extended.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3465</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="codeLine">  (void)fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3466</td>
    <td class="codeLine">  (void)fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="codeLine">  IEEEFloat u(extended);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3468</td>
    <td class="codeLine">  IEEEFloat u(extended);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="codeLine">  fs = u.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3469</td>
    <td class="codeLine">  fs = u.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="codeLine">  assert(fs == opOK || fs == opInexact);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3470</td>
    <td class="codeLine">  assert(fs == opOK || fs == opInexact);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="codeLine">  (void)fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3471</td>
    <td class="codeLine">  (void)fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="codeLine">  words[0] = *u.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3472</td>
    <td class="codeLine">  words[0] = *u.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="codeLine">  // If conversion was exact or resulted in a special case, we're done;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3474</td>
    <td class="codeLine">  // If conversion was exact or resulted in a special case, we're done;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="codeLine">  // just set the second double to zero.  Otherwise, re-convert back to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3475</td>
    <td class="codeLine">  // just set the second double to zero.  Otherwise, re-convert back to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="codeLine">  // the extended format and compute the difference.  This now should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3476</td>
    <td class="codeLine">  // the extended format and compute the difference.  This now should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="codeLine">  // convert exactly to double.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3477</td>
    <td class="codeLine">  // convert exactly to double.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="codeLine">  if (u.isFiniteNonZero() && losesInfo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3478</td>
    <td class="codeLine">  if (u.isFiniteNonZero() && losesInfo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="codeLine">    fs = u.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3479</td>
    <td class="codeLine">    fs = u.convert(extendedSemantics, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="codeLine">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3480</td>
    <td class="codeLine">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="codeLine">    (void)fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3481</td>
    <td class="codeLine">    (void)fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="codeLine">    IEEEFloat v(extended);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3483</td>
    <td class="codeLine">    IEEEFloat v(extended);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="codeLine">    v.subtract(u, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3484</td>
    <td class="codeLine">    v.subtract(u, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class="codeLine">    fs = v.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3485</td>
    <td class="codeLine">    fs = v.convert(semIEEEdouble, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="codeLine">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3486</td>
    <td class="codeLine">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="codeLine">    (void)fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3487</td>
    <td class="codeLine">    (void)fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="codeLine">    words[1] = *v.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3488</td>
    <td class="codeLine">    words[1] = *v.convertDoubleAPFloatToAPInt().getRawData();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3489</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="codeLine">    words[1] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3490</td>
    <td class="codeLine">    words[1] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="codeLine">  return APInt(128, words);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3493</td>
    <td class="codeLine">  return APInt(128, words);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3494</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="codeLine">template <const fltSemantics &S></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3496</td>
    <td class="codeLine">template <const fltSemantics &S></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="codeLine">APInt IEEEFloat::convertIEEEFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3497</td>
    <td class="codeLine">APInt IEEEFloat::convertIEEEFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="codeLine">  assert(semantics == &S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3498</td>
    <td class="codeLine">  assert(semantics == &S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="codeLine">  constexpr int bias = -(S.minExponent - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3500</td>
    <td class="codeLine">  constexpr int bias = -(S.minExponent - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="codeLine">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3501</td>
    <td class="codeLine">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="codeLine">  constexpr int integer_bit_part = trailing_significand_bits / integerPartWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3502</td>
    <td class="codeLine">  constexpr int integer_bit_part = trailing_significand_bits / integerPartWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="codeLine">  constexpr integerPart integer_bit =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3503</td>
    <td class="codeLine">  constexpr integerPart integer_bit =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="codeLine">      integerPart{1} << (trailing_significand_bits % integerPartWidth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3504</td>
    <td class="codeLine">      integerPart{1} << (trailing_significand_bits % integerPartWidth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="codeLine">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3505</td>
    <td class="codeLine">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="codeLine">  constexpr unsigned int exponent_bits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3506</td>
    <td class="codeLine">  constexpr unsigned int exponent_bits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="codeLine">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3507</td>
    <td class="codeLine">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="codeLine">  static_assert(exponent_bits < 64);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3508</td>
    <td class="codeLine">  static_assert(exponent_bits < 64);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="codeLine">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3509</td>
    <td class="codeLine">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="codeLine">  uint64_t myexponent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3511</td>
    <td class="codeLine">  uint64_t myexponent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="codeLine">  std::array<integerPart, partCountForBits(trailing_significand_bits)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3512</td>
    <td class="codeLine">  std::array<integerPart, partCountForBits(trailing_significand_bits)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="codeLine">      mysignificand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3513</td>
    <td class="codeLine">      mysignificand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3515</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="codeLine">    myexponent = exponent + bias;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3516</td>
    <td class="codeLine">    myexponent = exponent + bias;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="codeLine">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3517</td>
    <td class="codeLine">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="codeLine">                mysignificand.begin());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3518</td>
    <td class="codeLine">                mysignificand.begin());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="codeLine">    if (myexponent == 1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3519</td>
    <td class="codeLine">    if (myexponent == 1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="codeLine">        !(significandParts()[integer_bit_part] & integer_bit))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3520</td>
    <td class="codeLine">        !(significandParts()[integer_bit_part] & integer_bit))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="codeLine">      myexponent = 0; // denormal</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3521</td>
    <td class="codeLine">      myexponent = 0; // denormal</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="codeLine">  } else if (category == fcZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3522</td>
    <td class="codeLine">  } else if (category == fcZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="codeLine">    myexponent = ::exponentZero(S) + bias;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3523</td>
    <td class="codeLine">    myexponent = ::exponentZero(S) + bias;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="codeLine">    mysignificand.fill(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3524</td>
    <td class="codeLine">    mysignificand.fill(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="codeLine">  } else if (category == fcInfinity) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3525</td>
    <td class="codeLine">  } else if (category == fcInfinity) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class="codeLine">    if (S.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3526</td>
    <td class="codeLine">    if (S.nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="codeLine">      llvm_unreachable("semantics don't support inf!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3527</td>
    <td class="codeLine">      llvm_unreachable("semantics don't support inf!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3528</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="codeLine">    myexponent = ::exponentInf(S) + bias;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3529</td>
    <td class="codeLine">    myexponent = ::exponentInf(S) + bias;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="codeLine">    mysignificand.fill(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3530</td>
    <td class="codeLine">    mysignificand.fill(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3531</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="codeLine">    assert(category == fcNaN && "Unknown category!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3532</td>
    <td class="codeLine">    assert(category == fcNaN && "Unknown category!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="codeLine">    myexponent = ::exponentNaN(S) + bias;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3533</td>
    <td class="codeLine">    myexponent = ::exponentNaN(S) + bias;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="codeLine">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3534</td>
    <td class="codeLine">    std::copy_n(significandParts(), mysignificand.size(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="codeLine">                mysignificand.begin());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3535</td>
    <td class="codeLine">                mysignificand.begin());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="codeLine">  std::array<uint64_t, (S.sizeInBits + 63) / 64> words;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3537</td>
    <td class="codeLine">  std::array<uint64_t, (S.sizeInBits + 63) / 64> words;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="codeLine">  auto words_iter =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3538</td>
    <td class="codeLine">  auto words_iter =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="codeLine">      std::copy_n(mysignificand.begin(), mysignificand.size(), words.begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3539</td>
    <td class="codeLine">      std::copy_n(mysignificand.begin(), mysignificand.size(), words.begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="codeLine">  if constexpr (significand_mask != 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3540</td>
    <td class="codeLine">  if constexpr (significand_mask != 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="codeLine">    // Clear the integer bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3541</td>
    <td class="codeLine">    // Clear the integer bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="codeLine">    words[mysignificand.size() - 1] &= significand_mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3542</td>
    <td class="codeLine">    words[mysignificand.size() - 1] &= significand_mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="codeLine">  std::fill(words_iter, words.end(), uint64_t{0});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3544</td>
    <td class="codeLine">  std::fill(words_iter, words.end(), uint64_t{0});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="codeLine">  constexpr size_t last_word = words.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3545</td>
    <td class="codeLine">  constexpr size_t last_word = words.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="codeLine">  uint64_t shifted_sign = static_cast<uint64_t>(sign & 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3546</td>
    <td class="codeLine">  uint64_t shifted_sign = static_cast<uint64_t>(sign & 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="codeLine">                          << ((S.sizeInBits - 1) % 64);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3547</td>
    <td class="codeLine">                          << ((S.sizeInBits - 1) % 64);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="codeLine">  words[last_word] |= shifted_sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3548</td>
    <td class="codeLine">  words[last_word] |= shifted_sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="codeLine">  uint64_t shifted_exponent = (myexponent & exponent_mask)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3549</td>
    <td class="codeLine">  uint64_t shifted_exponent = (myexponent & exponent_mask)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="codeLine">                              << (trailing_significand_bits % 64);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3550</td>
    <td class="codeLine">                              << (trailing_significand_bits % 64);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="codeLine">  words[last_word] |= shifted_exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3551</td>
    <td class="codeLine">  words[last_word] |= shifted_exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="codeLine">  if constexpr (last_word == 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3552</td>
    <td class="codeLine">  if constexpr (last_word == 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="codeLine">    return APInt(S.sizeInBits, words[0]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3553</td>
    <td class="codeLine">    return APInt(S.sizeInBits, words[0]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3554</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="codeLine">  return APInt(S.sizeInBits, words);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3555</td>
    <td class="codeLine">  return APInt(S.sizeInBits, words);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3556</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="codeLine">APInt IEEEFloat::convertQuadrupleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3558</td>
    <td class="codeLine">APInt IEEEFloat::convertQuadrupleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="codeLine">  assert(partCount() == 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3559</td>
    <td class="codeLine">  assert(partCount() == 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEquad>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3560</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEquad>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3561</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="codeLine">APInt IEEEFloat::convertDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3563</td>
    <td class="codeLine">APInt IEEEFloat::convertDoubleAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="codeLine">  assert(partCount()==1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3564</td>
    <td class="codeLine">  assert(partCount()==1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEdouble>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3565</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEdouble>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3566</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="codeLine">APInt IEEEFloat::convertFloatAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3568</td>
    <td class="codeLine">APInt IEEEFloat::convertFloatAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="codeLine">  assert(partCount()==1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3569</td>
    <td class="codeLine">  assert(partCount()==1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEsingle>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3570</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEsingle>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3571</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="codeLine">APInt IEEEFloat::convertBFloatAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3573</td>
    <td class="codeLine">APInt IEEEFloat::convertBFloatAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3574</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semBFloat>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3575</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semBFloat>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3576</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="codeLine">APInt IEEEFloat::convertHalfAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3578</td>
    <td class="codeLine">APInt IEEEFloat::convertHalfAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="codeLine">  assert(partCount()==1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3579</td>
    <td class="codeLine">  assert(partCount()==1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEhalf>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3580</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semIEEEhalf>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E5M2APFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3583</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E5M2APFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3584</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E5M2>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3585</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E5M2>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3586</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E5M2FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3588</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E5M2FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3589</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E5M2FNUZ>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3590</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E5M2FNUZ>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3591</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E4M3FNAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3593</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E4M3FNAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3594</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E4M3FN>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3595</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E4M3FN>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E4M3FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3598</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E4M3FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3599</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E4M3FNUZ>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3600</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E4M3FNUZ>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3601</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E4M3B11FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3603</td>
    <td class="codeLine">APInt IEEEFloat::convertFloat8E4M3B11FNUZAPFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3604</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E4M3B11FNUZ>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3605</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloat8E4M3B11FNUZ>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="codeLine">APInt IEEEFloat::convertFloatTF32APFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3608</td>
    <td class="codeLine">APInt IEEEFloat::convertFloatTF32APFloatToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3609</td>
    <td class="codeLine">  assert(partCount() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloatTF32>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3610</td>
    <td class="codeLine">  return convertIEEEFloatToAPInt<semFloatTF32>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3611</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="codeLine">// This function creates an APInt that is just a bit map of the floating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3613</td>
    <td class="codeLine">// This function creates an APInt that is just a bit map of the floating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="codeLine">// point constant as it would appear in memory.  It is not a conversion,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3614</td>
    <td class="codeLine">// point constant as it would appear in memory.  It is not a conversion,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="codeLine">// and treating the result as a normal integer is unlikely to be useful.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3615</td>
    <td class="codeLine">// and treating the result as a normal integer is unlikely to be useful.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="codeLine">APInt IEEEFloat::bitcastToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3617</td>
    <td class="codeLine">APInt IEEEFloat::bitcastToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEhalf)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3618</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEhalf)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="codeLine">    return convertHalfAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3619</td>
    <td class="codeLine">    return convertHalfAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semBFloat)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3621</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semBFloat)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="codeLine">    return convertBFloatAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3622</td>
    <td class="codeLine">    return convertBFloatAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEsingle)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3624</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEsingle)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="codeLine">    return convertFloatAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3625</td>
    <td class="codeLine">    return convertFloatAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEdouble)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3627</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEdouble)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="codeLine">    return convertDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3628</td>
    <td class="codeLine">    return convertDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEquad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3630</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics*)&semIEEEquad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="codeLine">    return convertQuadrupleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3631</td>
    <td class="codeLine">    return convertQuadrupleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3633</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semPPCDoubleDoubleLegacy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="codeLine">    return convertPPCDoubleDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3634</td>
    <td class="codeLine">    return convertPPCDoubleDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3636</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="codeLine">    return convertFloat8E5M2APFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3637</td>
    <td class="codeLine">    return convertFloat8E5M2APFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2FNUZ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3639</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E5M2FNUZ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="codeLine">    return convertFloat8E5M2FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3640</td>
    <td class="codeLine">    return convertFloat8E5M2FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3642</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="codeLine">    return convertFloat8E4M3FNAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3643</td>
    <td class="codeLine">    return convertFloat8E4M3FNAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FNUZ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3645</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3FNUZ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="codeLine">    return convertFloat8E4M3FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3646</td>
    <td class="codeLine">    return convertFloat8E4M3FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3B11FNUZ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3648</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloat8E4M3B11FNUZ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="codeLine">    return convertFloat8E4M3B11FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3649</td>
    <td class="codeLine">    return convertFloat8E4M3B11FNUZAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloatTF32)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3651</td>
    <td class="codeLine">  if (semantics == (const llvm::fltSemantics *)&semFloatTF32)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="codeLine">    return convertFloatTF32APFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3652</td>
    <td class="codeLine">    return convertFloatTF32APFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3654</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semX87DoubleExtended &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="codeLine">         "unknown format!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3655</td>
    <td class="codeLine">         "unknown format!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="codeLine">  return convertF80LongDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3656</td>
    <td class="codeLine">  return convertF80LongDoubleAPFloatToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3657</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="codeLine">float IEEEFloat::convertToFloat() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3659</td>
    <td class="codeLine">float IEEEFloat::convertToFloat() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semIEEEsingle &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3660</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semIEEEsingle &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="codeLine">         "Float semantics are not IEEEsingle");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3661</td>
    <td class="codeLine">         "Float semantics are not IEEEsingle");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="codeLine">  APInt api = bitcastToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3662</td>
    <td class="codeLine">  APInt api = bitcastToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="codeLine">  return api.bitsToFloat();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3663</td>
    <td class="codeLine">  return api.bitsToFloat();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3664</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="codeLine">double IEEEFloat::convertToDouble() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3666</td>
    <td class="codeLine">double IEEEFloat::convertToDouble() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semIEEEdouble &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3667</td>
    <td class="codeLine">  assert(semantics == (const llvm::fltSemantics*)&semIEEEdouble &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="codeLine">         "Float semantics are not IEEEdouble");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3668</td>
    <td class="codeLine">         "Float semantics are not IEEEdouble");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="codeLine">  APInt api = bitcastToAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3669</td>
    <td class="codeLine">  APInt api = bitcastToAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="codeLine">  return api.bitsToDouble();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3670</td>
    <td class="codeLine">  return api.bitsToDouble();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="codeLine">/// Integer bit is explicit in this format.  Intel hardware (387 and later)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3673</td>
    <td class="codeLine">/// Integer bit is explicit in this format.  Intel hardware (387 and later)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="codeLine">/// does not support these bit patterns:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3674</td>
    <td class="codeLine">/// does not support these bit patterns:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="codeLine">///  exponent = all 1's, integer bit 0, significand 0 ("pseudoinfinity")</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3675</td>
    <td class="codeLine">///  exponent = all 1's, integer bit 0, significand 0 ("pseudoinfinity")</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="codeLine">///  exponent = all 1's, integer bit 0, significand nonzero ("pseudoNaN")</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3676</td>
    <td class="codeLine">///  exponent = all 1's, integer bit 0, significand nonzero ("pseudoNaN")</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="codeLine">///  exponent!=0 nor all 1's, integer bit 0 ("unnormal")</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3677</td>
    <td class="codeLine">///  exponent!=0 nor all 1's, integer bit 0 ("unnormal")</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="codeLine">///  exponent = 0, integer bit 1 ("pseudodenormal")</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3678</td>
    <td class="codeLine">///  exponent = 0, integer bit 1 ("pseudodenormal")</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="codeLine">/// At the moment, the first three are treated as NaNs, the last one as Normal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3679</td>
    <td class="codeLine">/// At the moment, the first three are treated as NaNs, the last one as Normal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="codeLine">void IEEEFloat::initFromF80LongDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3680</td>
    <td class="codeLine">void IEEEFloat::initFromF80LongDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="codeLine">  uint64_t i1 = api.getRawData()[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3681</td>
    <td class="codeLine">  uint64_t i1 = api.getRawData()[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="codeLine">  uint64_t i2 = api.getRawData()[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3682</td>
    <td class="codeLine">  uint64_t i2 = api.getRawData()[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="codeLine">  uint64_t myexponent = (i2 & 0x7fff);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3683</td>
    <td class="codeLine">  uint64_t myexponent = (i2 & 0x7fff);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="codeLine">  uint64_t mysignificand = i1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3684</td>
    <td class="codeLine">  uint64_t mysignificand = i1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="codeLine">  uint8_t myintegerbit = mysignificand >> 63;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3685</td>
    <td class="codeLine">  uint8_t myintegerbit = mysignificand >> 63;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="codeLine">  initialize(&semX87DoubleExtended);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3687</td>
    <td class="codeLine">  initialize(&semX87DoubleExtended);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="codeLine">  assert(partCount()==2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3688</td>
    <td class="codeLine">  assert(partCount()==2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="codeLine">  sign = static_cast<unsigned int>(i2>>15);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3690</td>
    <td class="codeLine">  sign = static_cast<unsigned int>(i2>>15);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="codeLine">  if (myexponent == 0 && mysignificand == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3691</td>
    <td class="codeLine">  if (myexponent == 0 && mysignificand == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="codeLine">    makeZero(sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3692</td>
    <td class="codeLine">    makeZero(sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="codeLine">  } else if (myexponent==0x7fff && mysignificand==0x8000000000000000ULL) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3693</td>
    <td class="codeLine">  } else if (myexponent==0x7fff && mysignificand==0x8000000000000000ULL) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="codeLine">    makeInf(sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3694</td>
    <td class="codeLine">    makeInf(sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="codeLine">  } else if ((myexponent == 0x7fff && mysignificand != 0x8000000000000000ULL) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3695</td>
    <td class="codeLine">  } else if ((myexponent == 0x7fff && mysignificand != 0x8000000000000000ULL) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="codeLine">             (myexponent != 0x7fff && myexponent != 0 && myintegerbit == 0)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3696</td>
    <td class="codeLine">             (myexponent != 0x7fff && myexponent != 0 && myintegerbit == 0)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="codeLine">    category = fcNaN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3697</td>
    <td class="codeLine">    category = fcNaN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="codeLine">    exponent = exponentNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3698</td>
    <td class="codeLine">    exponent = exponentNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class="codeLine">    significandParts()[0] = mysignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3699</td>
    <td class="codeLine">    significandParts()[0] = mysignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="codeLine">    significandParts()[1] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3700</td>
    <td class="codeLine">    significandParts()[1] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3701</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="codeLine">    category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3702</td>
    <td class="codeLine">    category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="codeLine">    exponent = myexponent - 16383;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3703</td>
    <td class="codeLine">    exponent = myexponent - 16383;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="codeLine">    significandParts()[0] = mysignificand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3704</td>
    <td class="codeLine">    significandParts()[0] = mysignificand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="codeLine">    significandParts()[1] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3705</td>
    <td class="codeLine">    significandParts()[1] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="codeLine">    if (myexponent==0)          // denormal</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3706</td>
    <td class="codeLine">    if (myexponent==0)          // denormal</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="codeLine">      exponent = -16382;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3707</td>
    <td class="codeLine">      exponent = -16382;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3709</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="codeLine">void IEEEFloat::initFromPPCDoubleDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3711</td>
    <td class="codeLine">void IEEEFloat::initFromPPCDoubleDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="codeLine">  uint64_t i1 = api.getRawData()[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3712</td>
    <td class="codeLine">  uint64_t i1 = api.getRawData()[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="codeLine">  uint64_t i2 = api.getRawData()[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3713</td>
    <td class="codeLine">  uint64_t i2 = api.getRawData()[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3714</td>
    <td class="codeLine">  opStatus fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="codeLine">  bool losesInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3715</td>
    <td class="codeLine">  bool losesInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="codeLine">  // Get the first double and convert to our format.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3717</td>
    <td class="codeLine">  // Get the first double and convert to our format.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="codeLine">  initFromDoubleAPInt(APInt(64, i1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3718</td>
    <td class="codeLine">  initFromDoubleAPInt(APInt(64, i1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="codeLine">  fs = convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3719</td>
    <td class="codeLine">  fs = convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3720</td>
    <td class="codeLine">  assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="codeLine">  (void)fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3721</td>
    <td class="codeLine">  (void)fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="codeLine">  // Unless we have a special case, add in second double.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3723</td>
    <td class="codeLine">  // Unless we have a special case, add in second double.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3724</td>
    <td class="codeLine">  if (isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="codeLine">    IEEEFloat v(semIEEEdouble, APInt(64, i2));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3725</td>
    <td class="codeLine">    IEEEFloat v(semIEEEdouble, APInt(64, i2));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="codeLine">    fs = v.convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3726</td>
    <td class="codeLine">    fs = v.convert(semPPCDoubleDoubleLegacy, rmNearestTiesToEven, &losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="codeLine">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3727</td>
    <td class="codeLine">    assert(fs == opOK && !losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="codeLine">    (void)fs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3728</td>
    <td class="codeLine">    (void)fs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3729</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="codeLine">    add(v, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3730</td>
    <td class="codeLine">    add(v, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3731</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3732</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3733</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="codeLine">template <const fltSemantics &S></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3734</td>
    <td class="codeLine">template <const fltSemantics &S></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="codeLine coveredLine">void IEEEFloat::initFromIEEEAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3735</td>
    <td class="codeLine coveredLine">void IEEEFloat::initFromIEEEAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="codeLine coveredLine">  assert(api.getBitWidth() == S.sizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3736</td>
    <td class="codeLine coveredLine">  assert(api.getBitWidth() == S.sizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="codeLine coveredLine">  constexpr integerPart integer_bit = integerPart{1}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3737</td>
    <td class="codeLine coveredLine">  constexpr integerPart integer_bit = integerPart{1}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="codeLine">                                      << ((S.precision - 1) % integerPartWidth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3738</td>
    <td class="codeLine">                                      << ((S.precision - 1) % integerPartWidth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="codeLine coveredLine">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3739</td>
    <td class="codeLine coveredLine">  constexpr uint64_t significand_mask = integer_bit - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="codeLine coveredLine">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3740</td>
    <td class="codeLine coveredLine">  constexpr unsigned int trailing_significand_bits = S.precision - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="codeLine coveredLine">  constexpr unsigned int stored_significand_parts =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3741</td>
    <td class="codeLine coveredLine">  constexpr unsigned int stored_significand_parts =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="codeLine">      partCountForBits(trailing_significand_bits);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3742</td>
    <td class="codeLine">      partCountForBits(trailing_significand_bits);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="codeLine coveredLine">  constexpr unsigned int exponent_bits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3743</td>
    <td class="codeLine coveredLine">  constexpr unsigned int exponent_bits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="codeLine">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3744</td>
    <td class="codeLine">      S.sizeInBits - 1 - trailing_significand_bits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="codeLine">  static_assert(exponent_bits < 64);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3745</td>
    <td class="codeLine">  static_assert(exponent_bits < 64);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="codeLine coveredLine">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3746</td>
    <td class="codeLine coveredLine">  constexpr uint64_t exponent_mask = (uint64_t{1} << exponent_bits) - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="codeLine coveredLine">  constexpr int bias = -(S.minExponent - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3747</td>
    <td class="codeLine coveredLine">  constexpr int bias = -(S.minExponent - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="codeLine">  // Copy the bits of the significand. We need to clear out the exponent and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3749</td>
    <td class="codeLine">  // Copy the bits of the significand. We need to clear out the exponent and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="codeLine">  // sign bit in the last word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3750</td>
    <td class="codeLine">  // sign bit in the last word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="codeLine">  std::array<integerPart, stored_significand_parts> mysignificand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3751</td>
    <td class="codeLine">  std::array<integerPart, stored_significand_parts> mysignificand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="codeLine coveredLine">  std::copy_n(api.getRawData(), mysignificand.size(), mysignificand.begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3752</td>
    <td class="codeLine coveredLine">  std::copy_n(api.getRawData(), mysignificand.size(), mysignificand.begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="codeLine">  if constexpr (significand_mask != 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3753</td>
    <td class="codeLine">  if constexpr (significand_mask != 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="codeLine coveredLine">    mysignificand[mysignificand.size() - 1] &= significand_mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3754</td>
    <td class="codeLine coveredLine">    mysignificand[mysignificand.size() - 1] &= significand_mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3755</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="codeLine">  // We assume the last word holds the sign bit, the exponent, and potentially</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3757</td>
    <td class="codeLine">  // We assume the last word holds the sign bit, the exponent, and potentially</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="codeLine">  // some of the trailing significand field.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3758</td>
    <td class="codeLine">  // some of the trailing significand field.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="codeLine coveredLine">  uint64_t last_word = api.getRawData()[api.getNumWords() - 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3759</td>
    <td class="codeLine coveredLine">  uint64_t last_word = api.getRawData()[api.getNumWords() - 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="codeLine coveredLine">  uint64_t myexponent =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3760</td>
    <td class="codeLine coveredLine">  uint64_t myexponent =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="codeLine coveredLine">      (last_word >> (trailing_significand_bits % 64)) & exponent_mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3761</td>
    <td class="codeLine coveredLine">      (last_word >> (trailing_significand_bits % 64)) & exponent_mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="codeLine coveredLine">  initialize(&S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3763</td>
    <td class="codeLine coveredLine">  initialize(&S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="codeLine coveredLine">  assert(partCount() == mysignificand.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3764</td>
    <td class="codeLine coveredLine">  assert(partCount() == mysignificand.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="codeLine coveredLine">  sign = static_cast<unsigned int>(last_word >> ((S.sizeInBits - 1) % 64));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3766</td>
    <td class="codeLine coveredLine">  sign = static_cast<unsigned int>(last_word >> ((S.sizeInBits - 1) % 64));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="codeLine">  bool all_zero_significand =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3768</td>
    <td class="codeLine">  bool all_zero_significand =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="codeLine coveredLine">      llvm::all_of(mysignificand, [](integerPart bits) { return bits == 0; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3769</td>
    <td class="codeLine coveredLine">      llvm::all_of(mysignificand, [](integerPart bits) { return bits == 0; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="codeLine coveredLine">  bool is_zero = myexponent == 0 && all_zero_significand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3771</td>
    <td class="codeLine coveredLine">  bool is_zero = myexponent == 0 && all_zero_significand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="codeLine">  if constexpr (S.nonFiniteBehavior == fltNonfiniteBehavior::IEEE754) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3773</td>
    <td class="codeLine">  if constexpr (S.nonFiniteBehavior == fltNonfiniteBehavior::IEEE754) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="codeLine coveredLine">    if (myexponent - bias == ::exponentInf(S) && all_zero_significand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3774</td>
    <td class="codeLine coveredLine">    if (myexponent - bias == ::exponentInf(S) && all_zero_significand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="codeLine">      makeInf(sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3775</td>
    <td class="codeLine">      makeInf(sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="codeLine coveredLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3776</td>
    <td class="codeLine coveredLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3777</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3778</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="codeLine coveredLine">  bool is_nan = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3780</td>
    <td class="codeLine coveredLine">  bool is_nan = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="codeLine">  if constexpr (S.nanEncoding == fltNanEncoding::IEEE) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3782</td>
    <td class="codeLine">  if constexpr (S.nanEncoding == fltNanEncoding::IEEE) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="codeLine coveredLine">    is_nan = myexponent - bias == ::exponentNaN(S) && !all_zero_significand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3783</td>
    <td class="codeLine coveredLine">    is_nan = myexponent - bias == ::exponentNaN(S) && !all_zero_significand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="codeLine">  } else if constexpr (S.nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3784</td>
    <td class="codeLine">  } else if constexpr (S.nanEncoding == fltNanEncoding::AllOnes) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="codeLine">    bool all_ones_significand =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3785</td>
    <td class="codeLine">    bool all_ones_significand =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="codeLine">        std::all_of(mysignificand.begin(), mysignificand.end() - 1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3786</td>
    <td class="codeLine">        std::all_of(mysignificand.begin(), mysignificand.end() - 1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="codeLine">                    [](integerPart bits) { return bits == ~integerPart{0}; }) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3787</td>
    <td class="codeLine">                    [](integerPart bits) { return bits == ~integerPart{0}; }) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class="codeLine">        (!significand_mask ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3788</td>
    <td class="codeLine">        (!significand_mask ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="codeLine">         mysignificand[mysignificand.size() - 1] == significand_mask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3789</td>
    <td class="codeLine">         mysignificand[mysignificand.size() - 1] == significand_mask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="codeLine">    is_nan = myexponent - bias == ::exponentNaN(S) && all_ones_significand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3790</td>
    <td class="codeLine">    is_nan = myexponent - bias == ::exponentNaN(S) && all_ones_significand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="codeLine">  } else if constexpr (S.nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3791</td>
    <td class="codeLine">  } else if constexpr (S.nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="codeLine">    is_nan = is_zero && sign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3792</td>
    <td class="codeLine">    is_nan = is_zero && sign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3793</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="codeLine coveredLine">  if (is_nan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3795</td>
    <td class="codeLine coveredLine">  if (is_nan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="codeLine">    category = fcNaN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3796</td>
    <td class="codeLine">    category = fcNaN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="codeLine">    exponent = ::exponentNaN(S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3797</td>
    <td class="codeLine">    exponent = ::exponentNaN(S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="codeLine">    std::copy_n(mysignificand.begin(), mysignificand.size(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3798</td>
    <td class="codeLine">    std::copy_n(mysignificand.begin(), mysignificand.size(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="codeLine">                significandParts());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3799</td>
    <td class="codeLine">                significandParts());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3800</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3801</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="codeLine coveredLine">  if (is_zero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3803</td>
    <td class="codeLine coveredLine">  if (is_zero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="codeLine coveredLine">    makeZero(sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3804</td>
    <td class="codeLine coveredLine">    makeZero(sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3805</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3806</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3808</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="codeLine">  exponent = myexponent - bias;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3809</td>
    <td class="codeLine">  exponent = myexponent - bias;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="codeLine">  std::copy_n(mysignificand.begin(), mysignificand.size(), significandParts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3810</td>
    <td class="codeLine">  std::copy_n(mysignificand.begin(), mysignificand.size(), significandParts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="codeLine">  if (myexponent == 0) // denormal</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3811</td>
    <td class="codeLine">  if (myexponent == 0) // denormal</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="codeLine">    exponent = S.minExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3812</td>
    <td class="codeLine">    exponent = S.minExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3813</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="codeLine">    significandParts()[mysignificand.size()-1] |= integer_bit; // integer bit</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3814</td>
    <td class="codeLine">    significandParts()[mysignificand.size()-1] |= integer_bit; // integer bit</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3815</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="codeLine">void IEEEFloat::initFromQuadrupleAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3817</td>
    <td class="codeLine">void IEEEFloat::initFromQuadrupleAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="codeLine">  initFromIEEEAPInt<semIEEEquad>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3818</td>
    <td class="codeLine">  initFromIEEEAPInt<semIEEEquad>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3819</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="codeLine coveredLine">void IEEEFloat::initFromDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3821</td>
    <td class="codeLine coveredLine">void IEEEFloat::initFromDoubleAPInt(const APInt &api) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="codeLine coveredLine">  initFromIEEEAPInt<semIEEEdouble>(api);</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3822</td>
    <td class="codeLine coveredLine">  initFromIEEEAPInt<semIEEEdouble>(api);</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3823</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="codeLine">void IEEEFloat::initFromFloatAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3825</td>
    <td class="codeLine">void IEEEFloat::initFromFloatAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="codeLine">  initFromIEEEAPInt<semIEEEsingle>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3826</td>
    <td class="codeLine">  initFromIEEEAPInt<semIEEEsingle>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3827</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="codeLine">void IEEEFloat::initFromBFloatAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3829</td>
    <td class="codeLine">void IEEEFloat::initFromBFloatAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="codeLine">  initFromIEEEAPInt<semBFloat>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3830</td>
    <td class="codeLine">  initFromIEEEAPInt<semBFloat>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3831</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="codeLine">void IEEEFloat::initFromHalfAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3833</td>
    <td class="codeLine">void IEEEFloat::initFromHalfAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="codeLine">  initFromIEEEAPInt<semIEEEhalf>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3834</td>
    <td class="codeLine">  initFromIEEEAPInt<semIEEEhalf>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3835</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E5M2APInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3837</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E5M2APInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E5M2>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3838</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E5M2>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3839</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E5M2FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3841</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E5M2FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E5M2FNUZ>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3842</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E5M2FNUZ>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3843</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E4M3FNAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3845</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E4M3FNAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E4M3FN>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3846</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E4M3FN>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3847</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E4M3FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3849</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E4M3FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E4M3FNUZ>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3850</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E4M3FNUZ>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3851</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E4M3B11FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3853</td>
    <td class="codeLine">void IEEEFloat::initFromFloat8E4M3B11FNUZAPInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E4M3B11FNUZ>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3854</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloat8E4M3B11FNUZ>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3855</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="codeLine">void IEEEFloat::initFromFloatTF32APInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3857</td>
    <td class="codeLine">void IEEEFloat::initFromFloatTF32APInt(const APInt &api) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloatTF32>(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3858</td>
    <td class="codeLine">  initFromIEEEAPInt<semFloatTF32>(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="codeLine">/// Treat api as containing the bits of a floating point number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3861</td>
    <td class="codeLine">/// Treat api as containing the bits of a floating point number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="codeLine coveredLine">void IEEEFloat::initFromAPInt(const fltSemantics *Sem, const APInt &api) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3862</td>
    <td class="codeLine coveredLine">void IEEEFloat::initFromAPInt(const fltSemantics *Sem, const APInt &api) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="codeLine coveredLine">  assert(api.getBitWidth() == Sem->sizeInBits);</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3863</td>
    <td class="codeLine coveredLine">  assert(api.getBitWidth() == Sem->sizeInBits);</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class="codeLine coveredLine">  if (Sem == &semIEEEhalf)</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3864</td>
    <td class="codeLine coveredLine">  if (Sem == &semIEEEhalf)</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="codeLine">    return initFromHalfAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3865</td>
    <td class="codeLine">    return initFromHalfAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="codeLine coveredLine">  if (Sem == &semBFloat)</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3866</td>
    <td class="codeLine coveredLine">  if (Sem == &semBFloat)</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="codeLine">    return initFromBFloatAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3867</td>
    <td class="codeLine">    return initFromBFloatAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="codeLine coveredLine">  if (Sem == &semIEEEsingle)</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3868</td>
    <td class="codeLine coveredLine">  if (Sem == &semIEEEsingle)</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="codeLine">    return initFromFloatAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3869</td>
    <td class="codeLine">    return initFromFloatAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="codeLine coveredLine">  if (Sem == &semIEEEdouble)</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3870</td>
    <td class="codeLine coveredLine">  if (Sem == &semIEEEdouble)</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="codeLine coveredLine">    return initFromDoubleAPInt(api);</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3871</td>
    <td class="codeLine coveredLine">    return initFromDoubleAPInt(api);</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="codeLine">  if (Sem == &semX87DoubleExtended)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3872</td>
    <td class="codeLine">  if (Sem == &semX87DoubleExtended)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="codeLine">    return initFromF80LongDoubleAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3873</td>
    <td class="codeLine">    return initFromF80LongDoubleAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="codeLine">  if (Sem == &semIEEEquad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3874</td>
    <td class="codeLine">  if (Sem == &semIEEEquad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="codeLine">    return initFromQuadrupleAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3875</td>
    <td class="codeLine">    return initFromQuadrupleAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="codeLine">  if (Sem == &semPPCDoubleDoubleLegacy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3876</td>
    <td class="codeLine">  if (Sem == &semPPCDoubleDoubleLegacy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="codeLine">    return initFromPPCDoubleDoubleAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3877</td>
    <td class="codeLine">    return initFromPPCDoubleDoubleAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="codeLine">  if (Sem == &semFloat8E5M2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3878</td>
    <td class="codeLine">  if (Sem == &semFloat8E5M2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="codeLine">    return initFromFloat8E5M2APInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3879</td>
    <td class="codeLine">    return initFromFloat8E5M2APInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="codeLine">  if (Sem == &semFloat8E5M2FNUZ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3880</td>
    <td class="codeLine">  if (Sem == &semFloat8E5M2FNUZ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="codeLine">    return initFromFloat8E5M2FNUZAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3881</td>
    <td class="codeLine">    return initFromFloat8E5M2FNUZAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="codeLine">  if (Sem == &semFloat8E4M3FN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3882</td>
    <td class="codeLine">  if (Sem == &semFloat8E4M3FN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="codeLine">    return initFromFloat8E4M3FNAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3883</td>
    <td class="codeLine">    return initFromFloat8E4M3FNAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="codeLine">  if (Sem == &semFloat8E4M3FNUZ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3884</td>
    <td class="codeLine">  if (Sem == &semFloat8E4M3FNUZ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="codeLine">    return initFromFloat8E4M3FNUZAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3885</td>
    <td class="codeLine">    return initFromFloat8E4M3FNUZAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="codeLine">  if (Sem == &semFloat8E4M3B11FNUZ)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3886</td>
    <td class="codeLine">  if (Sem == &semFloat8E4M3B11FNUZ)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="codeLine">    return initFromFloat8E4M3B11FNUZAPInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3887</td>
    <td class="codeLine">    return initFromFloat8E4M3B11FNUZAPInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="codeLine">  if (Sem == &semFloatTF32)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3888</td>
    <td class="codeLine">  if (Sem == &semFloatTF32)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="codeLine">    return initFromFloatTF32APInt(api);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3889</td>
    <td class="codeLine">    return initFromFloatTF32APInt(api);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="codeLine">  llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3891</td>
    <td class="codeLine">  llvm_unreachable(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3892</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="codeLine">/// Make this number the largest magnitude normal number in the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3894</td>
    <td class="codeLine">/// Make this number the largest magnitude normal number in the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="codeLine">/// semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3895</td>
    <td class="codeLine">/// semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="codeLine">void IEEEFloat::makeLargest(bool Negative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3896</td>
    <td class="codeLine">void IEEEFloat::makeLargest(bool Negative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="codeLine">  // We want (in interchange format):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3897</td>
    <td class="codeLine">  // We want (in interchange format):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="codeLine">  //   sign = {Negative}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3898</td>
    <td class="codeLine">  //   sign = {Negative}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="codeLine">  //   exponent = 1..10</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3899</td>
    <td class="codeLine">  //   exponent = 1..10</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="codeLine">  //   significand = 1..1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3900</td>
    <td class="codeLine">  //   significand = 1..1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3901</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3902</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="codeLine">  exponent = semantics->maxExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3903</td>
    <td class="codeLine">  exponent = semantics->maxExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="codeLine">  // Use memset to set all but the highest integerPart to all ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3905</td>
    <td class="codeLine">  // Use memset to set all but the highest integerPart to all ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="codeLine">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3906</td>
    <td class="codeLine">  integerPart *significand = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="codeLine">  unsigned PartCount = partCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3907</td>
    <td class="codeLine">  unsigned PartCount = partCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="codeLine">  memset(significand, 0xFF, sizeof(integerPart)*(PartCount - 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3908</td>
    <td class="codeLine">  memset(significand, 0xFF, sizeof(integerPart)*(PartCount - 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="codeLine">  // Set the high integerPart especially setting all unused top bits for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3910</td>
    <td class="codeLine">  // Set the high integerPart especially setting all unused top bits for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="codeLine">  // internal consistency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3911</td>
    <td class="codeLine">  // internal consistency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="codeLine">  const unsigned NumUnusedHighBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3912</td>
    <td class="codeLine">  const unsigned NumUnusedHighBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="codeLine">    PartCount*integerPartWidth - semantics->precision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3913</td>
    <td class="codeLine">    PartCount*integerPartWidth - semantics->precision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="codeLine">  significand[PartCount - 1] = (NumUnusedHighBits < integerPartWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3914</td>
    <td class="codeLine">  significand[PartCount - 1] = (NumUnusedHighBits < integerPartWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="codeLine">                                   ? (~integerPart(0) >> NumUnusedHighBits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3915</td>
    <td class="codeLine">                                   ? (~integerPart(0) >> NumUnusedHighBits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="codeLine">                                   : 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3916</td>
    <td class="codeLine">                                   : 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3918</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3919</td>
    <td class="codeLine">      semantics->nanEncoding == fltNanEncoding::AllOnes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="codeLine">    significand[0] &= ~integerPart(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3920</td>
    <td class="codeLine">    significand[0] &= ~integerPart(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3921</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="codeLine">/// Make this number the smallest magnitude denormal number in the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3923</td>
    <td class="codeLine">/// Make this number the smallest magnitude denormal number in the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="codeLine">/// semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3924</td>
    <td class="codeLine">/// semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="codeLine">void IEEEFloat::makeSmallest(bool Negative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3925</td>
    <td class="codeLine">void IEEEFloat::makeSmallest(bool Negative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="codeLine">  // We want (in interchange format):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3926</td>
    <td class="codeLine">  // We want (in interchange format):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="codeLine">  //   sign = {Negative}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3927</td>
    <td class="codeLine">  //   sign = {Negative}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="codeLine">  //   exponent = 0..0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3928</td>
    <td class="codeLine">  //   exponent = 0..0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="codeLine">  //   significand = 0..01</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3929</td>
    <td class="codeLine">  //   significand = 0..01</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3930</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3931</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="codeLine">  exponent = semantics->minExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3932</td>
    <td class="codeLine">  exponent = semantics->minExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="codeLine">  APInt::tcSet(significandParts(), 1, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3933</td>
    <td class="codeLine">  APInt::tcSet(significandParts(), 1, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3934</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="codeLine">void IEEEFloat::makeSmallestNormalized(bool Negative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3936</td>
    <td class="codeLine">void IEEEFloat::makeSmallestNormalized(bool Negative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="codeLine">  // We want (in interchange format):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3937</td>
    <td class="codeLine">  // We want (in interchange format):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="codeLine">  //   sign = {Negative}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3938</td>
    <td class="codeLine">  //   sign = {Negative}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="codeLine">  //   exponent = 0..0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3939</td>
    <td class="codeLine">  //   exponent = 0..0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="codeLine">  //   significand = 10..0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3940</td>
    <td class="codeLine">  //   significand = 10..0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3942</td>
    <td class="codeLine">  category = fcNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="codeLine">  zeroSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3943</td>
    <td class="codeLine">  zeroSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3944</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="codeLine">  exponent = semantics->minExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3945</td>
    <td class="codeLine">  exponent = semantics->minExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="codeLine">  APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3946</td>
    <td class="codeLine">  APInt::tcSetBit(significandParts(), semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3947</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &Sem, const APInt &API) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3949</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(const fltSemantics &Sem, const APInt &API) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="codeLine">  initFromAPInt(&Sem, API);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3950</td>
    <td class="codeLine">  initFromAPInt(&Sem, API);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3951</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(float f) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3953</td>
    <td class="codeLine">IEEEFloat::IEEEFloat(float f) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="codeLine">  initFromAPInt(&semIEEEsingle, APInt::floatToBits(f));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3954</td>
    <td class="codeLine">  initFromAPInt(&semIEEEsingle, APInt::floatToBits(f));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="codeLine coveredLine">IEEEFloat::IEEEFloat(double d) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3957</td>
    <td class="codeLine coveredLine">IEEEFloat::IEEEFloat(double d) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="codeLine coveredLine">  initFromAPInt(&semIEEEdouble, APInt::doubleToBits(d));</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3958</td>
    <td class="codeLine coveredLine">  initFromAPInt(&semIEEEdouble, APInt::doubleToBits(d));</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">3959</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3961</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="codeLine">  void append(SmallVectorImpl<char> &Buffer, StringRef Str) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3962</td>
    <td class="codeLine">  void append(SmallVectorImpl<char> &Buffer, StringRef Str) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="codeLine">    Buffer.append(Str.begin(), Str.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3963</td>
    <td class="codeLine">    Buffer.append(Str.begin(), Str.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="codeLine">  /// Removes data from the given significand until it is no more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3966</td>
    <td class="codeLine">  /// Removes data from the given significand until it is no more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class="codeLine">  /// precise than is required for the desired precision.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3967</td>
    <td class="codeLine">  /// precise than is required for the desired precision.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="codeLine">  void AdjustToPrecision(APInt &significand,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3968</td>
    <td class="codeLine">  void AdjustToPrecision(APInt &significand,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="codeLine">                         int &exp, unsigned FormatPrecision) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3969</td>
    <td class="codeLine">                         int &exp, unsigned FormatPrecision) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="codeLine">    unsigned bits = significand.getActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3970</td>
    <td class="codeLine">    unsigned bits = significand.getActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="codeLine">    // 196/59 is a very slight overestimate of lg_2(10).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3972</td>
    <td class="codeLine">    // 196/59 is a very slight overestimate of lg_2(10).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="codeLine">    unsigned bitsRequired = (FormatPrecision * 196 + 58) / 59;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3973</td>
    <td class="codeLine">    unsigned bitsRequired = (FormatPrecision * 196 + 58) / 59;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="codeLine">    if (bits <= bitsRequired) return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3975</td>
    <td class="codeLine">    if (bits <= bitsRequired) return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="codeLine">    unsigned tensRemovable = (bits - bitsRequired) * 59 / 196;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3977</td>
    <td class="codeLine">    unsigned tensRemovable = (bits - bitsRequired) * 59 / 196;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="codeLine">    if (!tensRemovable) return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3978</td>
    <td class="codeLine">    if (!tensRemovable) return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="codeLine">    exp += tensRemovable;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3980</td>
    <td class="codeLine">    exp += tensRemovable;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="codeLine">    APInt divisor(significand.getBitWidth(), 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3982</td>
    <td class="codeLine">    APInt divisor(significand.getBitWidth(), 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="codeLine">    APInt powten(significand.getBitWidth(), 10);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3983</td>
    <td class="codeLine">    APInt powten(significand.getBitWidth(), 10);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3984</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="codeLine">      if (tensRemovable & 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3985</td>
    <td class="codeLine">      if (tensRemovable & 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="codeLine">        divisor *= powten;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3986</td>
    <td class="codeLine">        divisor *= powten;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="codeLine">      tensRemovable >>= 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3987</td>
    <td class="codeLine">      tensRemovable >>= 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="codeLine">      if (!tensRemovable) break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3988</td>
    <td class="codeLine">      if (!tensRemovable) break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="codeLine">      powten *= powten;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3989</td>
    <td class="codeLine">      powten *= powten;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3990</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="codeLine">    significand = significand.udiv(divisor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3992</td>
    <td class="codeLine">    significand = significand.udiv(divisor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="codeLine">    // Truncate the significand down to its active bit count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3994</td>
    <td class="codeLine">    // Truncate the significand down to its active bit count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class="codeLine">    significand = significand.trunc(significand.getActiveBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3995</td>
    <td class="codeLine">    significand = significand.trunc(significand.getActiveBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="codeLine">  void AdjustToPrecision(SmallVectorImpl<char> &buffer,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3999</td>
    <td class="codeLine">  void AdjustToPrecision(SmallVectorImpl<char> &buffer,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="codeLine">                         int &exp, unsigned FormatPrecision) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4000</td>
    <td class="codeLine">                         int &exp, unsigned FormatPrecision) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="codeLine">    unsigned N = buffer.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4001</td>
    <td class="codeLine">    unsigned N = buffer.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class="codeLine">    if (N <= FormatPrecision) return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4002</td>
    <td class="codeLine">    if (N <= FormatPrecision) return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="codeLine">    // The most significant figures are the last ones in the buffer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4004</td>
    <td class="codeLine">    // The most significant figures are the last ones in the buffer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="codeLine">    unsigned FirstSignificant = N - FormatPrecision;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4005</td>
    <td class="codeLine">    unsigned FirstSignificant = N - FormatPrecision;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="codeLine">    // Round.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4007</td>
    <td class="codeLine">    // Round.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="codeLine">    // FIXME: this probably shouldn't use 'round half up'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4008</td>
    <td class="codeLine">    // FIXME: this probably shouldn't use 'round half up'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="codeLine">    // Rounding down is just a truncation, except we also want to drop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4010</td>
    <td class="codeLine">    // Rounding down is just a truncation, except we also want to drop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="codeLine">    // trailing zeros from the new result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4011</td>
    <td class="codeLine">    // trailing zeros from the new result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="codeLine">    if (buffer[FirstSignificant - 1] < '5') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4012</td>
    <td class="codeLine">    if (buffer[FirstSignificant - 1] < '5') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class="codeLine">      while (FirstSignificant < N && buffer[FirstSignificant] == '0')</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4013</td>
    <td class="codeLine">      while (FirstSignificant < N && buffer[FirstSignificant] == '0')</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="codeLine">        FirstSignificant++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4014</td>
    <td class="codeLine">        FirstSignificant++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="codeLine">      exp += FirstSignificant;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4016</td>
    <td class="codeLine">      exp += FirstSignificant;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="codeLine">      buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4017</td>
    <td class="codeLine">      buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4018</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4019</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="codeLine">    // Rounding up requires a decimal add-with-carry.  If we continue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4021</td>
    <td class="codeLine">    // Rounding up requires a decimal add-with-carry.  If we continue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="codeLine">    // the carry, the newly-introduced zeros will just be truncated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4022</td>
    <td class="codeLine">    // the carry, the newly-introduced zeros will just be truncated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="codeLine">    for (unsigned I = FirstSignificant; I != N; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4023</td>
    <td class="codeLine">    for (unsigned I = FirstSignificant; I != N; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="codeLine">      if (buffer[I] == '9') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4024</td>
    <td class="codeLine">      if (buffer[I] == '9') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="codeLine">        FirstSignificant++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4025</td>
    <td class="codeLine">        FirstSignificant++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4026</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="codeLine">        buffer[I]++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4027</td>
    <td class="codeLine">        buffer[I]++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4028</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4029</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4030</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4031</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="codeLine">    // If we carried through, we have exactly one digit of precision.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4032</td>
    <td class="codeLine">    // If we carried through, we have exactly one digit of precision.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="codeLine">    if (FirstSignificant == N) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4033</td>
    <td class="codeLine">    if (FirstSignificant == N) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="codeLine">      exp += FirstSignificant;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4034</td>
    <td class="codeLine">      exp += FirstSignificant;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="codeLine">      buffer.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4035</td>
    <td class="codeLine">      buffer.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="codeLine">      buffer.push_back('1');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4036</td>
    <td class="codeLine">      buffer.push_back('1');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4037</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4038</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="codeLine">    exp += FirstSignificant;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4040</td>
    <td class="codeLine">    exp += FirstSignificant;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="codeLine">    buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4041</td>
    <td class="codeLine">    buffer.erase(&buffer[0], &buffer[FirstSignificant]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4042</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4043</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="codeLine">void IEEEFloat::toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4045</td>
    <td class="codeLine">void IEEEFloat::toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="codeLine">                         unsigned FormatMaxPadding, bool TruncateZero) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4046</td>
    <td class="codeLine">                         unsigned FormatMaxPadding, bool TruncateZero) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="codeLine">  switch (category) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4047</td>
    <td class="codeLine">  switch (category) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="codeLine">  case fcInfinity:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4048</td>
    <td class="codeLine">  case fcInfinity:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="codeLine">    if (isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4049</td>
    <td class="codeLine">    if (isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="codeLine">      return append(Str, "-Inf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4050</td>
    <td class="codeLine">      return append(Str, "-Inf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4051</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="codeLine">      return append(Str, "+Inf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4052</td>
    <td class="codeLine">      return append(Str, "+Inf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="codeLine">  case fcNaN: return append(Str, "NaN");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4054</td>
    <td class="codeLine">  case fcNaN: return append(Str, "NaN");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="codeLine">  case fcZero:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4056</td>
    <td class="codeLine">  case fcZero:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="codeLine">    if (isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4057</td>
    <td class="codeLine">    if (isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="codeLine">      Str.push_back('-');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4058</td>
    <td class="codeLine">      Str.push_back('-');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="codeLine">    if (!FormatMaxPadding) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4060</td>
    <td class="codeLine">    if (!FormatMaxPadding) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="codeLine">      if (TruncateZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4061</td>
    <td class="codeLine">      if (TruncateZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="codeLine">        append(Str, "0.0E+0");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4062</td>
    <td class="codeLine">        append(Str, "0.0E+0");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4063</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="codeLine">        append(Str, "0.0");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4064</td>
    <td class="codeLine">        append(Str, "0.0");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="codeLine">        if (FormatPrecision > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4065</td>
    <td class="codeLine">        if (FormatPrecision > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="codeLine">          Str.append(FormatPrecision - 1, '0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4066</td>
    <td class="codeLine">          Str.append(FormatPrecision - 1, '0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="codeLine">        append(Str, "e+00");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4067</td>
    <td class="codeLine">        append(Str, "e+00");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4068</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4069</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4070</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4071</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="codeLine">  case fcNormal:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4073</td>
    <td class="codeLine">  case fcNormal:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4074</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="codeLine">  if (isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4077</td>
    <td class="codeLine">  if (isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="codeLine">    Str.push_back('-');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4078</td>
    <td class="codeLine">    Str.push_back('-');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="codeLine">  // Decompose the number into an APInt and an exponent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4080</td>
    <td class="codeLine">  // Decompose the number into an APInt and an exponent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="codeLine">  int exp = exponent - ((int) semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4081</td>
    <td class="codeLine">  int exp = exponent - ((int) semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="codeLine">  APInt significand(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4082</td>
    <td class="codeLine">  APInt significand(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="codeLine">      semantics->precision,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4083</td>
    <td class="codeLine">      semantics->precision,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="codeLine">      ArrayRef(significandParts(), partCountForBits(semantics->precision)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4084</td>
    <td class="codeLine">      ArrayRef(significandParts(), partCountForBits(semantics->precision)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="codeLine">  // Set FormatPrecision if zero.  We want to do this before we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4086</td>
    <td class="codeLine">  // Set FormatPrecision if zero.  We want to do this before we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="codeLine">  // truncate trailing zeros, as those are part of the precision.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4087</td>
    <td class="codeLine">  // truncate trailing zeros, as those are part of the precision.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="codeLine">  if (!FormatPrecision) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4088</td>
    <td class="codeLine">  if (!FormatPrecision) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="codeLine">    // We use enough digits so the number can be round-tripped back to an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4089</td>
    <td class="codeLine">    // We use enough digits so the number can be round-tripped back to an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="codeLine">    // APFloat. The formula comes from "How to Print Floating-Point Numbers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4090</td>
    <td class="codeLine">    // APFloat. The formula comes from "How to Print Floating-Point Numbers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="codeLine">    // Accurately" by Steele and White.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4091</td>
    <td class="codeLine">    // Accurately" by Steele and White.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="codeLine">    // FIXME: Using a formula based purely on the precision is conservative;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4092</td>
    <td class="codeLine">    // FIXME: Using a formula based purely on the precision is conservative;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="codeLine">    // we can print fewer digits depending on the actual value being printed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4093</td>
    <td class="codeLine">    // we can print fewer digits depending on the actual value being printed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="codeLine">    // FormatPrecision = 2 + floor(significandBits / lg_2(10))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4095</td>
    <td class="codeLine">    // FormatPrecision = 2 + floor(significandBits / lg_2(10))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="codeLine">    FormatPrecision = 2 + semantics->precision * 59 / 196;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4096</td>
    <td class="codeLine">    FormatPrecision = 2 + semantics->precision * 59 / 196;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4097</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="codeLine">  // Ignore trailing binary zeros.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4099</td>
    <td class="codeLine">  // Ignore trailing binary zeros.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="codeLine">  int trailingZeros = significand.countr_zero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4100</td>
    <td class="codeLine">  int trailingZeros = significand.countr_zero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="codeLine">  exp += trailingZeros;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4101</td>
    <td class="codeLine">  exp += trailingZeros;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="codeLine">  significand.lshrInPlace(trailingZeros);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4102</td>
    <td class="codeLine">  significand.lshrInPlace(trailingZeros);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="codeLine">  // Change the exponent from 2^e to 10^e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4104</td>
    <td class="codeLine">  // Change the exponent from 2^e to 10^e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="codeLine">  if (exp == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4105</td>
    <td class="codeLine">  if (exp == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="codeLine">    // Nothing to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4106</td>
    <td class="codeLine">    // Nothing to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="codeLine">  } else if (exp > 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4107</td>
    <td class="codeLine">  } else if (exp > 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="codeLine">    // Just shift left.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4108</td>
    <td class="codeLine">    // Just shift left.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="codeLine">    significand = significand.zext(semantics->precision + exp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4109</td>
    <td class="codeLine">    significand = significand.zext(semantics->precision + exp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="codeLine">    significand <<= exp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4110</td>
    <td class="codeLine">    significand <<= exp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="codeLine">    exp = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4111</td>
    <td class="codeLine">    exp = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="codeLine">  } else { /* exp < 0 */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4112</td>
    <td class="codeLine">  } else { /* exp < 0 */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="codeLine">    int texp = -exp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4113</td>
    <td class="codeLine">    int texp = -exp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="codeLine">    // We transform this using the identity:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4115</td>
    <td class="codeLine">    // We transform this using the identity:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="codeLine">    //   (N)(2^-e) == (N)(5^e)(10^-e)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4116</td>
    <td class="codeLine">    //   (N)(2^-e) == (N)(5^e)(10^-e)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="codeLine">    // This means we have to multiply N (the significand) by 5^e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4117</td>
    <td class="codeLine">    // This means we have to multiply N (the significand) by 5^e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="codeLine">    // To avoid overflow, we have to operate on numbers large</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4118</td>
    <td class="codeLine">    // To avoid overflow, we have to operate on numbers large</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="codeLine">    // enough to store N * 5^e:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4119</td>
    <td class="codeLine">    // enough to store N * 5^e:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="codeLine">    //   log2(N * 5^e) == log2(N) + e * log2(5)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4120</td>
    <td class="codeLine">    //   log2(N * 5^e) == log2(N) + e * log2(5)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="codeLine">    //                 <= semantics->precision + e * 137 / 59</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4121</td>
    <td class="codeLine">    //                 <= semantics->precision + e * 137 / 59</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="codeLine">    //   (log_2(5) ~ 2.321928 < 2.322034 ~ 137/59)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4122</td>
    <td class="codeLine">    //   (log_2(5) ~ 2.321928 < 2.322034 ~ 137/59)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="codeLine">    unsigned precision = semantics->precision + (137 * texp + 136) / 59;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4124</td>
    <td class="codeLine">    unsigned precision = semantics->precision + (137 * texp + 136) / 59;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="codeLine">    // Multiply significand by 5^e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4126</td>
    <td class="codeLine">    // Multiply significand by 5^e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="codeLine">    //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4127</td>
    <td class="codeLine">    //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="codeLine">    significand = significand.zext(precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4128</td>
    <td class="codeLine">    significand = significand.zext(precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="codeLine">    APInt five_to_the_i(precision, 5);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4129</td>
    <td class="codeLine">    APInt five_to_the_i(precision, 5);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4130</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="codeLine">      if (texp & 1) significand *= five_to_the_i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4131</td>
    <td class="codeLine">      if (texp & 1) significand *= five_to_the_i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="codeLine">      texp >>= 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4133</td>
    <td class="codeLine">      texp >>= 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="codeLine">      if (!texp) break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4134</td>
    <td class="codeLine">      if (!texp) break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="codeLine">      five_to_the_i *= five_to_the_i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4135</td>
    <td class="codeLine">      five_to_the_i *= five_to_the_i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4136</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4137</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="codeLine">  AdjustToPrecision(significand, exp, FormatPrecision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4139</td>
    <td class="codeLine">  AdjustToPrecision(significand, exp, FormatPrecision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="codeLine">  SmallVector<char, 256> buffer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4141</td>
    <td class="codeLine">  SmallVector<char, 256> buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="codeLine">  // Fill the buffer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4143</td>
    <td class="codeLine">  // Fill the buffer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="codeLine">  unsigned precision = significand.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4144</td>
    <td class="codeLine">  unsigned precision = significand.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="codeLine">  if (precision < 4) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4145</td>
    <td class="codeLine">  if (precision < 4) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="codeLine">    // We need enough precision to store the value 10.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4146</td>
    <td class="codeLine">    // We need enough precision to store the value 10.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="codeLine">    precision = 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4147</td>
    <td class="codeLine">    precision = 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="codeLine">    significand = significand.zext(precision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4148</td>
    <td class="codeLine">    significand = significand.zext(precision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="codeLine">  APInt ten(precision, 10);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4150</td>
    <td class="codeLine">  APInt ten(precision, 10);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="codeLine">  APInt digit(precision, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4151</td>
    <td class="codeLine">  APInt digit(precision, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="codeLine">  bool inTrail = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4153</td>
    <td class="codeLine">  bool inTrail = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="codeLine">  while (significand != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4154</td>
    <td class="codeLine">  while (significand != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="codeLine">    // digit <- significand % 10</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4155</td>
    <td class="codeLine">    // digit <- significand % 10</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="codeLine">    // significand <- significand / 10</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4156</td>
    <td class="codeLine">    // significand <- significand / 10</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="codeLine">    APInt::udivrem(significand, ten, significand, digit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4157</td>
    <td class="codeLine">    APInt::udivrem(significand, ten, significand, digit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="codeLine">    unsigned d = digit.getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4159</td>
    <td class="codeLine">    unsigned d = digit.getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="codeLine">    // Drop trailing zeros.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4161</td>
    <td class="codeLine">    // Drop trailing zeros.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="codeLine">    if (inTrail && !d) exp++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4162</td>
    <td class="codeLine">    if (inTrail && !d) exp++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4163</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="codeLine">      buffer.push_back((char) ('0' + d));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4164</td>
    <td class="codeLine">      buffer.push_back((char) ('0' + d));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="codeLine">      inTrail = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4165</td>
    <td class="codeLine">      inTrail = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4166</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="codeLine">  assert(!buffer.empty() && "no characters in buffer!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4169</td>
    <td class="codeLine">  assert(!buffer.empty() && "no characters in buffer!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="codeLine">  // Drop down to FormatPrecision.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4171</td>
    <td class="codeLine">  // Drop down to FormatPrecision.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="codeLine">  // TODO: don't do more precise calculations above than are required.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4172</td>
    <td class="codeLine">  // TODO: don't do more precise calculations above than are required.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="codeLine">  AdjustToPrecision(buffer, exp, FormatPrecision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4173</td>
    <td class="codeLine">  AdjustToPrecision(buffer, exp, FormatPrecision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="codeLine">  unsigned NDigits = buffer.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4175</td>
    <td class="codeLine">  unsigned NDigits = buffer.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="codeLine">  // Check whether we should use scientific notation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4177</td>
    <td class="codeLine">  // Check whether we should use scientific notation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="codeLine">  bool FormatScientific;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4178</td>
    <td class="codeLine">  bool FormatScientific;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="codeLine">  if (!FormatMaxPadding)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4179</td>
    <td class="codeLine">  if (!FormatMaxPadding)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="codeLine">    FormatScientific = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4180</td>
    <td class="codeLine">    FormatScientific = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4181</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="codeLine">    if (exp >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4182</td>
    <td class="codeLine">    if (exp >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="codeLine">      // 765e3 --> 765000</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4183</td>
    <td class="codeLine">      // 765e3 --> 765000</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="codeLine">      //              ^^^</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4184</td>
    <td class="codeLine">      //              ^^^</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="codeLine">      // But we shouldn't make the number look more precise than it is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4185</td>
    <td class="codeLine">      // But we shouldn't make the number look more precise than it is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="codeLine">      FormatScientific = ((unsigned) exp > FormatMaxPadding ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4186</td>
    <td class="codeLine">      FormatScientific = ((unsigned) exp > FormatMaxPadding ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="codeLine">                          NDigits + (unsigned) exp > FormatPrecision);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4187</td>
    <td class="codeLine">                          NDigits + (unsigned) exp > FormatPrecision);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4188</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="codeLine">      // Power of the most significant digit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4189</td>
    <td class="codeLine">      // Power of the most significant digit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="codeLine">      int MSD = exp + (int) (NDigits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4190</td>
    <td class="codeLine">      int MSD = exp + (int) (NDigits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="codeLine">      if (MSD >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4191</td>
    <td class="codeLine">      if (MSD >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="codeLine">        // 765e-2 == 7.65</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4192</td>
    <td class="codeLine">        // 765e-2 == 7.65</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="codeLine">        FormatScientific = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4193</td>
    <td class="codeLine">        FormatScientific = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4194</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="codeLine">        // 765e-5 == 0.00765</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4195</td>
    <td class="codeLine">        // 765e-5 == 0.00765</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="codeLine">        //           ^ ^^</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4196</td>
    <td class="codeLine">        //           ^ ^^</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="codeLine">        FormatScientific = ((unsigned) -MSD) > FormatMaxPadding;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4197</td>
    <td class="codeLine">        FormatScientific = ((unsigned) -MSD) > FormatMaxPadding;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4198</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4199</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4200</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="codeLine">  // Scientific formatting is pretty straightforward.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4202</td>
    <td class="codeLine">  // Scientific formatting is pretty straightforward.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="codeLine">  if (FormatScientific) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4203</td>
    <td class="codeLine">  if (FormatScientific) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="codeLine">    exp += (NDigits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4204</td>
    <td class="codeLine">    exp += (NDigits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="codeLine">    Str.push_back(buffer[NDigits-1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4206</td>
    <td class="codeLine">    Str.push_back(buffer[NDigits-1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="codeLine">    Str.push_back('.');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4207</td>
    <td class="codeLine">    Str.push_back('.');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="codeLine">    if (NDigits == 1 && TruncateZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4208</td>
    <td class="codeLine">    if (NDigits == 1 && TruncateZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4209</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4210</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="codeLine">      for (unsigned I = 1; I != NDigits; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4211</td>
    <td class="codeLine">      for (unsigned I = 1; I != NDigits; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="codeLine">        Str.push_back(buffer[NDigits-1-I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4212</td>
    <td class="codeLine">        Str.push_back(buffer[NDigits-1-I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="codeLine">    // Fill with zeros up to FormatPrecision.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4213</td>
    <td class="codeLine">    // Fill with zeros up to FormatPrecision.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="codeLine">    if (!TruncateZero && FormatPrecision > NDigits - 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4214</td>
    <td class="codeLine">    if (!TruncateZero && FormatPrecision > NDigits - 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="codeLine">      Str.append(FormatPrecision - NDigits + 1, '0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4215</td>
    <td class="codeLine">      Str.append(FormatPrecision - NDigits + 1, '0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="codeLine">    // For !TruncateZero we use lower 'e'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4216</td>
    <td class="codeLine">    // For !TruncateZero we use lower 'e'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="codeLine">    Str.push_back(TruncateZero ? 'E' : 'e');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4217</td>
    <td class="codeLine">    Str.push_back(TruncateZero ? 'E' : 'e');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="codeLine">    Str.push_back(exp >= 0 ? '+' : '-');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4219</td>
    <td class="codeLine">    Str.push_back(exp >= 0 ? '+' : '-');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="codeLine">    if (exp < 0) exp = -exp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4220</td>
    <td class="codeLine">    if (exp < 0) exp = -exp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="codeLine">    SmallVector<char, 6> expbuf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4221</td>
    <td class="codeLine">    SmallVector<char, 6> expbuf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4222</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="codeLine">      expbuf.push_back((char) ('0' + (exp % 10)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4223</td>
    <td class="codeLine">      expbuf.push_back((char) ('0' + (exp % 10)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class="codeLine">      exp /= 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4224</td>
    <td class="codeLine">      exp /= 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="codeLine">    } while (exp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4225</td>
    <td class="codeLine">    } while (exp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="codeLine">    // Exponent always at least two digits if we do not truncate zeros.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4226</td>
    <td class="codeLine">    // Exponent always at least two digits if we do not truncate zeros.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="codeLine">    if (!TruncateZero && expbuf.size() < 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4227</td>
    <td class="codeLine">    if (!TruncateZero && expbuf.size() < 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="codeLine">      expbuf.push_back('0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4228</td>
    <td class="codeLine">      expbuf.push_back('0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="codeLine">    for (unsigned I = 0, E = expbuf.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4229</td>
    <td class="codeLine">    for (unsigned I = 0, E = expbuf.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="codeLine">      Str.push_back(expbuf[E-1-I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4230</td>
    <td class="codeLine">      Str.push_back(expbuf[E-1-I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4231</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4232</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="codeLine">  // Non-scientific, positive exponents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4234</td>
    <td class="codeLine">  // Non-scientific, positive exponents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="codeLine">  if (exp >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4235</td>
    <td class="codeLine">  if (exp >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="codeLine">    for (unsigned I = 0; I != NDigits; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4236</td>
    <td class="codeLine">    for (unsigned I = 0; I != NDigits; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="codeLine">      Str.push_back(buffer[NDigits-1-I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4237</td>
    <td class="codeLine">      Str.push_back(buffer[NDigits-1-I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="codeLine">    for (unsigned I = 0; I != (unsigned) exp; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4238</td>
    <td class="codeLine">    for (unsigned I = 0; I != (unsigned) exp; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4239</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4240</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4241</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="codeLine">  // Non-scientific, negative exponents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4243</td>
    <td class="codeLine">  // Non-scientific, negative exponents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="codeLine">  // The number of digits to the left of the decimal point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4245</td>
    <td class="codeLine">  // The number of digits to the left of the decimal point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="codeLine">  int NWholeDigits = exp + (int) NDigits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4246</td>
    <td class="codeLine">  int NWholeDigits = exp + (int) NDigits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="codeLine">  unsigned I = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4248</td>
    <td class="codeLine">  unsigned I = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="codeLine">  if (NWholeDigits > 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4249</td>
    <td class="codeLine">  if (NWholeDigits > 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="codeLine">    for (; I != (unsigned) NWholeDigits; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4250</td>
    <td class="codeLine">    for (; I != (unsigned) NWholeDigits; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="codeLine">      Str.push_back(buffer[NDigits-I-1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4251</td>
    <td class="codeLine">      Str.push_back(buffer[NDigits-I-1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="codeLine">    Str.push_back('.');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4252</td>
    <td class="codeLine">    Str.push_back('.');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4253</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="codeLine">    unsigned NZeros = 1 + (unsigned) -NWholeDigits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4254</td>
    <td class="codeLine">    unsigned NZeros = 1 + (unsigned) -NWholeDigits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="codeLine">    Str.push_back('0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4256</td>
    <td class="codeLine">    Str.push_back('0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="codeLine">    Str.push_back('.');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4257</td>
    <td class="codeLine">    Str.push_back('.');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="codeLine">    for (unsigned Z = 1; Z != NZeros; ++Z)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4258</td>
    <td class="codeLine">    for (unsigned Z = 1; Z != NZeros; ++Z)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4259</td>
    <td class="codeLine">      Str.push_back('0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4260</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="codeLine">  for (; I != NDigits; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4262</td>
    <td class="codeLine">  for (; I != NDigits; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="codeLine">    Str.push_back(buffer[NDigits-I-1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4263</td>
    <td class="codeLine">    Str.push_back(buffer[NDigits-I-1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4264</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="codeLine">bool IEEEFloat::getExactInverse(APFloat *inv) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4266</td>
    <td class="codeLine">bool IEEEFloat::getExactInverse(APFloat *inv) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="codeLine">  // Special floats and denormals have no exact inverse.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4267</td>
    <td class="codeLine">  // Special floats and denormals have no exact inverse.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="codeLine">  if (!isFiniteNonZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4268</td>
    <td class="codeLine">  if (!isFiniteNonZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4269</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="codeLine">  // Check that the number is a power of two by making sure that only the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4271</td>
    <td class="codeLine">  // Check that the number is a power of two by making sure that only the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="codeLine">  // integer bit is set in the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4272</td>
    <td class="codeLine">  // integer bit is set in the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="codeLine">  if (significandLSB() != semantics->precision - 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4273</td>
    <td class="codeLine">  if (significandLSB() != semantics->precision - 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4274</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="codeLine">  // Get the inverse.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4276</td>
    <td class="codeLine">  // Get the inverse.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="codeLine">  IEEEFloat reciprocal(*semantics, 1ULL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4277</td>
    <td class="codeLine">  IEEEFloat reciprocal(*semantics, 1ULL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="codeLine">  if (reciprocal.divide(*this, rmNearestTiesToEven) != opOK)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4278</td>
    <td class="codeLine">  if (reciprocal.divide(*this, rmNearestTiesToEven) != opOK)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4279</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="codeLine">  // Avoid multiplication with a denormal, it is not safe on all platforms and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4281</td>
    <td class="codeLine">  // Avoid multiplication with a denormal, it is not safe on all platforms and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="codeLine">  // may be slower than a normal division.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4282</td>
    <td class="codeLine">  // may be slower than a normal division.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="codeLine">  if (reciprocal.isDenormal())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4283</td>
    <td class="codeLine">  if (reciprocal.isDenormal())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4284</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="codeLine">  assert(reciprocal.isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4286</td>
    <td class="codeLine">  assert(reciprocal.isFiniteNonZero() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="codeLine">         reciprocal.significandLSB() == reciprocal.semantics->precision - 1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4287</td>
    <td class="codeLine">         reciprocal.significandLSB() == reciprocal.semantics->precision - 1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="codeLine">  if (inv)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4289</td>
    <td class="codeLine">  if (inv)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="codeLine">    *inv = APFloat(reciprocal, *semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4290</td>
    <td class="codeLine">    *inv = APFloat(reciprocal, *semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4292</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4293</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="codeLine">bool IEEEFloat::isSignaling() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4295</td>
    <td class="codeLine">bool IEEEFloat::isSignaling() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="codeLine">  if (!isNaN())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4296</td>
    <td class="codeLine">  if (!isNaN())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4297</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4298</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4299</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="codeLine">  // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4301</td>
    <td class="codeLine">  // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="codeLine">  // first bit of the trailing significand being 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4302</td>
    <td class="codeLine">  // first bit of the trailing significand being 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="codeLine">  return !APInt::tcExtractBit(significandParts(), semantics->precision - 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4303</td>
    <td class="codeLine">  return !APInt::tcExtractBit(significandParts(), semantics->precision - 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4304</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="codeLine">/// IEEE-754R 2008 5.3.1: nextUp/nextDown.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4306</td>
    <td class="codeLine">/// IEEE-754R 2008 5.3.1: nextUp/nextDown.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4307</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="codeLine">/// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4308</td>
    <td class="codeLine">/// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="codeLine">/// appropriate sign switching before/after the computation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4309</td>
    <td class="codeLine">/// appropriate sign switching before/after the computation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::next(bool nextDown) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4310</td>
    <td class="codeLine">IEEEFloat::opStatus IEEEFloat::next(bool nextDown) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="codeLine">  // If we are performing nextDown, swap sign so we have -x.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4311</td>
    <td class="codeLine">  // If we are performing nextDown, swap sign so we have -x.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="codeLine">  if (nextDown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4312</td>
    <td class="codeLine">  if (nextDown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4313</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="codeLine">  // Compute nextUp(x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4315</td>
    <td class="codeLine">  // Compute nextUp(x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="codeLine">  opStatus result = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4316</td>
    <td class="codeLine">  opStatus result = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="codeLine">  // Handle each float category separately.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4318</td>
    <td class="codeLine">  // Handle each float category separately.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="codeLine">  switch (category) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4319</td>
    <td class="codeLine">  switch (category) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class="codeLine">  case fcInfinity:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4320</td>
    <td class="codeLine">  case fcInfinity:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="codeLine">    // nextUp(+inf) = +inf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4321</td>
    <td class="codeLine">    // nextUp(+inf) = +inf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="codeLine">    if (!isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4322</td>
    <td class="codeLine">    if (!isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4323</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="codeLine">    // nextUp(-inf) = -getLargest()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4324</td>
    <td class="codeLine">    // nextUp(-inf) = -getLargest()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="codeLine">    makeLargest(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4325</td>
    <td class="codeLine">    makeLargest(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4326</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="codeLine">  case fcNaN:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4327</td>
    <td class="codeLine">  case fcNaN:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="codeLine">    // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4328</td>
    <td class="codeLine">    // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="codeLine">    // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4329</td>
    <td class="codeLine">    // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="codeLine">    //                     change the payload.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4330</td>
    <td class="codeLine">    //                     change the payload.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4331</td>
    <td class="codeLine">    if (isSignaling()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="codeLine">      result = opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4332</td>
    <td class="codeLine">      result = opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="codeLine">      // For consistency, propagate the sign of the sNaN to the qNaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4333</td>
    <td class="codeLine">      // For consistency, propagate the sign of the sNaN to the qNaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="codeLine">      makeNaN(false, isNegative(), nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4334</td>
    <td class="codeLine">      makeNaN(false, isNegative(), nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4335</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4336</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="codeLine">  case fcZero:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4337</td>
    <td class="codeLine">  case fcZero:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="codeLine">    // nextUp(pm 0) = +getSmallest()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4338</td>
    <td class="codeLine">    // nextUp(pm 0) = +getSmallest()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="codeLine">    makeSmallest(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4339</td>
    <td class="codeLine">    makeSmallest(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4340</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="codeLine">  case fcNormal:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4341</td>
    <td class="codeLine">  case fcNormal:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="codeLine">    // nextUp(-getSmallest()) = -0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4342</td>
    <td class="codeLine">    // nextUp(-getSmallest()) = -0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="codeLine">    if (isSmallest() && isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4343</td>
    <td class="codeLine">    if (isSmallest() && isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="codeLine">      APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4344</td>
    <td class="codeLine">      APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="codeLine">      category = fcZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4345</td>
    <td class="codeLine">      category = fcZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="codeLine">      exponent = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4346</td>
    <td class="codeLine">      exponent = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="codeLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4347</td>
    <td class="codeLine">      if (semantics->nanEncoding == fltNanEncoding::NegativeZero)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="codeLine">        sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4348</td>
    <td class="codeLine">        sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4349</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4350</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="codeLine">    if (isLargest() && !isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4352</td>
    <td class="codeLine">    if (isLargest() && !isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="codeLine">      if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4353</td>
    <td class="codeLine">      if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="codeLine">        // nextUp(getLargest()) == NAN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4354</td>
    <td class="codeLine">        // nextUp(getLargest()) == NAN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="codeLine">        makeNaN();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4355</td>
    <td class="codeLine">        makeNaN();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4356</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4357</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="codeLine">        // nextUp(getLargest()) == INFINITY</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4358</td>
    <td class="codeLine">        // nextUp(getLargest()) == INFINITY</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="codeLine">        APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4359</td>
    <td class="codeLine">        APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="codeLine">        category = fcInfinity;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4360</td>
    <td class="codeLine">        category = fcInfinity;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="codeLine">        exponent = semantics->maxExponent + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4361</td>
    <td class="codeLine">        exponent = semantics->maxExponent + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4362</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4363</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4364</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="codeLine">    // nextUp(normal) == normal + inc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4366</td>
    <td class="codeLine">    // nextUp(normal) == normal + inc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="codeLine">    if (isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4367</td>
    <td class="codeLine">    if (isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="codeLine">      // If we are negative, we need to decrement the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4368</td>
    <td class="codeLine">      // If we are negative, we need to decrement the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="codeLine">      // We only cross a binade boundary that requires adjusting the exponent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4370</td>
    <td class="codeLine">      // We only cross a binade boundary that requires adjusting the exponent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="codeLine">      // if:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4371</td>
    <td class="codeLine">      // if:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="codeLine">      //   1. exponent != semantics->minExponent. This implies we are not in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4372</td>
    <td class="codeLine">      //   1. exponent != semantics->minExponent. This implies we are not in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="codeLine">      //   smallest binade or are dealing with denormals.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4373</td>
    <td class="codeLine">      //   smallest binade or are dealing with denormals.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="codeLine">      //   2. Our significand excluding the integral bit is all zeros.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4374</td>
    <td class="codeLine">      //   2. Our significand excluding the integral bit is all zeros.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="codeLine">      bool WillCrossBinadeBoundary =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4375</td>
    <td class="codeLine">      bool WillCrossBinadeBoundary =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="codeLine">        exponent != semantics->minExponent && isSignificandAllZeros();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4376</td>
    <td class="codeLine">        exponent != semantics->minExponent && isSignificandAllZeros();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="codeLine">      // Decrement the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4378</td>
    <td class="codeLine">      // Decrement the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4379</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="codeLine">      // We always do this since:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4380</td>
    <td class="codeLine">      // We always do this since:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="codeLine">      //   1. If we are dealing with a non-binade decrement, by definition we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4381</td>
    <td class="codeLine">      //   1. If we are dealing with a non-binade decrement, by definition we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="codeLine">      //   just decrement the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4382</td>
    <td class="codeLine">      //   just decrement the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="codeLine">      //   2. If we are dealing with a normal -> normal binade decrement, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4383</td>
    <td class="codeLine">      //   2. If we are dealing with a normal -> normal binade decrement, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="codeLine">      //   we have an explicit integral bit the fact that all bits but the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4384</td>
    <td class="codeLine">      //   we have an explicit integral bit the fact that all bits but the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="codeLine">      //   integral bit are zero implies that subtracting one will yield a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4385</td>
    <td class="codeLine">      //   integral bit are zero implies that subtracting one will yield a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class="codeLine">      //   significand with 0 integral bit and 1 in all other spots. Thus we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4386</td>
    <td class="codeLine">      //   significand with 0 integral bit and 1 in all other spots. Thus we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="codeLine">      //   must just adjust the exponent and set the integral bit to 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4387</td>
    <td class="codeLine">      //   must just adjust the exponent and set the integral bit to 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="codeLine">      //   3. If we are dealing with a normal -> denormal binade decrement,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4388</td>
    <td class="codeLine">      //   3. If we are dealing with a normal -> denormal binade decrement,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="codeLine">      //   since we set the integral bit to 0 when we represent denormals, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4389</td>
    <td class="codeLine">      //   since we set the integral bit to 0 when we represent denormals, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="codeLine">      //   just decrement the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4390</td>
    <td class="codeLine">      //   just decrement the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class="codeLine">      integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4391</td>
    <td class="codeLine">      integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="codeLine">      APInt::tcDecrement(Parts, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4392</td>
    <td class="codeLine">      APInt::tcDecrement(Parts, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="codeLine">      if (WillCrossBinadeBoundary) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4394</td>
    <td class="codeLine">      if (WillCrossBinadeBoundary) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="codeLine">        // Our result is a normal number. Do the following:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4395</td>
    <td class="codeLine">        // Our result is a normal number. Do the following:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="codeLine">        // 1. Set the integral bit to 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4396</td>
    <td class="codeLine">        // 1. Set the integral bit to 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="codeLine">        // 2. Decrement the exponent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4397</td>
    <td class="codeLine">        // 2. Decrement the exponent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="codeLine">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4398</td>
    <td class="codeLine">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="codeLine">        exponent--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4399</td>
    <td class="codeLine">        exponent--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4400</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4401</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="codeLine">      // If we are positive, we need to increment the significand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4402</td>
    <td class="codeLine">      // If we are positive, we need to increment the significand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="codeLine">      // We only cross a binade boundary that requires adjusting the exponent if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4404</td>
    <td class="codeLine">      // We only cross a binade boundary that requires adjusting the exponent if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="codeLine">      // the input is not a denormal and all of said input's significand bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4405</td>
    <td class="codeLine">      // the input is not a denormal and all of said input's significand bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="codeLine">      // are set. If all of said conditions are true: clear the significand, set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4406</td>
    <td class="codeLine">      // are set. If all of said conditions are true: clear the significand, set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="codeLine">      // the integral bit to 1, and increment the exponent. If we have a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4407</td>
    <td class="codeLine">      // the integral bit to 1, and increment the exponent. If we have a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="codeLine">      // denormal always increment since moving denormals and the numbers in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4408</td>
    <td class="codeLine">      // denormal always increment since moving denormals and the numbers in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="codeLine">      // smallest normal binade have the same exponent in our representation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4409</td>
    <td class="codeLine">      // smallest normal binade have the same exponent in our representation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="codeLine">      bool WillCrossBinadeBoundary = !isDenormal() && isSignificandAllOnes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4410</td>
    <td class="codeLine">      bool WillCrossBinadeBoundary = !isDenormal() && isSignificandAllOnes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="codeLine">      if (WillCrossBinadeBoundary) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4412</td>
    <td class="codeLine">      if (WillCrossBinadeBoundary) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="codeLine">        integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4413</td>
    <td class="codeLine">        integerPart *Parts = significandParts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="codeLine">        APInt::tcSet(Parts, 0, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4414</td>
    <td class="codeLine">        APInt::tcSet(Parts, 0, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="codeLine">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4415</td>
    <td class="codeLine">        APInt::tcSetBit(Parts, semantics->precision - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="codeLine">        assert(exponent != semantics->maxExponent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4416</td>
    <td class="codeLine">        assert(exponent != semantics->maxExponent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="codeLine">               "We can not increment an exponent beyond the maxExponent allowed"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4417</td>
    <td class="codeLine">               "We can not increment an exponent beyond the maxExponent allowed"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="codeLine">               " by the given floating point semantics.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4418</td>
    <td class="codeLine">               " by the given floating point semantics.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="codeLine">        exponent++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4419</td>
    <td class="codeLine">        exponent++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4420</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="codeLine">        incrementSignificand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4421</td>
    <td class="codeLine">        incrementSignificand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4422</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4423</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4424</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4425</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="codeLine">  // If we are performing nextDown, swap sign so we have -nextUp(-x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4427</td>
    <td class="codeLine">  // If we are performing nextDown, swap sign so we have -nextUp(-x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="codeLine">  if (nextDown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4428</td>
    <td class="codeLine">  if (nextDown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4429</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4431</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4432</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="codeLine">APFloatBase::ExponentType IEEEFloat::exponentNaN() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4434</td>
    <td class="codeLine">APFloatBase::ExponentType IEEEFloat::exponentNaN() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="codeLine">  return ::exponentNaN(*semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4435</td>
    <td class="codeLine">  return ::exponentNaN(*semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4436</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="codeLine">APFloatBase::ExponentType IEEEFloat::exponentInf() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4438</td>
    <td class="codeLine">APFloatBase::ExponentType IEEEFloat::exponentInf() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="codeLine">  return ::exponentInf(*semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4439</td>
    <td class="codeLine">  return ::exponentInf(*semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4440</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="codeLine coveredLine">APFloatBase::ExponentType IEEEFloat::exponentZero() const {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4442</td>
    <td class="codeLine coveredLine">APFloatBase::ExponentType IEEEFloat::exponentZero() const {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="codeLine coveredLine">  return ::exponentZero(*semantics);</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4443</td>
    <td class="codeLine coveredLine">  return ::exponentZero(*semantics);</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4444</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="codeLine">void IEEEFloat::makeInf(bool Negative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4446</td>
    <td class="codeLine">void IEEEFloat::makeInf(bool Negative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4447</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior == fltNonfiniteBehavior::NanOnly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="codeLine">    // There is no Inf, so make NaN instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4448</td>
    <td class="codeLine">    // There is no Inf, so make NaN instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="codeLine">    makeNaN(false, Negative);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4449</td>
    <td class="codeLine">    makeNaN(false, Negative);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4450</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4451</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="codeLine">  category = fcInfinity;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4452</td>
    <td class="codeLine">  category = fcInfinity;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4453</td>
    <td class="codeLine">  sign = Negative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="codeLine">  exponent = exponentInf();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4454</td>
    <td class="codeLine">  exponent = exponentInf();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="codeLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4455</td>
    <td class="codeLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4456</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="codeLine coveredLine">void IEEEFloat::makeZero(bool Negative) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4458</td>
    <td class="codeLine coveredLine">void IEEEFloat::makeZero(bool Negative) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="codeLine coveredLine">  category = fcZero;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4459</td>
    <td class="codeLine coveredLine">  category = fcZero;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="codeLine coveredLine">  sign = Negative;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4460</td>
    <td class="codeLine coveredLine">  sign = Negative;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="codeLine coveredLine">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4461</td>
    <td class="codeLine coveredLine">  if (semantics->nanEncoding == fltNanEncoding::NegativeZero) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="codeLine">    // Merge negative zero to positive because 0b10000...000 is used for NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4462</td>
    <td class="codeLine">    // Merge negative zero to positive because 0b10000...000 is used for NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4463</td>
    <td class="codeLine">    sign = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="codeLine coveredLine">  exponent = exponentZero();</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4465</td>
    <td class="codeLine coveredLine">  exponent = exponentZero();</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="codeLine coveredLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4466</td>
    <td class="codeLine coveredLine">  APInt::tcSet(significandParts(), 0, partCount());</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">4467</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="codeLine">void IEEEFloat::makeQuiet() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4469</td>
    <td class="codeLine">void IEEEFloat::makeQuiet() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="codeLine">  assert(isNaN());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4470</td>
    <td class="codeLine">  assert(isNaN());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior != fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4471</td>
    <td class="codeLine">  if (semantics->nonFiniteBehavior != fltNonfiniteBehavior::NanOnly)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="codeLine">    APInt::tcSetBit(significandParts(), semantics->precision - 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4472</td>
    <td class="codeLine">    APInt::tcSetBit(significandParts(), semantics->precision - 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4473</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="codeLine">int ilogb(const IEEEFloat &Arg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4475</td>
    <td class="codeLine">int ilogb(const IEEEFloat &Arg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="codeLine">  if (Arg.isNaN())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4476</td>
    <td class="codeLine">  if (Arg.isNaN())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="codeLine">    return IEEEFloat::IEK_NaN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4477</td>
    <td class="codeLine">    return IEEEFloat::IEK_NaN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="codeLine">  if (Arg.isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4478</td>
    <td class="codeLine">  if (Arg.isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="codeLine">    return IEEEFloat::IEK_Zero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4479</td>
    <td class="codeLine">    return IEEEFloat::IEK_Zero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="codeLine">  if (Arg.isInfinity())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4480</td>
    <td class="codeLine">  if (Arg.isInfinity())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="codeLine">    return IEEEFloat::IEK_Inf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4481</td>
    <td class="codeLine">    return IEEEFloat::IEK_Inf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="codeLine">  if (!Arg.isDenormal())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4482</td>
    <td class="codeLine">  if (!Arg.isDenormal())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="codeLine">    return Arg.exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4483</td>
    <td class="codeLine">    return Arg.exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="codeLine">  IEEEFloat Normalized(Arg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4485</td>
    <td class="codeLine">  IEEEFloat Normalized(Arg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="codeLine">  int SignificandBits = Arg.getSemantics().precision - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4486</td>
    <td class="codeLine">  int SignificandBits = Arg.getSemantics().precision - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="codeLine">  Normalized.exponent += SignificandBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4488</td>
    <td class="codeLine">  Normalized.exponent += SignificandBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="codeLine">  Normalized.normalize(IEEEFloat::rmNearestTiesToEven, lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4489</td>
    <td class="codeLine">  Normalized.normalize(IEEEFloat::rmNearestTiesToEven, lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="codeLine">  return Normalized.exponent - SignificandBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4490</td>
    <td class="codeLine">  return Normalized.exponent - SignificandBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4491</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="codeLine">IEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode RoundingMode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4493</td>
    <td class="codeLine">IEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode RoundingMode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="codeLine">  auto MaxExp = X.getSemantics().maxExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4494</td>
    <td class="codeLine">  auto MaxExp = X.getSemantics().maxExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="codeLine">  auto MinExp = X.getSemantics().minExponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4495</td>
    <td class="codeLine">  auto MinExp = X.getSemantics().minExponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="codeLine">  // If Exp is wildly out-of-scale, simply adding it to X.exponent will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4497</td>
    <td class="codeLine">  // If Exp is wildly out-of-scale, simply adding it to X.exponent will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="codeLine">  // overflow; clamp it to a safe range before adding, but ensure that the range</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4498</td>
    <td class="codeLine">  // overflow; clamp it to a safe range before adding, but ensure that the range</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="codeLine">  // is large enough that the clamp does not change the result. The range we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4499</td>
    <td class="codeLine">  // is large enough that the clamp does not change the result. The range we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="codeLine">  // need to support is the difference between the largest possible exponent and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4500</td>
    <td class="codeLine">  // need to support is the difference between the largest possible exponent and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="codeLine">  // the normalized exponent of half the smallest denormal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4501</td>
    <td class="codeLine">  // the normalized exponent of half the smallest denormal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="codeLine">  int SignificandBits = X.getSemantics().precision - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4503</td>
    <td class="codeLine">  int SignificandBits = X.getSemantics().precision - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="codeLine">  int MaxIncrement = MaxExp - (MinExp - SignificandBits) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4504</td>
    <td class="codeLine">  int MaxIncrement = MaxExp - (MinExp - SignificandBits) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="codeLine">  // Clamp to one past the range ends to let normalize handle overlflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4506</td>
    <td class="codeLine">  // Clamp to one past the range ends to let normalize handle overlflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="codeLine">  X.exponent += std::clamp(Exp, -MaxIncrement - 1, MaxIncrement);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4507</td>
    <td class="codeLine">  X.exponent += std::clamp(Exp, -MaxIncrement - 1, MaxIncrement);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="codeLine">  X.normalize(RoundingMode, lfExactlyZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4508</td>
    <td class="codeLine">  X.normalize(RoundingMode, lfExactlyZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="codeLine">  if (X.isNaN())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4509</td>
    <td class="codeLine">  if (X.isNaN())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="codeLine">    X.makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4510</td>
    <td class="codeLine">    X.makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="codeLine">  return X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4511</td>
    <td class="codeLine">  return X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4512</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="codeLine">IEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4514</td>
    <td class="codeLine">IEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="codeLine">  Exp = ilogb(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4515</td>
    <td class="codeLine">  Exp = ilogb(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="codeLine">  // Quiet signalling nans.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4517</td>
    <td class="codeLine">  // Quiet signalling nans.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="codeLine">  if (Exp == IEEEFloat::IEK_NaN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4518</td>
    <td class="codeLine">  if (Exp == IEEEFloat::IEK_NaN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="codeLine">    IEEEFloat Quiet(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4519</td>
    <td class="codeLine">    IEEEFloat Quiet(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="codeLine">    Quiet.makeQuiet();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4520</td>
    <td class="codeLine">    Quiet.makeQuiet();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="codeLine">    return Quiet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4521</td>
    <td class="codeLine">    return Quiet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="codeLine">  if (Exp == IEEEFloat::IEK_Inf)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4524</td>
    <td class="codeLine">  if (Exp == IEEEFloat::IEK_Inf)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4525</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="codeLine">  // 1 is added because frexp is defined to return a normalized fraction in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4527</td>
    <td class="codeLine">  // 1 is added because frexp is defined to return a normalized fraction in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="codeLine">  // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4528</td>
    <td class="codeLine">  // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="codeLine">  Exp = Exp == IEEEFloat::IEK_Zero ? 0 : Exp + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4529</td>
    <td class="codeLine">  Exp = Exp == IEEEFloat::IEK_Zero ? 0 : Exp + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="codeLine">  return scalbn(Val, -Exp, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4530</td>
    <td class="codeLine">  return scalbn(Val, -Exp, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4531</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4533</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4534</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="codeLine">      Floats(new APFloat[2]{APFloat(semIEEEdouble), APFloat(semIEEEdouble)}) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4535</td>
    <td class="codeLine">      Floats(new APFloat[2]{APFloat(semIEEEdouble), APFloat(semIEEEdouble)}) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4536</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4537</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, uninitializedTag)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4539</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, uninitializedTag)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4540</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="codeLine">      Floats(new APFloat[2]{APFloat(semIEEEdouble, uninitialized),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4541</td>
    <td class="codeLine">      Floats(new APFloat[2]{APFloat(semIEEEdouble, uninitialized),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="codeLine">                            APFloat(semIEEEdouble, uninitialized)}) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4542</td>
    <td class="codeLine">                            APFloat(semIEEEdouble, uninitialized)}) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4543</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4544</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, integerPart I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4546</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, integerPart I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="codeLine">    : Semantics(&S), Floats(new APFloat[2]{APFloat(semIEEEdouble, I),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4547</td>
    <td class="codeLine">    : Semantics(&S), Floats(new APFloat[2]{APFloat(semIEEEdouble, I),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="codeLine">                                           APFloat(semIEEEdouble)}) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4548</td>
    <td class="codeLine">                                           APFloat(semIEEEdouble)}) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4549</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4550</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, const APInt &I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4552</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, const APInt &I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4553</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="codeLine">      Floats(new APFloat[2]{</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4554</td>
    <td class="codeLine">      Floats(new APFloat[2]{</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="codeLine">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[0])),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4555</td>
    <td class="codeLine">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[0])),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="codeLine">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[1]))}) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4556</td>
    <td class="codeLine">          APFloat(semIEEEdouble, APInt(64, I.getRawData()[1]))}) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4557</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4558</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, APFloat &&First,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4560</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const fltSemantics &S, APFloat &&First,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="codeLine">                             APFloat &&Second)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4561</td>
    <td class="codeLine">                             APFloat &&Second)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4562</td>
    <td class="codeLine">    : Semantics(&S),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="codeLine">      Floats(new APFloat[2]{std::move(First), std::move(Second)}) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4563</td>
    <td class="codeLine">      Floats(new APFloat[2]{std::move(First), std::move(Second)}) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4564</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="codeLine">  assert(&Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4565</td>
    <td class="codeLine">  assert(&Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="codeLine">  assert(&Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4566</td>
    <td class="codeLine">  assert(&Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4567</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const DoubleAPFloat &RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4569</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(const DoubleAPFloat &RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="codeLine">    : Semantics(RHS.Semantics),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4570</td>
    <td class="codeLine">    : Semantics(RHS.Semantics),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="codeLine">      Floats(RHS.Floats ? new APFloat[2]{APFloat(RHS.Floats[0]),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4571</td>
    <td class="codeLine">      Floats(RHS.Floats ? new APFloat[2]{APFloat(RHS.Floats[0]),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="codeLine">                                         APFloat(RHS.Floats[1])}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4572</td>
    <td class="codeLine">                                         APFloat(RHS.Floats[1])}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="codeLine">                        : nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4573</td>
    <td class="codeLine">                        : nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4574</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4575</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(DoubleAPFloat &&RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4577</td>
    <td class="codeLine">DoubleAPFloat::DoubleAPFloat(DoubleAPFloat &&RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="codeLine">    : Semantics(RHS.Semantics), Floats(std::move(RHS.Floats)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4578</td>
    <td class="codeLine">    : Semantics(RHS.Semantics), Floats(std::move(RHS.Floats)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="codeLine">  RHS.Semantics = &semBogus;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4579</td>
    <td class="codeLine">  RHS.Semantics = &semBogus;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4580</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="codeLine">DoubleAPFloat &DoubleAPFloat::operator=(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4583</td>
    <td class="codeLine">DoubleAPFloat &DoubleAPFloat::operator=(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="codeLine">  if (Semantics == RHS.Semantics && RHS.Floats) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4584</td>
    <td class="codeLine">  if (Semantics == RHS.Semantics && RHS.Floats) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="codeLine">    Floats[0] = RHS.Floats[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4585</td>
    <td class="codeLine">    Floats[0] = RHS.Floats[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="codeLine">    Floats[1] = RHS.Floats[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4586</td>
    <td class="codeLine">    Floats[1] = RHS.Floats[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="codeLine">  } else if (this != &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4587</td>
    <td class="codeLine">  } else if (this != &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="codeLine">    this->~DoubleAPFloat();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4588</td>
    <td class="codeLine">    this->~DoubleAPFloat();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="codeLine">    new (this) DoubleAPFloat(RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4589</td>
    <td class="codeLine">    new (this) DoubleAPFloat(RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4590</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4591</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4592</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="codeLine">// Implement addition, subtraction, multiplication and division based on:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4594</td>
    <td class="codeLine">// Implement addition, subtraction, multiplication and division based on:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="codeLine">// "Software for Doubled-Precision Floating-Point Computations",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4595</td>
    <td class="codeLine">// "Software for Doubled-Precision Floating-Point Computations",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="codeLine">// by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4596</td>
    <td class="codeLine">// by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::addImpl(const APFloat &a, const APFloat &aa,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4597</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::addImpl(const APFloat &a, const APFloat &aa,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="codeLine">                                         const APFloat &c, const APFloat &cc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4598</td>
    <td class="codeLine">                                         const APFloat &c, const APFloat &cc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="codeLine">                                         roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4599</td>
    <td class="codeLine">                                         roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="codeLine">  int Status = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4600</td>
    <td class="codeLine">  int Status = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="codeLine">  APFloat z = a;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4601</td>
    <td class="codeLine">  APFloat z = a;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="codeLine">  Status |= z.add(c, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4602</td>
    <td class="codeLine">  Status |= z.add(c, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="codeLine">  if (!z.isFinite()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4603</td>
    <td class="codeLine">  if (!z.isFinite()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="codeLine">    if (!z.isInfinity()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4604</td>
    <td class="codeLine">    if (!z.isInfinity()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="codeLine">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4605</td>
    <td class="codeLine">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4606</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="codeLine">      return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4607</td>
    <td class="codeLine">      return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4608</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="codeLine">    Status = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4609</td>
    <td class="codeLine">    Status = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="codeLine">    auto AComparedToC = a.compareAbsoluteValue(c);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4610</td>
    <td class="codeLine">    auto AComparedToC = a.compareAbsoluteValue(c);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="codeLine">    z = cc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4611</td>
    <td class="codeLine">    z = cc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="codeLine">    Status |= z.add(aa, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4612</td>
    <td class="codeLine">    Status |= z.add(aa, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="codeLine">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4613</td>
    <td class="codeLine">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="codeLine">      // z = cc + aa + c + a;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4614</td>
    <td class="codeLine">      // z = cc + aa + c + a;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="codeLine">      Status |= z.add(c, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4615</td>
    <td class="codeLine">      Status |= z.add(c, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="codeLine">      Status |= z.add(a, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4616</td>
    <td class="codeLine">      Status |= z.add(a, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4617</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="codeLine">      // z = cc + aa + a + c;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4618</td>
    <td class="codeLine">      // z = cc + aa + a + c;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="codeLine">      Status |= z.add(a, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4619</td>
    <td class="codeLine">      Status |= z.add(a, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="codeLine">      Status |= z.add(c, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4620</td>
    <td class="codeLine">      Status |= z.add(c, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4621</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="codeLine">    if (!z.isFinite()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4622</td>
    <td class="codeLine">    if (!z.isFinite()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="codeLine">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4623</td>
    <td class="codeLine">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4624</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="codeLine">      return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4625</td>
    <td class="codeLine">      return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4626</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="codeLine">    Floats[0] = z;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4627</td>
    <td class="codeLine">    Floats[0] = z;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="codeLine">    APFloat zz = aa;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4628</td>
    <td class="codeLine">    APFloat zz = aa;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="codeLine">    Status |= zz.add(cc, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4629</td>
    <td class="codeLine">    Status |= zz.add(cc, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="codeLine">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4630</td>
    <td class="codeLine">    if (AComparedToC == APFloat::cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="codeLine">      // Floats[1] = a - z + c + zz;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4631</td>
    <td class="codeLine">      // Floats[1] = a - z + c + zz;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="codeLine">      Floats[1] = a;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4632</td>
    <td class="codeLine">      Floats[1] = a;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="codeLine">      Status |= Floats[1].subtract(z, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4633</td>
    <td class="codeLine">      Status |= Floats[1].subtract(z, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="codeLine">      Status |= Floats[1].add(c, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4634</td>
    <td class="codeLine">      Status |= Floats[1].add(c, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="codeLine">      Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4635</td>
    <td class="codeLine">      Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4636</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="codeLine">      // Floats[1] = c - z + a + zz;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4637</td>
    <td class="codeLine">      // Floats[1] = c - z + a + zz;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="codeLine">      Floats[1] = c;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4638</td>
    <td class="codeLine">      Floats[1] = c;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="codeLine">      Status |= Floats[1].subtract(z, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4639</td>
    <td class="codeLine">      Status |= Floats[1].subtract(z, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="codeLine">      Status |= Floats[1].add(a, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4640</td>
    <td class="codeLine">      Status |= Floats[1].add(a, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="codeLine">      Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4641</td>
    <td class="codeLine">      Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4642</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4643</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="codeLine">    // q = a - z;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4644</td>
    <td class="codeLine">    // q = a - z;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="codeLine">    APFloat q = a;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4645</td>
    <td class="codeLine">    APFloat q = a;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="codeLine">    Status |= q.subtract(z, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4646</td>
    <td class="codeLine">    Status |= q.subtract(z, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="codeLine">    // zz = q + c + (a - (q + z)) + aa + cc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4648</td>
    <td class="codeLine">    // zz = q + c + (a - (q + z)) + aa + cc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="codeLine">    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4649</td>
    <td class="codeLine">    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="codeLine">    auto zz = q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4650</td>
    <td class="codeLine">    auto zz = q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="codeLine">    Status |= zz.add(c, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4651</td>
    <td class="codeLine">    Status |= zz.add(c, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="codeLine">    Status |= q.add(z, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4652</td>
    <td class="codeLine">    Status |= q.add(z, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="codeLine">    Status |= q.subtract(a, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4653</td>
    <td class="codeLine">    Status |= q.subtract(a, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="codeLine">    q.changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4654</td>
    <td class="codeLine">    q.changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="codeLine">    Status |= zz.add(q, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4655</td>
    <td class="codeLine">    Status |= zz.add(q, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="codeLine">    Status |= zz.add(aa, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4656</td>
    <td class="codeLine">    Status |= zz.add(aa, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="codeLine">    Status |= zz.add(cc, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4657</td>
    <td class="codeLine">    Status |= zz.add(cc, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="codeLine">    if (zz.isZero() && !zz.isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4658</td>
    <td class="codeLine">    if (zz.isZero() && !zz.isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="codeLine">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4659</td>
    <td class="codeLine">      Floats[0] = std::move(z);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4660</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="codeLine">      return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4661</td>
    <td class="codeLine">      return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4662</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="codeLine">    Floats[0] = z;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4663</td>
    <td class="codeLine">    Floats[0] = z;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="codeLine">    Status |= Floats[0].add(zz, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4664</td>
    <td class="codeLine">    Status |= Floats[0].add(zz, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="codeLine">    if (!Floats[0].isFinite()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4665</td>
    <td class="codeLine">    if (!Floats[0].isFinite()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4666</td>
    <td class="codeLine">      Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="codeLine">      return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4667</td>
    <td class="codeLine">      return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4668</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="codeLine">    Floats[1] = std::move(z);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4669</td>
    <td class="codeLine">    Floats[1] = std::move(z);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="codeLine">    Status |= Floats[1].subtract(Floats[0], RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4670</td>
    <td class="codeLine">    Status |= Floats[1].subtract(Floats[0], RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="codeLine">    Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4671</td>
    <td class="codeLine">    Status |= Floats[1].add(zz, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="codeLine">  return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4673</td>
    <td class="codeLine">  return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::addWithSpecial(const DoubleAPFloat &LHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4676</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::addWithSpecial(const DoubleAPFloat &LHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="codeLine">                                                const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4677</td>
    <td class="codeLine">                                                const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="codeLine">                                                DoubleAPFloat &Out,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4678</td>
    <td class="codeLine">                                                DoubleAPFloat &Out,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="codeLine">                                                roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4679</td>
    <td class="codeLine">                                                roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="codeLine">  if (LHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4680</td>
    <td class="codeLine">  if (LHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4681</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4682</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4683</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="codeLine">  if (RHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4684</td>
    <td class="codeLine">  if (RHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4685</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4686</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4687</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="codeLine">  if (LHS.getCategory() == fcZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4688</td>
    <td class="codeLine">  if (LHS.getCategory() == fcZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4689</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4690</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4691</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="codeLine">  if (RHS.getCategory() == fcZero) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4692</td>
    <td class="codeLine">  if (RHS.getCategory() == fcZero) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4693</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4694</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="codeLine">  if (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcInfinity &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4696</td>
    <td class="codeLine">  if (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcInfinity &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="codeLine">      LHS.isNegative() != RHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4697</td>
    <td class="codeLine">      LHS.isNegative() != RHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="codeLine">    Out.makeNaN(false, Out.isNegative(), nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4698</td>
    <td class="codeLine">    Out.makeNaN(false, Out.isNegative(), nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4699</td>
    <td class="codeLine">    return opInvalidOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4700</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="codeLine">  if (LHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4701</td>
    <td class="codeLine">  if (LHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4702</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4703</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4704</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="codeLine">  if (RHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4705</td>
    <td class="codeLine">  if (RHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4706</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4707</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="codeLine">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4709</td>
    <td class="codeLine">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="codeLine">  APFloat A(LHS.Floats[0]), AA(LHS.Floats[1]), C(RHS.Floats[0]),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4711</td>
    <td class="codeLine">  APFloat A(LHS.Floats[0]), AA(LHS.Floats[1]), C(RHS.Floats[0]),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="codeLine">      CC(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4712</td>
    <td class="codeLine">      CC(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="codeLine">  assert(&A.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4713</td>
    <td class="codeLine">  assert(&A.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="codeLine">  assert(&AA.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4714</td>
    <td class="codeLine">  assert(&AA.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="codeLine">  assert(&C.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4715</td>
    <td class="codeLine">  assert(&C.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="codeLine">  assert(&CC.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4716</td>
    <td class="codeLine">  assert(&CC.getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="codeLine">  assert(&Out.Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4717</td>
    <td class="codeLine">  assert(&Out.Floats[0].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="codeLine">  assert(&Out.Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4718</td>
    <td class="codeLine">  assert(&Out.Floats[1].getSemantics() == &semIEEEdouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="codeLine">  return Out.addImpl(A, AA, C, CC, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4719</td>
    <td class="codeLine">  return Out.addImpl(A, AA, C, CC, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4720</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::add(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4722</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::add(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="codeLine">                                     roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4723</td>
    <td class="codeLine">                                     roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="codeLine">  return addWithSpecial(*this, RHS, *this, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4724</td>
    <td class="codeLine">  return addWithSpecial(*this, RHS, *this, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::subtract(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4727</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::subtract(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="codeLine">                                          roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4728</td>
    <td class="codeLine">                                          roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="codeLine">  changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4729</td>
    <td class="codeLine">  changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="codeLine">  auto Ret = add(RHS, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4730</td>
    <td class="codeLine">  auto Ret = add(RHS, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="codeLine">  changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4731</td>
    <td class="codeLine">  changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4732</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4733</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::multiply(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4735</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::multiply(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="codeLine">                                          APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4736</td>
    <td class="codeLine">                                          APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="codeLine">  const auto &LHS = *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4737</td>
    <td class="codeLine">  const auto &LHS = *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="codeLine">  auto &Out = *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4738</td>
    <td class="codeLine">  auto &Out = *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="codeLine">  /* Interesting observation: For special categories, finding the lowest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4739</td>
    <td class="codeLine">  /* Interesting observation: For special categories, finding the lowest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="codeLine">     common ancestor of the following layered graph gives the correct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4740</td>
    <td class="codeLine">     common ancestor of the following layered graph gives the correct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="codeLine">     return category:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4741</td>
    <td class="codeLine">     return category:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="codeLine">        NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4743</td>
    <td class="codeLine">        NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="codeLine">       /   \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4744</td>
    <td class="codeLine">       /   \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="codeLine">     Zero  Inf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4745</td>
    <td class="codeLine">     Zero  Inf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="codeLine">       \   /</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4746</td>
    <td class="codeLine">       \   /</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="codeLine">       Normal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4747</td>
    <td class="codeLine">       Normal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="codeLine">     e.g. NaN * NaN = NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4749</td>
    <td class="codeLine">     e.g. NaN * NaN = NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class="codeLine">          Zero * Inf = NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4750</td>
    <td class="codeLine">          Zero * Inf = NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="codeLine">          Normal * Zero = Zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4751</td>
    <td class="codeLine">          Normal * Zero = Zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="codeLine">          Normal * Inf = Inf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4752</td>
    <td class="codeLine">          Normal * Inf = Inf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="codeLine">  */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4753</td>
    <td class="codeLine">  */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="codeLine">  if (LHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4754</td>
    <td class="codeLine">  if (LHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4755</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4756</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="codeLine">  if (RHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4758</td>
    <td class="codeLine">  if (RHS.getCategory() == fcNaN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4759</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4760</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4761</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="codeLine">  if ((LHS.getCategory() == fcZero && RHS.getCategory() == fcInfinity) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4762</td>
    <td class="codeLine">  if ((LHS.getCategory() == fcZero && RHS.getCategory() == fcInfinity) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="codeLine">      (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcZero)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4763</td>
    <td class="codeLine">      (LHS.getCategory() == fcInfinity && RHS.getCategory() == fcZero)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="codeLine">    Out.makeNaN(false, false, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4764</td>
    <td class="codeLine">    Out.makeNaN(false, false, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4765</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4766</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="codeLine">  if (LHS.getCategory() == fcZero || LHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4767</td>
    <td class="codeLine">  if (LHS.getCategory() == fcZero || LHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4768</td>
    <td class="codeLine">    Out = LHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4769</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4770</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="codeLine">  if (RHS.getCategory() == fcZero || RHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4771</td>
    <td class="codeLine">  if (RHS.getCategory() == fcZero || RHS.getCategory() == fcInfinity) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4772</td>
    <td class="codeLine">    Out = RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4773</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="codeLine">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4775</td>
    <td class="codeLine">  assert(LHS.getCategory() == fcNormal && RHS.getCategory() == fcNormal &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="codeLine">         "Special cases not handled exhaustively");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4776</td>
    <td class="codeLine">         "Special cases not handled exhaustively");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="codeLine">  int Status = opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4778</td>
    <td class="codeLine">  int Status = opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="codeLine">  APFloat A = Floats[0], B = Floats[1], C = RHS.Floats[0], D = RHS.Floats[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4779</td>
    <td class="codeLine">  APFloat A = Floats[0], B = Floats[1], C = RHS.Floats[0], D = RHS.Floats[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="codeLine">  // t = a * c</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4780</td>
    <td class="codeLine">  // t = a * c</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="codeLine">  APFloat T = A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4781</td>
    <td class="codeLine">  APFloat T = A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="codeLine">  Status |= T.multiply(C, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4782</td>
    <td class="codeLine">  Status |= T.multiply(C, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="codeLine">  if (!T.isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4783</td>
    <td class="codeLine">  if (!T.isFiniteNonZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="codeLine">    Floats[0] = T;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4784</td>
    <td class="codeLine">    Floats[0] = T;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="codeLine">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4785</td>
    <td class="codeLine">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="codeLine">    return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4786</td>
    <td class="codeLine">    return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4787</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="codeLine">  // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4789</td>
    <td class="codeLine">  // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="codeLine">  APFloat Tau = A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4790</td>
    <td class="codeLine">  APFloat Tau = A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="codeLine">  T.changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4791</td>
    <td class="codeLine">  T.changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="codeLine">  Status |= Tau.fusedMultiplyAdd(C, T, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4792</td>
    <td class="codeLine">  Status |= Tau.fusedMultiplyAdd(C, T, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="codeLine">  T.changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4793</td>
    <td class="codeLine">  T.changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4794</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="codeLine">    // v = a * d</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4795</td>
    <td class="codeLine">    // v = a * d</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="codeLine">    APFloat V = A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4796</td>
    <td class="codeLine">    APFloat V = A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="codeLine">    Status |= V.multiply(D, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4797</td>
    <td class="codeLine">    Status |= V.multiply(D, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="codeLine">    // w = b * c</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4798</td>
    <td class="codeLine">    // w = b * c</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="codeLine">    APFloat W = B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4799</td>
    <td class="codeLine">    APFloat W = B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="codeLine">    Status |= W.multiply(C, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4800</td>
    <td class="codeLine">    Status |= W.multiply(C, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="codeLine">    Status |= V.add(W, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4801</td>
    <td class="codeLine">    Status |= V.add(W, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="codeLine">    // tau += v + w</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4802</td>
    <td class="codeLine">    // tau += v + w</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="codeLine">    Status |= Tau.add(V, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4803</td>
    <td class="codeLine">    Status |= Tau.add(V, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="codeLine">  // u = t + tau</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4805</td>
    <td class="codeLine">  // u = t + tau</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="codeLine">  APFloat U = T;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4806</td>
    <td class="codeLine">  APFloat U = T;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="codeLine">  Status |= U.add(Tau, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4807</td>
    <td class="codeLine">  Status |= U.add(Tau, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="codeLine">  Floats[0] = U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4809</td>
    <td class="codeLine">  Floats[0] = U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="codeLine">  if (!U.isFinite()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4810</td>
    <td class="codeLine">  if (!U.isFinite()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="codeLine">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4811</td>
    <td class="codeLine">    Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4812</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="codeLine">    // Floats[1] = (t - u) + tau</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4813</td>
    <td class="codeLine">    // Floats[1] = (t - u) + tau</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="codeLine">    Status |= T.subtract(U, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4814</td>
    <td class="codeLine">    Status |= T.subtract(U, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="codeLine">    Status |= T.add(Tau, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4815</td>
    <td class="codeLine">    Status |= T.add(Tau, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="codeLine">    Floats[1] = T;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4816</td>
    <td class="codeLine">    Floats[1] = T;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="codeLine">  return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4818</td>
    <td class="codeLine">  return (opStatus)Status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4819</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::divide(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4821</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::divide(const DoubleAPFloat &RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="codeLine">                                        APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4822</td>
    <td class="codeLine">                                        APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4823</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4824</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="codeLine">  auto Ret =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4825</td>
    <td class="codeLine">  auto Ret =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="codeLine">      Tmp.divide(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()), RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4826</td>
    <td class="codeLine">      Tmp.divide(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()), RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4827</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4828</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4829</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::remainder(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4831</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::remainder(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4832</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4833</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="codeLine">  auto Ret =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4834</td>
    <td class="codeLine">  auto Ret =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="codeLine">      Tmp.remainder(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4835</td>
    <td class="codeLine">      Tmp.remainder(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4836</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4837</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4838</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::mod(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4840</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::mod(const DoubleAPFloat &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4841</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4842</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="codeLine">  auto Ret = Tmp.mod(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4843</td>
    <td class="codeLine">  auto Ret = Tmp.mod(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4844</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4845</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4846</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4848</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="codeLine">DoubleAPFloat::fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4849</td>
    <td class="codeLine">DoubleAPFloat::fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="codeLine">                                const DoubleAPFloat &Addend,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4850</td>
    <td class="codeLine">                                const DoubleAPFloat &Addend,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="codeLine">                                APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4851</td>
    <td class="codeLine">                                APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4852</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4853</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="codeLine">  auto Ret = Tmp.fusedMultiplyAdd(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4854</td>
    <td class="codeLine">  auto Ret = Tmp.fusedMultiplyAdd(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="codeLine">      APFloat(semPPCDoubleDoubleLegacy, Multiplicand.bitcastToAPInt()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4855</td>
    <td class="codeLine">      APFloat(semPPCDoubleDoubleLegacy, Multiplicand.bitcastToAPInt()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="codeLine">      APFloat(semPPCDoubleDoubleLegacy, Addend.bitcastToAPInt()), RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4856</td>
    <td class="codeLine">      APFloat(semPPCDoubleDoubleLegacy, Addend.bitcastToAPInt()), RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4857</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4858</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::roundToIntegral(APFloat::roundingMode RM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4861</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::roundToIntegral(APFloat::roundingMode RM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4862</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4863</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="codeLine">  auto Ret = Tmp.roundToIntegral(RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4864</td>
    <td class="codeLine">  auto Ret = Tmp.roundToIntegral(RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4865</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4866</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4867</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="codeLine">void DoubleAPFloat::changeSign() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4869</td>
    <td class="codeLine">void DoubleAPFloat::changeSign() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="codeLine">  Floats[0].changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4870</td>
    <td class="codeLine">  Floats[0].changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="codeLine">  Floats[1].changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4871</td>
    <td class="codeLine">  Floats[1].changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4872</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="codeLine">APFloat::cmpResult</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4874</td>
    <td class="codeLine">APFloat::cmpResult</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="codeLine">DoubleAPFloat::compareAbsoluteValue(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4875</td>
    <td class="codeLine">DoubleAPFloat::compareAbsoluteValue(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="codeLine">  auto Result = Floats[0].compareAbsoluteValue(RHS.Floats[0]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4876</td>
    <td class="codeLine">  auto Result = Floats[0].compareAbsoluteValue(RHS.Floats[0]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="codeLine">  if (Result != cmpEqual)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4877</td>
    <td class="codeLine">  if (Result != cmpEqual)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4878</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="codeLine">  Result = Floats[1].compareAbsoluteValue(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4879</td>
    <td class="codeLine">  Result = Floats[1].compareAbsoluteValue(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="codeLine">  if (Result == cmpLessThan || Result == cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4880</td>
    <td class="codeLine">  if (Result == cmpLessThan || Result == cmpGreaterThan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="codeLine">    auto Against = Floats[0].isNegative() ^ Floats[1].isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4881</td>
    <td class="codeLine">    auto Against = Floats[0].isNegative() ^ Floats[1].isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="codeLine">    auto RHSAgainst = RHS.Floats[0].isNegative() ^ RHS.Floats[1].isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4882</td>
    <td class="codeLine">    auto RHSAgainst = RHS.Floats[0].isNegative() ^ RHS.Floats[1].isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="codeLine">    if (Against && !RHSAgainst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4883</td>
    <td class="codeLine">    if (Against && !RHSAgainst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4884</td>
    <td class="codeLine">      return cmpLessThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="codeLine">    if (!Against && RHSAgainst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4885</td>
    <td class="codeLine">    if (!Against && RHSAgainst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4886</td>
    <td class="codeLine">      return cmpGreaterThan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="codeLine">    if (!Against && !RHSAgainst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4887</td>
    <td class="codeLine">    if (!Against && !RHSAgainst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4888</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="codeLine">    if (Against && RHSAgainst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4889</td>
    <td class="codeLine">    if (Against && RHSAgainst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="codeLine">      return (cmpResult)(cmpLessThan + cmpGreaterThan - Result);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4890</td>
    <td class="codeLine">      return (cmpResult)(cmpLessThan + cmpGreaterThan - Result);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4891</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4892</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="codeLine">APFloat::fltCategory DoubleAPFloat::getCategory() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4895</td>
    <td class="codeLine">APFloat::fltCategory DoubleAPFloat::getCategory() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="codeLine">  return Floats[0].getCategory();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4896</td>
    <td class="codeLine">  return Floats[0].getCategory();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4897</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="codeLine">bool DoubleAPFloat::isNegative() const { return Floats[0].isNegative(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4899</td>
    <td class="codeLine">bool DoubleAPFloat::isNegative() const { return Floats[0].isNegative(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="codeLine">void DoubleAPFloat::makeInf(bool Neg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4901</td>
    <td class="codeLine">void DoubleAPFloat::makeInf(bool Neg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="codeLine">  Floats[0].makeInf(Neg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4902</td>
    <td class="codeLine">  Floats[0].makeInf(Neg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4903</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4904</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4905</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="codeLine">void DoubleAPFloat::makeZero(bool Neg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4906</td>
    <td class="codeLine">void DoubleAPFloat::makeZero(bool Neg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="codeLine">  Floats[0].makeZero(Neg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4907</td>
    <td class="codeLine">  Floats[0].makeZero(Neg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4908</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4909</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="codeLine">void DoubleAPFloat::makeLargest(bool Neg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4911</td>
    <td class="codeLine">void DoubleAPFloat::makeLargest(bool Neg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4912</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="codeLine">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x7fefffffffffffffull));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4913</td>
    <td class="codeLine">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x7fefffffffffffffull));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="codeLine">  Floats[1] = APFloat(semIEEEdouble, APInt(64, 0x7c8ffffffffffffeull));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4914</td>
    <td class="codeLine">  Floats[1] = APFloat(semIEEEdouble, APInt(64, 0x7c8ffffffffffffeull));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="codeLine">  if (Neg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4915</td>
    <td class="codeLine">  if (Neg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4916</td>
    <td class="codeLine">    changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4917</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="codeLine">void DoubleAPFloat::makeSmallest(bool Neg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4919</td>
    <td class="codeLine">void DoubleAPFloat::makeSmallest(bool Neg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4920</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="codeLine">  Floats[0].makeSmallest(Neg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4921</td>
    <td class="codeLine">  Floats[0].makeSmallest(Neg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4922</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4923</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="codeLine">void DoubleAPFloat::makeSmallestNormalized(bool Neg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4925</td>
    <td class="codeLine">void DoubleAPFloat::makeSmallestNormalized(bool Neg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4926</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="codeLine">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x0360000000000000ull));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4927</td>
    <td class="codeLine">  Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x0360000000000000ull));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="codeLine">  if (Neg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4928</td>
    <td class="codeLine">  if (Neg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="codeLine">    Floats[0].changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4929</td>
    <td class="codeLine">    Floats[0].changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4930</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="codeLine">void DoubleAPFloat::makeNaN(bool SNaN, bool Neg, const APInt *fill) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4933</td>
    <td class="codeLine">void DoubleAPFloat::makeNaN(bool SNaN, bool Neg, const APInt *fill) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="codeLine">  Floats[0].makeNaN(SNaN, Neg, fill);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4934</td>
    <td class="codeLine">  Floats[0].makeNaN(SNaN, Neg, fill);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4935</td>
    <td class="codeLine">  Floats[1].makeZero(/* Neg = */ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4936</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4937</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="codeLine">APFloat::cmpResult DoubleAPFloat::compare(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4938</td>
    <td class="codeLine">APFloat::cmpResult DoubleAPFloat::compare(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="codeLine">  auto Result = Floats[0].compare(RHS.Floats[0]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4939</td>
    <td class="codeLine">  auto Result = Floats[0].compare(RHS.Floats[0]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="codeLine">  // |Float[0]| > |Float[1]|</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4940</td>
    <td class="codeLine">  // |Float[0]| > |Float[1]|</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="codeLine">  if (Result == APFloat::cmpEqual)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4941</td>
    <td class="codeLine">  if (Result == APFloat::cmpEqual)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="codeLine">    return Floats[1].compare(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4942</td>
    <td class="codeLine">    return Floats[1].compare(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4943</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4944</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="codeLine">bool DoubleAPFloat::bitwiseIsEqual(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4946</td>
    <td class="codeLine">bool DoubleAPFloat::bitwiseIsEqual(const DoubleAPFloat &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="codeLine">  return Floats[0].bitwiseIsEqual(RHS.Floats[0]) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4947</td>
    <td class="codeLine">  return Floats[0].bitwiseIsEqual(RHS.Floats[0]) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="codeLine">         Floats[1].bitwiseIsEqual(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4948</td>
    <td class="codeLine">         Floats[1].bitwiseIsEqual(RHS.Floats[1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="codeLine">hash_code hash_value(const DoubleAPFloat &Arg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4951</td>
    <td class="codeLine">hash_code hash_value(const DoubleAPFloat &Arg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="codeLine">  if (Arg.Floats)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4952</td>
    <td class="codeLine">  if (Arg.Floats)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="codeLine">    return hash_combine(hash_value(Arg.Floats[0]), hash_value(Arg.Floats[1]));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4953</td>
    <td class="codeLine">    return hash_combine(hash_value(Arg.Floats[0]), hash_value(Arg.Floats[1]));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="codeLine">  return hash_combine(Arg.Semantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4954</td>
    <td class="codeLine">  return hash_combine(Arg.Semantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="codeLine">APInt DoubleAPFloat::bitcastToAPInt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4957</td>
    <td class="codeLine">APInt DoubleAPFloat::bitcastToAPInt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4958</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="codeLine">  uint64_t Data[] = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4959</td>
    <td class="codeLine">  uint64_t Data[] = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="codeLine">      Floats[0].bitcastToAPInt().getRawData()[0],</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4960</td>
    <td class="codeLine">      Floats[0].bitcastToAPInt().getRawData()[0],</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="codeLine">      Floats[1].bitcastToAPInt().getRawData()[0],</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4961</td>
    <td class="codeLine">      Floats[1].bitcastToAPInt().getRawData()[0],</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4962</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="codeLine">  return APInt(128, 2, Data);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4963</td>
    <td class="codeLine">  return APInt(128, 2, Data);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4964</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="codeLine">Expected<APFloat::opStatus> DoubleAPFloat::convertFromString(StringRef S,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4966</td>
    <td class="codeLine">Expected<APFloat::opStatus> DoubleAPFloat::convertFromString(StringRef S,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="codeLine">                                                             roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4967</td>
    <td class="codeLine">                                                             roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4968</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4969</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromString(S, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4970</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromString(S, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4971</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4972</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4973</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::next(bool nextDown) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4975</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::next(bool nextDown) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4976</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4977</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="codeLine">  auto Ret = Tmp.next(nextDown);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4978</td>
    <td class="codeLine">  auto Ret = Tmp.next(nextDown);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4979</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4980</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4981</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4983</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="codeLine">DoubleAPFloat::convertToInteger(MutableArrayRef<integerPart> Input,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4984</td>
    <td class="codeLine">DoubleAPFloat::convertToInteger(MutableArrayRef<integerPart> Input,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="codeLine">                                unsigned int Width, bool IsSigned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4985</td>
    <td class="codeLine">                                unsigned int Width, bool IsSigned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="codeLine">                                roundingMode RM, bool *IsExact) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4986</td>
    <td class="codeLine">                                roundingMode RM, bool *IsExact) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4987</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="codeLine">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4988</td>
    <td class="codeLine">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="codeLine">      .convertToInteger(Input, Width, IsSigned, RM, IsExact);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4989</td>
    <td class="codeLine">      .convertToInteger(Input, Width, IsSigned, RM, IsExact);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4990</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::convertFromAPInt(const APInt &Input,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4992</td>
    <td class="codeLine">APFloat::opStatus DoubleAPFloat::convertFromAPInt(const APInt &Input,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="codeLine">                                                  bool IsSigned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4993</td>
    <td class="codeLine">                                                  bool IsSigned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="codeLine">                                                  roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4994</td>
    <td class="codeLine">                                                  roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4995</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4996</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromAPInt(Input, IsSigned, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4997</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromAPInt(Input, IsSigned, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4998</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4999</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5000</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5002</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="codeLine">DoubleAPFloat::convertFromSignExtendedInteger(const integerPart *Input,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5003</td>
    <td class="codeLine">DoubleAPFloat::convertFromSignExtendedInteger(const integerPart *Input,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="codeLine">                                              unsigned int InputSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5004</td>
    <td class="codeLine">                                              unsigned int InputSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="codeLine">                                              bool IsSigned, roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5005</td>
    <td class="codeLine">                                              bool IsSigned, roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5006</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5007</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5008</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5009</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5010</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5011</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5013</td>
    <td class="codeLine">APFloat::opStatus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="codeLine">DoubleAPFloat::convertFromZeroExtendedInteger(const integerPart *Input,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5014</td>
    <td class="codeLine">DoubleAPFloat::convertFromZeroExtendedInteger(const integerPart *Input,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="codeLine">                                              unsigned int InputSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5015</td>
    <td class="codeLine">                                              unsigned int InputSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="codeLine">                                              bool IsSigned, roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5016</td>
    <td class="codeLine">                                              bool IsSigned, roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5017</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5018</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5019</td>
    <td class="codeLine">  auto Ret = Tmp.convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5020</td>
    <td class="codeLine">  *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5021</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="codeLine">unsigned int DoubleAPFloat::convertToHexString(char *DST,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5024</td>
    <td class="codeLine">unsigned int DoubleAPFloat::convertToHexString(char *DST,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class="codeLine">                                               unsigned int HexDigits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5025</td>
    <td class="codeLine">                                               unsigned int HexDigits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="codeLine">                                               bool UpperCase,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5026</td>
    <td class="codeLine">                                               bool UpperCase,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="codeLine">                                               roundingMode RM) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5027</td>
    <td class="codeLine">                                               roundingMode RM) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5028</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="codeLine">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5029</td>
    <td class="codeLine">  return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="codeLine">      .convertToHexString(DST, HexDigits, UpperCase, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5030</td>
    <td class="codeLine">      .convertToHexString(DST, HexDigits, UpperCase, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5031</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class="codeLine">bool DoubleAPFloat::isDenormal() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5033</td>
    <td class="codeLine">bool DoubleAPFloat::isDenormal() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="codeLine">  return getCategory() == fcNormal &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5034</td>
    <td class="codeLine">  return getCategory() == fcNormal &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="codeLine">         (Floats[0].isDenormal() || Floats[1].isDenormal() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5035</td>
    <td class="codeLine">         (Floats[0].isDenormal() || Floats[1].isDenormal() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="codeLine">          // (double)(Hi + Lo) == Hi defines a normal number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5036</td>
    <td class="codeLine">          // (double)(Hi + Lo) == Hi defines a normal number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="codeLine">          Floats[0] != Floats[0] + Floats[1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5037</td>
    <td class="codeLine">          Floats[0] != Floats[0] + Floats[1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5038</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="codeLine">bool DoubleAPFloat::isSmallest() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5040</td>
    <td class="codeLine">bool DoubleAPFloat::isSmallest() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="codeLine">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5041</td>
    <td class="codeLine">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5042</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="codeLine">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5043</td>
    <td class="codeLine">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="codeLine">  Tmp.makeSmallest(this->isNegative());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5044</td>
    <td class="codeLine">  Tmp.makeSmallest(this->isNegative());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="codeLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5045</td>
    <td class="codeLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5046</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="codeLine">bool DoubleAPFloat::isSmallestNormalized() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5048</td>
    <td class="codeLine">bool DoubleAPFloat::isSmallestNormalized() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="codeLine">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5049</td>
    <td class="codeLine">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5050</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="codeLine">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5052</td>
    <td class="codeLine">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="codeLine">  Tmp.makeSmallestNormalized(this->isNegative());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5053</td>
    <td class="codeLine">  Tmp.makeSmallestNormalized(this->isNegative());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="codeLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5054</td>
    <td class="codeLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5055</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5056</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="codeLine">bool DoubleAPFloat::isLargest() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5057</td>
    <td class="codeLine">bool DoubleAPFloat::isLargest() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="codeLine">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5058</td>
    <td class="codeLine">  if (getCategory() != fcNormal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5059</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="codeLine">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5060</td>
    <td class="codeLine">  DoubleAPFloat Tmp(*this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="codeLine">  Tmp.makeLargest(this->isNegative());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5061</td>
    <td class="codeLine">  Tmp.makeLargest(this->isNegative());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="codeLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5062</td>
    <td class="codeLine">  return Tmp.compare(*this) == cmpEqual;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5063</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="codeLine">bool DoubleAPFloat::isInteger() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5065</td>
    <td class="codeLine">bool DoubleAPFloat::isInteger() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5066</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="codeLine">  return Floats[0].isInteger() && Floats[1].isInteger();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5067</td>
    <td class="codeLine">  return Floats[0].isInteger() && Floats[1].isInteger();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5068</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="codeLine">void DoubleAPFloat::toString(SmallVectorImpl<char> &Str,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5070</td>
    <td class="codeLine">void DoubleAPFloat::toString(SmallVectorImpl<char> &Str,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="codeLine">                             unsigned FormatPrecision,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5071</td>
    <td class="codeLine">                             unsigned FormatPrecision,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="codeLine">                             unsigned FormatMaxPadding,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5072</td>
    <td class="codeLine">                             unsigned FormatMaxPadding,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="codeLine">                             bool TruncateZero) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5073</td>
    <td class="codeLine">                             bool TruncateZero) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5074</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="codeLine">  APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5075</td>
    <td class="codeLine">  APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="codeLine">      .toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5076</td>
    <td class="codeLine">      .toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="codeLine">bool DoubleAPFloat::getExactInverse(APFloat *inv) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5079</td>
    <td class="codeLine">bool DoubleAPFloat::getExactInverse(APFloat *inv) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5080</td>
    <td class="codeLine">  assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5081</td>
    <td class="codeLine">  APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="codeLine">  if (!inv)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5082</td>
    <td class="codeLine">  if (!inv)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="codeLine">    return Tmp.getExactInverse(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5083</td>
    <td class="codeLine">    return Tmp.getExactInverse(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="codeLine">  APFloat Inv(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5084</td>
    <td class="codeLine">  APFloat Inv(semPPCDoubleDoubleLegacy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="codeLine">  auto Ret = Tmp.getExactInverse(&Inv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5085</td>
    <td class="codeLine">  auto Ret = Tmp.getExactInverse(&Inv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="codeLine">  *inv = APFloat(semPPCDoubleDouble, Inv.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5086</td>
    <td class="codeLine">  *inv = APFloat(semPPCDoubleDouble, Inv.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5087</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5088</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="codeLine">DoubleAPFloat scalbn(const DoubleAPFloat &Arg, int Exp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5090</td>
    <td class="codeLine">DoubleAPFloat scalbn(const DoubleAPFloat &Arg, int Exp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="codeLine">                     APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5091</td>
    <td class="codeLine">                     APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="codeLine">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5092</td>
    <td class="codeLine">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="codeLine">  return DoubleAPFloat(semPPCDoubleDouble, scalbn(Arg.Floats[0], Exp, RM),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5093</td>
    <td class="codeLine">  return DoubleAPFloat(semPPCDoubleDouble, scalbn(Arg.Floats[0], Exp, RM),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="codeLine">                       scalbn(Arg.Floats[1], Exp, RM));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5094</td>
    <td class="codeLine">                       scalbn(Arg.Floats[1], Exp, RM));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5095</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="codeLine">DoubleAPFloat frexp(const DoubleAPFloat &Arg, int &Exp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5097</td>
    <td class="codeLine">DoubleAPFloat frexp(const DoubleAPFloat &Arg, int &Exp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="codeLine">                    APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5098</td>
    <td class="codeLine">                    APFloat::roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="codeLine">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5099</td>
    <td class="codeLine">  assert(Arg.Semantics == &semPPCDoubleDouble && "Unexpected Semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="codeLine">  APFloat First = frexp(Arg.Floats[0], Exp, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5100</td>
    <td class="codeLine">  APFloat First = frexp(Arg.Floats[0], Exp, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="codeLine">  APFloat Second = Arg.Floats[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5101</td>
    <td class="codeLine">  APFloat Second = Arg.Floats[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="codeLine">  if (Arg.getCategory() == APFloat::fcNormal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5102</td>
    <td class="codeLine">  if (Arg.getCategory() == APFloat::fcNormal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="codeLine">    Second = scalbn(Second, -Exp, RM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5103</td>
    <td class="codeLine">    Second = scalbn(Second, -Exp, RM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="codeLine">  return DoubleAPFloat(semPPCDoubleDouble, std::move(First), std::move(Second));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5104</td>
    <td class="codeLine">  return DoubleAPFloat(semPPCDoubleDouble, std::move(First), std::move(Second));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5105</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5107</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="codeLine coveredLine">APFloat::Storage::Storage(IEEEFloat F, const fltSemantics &Semantics) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">5109</td>
    <td class="codeLine coveredLine">APFloat::Storage::Storage(IEEEFloat F, const fltSemantics &Semantics) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="codeLine coveredLine">  if (usesLayout<IEEEFloat>(Semantics)) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">5110</td>
    <td class="codeLine coveredLine">  if (usesLayout<IEEEFloat>(Semantics)) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="codeLine coveredLine">    new (&IEEE) IEEEFloat(std::move(F));</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">5111</td>
    <td class="codeLine coveredLine">    new (&IEEE) IEEEFloat(std::move(F));</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">5112</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5113</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class="codeLine">  if (usesLayout<DoubleAPFloat>(Semantics)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5114</td>
    <td class="codeLine">  if (usesLayout<DoubleAPFloat>(Semantics)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="codeLine">    const fltSemantics& S = F.getSemantics();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5115</td>
    <td class="codeLine">    const fltSemantics& S = F.getSemantics();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="codeLine">    new (&Double)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5116</td>
    <td class="codeLine">    new (&Double)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="codeLine">        DoubleAPFloat(Semantics, APFloat(std::move(F), S),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5117</td>
    <td class="codeLine">        DoubleAPFloat(Semantics, APFloat(std::move(F), S),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="codeLine">                      APFloat(semIEEEdouble));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5118</td>
    <td class="codeLine">                      APFloat(semIEEEdouble));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5119</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5120</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="codeLine">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5121</td>
    <td class="codeLine">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5122</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="codeLine">Expected<APFloat::opStatus> APFloat::convertFromString(StringRef Str,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5124</td>
    <td class="codeLine">Expected<APFloat::opStatus> APFloat::convertFromString(StringRef Str,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="codeLine">                                                       roundingMode RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5125</td>
    <td class="codeLine">                                                       roundingMode RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="codeLine">  APFLOAT_DISPATCH_ON_SEMANTICS(convertFromString(Str, RM));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5126</td>
    <td class="codeLine">  APFLOAT_DISPATCH_ON_SEMANTICS(convertFromString(Str, RM));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5127</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="codeLine">hash_code hash_value(const APFloat &Arg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5129</td>
    <td class="codeLine">hash_code hash_value(const APFloat &Arg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="codeLine">  if (APFloat::usesLayout<detail::IEEEFloat>(Arg.getSemantics()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5130</td>
    <td class="codeLine">  if (APFloat::usesLayout<detail::IEEEFloat>(Arg.getSemantics()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="codeLine">    return hash_value(Arg.U.IEEE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5131</td>
    <td class="codeLine">    return hash_value(Arg.U.IEEE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="codeLine">  if (APFloat::usesLayout<detail::DoubleAPFloat>(Arg.getSemantics()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5132</td>
    <td class="codeLine">  if (APFloat::usesLayout<detail::DoubleAPFloat>(Arg.getSemantics()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="codeLine">    return hash_value(Arg.U.Double);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5133</td>
    <td class="codeLine">    return hash_value(Arg.U.Double);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="codeLine">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5134</td>
    <td class="codeLine">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5135</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="codeLine">APFloat::APFloat(const fltSemantics &Semantics, StringRef S)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5137</td>
    <td class="codeLine">APFloat::APFloat(const fltSemantics &Semantics, StringRef S)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="codeLine">    : APFloat(Semantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5138</td>
    <td class="codeLine">    : APFloat(Semantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="codeLine">  auto StatusOrErr = convertFromString(S, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5139</td>
    <td class="codeLine">  auto StatusOrErr = convertFromString(S, rmNearestTiesToEven);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="codeLine">  assert(StatusOrErr && "Invalid floating point representation");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5140</td>
    <td class="codeLine">  assert(StatusOrErr && "Invalid floating point representation");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="codeLine">  consumeError(StatusOrErr.takeError());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5141</td>
    <td class="codeLine">  consumeError(StatusOrErr.takeError());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5142</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="codeLine">FPClassTest APFloat::classify() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5144</td>
    <td class="codeLine">FPClassTest APFloat::classify() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class="codeLine">  if (isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5145</td>
    <td class="codeLine">  if (isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="codeLine">    return isNegative() ? fcNegZero : fcPosZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5146</td>
    <td class="codeLine">    return isNegative() ? fcNegZero : fcPosZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="codeLine">  if (isNormal())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5147</td>
    <td class="codeLine">  if (isNormal())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="codeLine">    return isNegative() ? fcNegNormal : fcPosNormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5148</td>
    <td class="codeLine">    return isNegative() ? fcNegNormal : fcPosNormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="codeLine">  if (isDenormal())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5149</td>
    <td class="codeLine">  if (isDenormal())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="codeLine">    return isNegative() ? fcNegSubnormal : fcPosSubnormal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5150</td>
    <td class="codeLine">    return isNegative() ? fcNegSubnormal : fcPosSubnormal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="codeLine">  if (isInfinity())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5151</td>
    <td class="codeLine">  if (isInfinity())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="codeLine">    return isNegative() ? fcNegInf : fcPosInf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5152</td>
    <td class="codeLine">    return isNegative() ? fcNegInf : fcPosInf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="codeLine">  assert(isNaN() && "Other class of FP constant");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5153</td>
    <td class="codeLine">  assert(isNaN() && "Other class of FP constant");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="codeLine">  return isSignaling() ? fcSNan : fcQNan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5154</td>
    <td class="codeLine">  return isSignaling() ? fcSNan : fcQNan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5155</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="codeLine">APFloat::opStatus APFloat::convert(const fltSemantics &ToSemantics,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5157</td>
    <td class="codeLine">APFloat::opStatus APFloat::convert(const fltSemantics &ToSemantics,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="codeLine">                                   roundingMode RM, bool *losesInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5158</td>
    <td class="codeLine">                                   roundingMode RM, bool *losesInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="codeLine">  if (&getSemantics() == &ToSemantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5159</td>
    <td class="codeLine">  if (&getSemantics() == &ToSemantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="codeLine">    *losesInfo = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5160</td>
    <td class="codeLine">    *losesInfo = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5161</td>
    <td class="codeLine">    return opOK;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5162</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class="codeLine">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5163</td>
    <td class="codeLine">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="codeLine">      usesLayout<IEEEFloat>(ToSemantics))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5164</td>
    <td class="codeLine">      usesLayout<IEEEFloat>(ToSemantics))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="codeLine">    return U.IEEE.convert(ToSemantics, RM, losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5165</td>
    <td class="codeLine">    return U.IEEE.convert(ToSemantics, RM, losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="codeLine">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5166</td>
    <td class="codeLine">  if (usesLayout<IEEEFloat>(getSemantics()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="codeLine">      usesLayout<DoubleAPFloat>(ToSemantics)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5167</td>
    <td class="codeLine">      usesLayout<DoubleAPFloat>(ToSemantics)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="codeLine">    assert(&ToSemantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5168</td>
    <td class="codeLine">    assert(&ToSemantics == &semPPCDoubleDouble);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="codeLine">    auto Ret = U.IEEE.convert(semPPCDoubleDoubleLegacy, RM, losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5169</td>
    <td class="codeLine">    auto Ret = U.IEEE.convert(semPPCDoubleDoubleLegacy, RM, losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="codeLine">    *this = APFloat(ToSemantics, U.IEEE.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5170</td>
    <td class="codeLine">    *this = APFloat(ToSemantics, U.IEEE.bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class="codeLine">    return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5171</td>
    <td class="codeLine">    return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="codeLine">  if (usesLayout<DoubleAPFloat>(getSemantics()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5173</td>
    <td class="codeLine">  if (usesLayout<DoubleAPFloat>(getSemantics()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="codeLine">      usesLayout<IEEEFloat>(ToSemantics)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5174</td>
    <td class="codeLine">      usesLayout<IEEEFloat>(ToSemantics)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class="codeLine">    auto Ret = getIEEE().convert(ToSemantics, RM, losesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5175</td>
    <td class="codeLine">    auto Ret = getIEEE().convert(ToSemantics, RM, losesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="codeLine">    *this = APFloat(std::move(getIEEE()), ToSemantics);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5176</td>
    <td class="codeLine">    *this = APFloat(std::move(getIEEE()), ToSemantics);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="codeLine">    return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5177</td>
    <td class="codeLine">    return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="codeLine">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5179</td>
    <td class="codeLine">  llvm_unreachable("Unexpected semantics");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="codeLine">APFloat APFloat::getAllOnesValue(const fltSemantics &Semantics) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5182</td>
    <td class="codeLine">APFloat APFloat::getAllOnesValue(const fltSemantics &Semantics) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="codeLine">  return APFloat(Semantics, APInt::getAllOnes(Semantics.sizeInBits));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5183</td>
    <td class="codeLine">  return APFloat(Semantics, APInt::getAllOnes(Semantics.sizeInBits));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="codeLine">void APFloat::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5186</td>
    <td class="codeLine">void APFloat::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="codeLine">  SmallVector<char, 16> Buffer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5187</td>
    <td class="codeLine">  SmallVector<char, 16> Buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="codeLine">  toString(Buffer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5188</td>
    <td class="codeLine">  toString(Buffer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="codeLine">  OS << Buffer << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5189</td>
    <td class="codeLine">  OS << Buffer << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5190</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5192</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="codeLine">LLVM_DUMP_METHOD void APFloat::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5193</td>
    <td class="codeLine">LLVM_DUMP_METHOD void APFloat::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5194</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="codeLine">void APFloat::Profile(FoldingSetNodeID &NID) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5196</td>
    <td class="codeLine">void APFloat::Profile(FoldingSetNodeID &NID) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="codeLine">  NID.Add(bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5197</td>
    <td class="codeLine">  NID.Add(bitcastToAPInt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5198</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="codeLine">/* Same as convertToInteger(integerPart*, ...), except the result is returned in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5200</td>
    <td class="codeLine">/* Same as convertToInteger(integerPart*, ...), except the result is returned in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="codeLine">   an APSInt, whose initial bit-width and signed-ness are used to determine the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5201</td>
    <td class="codeLine">   an APSInt, whose initial bit-width and signed-ness are used to determine the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="codeLine">   precision of the conversion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5202</td>
    <td class="codeLine">   precision of the conversion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="codeLine"> */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5203</td>
    <td class="codeLine"> */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="codeLine">APFloat::opStatus APFloat::convertToInteger(APSInt &result,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5204</td>
    <td class="codeLine">APFloat::opStatus APFloat::convertToInteger(APSInt &result,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class="codeLine">                                            roundingMode rounding_mode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5205</td>
    <td class="codeLine">                                            roundingMode rounding_mode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5206</td>
    <td class="codeLine">                                            bool *isExact) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5206</td>
    <td class="codeLine">                                            bool *isExact) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5207</td>
    <td class="codeLine">  unsigned bitWidth = result.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5207</td>
    <td class="codeLine">  unsigned bitWidth = result.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5208</td>
    <td class="codeLine">  SmallVector<uint64_t, 4> parts(result.getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5208</td>
    <td class="codeLine">  SmallVector<uint64_t, 4> parts(result.getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5209</td>
    <td class="codeLine">  opStatus status = convertToInteger(parts, bitWidth, result.isSigned(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5209</td>
    <td class="codeLine">  opStatus status = convertToInteger(parts, bitWidth, result.isSigned(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5210</td>
    <td class="codeLine">                                     rounding_mode, isExact);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5210</td>
    <td class="codeLine">                                     rounding_mode, isExact);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5211</td>
    <td class="codeLine">  // Keeps the original signed-ness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5211</td>
    <td class="codeLine">  // Keeps the original signed-ness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5212</td>
    <td class="codeLine">  result = APInt(bitWidth, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5212</td>
    <td class="codeLine">  result = APInt(bitWidth, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5213</td>
    <td class="codeLine">  return status;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5213</td>
    <td class="codeLine">  return status;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5214</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5214</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5216</td>
    <td class="codeLine">double APFloat::convertToDouble() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5216</td>
    <td class="codeLine">double APFloat::convertToDouble() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5217</td>
    <td class="codeLine">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEdouble)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5217</td>
    <td class="codeLine">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEdouble)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5218</td>
    <td class="codeLine">    return getIEEE().convertToDouble();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5218</td>
    <td class="codeLine">    return getIEEE().convertToDouble();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5219</td>
    <td class="codeLine">  assert(getSemantics().isRepresentableBy(semIEEEdouble) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5219</td>
    <td class="codeLine">  assert(getSemantics().isRepresentableBy(semIEEEdouble) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5220</td>
    <td class="codeLine">         "Float semantics is not representable by IEEEdouble");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5220</td>
    <td class="codeLine">         "Float semantics is not representable by IEEEdouble");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5221</td>
    <td class="codeLine">  APFloat Temp = *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5221</td>
    <td class="codeLine">  APFloat Temp = *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5222</td>
    <td class="codeLine">  bool LosesInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5222</td>
    <td class="codeLine">  bool LosesInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5223</td>
    <td class="codeLine">  opStatus St = Temp.convert(semIEEEdouble, rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5223</td>
    <td class="codeLine">  opStatus St = Temp.convert(semIEEEdouble, rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5224</td>
    <td class="codeLine">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5224</td>
    <td class="codeLine">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5225</td>
    <td class="codeLine">  (void)St;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5225</td>
    <td class="codeLine">  (void)St;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5226</td>
    <td class="codeLine">  return Temp.getIEEE().convertToDouble();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5226</td>
    <td class="codeLine">  return Temp.getIEEE().convertToDouble();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5227</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5227</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5229</td>
    <td class="codeLine">float APFloat::convertToFloat() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5229</td>
    <td class="codeLine">float APFloat::convertToFloat() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5230</td>
    <td class="codeLine">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEsingle)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5230</td>
    <td class="codeLine">  if (&getSemantics() == (const llvm::fltSemantics *)&semIEEEsingle)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5231</td>
    <td class="codeLine">    return getIEEE().convertToFloat();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5231</td>
    <td class="codeLine">    return getIEEE().convertToFloat();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5232</td>
    <td class="codeLine">  assert(getSemantics().isRepresentableBy(semIEEEsingle) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5232</td>
    <td class="codeLine">  assert(getSemantics().isRepresentableBy(semIEEEsingle) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5233</td>
    <td class="codeLine">         "Float semantics is not representable by IEEEsingle");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5233</td>
    <td class="codeLine">         "Float semantics is not representable by IEEEsingle");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5234</td>
    <td class="codeLine">  APFloat Temp = *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5234</td>
    <td class="codeLine">  APFloat Temp = *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5235</td>
    <td class="codeLine">  bool LosesInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5235</td>
    <td class="codeLine">  bool LosesInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5236</td>
    <td class="codeLine">  opStatus St = Temp.convert(semIEEEsingle, rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5236</td>
    <td class="codeLine">  opStatus St = Temp.convert(semIEEEsingle, rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5237</td>
    <td class="codeLine">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5237</td>
    <td class="codeLine">  assert(!(St & opInexact) && !LosesInfo && "Unexpected imprecision");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5238</td>
    <td class="codeLine">  (void)St;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5238</td>
    <td class="codeLine">  (void)St;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5239</td>
    <td class="codeLine">  return Temp.getIEEE().convertToFloat();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5239</td>
    <td class="codeLine">  return Temp.getIEEE().convertToFloat();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5240</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5240</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5242</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5242</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5244</td>
    <td class="codeLine">#undef APFLOAT_DISPATCH_ON_SEMANTICS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5244</td>
    <td class="codeLine">#undef APFLOAT_DISPATCH_ON_SEMANTICS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>