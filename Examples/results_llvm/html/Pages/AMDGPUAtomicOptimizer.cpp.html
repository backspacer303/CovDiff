<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AMDGPUAtomicOptimizer.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- AMDGPUAtomicOptimizer.cpp -----------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// This pass optimizes atomic operations by using a single lane of a wavefront</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// to perform the atomic operation, thus reducing contention on that memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">/// location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">/// Atomic optimizer uses following strategies to compute scan and reduced</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">/// values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">/// 1. DPP -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">///   This is the most efficient implementation for scan. DPP uses Whole Wave</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">///   Mode (WWM)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">/// 2. Iterative -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">//    An alternative implementation iterates over all active lanes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">///   of Wavefront using llvm.cttz and performs scan  using readlane & writelane</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">///   intrinsics</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "AMDGPU.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "GCNSubtarget.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/IR/InstVisitor.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/Target/TargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#define DEBUG_TYPE "amdgpu-atomic-optimizer"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">using namespace llvm::AMDGPU;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">struct ReplacementInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">  Instruction *I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">  AtomicRMWInst::BinOp Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">  unsigned ValIdx;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">  bool ValDivergent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">class AMDGPUAtomicOptimizer : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">  ScanOptions ScanImpl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="uncoveredLine">  AMDGPUAtomicOptimizer(ScanOptions ScanImpl)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="uncoveredLine">      : FunctionPass(ID), ScanImpl(ScanImpl) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">  bool runOnFunction(Function &F) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="uncoveredLine">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="uncoveredLine">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="uncoveredLine">    AU.addRequired<TargetPassConfig>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">class AMDGPUAtomicOptimizerImpl</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">    : public InstVisitor<AMDGPUAtomicOptimizerImpl> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">  SmallVector<ReplacementInfo, 8> ToReplace;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">  const UniformityInfo *UA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">  const DataLayout *DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">  DomTreeUpdater &DTU;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">  const GCNSubtarget *ST;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">  bool IsPixelShader;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">  ScanOptions ScanImpl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">  Value *buildReduction(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">                        Value *const Identity) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  Value *buildScan(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">                   Value *const Identity) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  Value *buildShiftRight(IRBuilder<> &B, Value *V, Value *const Identity) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">  std::pair<Value *, Value *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  buildScanIteratively(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">                       Value *const Identity, Value *V, Instruction &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">                       BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  void optimizeAtomic(Instruction &I, AtomicRMWInst::BinOp Op, unsigned ValIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">                      bool ValDivergent) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  AMDGPUAtomicOptimizerImpl() = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="uncoveredLine">  AMDGPUAtomicOptimizerImpl(const UniformityInfo *UA, const DataLayout *DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">                            DomTreeUpdater &DTU, const GCNSubtarget *ST,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">                            bool IsPixelShader, ScanOptions ScanImpl)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="uncoveredLine">      : UA(UA), DL(DL), DTU(DTU), ST(ST), IsPixelShader(IsPixelShader),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="uncoveredLine">        ScanImpl(ScanImpl) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  bool run(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  void visitAtomicRMWInst(AtomicRMWInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  void visitIntrinsicInst(IntrinsicInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">char AMDGPUAtomicOptimizer::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">char &llvm::AMDGPUAtomicOptimizerID = AMDGPUAtomicOptimizer::ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="uncoveredLine">bool AMDGPUAtomicOptimizer::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">  if (skipFunction(F)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  const UniformityInfo *UA =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="uncoveredLine">      &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="uncoveredLine">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  DominatorTreeWrapperPass *const DTW =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">      getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">  DomTreeUpdater DTU(DTW ? &DTW->getDomTree() : nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="uncoveredLine">  const TargetPassConfig &TPC = getAnalysis<TargetPassConfig>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="uncoveredLine">  const TargetMachine &TM = TPC.getTM<TargetMachine>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="uncoveredLine">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">  return AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="uncoveredLine">      .run(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">PreservedAnalyses AMDGPUAtomicOptimizerPass::run(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">                                                 FunctionAnalysisManager &AM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="uncoveredLine">  const auto *UA = &AM.getResult<UniformityInfoAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="uncoveredLine">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">  DomTreeUpdater DTU(&AM.getResult<DominatorTreeAnalysis>(F),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="uncoveredLine">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="uncoveredLine">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">  bool IsChanged =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="uncoveredLine">      AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">          .run(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">  if (!IsChanged) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="uncoveredLine">    return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">  PreservedAnalyses PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">  return PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="uncoveredLine">bool AMDGPUAtomicOptimizerImpl::run(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  // Scan option None disables the Pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">  if (ScanImpl == ScanOptions::None) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">  visit(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">  const bool Changed = !ToReplace.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">  for (ReplacementInfo &Info : ToReplace) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">    optimizeAtomic(*Info.I, Info.Op, Info.ValIdx, Info.ValDivergent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">  ToReplace.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">void AMDGPUAtomicOptimizerImpl::visitAtomicRMWInst(AtomicRMWInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  // Early exit for unhandled address space atomic instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">  switch (I.getPointerAddressSpace()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">  case AMDGPUAS::GLOBAL_ADDRESS:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">  case AMDGPUAS::LOCAL_ADDRESS:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  AtomicRMWInst::BinOp Op = I.getOperation();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">  switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  case AtomicRMWInst::Sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  case AtomicRMWInst::And:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">  case AtomicRMWInst::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">  case AtomicRMWInst::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  case AtomicRMWInst::Max:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  case AtomicRMWInst::Min:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">  case AtomicRMWInst::UMax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  case AtomicRMWInst::UMin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">  const unsigned PtrIdx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">  const unsigned ValIdx = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  // If the pointer operand is divergent, then each lane is doing an atomic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">  // operation on a different address, and we cannot optimize that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">  if (UA->isDivergentUse(I.getOperandUse(PtrIdx))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  // If the value operand is divergent, each lane is contributing a different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  // bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="uncoveredLine">  if (ValDivergent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  // remember the instruction so we can come back to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  ToReplace.push_back(Info);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">void AMDGPUAtomicOptimizerImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  AtomicRMWInst::BinOp Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">  switch (I.getIntrinsicID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::Add;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_sub:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::Sub;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_and:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_and:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_and:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_and:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_and:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::And;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_or:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::Or;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_xor:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::Xor;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_smin:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_smin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_smin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::Min;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_umin:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_umin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_umin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::UMin;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_smax:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_smax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_smax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::Max;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">  case Intrinsic::amdgcn_buffer_atomic_umax:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  case Intrinsic::amdgcn_struct_buffer_atomic_umax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  case Intrinsic::amdgcn_raw_buffer_atomic_umax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">    Op = AtomicRMWInst::UMax;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">  const unsigned ValIdx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  // If the value operand is divergent, each lane is contributing a different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  // bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="uncoveredLine">  if (ValDivergent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">  // If any of the other arguments to the intrinsic are divergent, we can't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">  // optimize the operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">  for (unsigned Idx = 1; Idx < I.getNumOperands(); Idx++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">    if (UA->isDivergentUse(I.getOperandUse(Idx))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  // remember the instruction so we can come back to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">  ToReplace.push_back(Info);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">// Use the builder to create the non-atomic counterpart of the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">// atomicrmw binary op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">static Value *buildNonAtomicBinOp(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">                                  Value *LHS, Value *RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">  CmpInst::Predicate Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">  switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">    llvm_unreachable("Unhandled atomic op");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">    return B.CreateBinOp(Instruction::Add, LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Sub:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">    return B.CreateBinOp(Instruction::Sub, LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">  case AtomicRMWInst::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">    return B.CreateBinOp(Instruction::And, LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Or:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">    return B.CreateBinOp(Instruction::Or, LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Xor:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">    return B.CreateBinOp(Instruction::Xor, LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Max:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">    Pred = CmpInst::ICMP_SGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Min:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">    Pred = CmpInst::ICMP_SLT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">  case AtomicRMWInst::UMax:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">    Pred = CmpInst::ICMP_UGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">  case AtomicRMWInst::UMin:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">    Pred = CmpInst::ICMP_ULT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">  Value *Cond = B.CreateICmp(Pred, LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">  return B.CreateSelect(Cond, LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">// Use the builder to create a reduction of V across the wavefront, with all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">// lanes active, returning the same result in all lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">Value *AMDGPUAtomicOptimizerImpl::buildReduction(IRBuilder<> &B,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">                                                 AtomicRMWInst::BinOp Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">                                                 Value *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">                                                 Value *const Identity) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">  Type *const Ty = V->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">  Function *UpdateDPP =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  // Reduce within each row of 16 lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    V = buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">        B, Op, V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">        B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">                     {Identity, V, B.getInt32(DPP::ROW_XMASK0 | 1 << Idx),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  // Reduce within each pair of rows (i.e. 32 lanes).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">  assert(ST->hasPermLaneX16());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">  V = buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">      B, Op, V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">      B.CreateIntrinsic(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">          Intrinsic::amdgcn_permlanex16, {},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">          {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">  if (ST->isWave32())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">  if (ST->hasPermLane64()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">    // Reduce across the upper and lower 32 lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    return buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">        B, Op, V, B.CreateIntrinsic(Intrinsic::amdgcn_permlane64, {}, V));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  // Pick an arbitrary lane from 0..31 and an arbitrary lane from 32..63 and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  // combine them with a scalar operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  Function *ReadLane =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">  Value *const Lane0 = B.CreateCall(ReadLane, {V, B.getInt32(0)});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">  Value *const Lane32 = B.CreateCall(ReadLane, {V, B.getInt32(32)});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">  return buildNonAtomicBinOp(B, Op, Lane0, Lane32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">// Use the builder to create an inclusive scan of V across the wavefront, with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">// all lanes active.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">Value *AMDGPUAtomicOptimizerImpl::buildScan(IRBuilder<> &B,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">                                            AtomicRMWInst::BinOp Op, Value *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">                                            Value *const Identity) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">  Type *const Ty = V->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  Function *UpdateDPP =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">    V = buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">        B, Op, V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">        B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 | 1 << Idx),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="uncoveredLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">  if (ST->hasDPPBroadcasts()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">    // GFX9 has DPP row broadcast operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">    V = buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">        B, Op, V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">        B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">                     {Identity, V, B.getInt32(DPP::BCAST15), B.getInt32(0xa),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">    V = buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">        B, Op, V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">        B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">                     {Identity, V, B.getInt32(DPP::BCAST31), B.getInt32(0xc),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">    // row operations we have to use permlane or readlane.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">    // Combine lane 15 into lanes 16..31 (and, for wave 64, lane 47 into lanes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">    // 48..63).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">    assert(ST->hasPermLaneX16());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">    Value *const PermX = B.CreateIntrinsic(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">        Intrinsic::amdgcn_permlanex16, {},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">        {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">    V = buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">        B, Op, V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">        B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">                     {Identity, PermX, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">                      B.getInt32(0xa), B.getInt32(0xf), B.getFalse()}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">    if (!ST->isWave32()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">      // Combine lane 31 into lanes 32..63.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">      Value *const Lane31 = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">                                              {V, B.getInt32(31)});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">      V = buildNonAtomicBinOp(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">          B, Op, V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">          B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">                       {Identity, Lane31, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">                        B.getInt32(0xc), B.getInt32(0xf), B.getFalse()}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">// Use the builder to create a shift right of V across the wavefront, with all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">// lanes active, to turn an inclusive scan into an exclusive scan.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">Value *AMDGPUAtomicOptimizerImpl::buildShiftRight(IRBuilder<> &B, Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">                                                  Value *const Identity) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">  Type *const Ty = V->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">  Function *UpdateDPP =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">  if (ST->hasDPPWavefrontShifts()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">    // GFX9 has DPP wavefront shift operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">    V = B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">                     {Identity, V, B.getInt32(DPP::WAVE_SHR1), B.getInt32(0xf),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">                      B.getInt32(0xf), B.getFalse()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">    Function *ReadLane =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">    Function *WriteLane =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_writelane, {});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">    // row operations we have to use permlane or readlane.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">    Value *Old = V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">    V = B.CreateCall(UpdateDPP,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 + 1),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">    // Copy the old lane 15 to the new lane 16.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">    V = B.CreateCall(WriteLane, {B.CreateCall(ReadLane, {Old, B.getInt32(15)}),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">                                 B.getInt32(16), V});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">    if (!ST->isWave32()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">      // Copy the old lane 31 to the new lane 32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">      V = B.CreateCall(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">          WriteLane,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">          {B.CreateCall(ReadLane, {Old, B.getInt32(31)}), B.getInt32(32), V});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">      // Copy the old lane 47 to the new lane 48.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">      V = B.CreateCall(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">          WriteLane,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">          {B.CreateCall(ReadLane, {Old, B.getInt32(47)}), B.getInt32(48), V});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">// Use the builder to create an exclusive scan and compute the final reduced</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">// value using an iterative approach. This provides an alternative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">// implementation to DPP which uses WMM for scan computations. This API iterate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">// over active lanes to read, compute and update the value using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">// readlane and writelane intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">std::pair<Value *, Value *> AMDGPUAtomicOptimizerImpl::buildScanIteratively(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">    IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *const Identity, Value *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">    Instruction &I, BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">  auto *Ty = I.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">  auto *WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">  auto *EntryBB = I.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">  auto NeedResult = !I.use_empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  auto *Ballot =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  // Start inserting instructions for ComputeLoop block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">  B.SetInsertPoint(ComputeLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  // Phi nodes for Accumulator, Scan results destination, and Active Lanes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">  auto *Accumulator = B.CreatePHI(Ty, 2, "Accumulator");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">  Accumulator->addIncoming(Identity, EntryBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">  PHINode *OldValuePhi = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">  if (NeedResult) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">    OldValuePhi = B.CreatePHI(Ty, 2, "OldValuePhi");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">    OldValuePhi->addIncoming(PoisonValue::get(Ty), EntryBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="uncoveredLine">  auto *ActiveBits = B.CreatePHI(WaveTy, 2, "ActiveBits");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">  ActiveBits->addIncoming(Ballot, EntryBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  // Use llvm.cttz instrinsic to find the lowest remaining active lane.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  auto *FF1 =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">      B.CreateIntrinsic(Intrinsic::cttz, WaveTy, {ActiveBits, B.getTrue()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="uncoveredLine">  auto *LaneIdxInt = B.CreateTrunc(FF1, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">  // Get the value required for atomic operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">  auto *LaneValue =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">      B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {}, {V, LaneIdxInt});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  // Perform writelane if intermediate scan results are required later in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  // kernel computations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="uncoveredLine">  Value *OldValue = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">  if (NeedResult) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">    OldValue = B.CreateIntrinsic(Intrinsic::amdgcn_writelane, {},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">                                 {Accumulator, LaneIdxInt, OldValuePhi});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">    OldValuePhi->addIncoming(OldValue, ComputeLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">  // Accumulate the results</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="uncoveredLine">  auto *NewAccumulator = buildNonAtomicBinOp(B, Op, Accumulator, LaneValue);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">  Accumulator->addIncoming(NewAccumulator, ComputeLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  // Set bit to zero of current active lane so that for next iteration llvm.cttz</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">  // return the next active lane</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">  auto *Mask = B.CreateShl(ConstantInt::get(WaveTy, 1), FF1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">  auto *InverseMask = B.CreateXor(Mask, ConstantInt::get(WaveTy, -1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">  auto *NewActiveBits = B.CreateAnd(ActiveBits, InverseMask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">  ActiveBits->addIncoming(NewActiveBits, ComputeLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">  // Branch out of the loop when all lanes are processed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">  auto *IsEnd = B.CreateICmpEQ(NewActiveBits, ConstantInt::get(WaveTy, 0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">  B.CreateCondBr(IsEnd, ComputeEnd, ComputeLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">  B.SetInsertPoint(ComputeEnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">  return {OldValue, NewAccumulator};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">static APInt getIdentityValueForAtomicOp(AtomicRMWInst::BinOp Op,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">                                         unsigned BitWidth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">  switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">    llvm_unreachable("Unhandled atomic op");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">  case AtomicRMWInst::Sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  case AtomicRMWInst::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">  case AtomicRMWInst::Xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  case AtomicRMWInst::UMax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">    return APInt::getMinValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">  case AtomicRMWInst::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">  case AtomicRMWInst::UMin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">    return APInt::getMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Max:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">    return APInt::getSignedMinValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">  case AtomicRMWInst::Min:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">    return APInt::getSignedMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">static Value *buildMul(IRBuilder<> &B, Value *LHS, Value *RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">  const ConstantInt *CI = dyn_cast<ConstantInt>(LHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">  return (CI && CI->isOne()) ? RHS : B.CreateMul(LHS, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">void AMDGPUAtomicOptimizerImpl::optimizeAtomic(Instruction &I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">                                               AtomicRMWInst::BinOp Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">                                               unsigned ValIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">                                               bool ValDivergent) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  // Start building just before the instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">  IRBuilder<> B(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  // If we are in a pixel shader, because of how we have to mask out helper</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  // lane invocations, we need to record the entry and exit BB's.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">  BasicBlock *PixelEntryBB = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">  BasicBlock *PixelExitBB = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  // If we're optimizing an atomic within a pixel shader, we need to wrap the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">  // entire atomic operation in a helper-lane check. We do not want any helper</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  // lanes that are around only for the purposes of derivatives to take part</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  // in any cross-lane communication, and we use a branch on whether the lane is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">  // live to do this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">  if (IsPixelShader) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">    // Record I's original position as the entry block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">    PixelEntryBB = I.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">    Value *const Cond = B.CreateIntrinsic(Intrinsic::amdgcn_ps_live, {}, {});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">    Instruction *const NonHelperTerminator =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">        SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">    // Record I's new position as the exit block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">    PixelExitBB = I.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">    I.moveBefore(NonHelperTerminator);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">    B.SetInsertPoint(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">  Type *const Ty = I.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">  const unsigned TyBitWidth = DL->getTypeSizeInBits(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">  auto *const VecTy = FixedVectorType::get(B.getInt32Ty(), 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  // This is the value in the atomic operation we need to combine in order to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  // reduce the number of atomic operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">  Value *const V = I.getOperand(ValIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">  // We need to know how many lanes are active within the wavefront, and we do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  // this by doing a ballot of active lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">  Type *const WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">  CallInst *const Ballot =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">  // We need to know how many lanes are active within the wavefront that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  // below us. If we counted each lane linearly starting from 0, a lane is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  // below us only if its associated index was less than ours. We do this by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">  // using the mbcnt intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">  Value *Mbcnt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">  if (ST->isWave32()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">                              {Ballot, B.getInt32(0)});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">    Value *const BitCast = B.CreateBitCast(Ballot, VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">    Value *const ExtractLo = B.CreateExtractElement(BitCast, B.getInt32(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">    Value *const ExtractHi = B.CreateExtractElement(BitCast, B.getInt32(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">                              {ExtractLo, B.getInt32(0)});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">    Mbcnt =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">        B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {ExtractHi, Mbcnt});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">  Mbcnt = B.CreateIntCast(Mbcnt, Ty, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  Value *const Identity = B.getInt(getIdentityValueForAtomicOp(Op, TyBitWidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">  Value *ExclScan = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">  Value *NewV = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">  const bool NeedResult = !I.use_empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">  Function *F = I.getFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">  LLVMContext &C = F->getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">  BasicBlock *ComputeLoop = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">  BasicBlock *ComputeEnd = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  // If we have a divergent value in each lane, we need to combine the value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">  // using DPP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">  if (ValDivergent) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">    const AtomicRMWInst::BinOp ScanOp =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">        Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">    if (ScanImpl == ScanOptions::DPP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">      // First we need to set all inactive invocations to the identity value, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">      // that they can correctly contribute to the final result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">      NewV =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">          B.CreateIntrinsic(Intrinsic::amdgcn_set_inactive, Ty, {V, Identity});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">      const AtomicRMWInst::BinOp ScanOp =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">          Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">      if (!NeedResult && ST->hasPermLaneX16()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">        // On GFX10 the permlanex16 instruction helps us build a reduction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">        // without too many readlanes and writelanes, which are generally bad</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">        // for performance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">        NewV = buildReduction(B, ScanOp, NewV, Identity);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">        NewV = buildScan(B, ScanOp, NewV, Identity);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">        if (NeedResult)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">          ExclScan = buildShiftRight(B, NewV, Identity);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">        // Read the value from the last lane, which has accumulated the values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">        // of each active lane in the wavefront. This will be our new value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">        // which we will provide to the atomic operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">        Value *const LastLaneIdx = B.getInt32(ST->getWavefrontSize() - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">        assert(TyBitWidth == 32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">        NewV = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">                                 {NewV, LastLaneIdx});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">      // Finally mark the readlanes in the WWM section.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">      NewV = B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, NewV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">    } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">      // Alternative implementation for scan</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">      ComputeLoop = BasicBlock::Create(C, "ComputeLoop", F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">      ComputeEnd = BasicBlock::Create(C, "ComputeEnd", F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">      std::tie(ExclScan, NewV) = buildScanIteratively(B, ScanOp, Identity, V, I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">                                                      ComputeLoop, ComputeEnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">      llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">    switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">      llvm_unreachable("Unhandled atomic op");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">    case AtomicRMWInst::Add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">    case AtomicRMWInst::Sub: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">      // The new value we will be contributing to the atomic operation is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">      // old value times the number of active lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">      Value *const Ctpop = B.CreateIntCast(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">      NewV = buildMul(B, V, Ctpop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">    case AtomicRMWInst::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">    case AtomicRMWInst::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">    case AtomicRMWInst::Max:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">    case AtomicRMWInst::Min:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">    case AtomicRMWInst::UMax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">    case AtomicRMWInst::UMin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">      // These operations with a uniform value are idempotent: doing the atomic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">      // operation multiple times has the same effect as doing it once.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">      NewV = V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">    case AtomicRMWInst::Xor:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">      // The new value we will be contributing to the atomic operation is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">      // old value times the parity of the number of active lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">      Value *const Ctpop = B.CreateIntCast(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">      NewV = buildMul(B, V, B.CreateAnd(Ctpop, 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">  // We only want a single lane to enter our new control flow, and we do this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  // by checking if there are any active lanes below us. Only one lane will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">  // have 0 active lanes below us, so that will be the only one to progress.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">  Value *const Cond = B.CreateICmpEQ(Mbcnt, B.getIntN(TyBitWidth, 0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">  // Store I's original basic block before we split the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">  BasicBlock *const EntryBB = I.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">  // We need to introduce some new control flow to force a single lane to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">  // active. We do this by splitting I's basic block at I, and introducing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">  // new block such that:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  // entry --> single_lane -\</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">  //       \------------------> exit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">  Instruction *const SingleLaneTerminator =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">      SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">  // At this point, we have split the I's block to allow one lane in wavefront</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">  // to update the precomputed reduced value. Also, completed the codegen for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">  // new control flow i.e. iterative loop which perform reduction and scan using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">  // ComputeLoop and ComputeEnd.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">  // For the new control flow, we need to move branch instruction i.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">  // terminator created during SplitBlockAndInsertIfThen from I's block to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">  // ComputeEnd block. We also need to set up predecessor to next block when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">  // single lane done updating the final reduced value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">  BasicBlock *Predecessor = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">  if (ValDivergent && ScanImpl == ScanOptions::Iterative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">    // Move terminator from I's block to ComputeEnd block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">    Instruction *Terminator = EntryBB->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">    B.SetInsertPoint(ComputeEnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="uncoveredLine">    Terminator->removeFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">    B.Insert(Terminator);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">    // Branch to ComputeLoop Block unconditionally from the I's block for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">    // iterative approach.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">    B.SetInsertPoint(EntryBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">    B.CreateBr(ComputeLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">    // Update the dominator tree for new control flow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">    DTU.applyUpdates(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">        {{DominatorTree::Insert, EntryBB, ComputeLoop},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">         {DominatorTree::Insert, ComputeLoop, ComputeEnd},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">         {DominatorTree::Delete, EntryBB, SingleLaneTerminator->getParent()}});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">    Predecessor = ComputeEnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">    Predecessor = EntryBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  // Move the IR builder into single_lane next.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">  B.SetInsertPoint(SingleLaneTerminator);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  // Clone the original atomic operation into single lane, replacing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">  // original value with our newly created one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">  Instruction *const NewI = I.clone();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">  B.Insert(NewI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">  NewI->setOperand(ValIdx, NewV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  // Move the IR builder into exit next, and start inserting just before the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  // original instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">  B.SetInsertPoint(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">  if (NeedResult) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">    // Create a PHI node to get our new atomic result into the exit block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">    PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">    PHI->addIncoming(PoisonValue::get(Ty), Predecessor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">    PHI->addIncoming(NewI, SingleLaneTerminator->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">    // We need to broadcast the value who was the lowest active lane (the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">    // lane) to all other lanes in the wavefront. We use an intrinsic for this,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">    // but have to handle 64-bit broadcasts with two calls to this intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">    Value *BroadcastI = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">    if (TyBitWidth == 64) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">      Value *const ExtractLo = B.CreateTrunc(PHI, B.getInt32Ty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">      Value *const ExtractHi =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">          B.CreateTrunc(B.CreateLShr(PHI, 32), B.getInt32Ty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">      CallInst *const ReadFirstLaneLo =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractLo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">      CallInst *const ReadFirstLaneHi =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractHi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">      Value *const PartialInsert = B.CreateInsertElement(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">          PoisonValue::get(VecTy), ReadFirstLaneLo, B.getInt32(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">      Value *const Insert =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">          B.CreateInsertElement(PartialInsert, ReadFirstLaneHi, B.getInt32(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">      BroadcastI = B.CreateBitCast(Insert, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">    } else if (TyBitWidth == 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">      BroadcastI = B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, PHI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">      llvm_unreachable("Unhandled atomic bit width");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">    // Now that we have the result of our single atomic operation, we need to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">    // get our individual lane's slice into the result. We use the lane offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">    // we previously calculated combined with the atomic result value we got</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">    // from the first lane, to get our lane's index into the atomic result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">    Value *LaneOffset = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">    if (ValDivergent) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">      if (ScanImpl == ScanOptions::DPP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">        LaneOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">            B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, ExclScan);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">      } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">        LaneOffset = ExclScan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">        llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">      switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">      default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">        llvm_unreachable("Unhandled atomic op");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">      case AtomicRMWInst::Add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">      case AtomicRMWInst::Sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">        LaneOffset = buildMul(B, V, Mbcnt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">      case AtomicRMWInst::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">      case AtomicRMWInst::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">      case AtomicRMWInst::Max:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">      case AtomicRMWInst::Min:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">      case AtomicRMWInst::UMax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">      case AtomicRMWInst::UMin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">        LaneOffset = B.CreateSelect(Cond, Identity, V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">      case AtomicRMWInst::Xor:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">        LaneOffset = buildMul(B, V, B.CreateAnd(Mbcnt, 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">    Value *const Result = buildNonAtomicBinOp(B, Op, BroadcastI, LaneOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">    if (IsPixelShader) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">      // Need a final PHI to reconverge to above the helper lane branch mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">      B.SetInsertPoint(PixelExitBB->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">      PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">      PHI->addIncoming(PoisonValue::get(Ty), PixelEntryBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">      PHI->addIncoming(Result, I.getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="uncoveredLine">      I.replaceAllUsesWith(PHI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">      // Replace the original atomic instruction with the new one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="uncoveredLine">      I.replaceAllUsesWith(Result);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">  // And delete the original.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">  I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">                      "AMDGPU atomic optimizations", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="coveredLine">INITIALIZE_PASS_END(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">                    "AMDGPU atomic optimizations", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">FunctionPass *llvm::createAMDGPUAtomicOptimizerPass(ScanOptions ScanStrategy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">  return new AMDGPUAtomicOptimizer(ScanStrategy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_121AMDGPUAtomicOptimizerC2EN4llvm11ScanOptionsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_121AMDGPUAtomicOptimizer16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125AMDGPUAtomicOptimizerImplC2EPKN4llvm21GenericUniformityInfoINS1_17GenericSSAContextINS1_8FunctionEEEEEPKNS1_10DataLayoutERNS1_14DomTreeUpdaterEPKNS1_12GCNSubtargetEbNS1_11ScanOptionsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_121AMDGPUAtomicOptimizer13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm25AMDGPUAtomicOptimizerPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl3runERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl18visitAtomicRMWInstERN4llvm13AtomicRMWInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl18visitIntrinsicInstERN4llvm13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19buildNonAtomicBinOpRN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEENS_13AtomicRMWInst5BinOpEPNS_5ValueES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl14buildReductionERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEENS1_13AtomicRMWInst5BinOpEPNS1_5ValueESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl9buildScanERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEENS1_13AtomicRMWInst5BinOpEPNS1_5ValueESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl15buildShiftRightERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl20buildScanIterativelyERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEENS1_13AtomicRMWInst5BinOpEPNS1_5ValueESA_RNS1_11InstructionEPNS1_10BasicBlockESE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL27getIdentityValueForAtomicOpN4llvm13AtomicRMWInst5BinOpEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8buildMulRN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEEPNS_5ValueES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125AMDGPUAtomicOptimizerImpl14optimizeAtomicERN4llvm11InstructionENS1_13AtomicRMWInst5BinOpEjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL39initializeAMDGPUAtomicOptimizerPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm35initializeAMDGPUAtomicOptimizerPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm31createAMDGPUAtomicOptimizerPassENS_11ScanOptionsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- AMDGPUAtomicOptimizer.cpp -----------------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- AMDGPUAtomicOptimizer.cpp -----------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// This pass optimizes atomic operations by using a single lane of a wavefront</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// This pass optimizes atomic operations by using a single lane of a wavefront</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// to perform the atomic operation, thus reducing contention on that memory</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// to perform the atomic operation, thus reducing contention on that memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">/// location.</td>
    <td class="lineNumber">12</td>
    <td class="codeline">/// location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">/// Atomic optimizer uses following strategies to compute scan and reduced</td>
    <td class="lineNumber">13</td>
    <td class="codeline">/// Atomic optimizer uses following strategies to compute scan and reduced</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">/// values</td>
    <td class="lineNumber">14</td>
    <td class="codeline">/// values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">/// 1. DPP -</td>
    <td class="lineNumber">15</td>
    <td class="codeline">/// 1. DPP -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">///   This is the most efficient implementation for scan. DPP uses Whole Wave</td>
    <td class="lineNumber">16</td>
    <td class="codeline">///   This is the most efficient implementation for scan. DPP uses Whole Wave</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">///   Mode (WWM)</td>
    <td class="lineNumber">17</td>
    <td class="codeline">///   Mode (WWM)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">/// 2. Iterative -</td>
    <td class="lineNumber">18</td>
    <td class="codeline">/// 2. Iterative -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">//    An alternative implementation iterates over all active lanes</td>
    <td class="lineNumber">19</td>
    <td class="codeline">//    An alternative implementation iterates over all active lanes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">///   of Wavefront using llvm.cttz and performs scan  using readlane & writelane</td>
    <td class="lineNumber">20</td>
    <td class="codeline">///   of Wavefront using llvm.cttz and performs scan  using readlane & writelane</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">///   intrinsics</td>
    <td class="lineNumber">21</td>
    <td class="codeline">///   intrinsics</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">22</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline"></td>
    <td class="lineNumber">23</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "AMDGPU.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "AMDGPU.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "GCNSubtarget.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "GCNSubtarget.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/DomTreeUpdater.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/UniformityAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/InstVisitor.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline"></td>
    <td class="lineNumber">35</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#define DEBUG_TYPE "amdgpu-atomic-optimizer"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#define DEBUG_TYPE "amdgpu-atomic-optimizer"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">38</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">using namespace llvm::AMDGPU;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">using namespace llvm::AMDGPU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">41</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline"></td>
    <td class="lineNumber">42</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">struct ReplacementInfo {</td>
    <td class="lineNumber">43</td>
    <td class="codeline">struct ReplacementInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">  Instruction *I;</td>
    <td class="lineNumber">44</td>
    <td class="codeline">  Instruction *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">  AtomicRMWInst::BinOp Op;</td>
    <td class="lineNumber">45</td>
    <td class="codeline">  AtomicRMWInst::BinOp Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">  unsigned ValIdx;</td>
    <td class="lineNumber">46</td>
    <td class="codeline">  unsigned ValIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">  bool ValDivergent;</td>
    <td class="lineNumber">47</td>
    <td class="codeline">  bool ValDivergent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">};</td>
    <td class="lineNumber">48</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">class AMDGPUAtomicOptimizer : public FunctionPass {</td>
    <td class="lineNumber">50</td>
    <td class="codeline">class AMDGPUAtomicOptimizer : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">51</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">52</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">  ScanOptions ScanImpl;</td>
    <td class="lineNumber">53</td>
    <td class="codeline">  ScanOptions ScanImpl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">  AMDGPUAtomicOptimizer(ScanOptions ScanImpl)</td>
    <td class="lineNumber">54</td>
    <td class="codeline">  AMDGPUAtomicOptimizer(ScanOptions ScanImpl)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">      : FunctionPass(ID), ScanImpl(ScanImpl) {}</td>
    <td class="lineNumber">55</td>
    <td class="codeline">      : FunctionPass(ID), ScanImpl(ScanImpl) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">57</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">59</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">60</td>
    <td class="codeline">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td class="lineNumber">61</td>
    <td class="codeline">    AU.addRequired<UniformityInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">62</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">63</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">};</td>
    <td class="lineNumber">64</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">class AMDGPUAtomicOptimizerImpl</td>
    <td class="lineNumber">66</td>
    <td class="codeline">class AMDGPUAtomicOptimizerImpl</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">    : public InstVisitor<AMDGPUAtomicOptimizerImpl> {</td>
    <td class="lineNumber">67</td>
    <td class="codeline">    : public InstVisitor<AMDGPUAtomicOptimizerImpl> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">68</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">  SmallVector<ReplacementInfo, 8> ToReplace;</td>
    <td class="lineNumber">69</td>
    <td class="codeline">  SmallVector<ReplacementInfo, 8> ToReplace;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">  const UniformityInfo *UA;</td>
    <td class="lineNumber">70</td>
    <td class="codeline">  const UniformityInfo *UA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">  const DataLayout *DL;</td>
    <td class="lineNumber">71</td>
    <td class="codeline">  const DataLayout *DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  DomTreeUpdater &DTU;</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  DomTreeUpdater &DTU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">  const GCNSubtarget *ST;</td>
    <td class="lineNumber">73</td>
    <td class="codeline">  const GCNSubtarget *ST;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">  bool IsPixelShader;</td>
    <td class="lineNumber">74</td>
    <td class="codeline">  bool IsPixelShader;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">  ScanOptions ScanImpl;</td>
    <td class="lineNumber">75</td>
    <td class="codeline">  ScanOptions ScanImpl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline"></td>
    <td class="lineNumber">76</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  Value *buildReduction(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  Value *buildReduction(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">                        Value *const Identity) const;</td>
    <td class="lineNumber">78</td>
    <td class="codeline">                        Value *const Identity) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  Value *buildScan(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  Value *buildScan(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">                   Value *const Identity) const;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">                   Value *const Identity) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  Value *buildShiftRight(IRBuilder<> &B, Value *V, Value *const Identity) const;</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  Value *buildShiftRight(IRBuilder<> &B, Value *V, Value *const Identity) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  std::pair<Value *, Value *></td>
    <td class="lineNumber">83</td>
    <td class="codeline">  std::pair<Value *, Value *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  buildScanIteratively(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  buildScanIteratively(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">                       Value *const Identity, Value *V, Instruction &I,</td>
    <td class="lineNumber">85</td>
    <td class="codeline">                       Value *const Identity, Value *V, Instruction &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">                       BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const;</td>
    <td class="lineNumber">86</td>
    <td class="codeline">                       BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  void optimizeAtomic(Instruction &I, AtomicRMWInst::BinOp Op, unsigned ValIdx,</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  void optimizeAtomic(Instruction &I, AtomicRMWInst::BinOp Op, unsigned ValIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">                      bool ValDivergent) const;</td>
    <td class="lineNumber">89</td>
    <td class="codeline">                      bool ValDivergent) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">91</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  AMDGPUAtomicOptimizerImpl() = delete;</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  AMDGPUAtomicOptimizerImpl() = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  AMDGPUAtomicOptimizerImpl(const UniformityInfo *UA, const DataLayout *DL,</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  AMDGPUAtomicOptimizerImpl(const UniformityInfo *UA, const DataLayout *DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">                            DomTreeUpdater &DTU, const GCNSubtarget *ST,</td>
    <td class="lineNumber">95</td>
    <td class="codeline">                            DomTreeUpdater &DTU, const GCNSubtarget *ST,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">                            bool IsPixelShader, ScanOptions ScanImpl)</td>
    <td class="lineNumber">96</td>
    <td class="codeline">                            bool IsPixelShader, ScanOptions ScanImpl)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">      : UA(UA), DL(DL), DTU(DTU), ST(ST), IsPixelShader(IsPixelShader),</td>
    <td class="lineNumber">97</td>
    <td class="codeline">      : UA(UA), DL(DL), DTU(DTU), ST(ST), IsPixelShader(IsPixelShader),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">        ScanImpl(ScanImpl) {}</td>
    <td class="lineNumber">98</td>
    <td class="codeline">        ScanImpl(ScanImpl) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline"></td>
    <td class="lineNumber">99</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  bool run(Function &F);</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  bool run(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  void visitAtomicRMWInst(AtomicRMWInst &I);</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  void visitAtomicRMWInst(AtomicRMWInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  void visitIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  void visitIntrinsicInst(IntrinsicInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">};</td>
    <td class="lineNumber">104</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">106</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">char AMDGPUAtomicOptimizer::ID = 0;</td>
    <td class="lineNumber">108</td>
    <td class="codeline">char AMDGPUAtomicOptimizer::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">char &llvm::AMDGPUAtomicOptimizerID = AMDGPUAtomicOptimizer::ID;</td>
    <td class="lineNumber">110</td>
    <td class="codeline">char &llvm::AMDGPUAtomicOptimizerID = AMDGPUAtomicOptimizer::ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">bool AMDGPUAtomicOptimizer::runOnFunction(Function &F) {</td>
    <td class="lineNumber">112</td>
    <td class="codeline">bool AMDGPUAtomicOptimizer::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  if (skipFunction(F)) {</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  if (skipFunction(F)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">114</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  const UniformityInfo *UA =</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  const UniformityInfo *UA =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">      &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td class="lineNumber">118</td>
    <td class="codeline">      &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  DominatorTreeWrapperPass *const DTW =</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  DominatorTreeWrapperPass *const DTW =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">      getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">122</td>
    <td class="codeline">      getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  DomTreeUpdater DTU(DTW ? &DTW->getDomTree() : nullptr,</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  DomTreeUpdater DTU(DTW ? &DTW->getDomTree() : nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">124</td>
    <td class="codeline">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  const TargetPassConfig &TPC = getAnalysis<TargetPassConfig>();</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  const TargetPassConfig &TPC = getAnalysis<TargetPassConfig>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  const TargetMachine &TM = TPC.getTM<TargetMachine>();</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  const TargetMachine &TM = TPC.getTM<TargetMachine>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  return AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  return AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">      .run(F);</td>
    <td class="lineNumber">133</td>
    <td class="codeline">      .run(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">}</td>
    <td class="lineNumber">134</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">PreservedAnalyses AMDGPUAtomicOptimizerPass::run(Function &F,</td>
    <td class="lineNumber">136</td>
    <td class="codeline">PreservedAnalyses AMDGPUAtomicOptimizerPass::run(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">                                                 FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">137</td>
    <td class="codeline">                                                 FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  const auto *UA = &AM.getResult<UniformityInfoAnalysis>(F);</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  const auto *UA = &AM.getResult<UniformityInfoAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline"></td>
    <td class="lineNumber">141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  DomTreeUpdater DTU(&AM.getResult<DominatorTreeAnalysis>(F),</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  DomTreeUpdater DTU(&AM.getResult<DominatorTreeAnalysis>(F),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">143</td>
    <td class="codeline">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline"></td>
    <td class="lineNumber">147</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  bool IsChanged =</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  bool IsChanged =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">      AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td class="lineNumber">149</td>
    <td class="codeline">      AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">          .run(F);</td>
    <td class="lineNumber">150</td>
    <td class="codeline">          .run(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  if (!IsChanged) {</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  if (!IsChanged) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">153</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  PA.preserve<DominatorTreeAnalysis>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  return PA;</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  return PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">}</td>
    <td class="lineNumber">159</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">bool AMDGPUAtomicOptimizerImpl::run(Function &F) {</td>
    <td class="lineNumber">161</td>
    <td class="codeline">bool AMDGPUAtomicOptimizerImpl::run(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  // Scan option None disables the Pass</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  // Scan option None disables the Pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  if (ScanImpl == ScanOptions::None) {</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  if (ScanImpl == ScanOptions::None) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">165</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  visit(F);</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  visit(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline"></td>
    <td class="lineNumber">169</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  const bool Changed = !ToReplace.empty();</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  const bool Changed = !ToReplace.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  for (ReplacementInfo &Info : ToReplace) {</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  for (ReplacementInfo &Info : ToReplace) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    optimizeAtomic(*Info.I, Info.Op, Info.ValIdx, Info.ValDivergent);</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    optimizeAtomic(*Info.I, Info.Op, Info.ValIdx, Info.ValDivergent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  ToReplace.clear();</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  ToReplace.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">}</td>
    <td class="lineNumber">179</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">void AMDGPUAtomicOptimizerImpl::visitAtomicRMWInst(AtomicRMWInst &I) {</td>
    <td class="lineNumber">181</td>
    <td class="codeline">void AMDGPUAtomicOptimizerImpl::visitAtomicRMWInst(AtomicRMWInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  // Early exit for unhandled address space atomic instructions.</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  // Early exit for unhandled address space atomic instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  switch (I.getPointerAddressSpace()) {</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  switch (I.getPointerAddressSpace()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">185</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  case AMDGPUAS::GLOBAL_ADDRESS:</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  case AMDGPUAS::GLOBAL_ADDRESS:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  case AMDGPUAS::LOCAL_ADDRESS:</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  case AMDGPUAS::LOCAL_ADDRESS:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  AtomicRMWInst::BinOp Op = I.getOperation();</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  AtomicRMWInst::BinOp Op = I.getOperation();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  switch (Op) {</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">195</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  case AtomicRMWInst::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  case AtomicRMWInst::Sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  case AtomicRMWInst::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  case AtomicRMWInst::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  case AtomicRMWInst::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  case AtomicRMWInst::Max:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  case AtomicRMWInst::Min:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  case AtomicRMWInst::UMax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  case AtomicRMWInst::UMin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">205</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  const unsigned PtrIdx = 0;</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  const unsigned PtrIdx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  const unsigned ValIdx = 1;</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  const unsigned ValIdx = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  // If the pointer operand is divergent, then each lane is doing an atomic</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  // If the pointer operand is divergent, then each lane is doing an atomic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  // operation on a different address, and we cannot optimize that.</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  // operation on a different address, and we cannot optimize that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  if (UA->isDivergentUse(I.getOperandUse(PtrIdx))) {</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  if (UA->isDivergentUse(I.getOperandUse(PtrIdx))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">214</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  // If the value operand is divergent, each lane is contributing a different</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  // If the value operand is divergent, each lane is contributing a different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  // value to the atomic calculation. We can only optimize divergent values if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  // bits.</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  // bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  if (ValDivergent &&</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  if (ValDivergent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td class="lineNumber">224</td>
    <td class="codeline">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  // atomic operation to do the calculation for the entire wavefront, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  // remember the instruction so we can come back to it.</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  // remember the instruction so we can come back to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  ToReplace.push_back(Info);</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  ToReplace.push_back(Info);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">}</td>
    <td class="lineNumber">234</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">void AMDGPUAtomicOptimizerImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">236</td>
    <td class="codeline">void AMDGPUAtomicOptimizerImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  AtomicRMWInst::BinOp Op;</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  AtomicRMWInst::BinOp Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  switch (I.getIntrinsicID()) {</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  switch (I.getIntrinsicID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">241</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_add:</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_add:</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_add:</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_add:</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_add:</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    Op = AtomicRMWInst::Add;</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    Op = AtomicRMWInst::Add;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_sub:</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_sub:</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_sub:</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_sub:</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_sub:</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">    Op = AtomicRMWInst::Sub;</td>
    <td class="lineNumber">254</td>
    <td class="codeline">    Op = AtomicRMWInst::Sub;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">255</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_and:</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_and:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_and:</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_and:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_and:</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_and:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_and:</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_and:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_and:</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_and:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    Op = AtomicRMWInst::And;</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    Op = AtomicRMWInst::And;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_or:</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_or:</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_or:</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_or:</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_or:</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    Op = AtomicRMWInst::Or;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    Op = AtomicRMWInst::Or;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">269</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_xor:</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_xor:</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_xor:</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_xor:</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_xor:</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    Op = AtomicRMWInst::Xor;</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    Op = AtomicRMWInst::Xor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">276</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_smin:</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_smin:</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smin:</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_smin:</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smin:</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    Op = AtomicRMWInst::Min;</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    Op = AtomicRMWInst::Min;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_umin:</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_umin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_umin:</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_umin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umin:</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_umin:</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_umin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umin:</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    Op = AtomicRMWInst::UMin;</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    Op = AtomicRMWInst::UMin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_smax:</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_smax:</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smax:</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_smax:</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smax:</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    Op = AtomicRMWInst::Max;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    Op = AtomicRMWInst::Max;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">297</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_umax:</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  case Intrinsic::amdgcn_buffer_atomic_umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_umax:</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_buffer_atomic_umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umax:</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_umax:</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_buffer_atomic_umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umax:</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    Op = AtomicRMWInst::UMax;</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    Op = AtomicRMWInst::UMax;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline"></td>
    <td class="lineNumber">306</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  const unsigned ValIdx = 0;</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  const unsigned ValIdx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline"></td>
    <td class="lineNumber">310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  // If the value operand is divergent, each lane is contributing a different</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  // If the value operand is divergent, each lane is contributing a different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  // value to the atomic calculation. We can only optimize divergent values if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  // bits.</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  // bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  if (ValDivergent &&</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  if (ValDivergent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td class="lineNumber">316</td>
    <td class="codeline">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">317</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  // If any of the other arguments to the intrinsic are divergent, we can't</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  // If any of the other arguments to the intrinsic are divergent, we can't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">  // optimize the operation.</td>
    <td class="lineNumber">321</td>
    <td class="codeline">  // optimize the operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  for (unsigned Idx = 1; Idx < I.getNumOperands(); Idx++) {</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  for (unsigned Idx = 1; Idx < I.getNumOperands(); Idx++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">    if (UA->isDivergentUse(I.getOperandUse(Idx))) {</td>
    <td class="lineNumber">323</td>
    <td class="codeline">    if (UA->isDivergentUse(I.getOperandUse(Idx))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">324</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">325</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  // atomic operation to do the calculation for the entire wavefront, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  // remember the instruction so we can come back to it.</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  // remember the instruction so we can come back to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  ToReplace.push_back(Info);</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  ToReplace.push_back(Info);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">}</td>
    <td class="lineNumber">334</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">// Use the builder to create the non-atomic counterpart of the specified</td>
    <td class="lineNumber">336</td>
    <td class="codeline">// Use the builder to create the non-atomic counterpart of the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">// atomicrmw binary op.</td>
    <td class="lineNumber">337</td>
    <td class="codeline">// atomicrmw binary op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">static Value *buildNonAtomicBinOp(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">338</td>
    <td class="codeline">static Value *buildNonAtomicBinOp(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">                                  Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">339</td>
    <td class="codeline">                                  Value *LHS, Value *RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  CmpInst::Predicate Pred;</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  CmpInst::Predicate Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">  switch (Op) {</td>
    <td class="lineNumber">342</td>
    <td class="codeline">  switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">    llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">344</td>
    <td class="codeline">    llvm_unreachable("Unhandled atomic op");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  case AtomicRMWInst::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Add, LHS, RHS);</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Add, LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  case AtomicRMWInst::Sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Sub, LHS, RHS);</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Sub, LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  case AtomicRMWInst::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::And, LHS, RHS);</td>
    <td class="lineNumber">350</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::And, LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  case AtomicRMWInst::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Or, LHS, RHS);</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Or, LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  case AtomicRMWInst::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Xor, LHS, RHS);</td>
    <td class="lineNumber">354</td>
    <td class="codeline">    return B.CreateBinOp(Instruction::Xor, LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  case AtomicRMWInst::Max:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">    Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">357</td>
    <td class="codeline">    Pred = CmpInst::ICMP_SGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">358</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  case AtomicRMWInst::Min:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    Pred = CmpInst::ICMP_SLT;</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    Pred = CmpInst::ICMP_SLT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  case AtomicRMWInst::UMax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">    Pred = CmpInst::ICMP_UGT;</td>
    <td class="lineNumber">363</td>
    <td class="codeline">    Pred = CmpInst::ICMP_UGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">364</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  case AtomicRMWInst::UMin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">    Pred = CmpInst::ICMP_ULT;</td>
    <td class="lineNumber">366</td>
    <td class="codeline">    Pred = CmpInst::ICMP_ULT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">367</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  Value *Cond = B.CreateICmp(Pred, LHS, RHS);</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  Value *Cond = B.CreateICmp(Pred, LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  return B.CreateSelect(Cond, LHS, RHS);</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  return B.CreateSelect(Cond, LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">}</td>
    <td class="lineNumber">371</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">// Use the builder to create a reduction of V across the wavefront, with all</td>
    <td class="lineNumber">373</td>
    <td class="codeline">// Use the builder to create a reduction of V across the wavefront, with all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">// lanes active, returning the same result in all lanes.</td>
    <td class="lineNumber">374</td>
    <td class="codeline">// lanes active, returning the same result in all lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">Value *AMDGPUAtomicOptimizerImpl::buildReduction(IRBuilder<> &B,</td>
    <td class="lineNumber">375</td>
    <td class="codeline">Value *AMDGPUAtomicOptimizerImpl::buildReduction(IRBuilder<> &B,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">                                                 AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">376</td>
    <td class="codeline">                                                 AtomicRMWInst::BinOp Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">                                                 Value *V,</td>
    <td class="lineNumber">377</td>
    <td class="codeline">                                                 Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">                                                 Value *const Identity) const {</td>
    <td class="lineNumber">378</td>
    <td class="codeline">                                                 Value *const Identity) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  Type *const Ty = V->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  Module *M = B.GetInsertBlock()->getModule();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  Function *UpdateDPP =</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  Function *UpdateDPP =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">382</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline"></td>
    <td class="lineNumber">383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  // Reduce within each row of 16 lanes.</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  // Reduce within each row of 16 lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">        B, Op, V,</td>
    <td class="lineNumber">387</td>
    <td class="codeline">        B, Op, V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">388</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::ROW_XMASK0 | 1 << Idx),</td>
    <td class="lineNumber">389</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::ROW_XMASK0 | 1 << Idx),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">390</td>
    <td class="codeline">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  // Reduce within each pair of rows (i.e. 32 lanes).</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  // Reduce within each pair of rows (i.e. 32 lanes).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  assert(ST->hasPermLaneX16());</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  assert(ST->hasPermLaneX16());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  V = buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">      B, Op, V,</td>
    <td class="lineNumber">396</td>
    <td class="codeline">      B, Op, V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">      B.CreateIntrinsic(</td>
    <td class="lineNumber">397</td>
    <td class="codeline">      B.CreateIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">          Intrinsic::amdgcn_permlanex16, {},</td>
    <td class="lineNumber">398</td>
    <td class="codeline">          Intrinsic::amdgcn_permlanex16, {},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">          {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()}));</td>
    <td class="lineNumber">399</td>
    <td class="codeline">          {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline"></td>
    <td class="lineNumber">400</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  if (ST->isWave32())</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  if (ST->isWave32())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">402</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  if (ST->hasPermLane64()) {</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  if (ST->hasPermLane64()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    // Reduce across the upper and lower 32 lanes.</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    // Reduce across the upper and lower 32 lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    return buildNonAtomicBinOp(</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    return buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">        B, Op, V, B.CreateIntrinsic(Intrinsic::amdgcn_permlane64, {}, V));</td>
    <td class="lineNumber">407</td>
    <td class="codeline">        B, Op, V, B.CreateIntrinsic(Intrinsic::amdgcn_permlane64, {}, V));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  // Pick an arbitrary lane from 0..31 and an arbitrary lane from 32..63 and</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  // Pick an arbitrary lane from 0..31 and an arbitrary lane from 32..63 and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  // combine them with a scalar operation.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  // combine them with a scalar operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  Function *ReadLane =</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  Function *ReadLane =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td class="lineNumber">413</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  Value *const Lane0 = B.CreateCall(ReadLane, {V, B.getInt32(0)});</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  Value *const Lane0 = B.CreateCall(ReadLane, {V, B.getInt32(0)});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  Value *const Lane32 = B.CreateCall(ReadLane, {V, B.getInt32(32)});</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  Value *const Lane32 = B.CreateCall(ReadLane, {V, B.getInt32(32)});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  return buildNonAtomicBinOp(B, Op, Lane0, Lane32);</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  return buildNonAtomicBinOp(B, Op, Lane0, Lane32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">}</td>
    <td class="lineNumber">417</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">// Use the builder to create an inclusive scan of V across the wavefront, with</td>
    <td class="lineNumber">419</td>
    <td class="codeline">// Use the builder to create an inclusive scan of V across the wavefront, with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">// all lanes active.</td>
    <td class="lineNumber">420</td>
    <td class="codeline">// all lanes active.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">Value *AMDGPUAtomicOptimizerImpl::buildScan(IRBuilder<> &B,</td>
    <td class="lineNumber">421</td>
    <td class="codeline">Value *AMDGPUAtomicOptimizerImpl::buildScan(IRBuilder<> &B,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">                                            AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">422</td>
    <td class="codeline">                                            AtomicRMWInst::BinOp Op, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">                                            Value *const Identity) const {</td>
    <td class="lineNumber">423</td>
    <td class="codeline">                                            Value *const Identity) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  Type *const Ty = V->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  Module *M = B.GetInsertBlock()->getModule();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  Function *UpdateDPP =</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  Function *UpdateDPP =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">427</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">430</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">        B, Op, V,</td>
    <td class="lineNumber">431</td>
    <td class="codeline">        B, Op, V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">432</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 | 1 << Idx),</td>
    <td class="lineNumber">433</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 | 1 << Idx),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">434</td>
    <td class="codeline">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  if (ST->hasDPPBroadcasts()) {</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  if (ST->hasDPPBroadcasts()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">    // GFX9 has DPP row broadcast operations.</td>
    <td class="lineNumber">437</td>
    <td class="codeline">    // GFX9 has DPP row broadcast operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">        B, Op, V,</td>
    <td class="lineNumber">439</td>
    <td class="codeline">        B, Op, V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">440</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::BCAST15), B.getInt32(0xa),</td>
    <td class="lineNumber">441</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::BCAST15), B.getInt32(0xa),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">442</td>
    <td class="codeline">                      B.getInt32(0xf), B.getFalse()}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">443</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">        B, Op, V,</td>
    <td class="lineNumber">444</td>
    <td class="codeline">        B, Op, V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">445</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::BCAST31), B.getInt32(0xc),</td>
    <td class="lineNumber">446</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::BCAST31), B.getInt32(0xc),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">447</td>
    <td class="codeline">                      B.getInt32(0xf), B.getFalse()}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td class="lineNumber">449</td>
    <td class="codeline">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">    // row operations we have to use permlane or readlane.</td>
    <td class="lineNumber">450</td>
    <td class="codeline">    // row operations we have to use permlane or readlane.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">    // Combine lane 15 into lanes 16..31 (and, for wave 64, lane 47 into lanes</td>
    <td class="lineNumber">452</td>
    <td class="codeline">    // Combine lane 15 into lanes 16..31 (and, for wave 64, lane 47 into lanes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">    // 48..63).</td>
    <td class="lineNumber">453</td>
    <td class="codeline">    // 48..63).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">    assert(ST->hasPermLaneX16());</td>
    <td class="lineNumber">454</td>
    <td class="codeline">    assert(ST->hasPermLaneX16());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">    Value *const PermX = B.CreateIntrinsic(</td>
    <td class="lineNumber">455</td>
    <td class="codeline">    Value *const PermX = B.CreateIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">        Intrinsic::amdgcn_permlanex16, {},</td>
    <td class="lineNumber">456</td>
    <td class="codeline">        Intrinsic::amdgcn_permlanex16, {},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">        {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()});</td>
    <td class="lineNumber">457</td>
    <td class="codeline">        {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    V = buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">        B, Op, V,</td>
    <td class="lineNumber">459</td>
    <td class="codeline">        B, Op, V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">460</td>
    <td class="codeline">        B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">                     {Identity, PermX, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td class="lineNumber">461</td>
    <td class="codeline">                     {Identity, PermX, B.getInt32(DPP::QUAD_PERM_ID),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">                      B.getInt32(0xa), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">462</td>
    <td class="codeline">                      B.getInt32(0xa), B.getInt32(0xf), B.getFalse()}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">    if (!ST->isWave32()) {</td>
    <td class="lineNumber">463</td>
    <td class="codeline">    if (!ST->isWave32()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">      // Combine lane 31 into lanes 32..63.</td>
    <td class="lineNumber">464</td>
    <td class="codeline">      // Combine lane 31 into lanes 32..63.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">      Value *const Lane31 = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td class="lineNumber">465</td>
    <td class="codeline">      Value *const Lane31 = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">                                              {V, B.getInt32(31)});</td>
    <td class="lineNumber">466</td>
    <td class="codeline">                                              {V, B.getInt32(31)});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">      V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">467</td>
    <td class="codeline">      V = buildNonAtomicBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">          B, Op, V,</td>
    <td class="lineNumber">468</td>
    <td class="codeline">          B, Op, V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">          B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">469</td>
    <td class="codeline">          B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">                       {Identity, Lane31, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td class="lineNumber">470</td>
    <td class="codeline">                       {Identity, Lane31, B.getInt32(DPP::QUAD_PERM_ID),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">                        B.getInt32(0xc), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">471</td>
    <td class="codeline">                        B.getInt32(0xc), B.getInt32(0xf), B.getFalse()}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">472</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">}</td>
    <td class="lineNumber">475</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">// Use the builder to create a shift right of V across the wavefront, with all</td>
    <td class="lineNumber">477</td>
    <td class="codeline">// Use the builder to create a shift right of V across the wavefront, with all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">// lanes active, to turn an inclusive scan into an exclusive scan.</td>
    <td class="lineNumber">478</td>
    <td class="codeline">// lanes active, to turn an inclusive scan into an exclusive scan.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">Value *AMDGPUAtomicOptimizerImpl::buildShiftRight(IRBuilder<> &B, Value *V,</td>
    <td class="lineNumber">479</td>
    <td class="codeline">Value *AMDGPUAtomicOptimizerImpl::buildShiftRight(IRBuilder<> &B, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">                                                  Value *const Identity) const {</td>
    <td class="lineNumber">480</td>
    <td class="codeline">                                                  Value *const Identity) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  Type *const Ty = V->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  Module *M = B.GetInsertBlock()->getModule();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  Function *UpdateDPP =</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  Function *UpdateDPP =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">484</td>
    <td class="codeline">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  if (ST->hasDPPWavefrontShifts()) {</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  if (ST->hasDPPWavefrontShifts()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">    // GFX9 has DPP wavefront shift operations.</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    // GFX9 has DPP wavefront shift operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">    V = B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">488</td>
    <td class="codeline">    V = B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::WAVE_SHR1), B.getInt32(0xf),</td>
    <td class="lineNumber">489</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::WAVE_SHR1), B.getInt32(0xf),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">                      B.getInt32(0xf), B.getFalse()});</td>
    <td class="lineNumber">490</td>
    <td class="codeline">                      B.getInt32(0xf), B.getFalse()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">    Function *ReadLane =</td>
    <td class="lineNumber">492</td>
    <td class="codeline">    Function *ReadLane =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td class="lineNumber">493</td>
    <td class="codeline">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    Function *WriteLane =</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    Function *WriteLane =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_writelane, {});</td>
    <td class="lineNumber">495</td>
    <td class="codeline">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_writelane, {});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">    // row operations we have to use permlane or readlane.</td>
    <td class="lineNumber">498</td>
    <td class="codeline">    // row operations we have to use permlane or readlane.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    Value *Old = V;</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    Value *Old = V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    V = B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    V = B.CreateCall(UpdateDPP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 + 1),</td>
    <td class="lineNumber">501</td>
    <td class="codeline">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 + 1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()});</td>
    <td class="lineNumber">502</td>
    <td class="codeline">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">    // Copy the old lane 15 to the new lane 16.</td>
    <td class="lineNumber">504</td>
    <td class="codeline">    // Copy the old lane 15 to the new lane 16.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    V = B.CreateCall(WriteLane, {B.CreateCall(ReadLane, {Old, B.getInt32(15)}),</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    V = B.CreateCall(WriteLane, {B.CreateCall(ReadLane, {Old, B.getInt32(15)}),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">                                 B.getInt32(16), V});</td>
    <td class="lineNumber">506</td>
    <td class="codeline">                                 B.getInt32(16), V});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">    if (!ST->isWave32()) {</td>
    <td class="lineNumber">508</td>
    <td class="codeline">    if (!ST->isWave32()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">      // Copy the old lane 31 to the new lane 32.</td>
    <td class="lineNumber">509</td>
    <td class="codeline">      // Copy the old lane 31 to the new lane 32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">      V = B.CreateCall(</td>
    <td class="lineNumber">510</td>
    <td class="codeline">      V = B.CreateCall(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">          WriteLane,</td>
    <td class="lineNumber">511</td>
    <td class="codeline">          WriteLane,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">          {B.CreateCall(ReadLane, {Old, B.getInt32(31)}), B.getInt32(32), V});</td>
    <td class="lineNumber">512</td>
    <td class="codeline">          {B.CreateCall(ReadLane, {Old, B.getInt32(31)}), B.getInt32(32), V});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">      // Copy the old lane 47 to the new lane 48.</td>
    <td class="lineNumber">514</td>
    <td class="codeline">      // Copy the old lane 47 to the new lane 48.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">      V = B.CreateCall(</td>
    <td class="lineNumber">515</td>
    <td class="codeline">      V = B.CreateCall(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">          WriteLane,</td>
    <td class="lineNumber">516</td>
    <td class="codeline">          WriteLane,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">          {B.CreateCall(ReadLane, {Old, B.getInt32(47)}), B.getInt32(48), V});</td>
    <td class="lineNumber">517</td>
    <td class="codeline">          {B.CreateCall(ReadLane, {Old, B.getInt32(47)}), B.getInt32(48), V});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">}</td>
    <td class="lineNumber">522</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">// Use the builder to create an exclusive scan and compute the final reduced</td>
    <td class="lineNumber">524</td>
    <td class="codeline">// Use the builder to create an exclusive scan and compute the final reduced</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">// value using an iterative approach. This provides an alternative</td>
    <td class="lineNumber">525</td>
    <td class="codeline">// value using an iterative approach. This provides an alternative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">// implementation to DPP which uses WMM for scan computations. This API iterate</td>
    <td class="lineNumber">526</td>
    <td class="codeline">// implementation to DPP which uses WMM for scan computations. This API iterate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">// over active lanes to read, compute and update the value using</td>
    <td class="lineNumber">527</td>
    <td class="codeline">// over active lanes to read, compute and update the value using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">// readlane and writelane intrinsics.</td>
    <td class="lineNumber">528</td>
    <td class="codeline">// readlane and writelane intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">std::pair<Value *, Value *> AMDGPUAtomicOptimizerImpl::buildScanIteratively(</td>
    <td class="lineNumber">529</td>
    <td class="codeline">std::pair<Value *, Value *> AMDGPUAtomicOptimizerImpl::buildScanIteratively(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *const Identity, Value *V,</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *const Identity, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">    Instruction &I, BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const {</td>
    <td class="lineNumber">531</td>
    <td class="codeline">    Instruction &I, BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline"></td>
    <td class="lineNumber">532</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  auto *Ty = I.getType();</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  auto *Ty = I.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  auto *WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  auto *WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  auto *EntryBB = I.getParent();</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  auto *EntryBB = I.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  auto NeedResult = !I.use_empty();</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  auto NeedResult = !I.use_empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  auto *Ballot =</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  auto *Ballot =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td class="lineNumber">539</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  // Start inserting instructions for ComputeLoop block</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  // Start inserting instructions for ComputeLoop block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  B.SetInsertPoint(ComputeLoop);</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  B.SetInsertPoint(ComputeLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  // Phi nodes for Accumulator, Scan results destination, and Active Lanes</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  // Phi nodes for Accumulator, Scan results destination, and Active Lanes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  auto *Accumulator = B.CreatePHI(Ty, 2, "Accumulator");</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  auto *Accumulator = B.CreatePHI(Ty, 2, "Accumulator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  Accumulator->addIncoming(Identity, EntryBB);</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  Accumulator->addIncoming(Identity, EntryBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  PHINode *OldValuePhi = nullptr;</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  PHINode *OldValuePhi = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  if (NeedResult) {</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  if (NeedResult) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">    OldValuePhi = B.CreatePHI(Ty, 2, "OldValuePhi");</td>
    <td class="lineNumber">548</td>
    <td class="codeline">    OldValuePhi = B.CreatePHI(Ty, 2, "OldValuePhi");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">    OldValuePhi->addIncoming(PoisonValue::get(Ty), EntryBB);</td>
    <td class="lineNumber">549</td>
    <td class="codeline">    OldValuePhi->addIncoming(PoisonValue::get(Ty), EntryBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  auto *ActiveBits = B.CreatePHI(WaveTy, 2, "ActiveBits");</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  auto *ActiveBits = B.CreatePHI(WaveTy, 2, "ActiveBits");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  ActiveBits->addIncoming(Ballot, EntryBB);</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  ActiveBits->addIncoming(Ballot, EntryBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  // Use llvm.cttz instrinsic to find the lowest remaining active lane.</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  // Use llvm.cttz instrinsic to find the lowest remaining active lane.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  auto *FF1 =</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  auto *FF1 =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::cttz, WaveTy, {ActiveBits, B.getTrue()});</td>
    <td class="lineNumber">556</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::cttz, WaveTy, {ActiveBits, B.getTrue()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  auto *LaneIdxInt = B.CreateTrunc(FF1, Ty);</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  auto *LaneIdxInt = B.CreateTrunc(FF1, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline"></td>
    <td class="lineNumber">558</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">  // Get the value required for atomic operation</td>
    <td class="lineNumber">559</td>
    <td class="codeline">  // Get the value required for atomic operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">  auto *LaneValue =</td>
    <td class="lineNumber">560</td>
    <td class="codeline">  auto *LaneValue =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {}, {V, LaneIdxInt});</td>
    <td class="lineNumber">561</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {}, {V, LaneIdxInt});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  // Perform writelane if intermediate scan results are required later in the</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  // Perform writelane if intermediate scan results are required later in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  // kernel computations</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  // kernel computations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">  Value *OldValue = nullptr;</td>
    <td class="lineNumber">565</td>
    <td class="codeline">  Value *OldValue = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  if (NeedResult) {</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  if (NeedResult) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">    OldValue = B.CreateIntrinsic(Intrinsic::amdgcn_writelane, {},</td>
    <td class="lineNumber">567</td>
    <td class="codeline">    OldValue = B.CreateIntrinsic(Intrinsic::amdgcn_writelane, {},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">                                 {Accumulator, LaneIdxInt, OldValuePhi});</td>
    <td class="lineNumber">568</td>
    <td class="codeline">                                 {Accumulator, LaneIdxInt, OldValuePhi});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">    OldValuePhi->addIncoming(OldValue, ComputeLoop);</td>
    <td class="lineNumber">569</td>
    <td class="codeline">    OldValuePhi->addIncoming(OldValue, ComputeLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline"></td>
    <td class="lineNumber">571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  // Accumulate the results</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  // Accumulate the results</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  auto *NewAccumulator = buildNonAtomicBinOp(B, Op, Accumulator, LaneValue);</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  auto *NewAccumulator = buildNonAtomicBinOp(B, Op, Accumulator, LaneValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  Accumulator->addIncoming(NewAccumulator, ComputeLoop);</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  Accumulator->addIncoming(NewAccumulator, ComputeLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  // Set bit to zero of current active lane so that for next iteration llvm.cttz</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  // Set bit to zero of current active lane so that for next iteration llvm.cttz</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  // return the next active lane</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  // return the next active lane</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">  auto *Mask = B.CreateShl(ConstantInt::get(WaveTy, 1), FF1);</td>
    <td class="lineNumber">578</td>
    <td class="codeline">  auto *Mask = B.CreateShl(ConstantInt::get(WaveTy, 1), FF1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  auto *InverseMask = B.CreateXor(Mask, ConstantInt::get(WaveTy, -1));</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  auto *InverseMask = B.CreateXor(Mask, ConstantInt::get(WaveTy, -1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  auto *NewActiveBits = B.CreateAnd(ActiveBits, InverseMask);</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  auto *NewActiveBits = B.CreateAnd(ActiveBits, InverseMask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">  ActiveBits->addIncoming(NewActiveBits, ComputeLoop);</td>
    <td class="lineNumber">582</td>
    <td class="codeline">  ActiveBits->addIncoming(NewActiveBits, ComputeLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  // Branch out of the loop when all lanes are processed.</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  // Branch out of the loop when all lanes are processed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  auto *IsEnd = B.CreateICmpEQ(NewActiveBits, ConstantInt::get(WaveTy, 0));</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  auto *IsEnd = B.CreateICmpEQ(NewActiveBits, ConstantInt::get(WaveTy, 0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  B.CreateCondBr(IsEnd, ComputeEnd, ComputeLoop);</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  B.CreateCondBr(IsEnd, ComputeEnd, ComputeLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">  B.SetInsertPoint(ComputeEnd);</td>
    <td class="lineNumber">588</td>
    <td class="codeline">  B.SetInsertPoint(ComputeEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline"></td>
    <td class="lineNumber">589</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  return {OldValue, NewAccumulator};</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  return {OldValue, NewAccumulator};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">}</td>
    <td class="lineNumber">591</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">static APInt getIdentityValueForAtomicOp(AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">593</td>
    <td class="codeline">static APInt getIdentityValueForAtomicOp(AtomicRMWInst::BinOp Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">                                         unsigned BitWidth) {</td>
    <td class="lineNumber">594</td>
    <td class="codeline">                                         unsigned BitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  switch (Op) {</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    llvm_unreachable("Unhandled atomic op");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  case AtomicRMWInst::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  case AtomicRMWInst::Sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  case AtomicRMWInst::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  case AtomicRMWInst::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  case AtomicRMWInst::UMax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    return APInt::getMinValue(BitWidth);</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    return APInt::getMinValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  case AtomicRMWInst::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  case AtomicRMWInst::UMin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    return APInt::getMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  case AtomicRMWInst::Max:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    return APInt::getSignedMinValue(BitWidth);</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    return APInt::getSignedMinValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  case AtomicRMWInst::Min:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    return APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    return APInt::getSignedMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">}</td>
    <td class="lineNumber">612</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">static Value *buildMul(IRBuilder<> &B, Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">614</td>
    <td class="codeline">static Value *buildMul(IRBuilder<> &B, Value *LHS, Value *RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  const ConstantInt *CI = dyn_cast<ConstantInt>(LHS);</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  const ConstantInt *CI = dyn_cast<ConstantInt>(LHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  return (CI && CI->isOne()) ? RHS : B.CreateMul(LHS, RHS);</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  return (CI && CI->isOne()) ? RHS : B.CreateMul(LHS, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">}</td>
    <td class="lineNumber">617</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">void AMDGPUAtomicOptimizerImpl::optimizeAtomic(Instruction &I,</td>
    <td class="lineNumber">619</td>
    <td class="codeline">void AMDGPUAtomicOptimizerImpl::optimizeAtomic(Instruction &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">                                               AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">620</td>
    <td class="codeline">                                               AtomicRMWInst::BinOp Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">                                               unsigned ValIdx,</td>
    <td class="lineNumber">621</td>
    <td class="codeline">                                               unsigned ValIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">                                               bool ValDivergent) const {</td>
    <td class="lineNumber">622</td>
    <td class="codeline">                                               bool ValDivergent) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  // Start building just before the instruction.</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  // Start building just before the instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  IRBuilder<> B(&I);</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  IRBuilder<> B(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  // If we are in a pixel shader, because of how we have to mask out helper</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  // If we are in a pixel shader, because of how we have to mask out helper</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  // lane invocations, we need to record the entry and exit BB's.</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  // lane invocations, we need to record the entry and exit BB's.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  BasicBlock *PixelEntryBB = nullptr;</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  BasicBlock *PixelEntryBB = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  BasicBlock *PixelExitBB = nullptr;</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  BasicBlock *PixelExitBB = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  // If we're optimizing an atomic within a pixel shader, we need to wrap the</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  // If we're optimizing an atomic within a pixel shader, we need to wrap the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  // entire atomic operation in a helper-lane check. We do not want any helper</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  // entire atomic operation in a helper-lane check. We do not want any helper</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  // lanes that are around only for the purposes of derivatives to take part</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  // lanes that are around only for the purposes of derivatives to take part</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  // in any cross-lane communication, and we use a branch on whether the lane is</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  // in any cross-lane communication, and we use a branch on whether the lane is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  // live to do this.</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  // live to do this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">  if (IsPixelShader) {</td>
    <td class="lineNumber">636</td>
    <td class="codeline">  if (IsPixelShader) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">    // Record I's original position as the entry block.</td>
    <td class="lineNumber">637</td>
    <td class="codeline">    // Record I's original position as the entry block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    PixelEntryBB = I.getParent();</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    PixelEntryBB = I.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline"></td>
    <td class="lineNumber">639</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    Value *const Cond = B.CreateIntrinsic(Intrinsic::amdgcn_ps_live, {}, {});</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    Value *const Cond = B.CreateIntrinsic(Intrinsic::amdgcn_ps_live, {}, {});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    Instruction *const NonHelperTerminator =</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    Instruction *const NonHelperTerminator =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">        SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td class="lineNumber">642</td>
    <td class="codeline">        SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">    // Record I's new position as the exit block.</td>
    <td class="lineNumber">644</td>
    <td class="codeline">    // Record I's new position as the exit block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">    PixelExitBB = I.getParent();</td>
    <td class="lineNumber">645</td>
    <td class="codeline">    PixelExitBB = I.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">    I.moveBefore(NonHelperTerminator);</td>
    <td class="lineNumber">647</td>
    <td class="codeline">    I.moveBefore(NonHelperTerminator);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">    B.SetInsertPoint(&I);</td>
    <td class="lineNumber">648</td>
    <td class="codeline">    B.SetInsertPoint(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline"></td>
    <td class="lineNumber">650</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  Type *const Ty = I.getType();</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  Type *const Ty = I.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  const unsigned TyBitWidth = DL->getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  const unsigned TyBitWidth = DL->getTypeSizeInBits(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  auto *const VecTy = FixedVectorType::get(B.getInt32Ty(), 2);</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  auto *const VecTy = FixedVectorType::get(B.getInt32Ty(), 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  // This is the value in the atomic operation we need to combine in order to</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  // This is the value in the atomic operation we need to combine in order to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  // reduce the number of atomic operations.</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  // reduce the number of atomic operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  Value *const V = I.getOperand(ValIdx);</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  Value *const V = I.getOperand(ValIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  // We need to know how many lanes are active within the wavefront, and we do</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  // We need to know how many lanes are active within the wavefront, and we do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  // this by doing a ballot of active lanes.</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  // this by doing a ballot of active lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  Type *const WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  Type *const WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  CallInst *const Ballot =</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  CallInst *const Ballot =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td class="lineNumber">663</td>
    <td class="codeline">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline"></td>
    <td class="lineNumber">664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  // We need to know how many lanes are active within the wavefront that are</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  // We need to know how many lanes are active within the wavefront that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  // below us. If we counted each lane linearly starting from 0, a lane is</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  // below us. If we counted each lane linearly starting from 0, a lane is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  // below us only if its associated index was less than ours. We do this by</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  // below us only if its associated index was less than ours. We do this by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  // using the mbcnt intrinsic.</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  // using the mbcnt intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  Value *Mbcnt;</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  Value *Mbcnt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  if (ST->isWave32()) {</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  if (ST->isWave32()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">                              {Ballot, B.getInt32(0)});</td>
    <td class="lineNumber">672</td>
    <td class="codeline">                              {Ballot, B.getInt32(0)});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    Value *const BitCast = B.CreateBitCast(Ballot, VecTy);</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    Value *const BitCast = B.CreateBitCast(Ballot, VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">    Value *const ExtractLo = B.CreateExtractElement(BitCast, B.getInt32(0));</td>
    <td class="lineNumber">675</td>
    <td class="codeline">    Value *const ExtractLo = B.CreateExtractElement(BitCast, B.getInt32(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    Value *const ExtractHi = B.CreateExtractElement(BitCast, B.getInt32(1));</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    Value *const ExtractHi = B.CreateExtractElement(BitCast, B.getInt32(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td class="lineNumber">677</td>
    <td class="codeline">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">                              {ExtractLo, B.getInt32(0)});</td>
    <td class="lineNumber">678</td>
    <td class="codeline">                              {ExtractLo, B.getInt32(0)});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">    Mbcnt =</td>
    <td class="lineNumber">679</td>
    <td class="codeline">    Mbcnt =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">        B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {ExtractHi, Mbcnt});</td>
    <td class="lineNumber">680</td>
    <td class="codeline">        B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {ExtractHi, Mbcnt});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  Mbcnt = B.CreateIntCast(Mbcnt, Ty, false);</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  Mbcnt = B.CreateIntCast(Mbcnt, Ty, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  Value *const Identity = B.getInt(getIdentityValueForAtomicOp(Op, TyBitWidth));</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  Value *const Identity = B.getInt(getIdentityValueForAtomicOp(Op, TyBitWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  Value *ExclScan = nullptr;</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  Value *ExclScan = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  Value *NewV = nullptr;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  Value *NewV = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  const bool NeedResult = !I.use_empty();</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  const bool NeedResult = !I.use_empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  Function *F = I.getFunction();</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  Function *F = I.getFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  LLVMContext &C = F->getContext();</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  LLVMContext &C = F->getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  BasicBlock *ComputeLoop = nullptr;</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  BasicBlock *ComputeLoop = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  BasicBlock *ComputeEnd = nullptr;</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  BasicBlock *ComputeEnd = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  // If we have a divergent value in each lane, we need to combine the value</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  // If we have a divergent value in each lane, we need to combine the value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  // using DPP.</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  // using DPP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">  if (ValDivergent) {</td>
    <td class="lineNumber">697</td>
    <td class="codeline">  if (ValDivergent) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">    const AtomicRMWInst::BinOp ScanOp =</td>
    <td class="lineNumber">698</td>
    <td class="codeline">    const AtomicRMWInst::BinOp ScanOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">        Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td class="lineNumber">699</td>
    <td class="codeline">        Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">    if (ScanImpl == ScanOptions::DPP) {</td>
    <td class="lineNumber">700</td>
    <td class="codeline">    if (ScanImpl == ScanOptions::DPP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">      // First we need to set all inactive invocations to the identity value, so</td>
    <td class="lineNumber">701</td>
    <td class="codeline">      // First we need to set all inactive invocations to the identity value, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">      // that they can correctly contribute to the final result.</td>
    <td class="lineNumber">702</td>
    <td class="codeline">      // that they can correctly contribute to the final result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">      NewV =</td>
    <td class="lineNumber">703</td>
    <td class="codeline">      NewV =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">          B.CreateIntrinsic(Intrinsic::amdgcn_set_inactive, Ty, {V, Identity});</td>
    <td class="lineNumber">704</td>
    <td class="codeline">          B.CreateIntrinsic(Intrinsic::amdgcn_set_inactive, Ty, {V, Identity});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">      const AtomicRMWInst::BinOp ScanOp =</td>
    <td class="lineNumber">705</td>
    <td class="codeline">      const AtomicRMWInst::BinOp ScanOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">          Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td class="lineNumber">706</td>
    <td class="codeline">          Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">      if (!NeedResult && ST->hasPermLaneX16()) {</td>
    <td class="lineNumber">707</td>
    <td class="codeline">      if (!NeedResult && ST->hasPermLaneX16()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">        // On GFX10 the permlanex16 instruction helps us build a reduction</td>
    <td class="lineNumber">708</td>
    <td class="codeline">        // On GFX10 the permlanex16 instruction helps us build a reduction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">        // without too many readlanes and writelanes, which are generally bad</td>
    <td class="lineNumber">709</td>
    <td class="codeline">        // without too many readlanes and writelanes, which are generally bad</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">        // for performance.</td>
    <td class="lineNumber">710</td>
    <td class="codeline">        // for performance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">        NewV = buildReduction(B, ScanOp, NewV, Identity);</td>
    <td class="lineNumber">711</td>
    <td class="codeline">        NewV = buildReduction(B, ScanOp, NewV, Identity);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">712</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">        NewV = buildScan(B, ScanOp, NewV, Identity);</td>
    <td class="lineNumber">713</td>
    <td class="codeline">        NewV = buildScan(B, ScanOp, NewV, Identity);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">        if (NeedResult)</td>
    <td class="lineNumber">714</td>
    <td class="codeline">        if (NeedResult)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">          ExclScan = buildShiftRight(B, NewV, Identity);</td>
    <td class="lineNumber">715</td>
    <td class="codeline">          ExclScan = buildShiftRight(B, NewV, Identity);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">        // Read the value from the last lane, which has accumulated the values</td>
    <td class="lineNumber">716</td>
    <td class="codeline">        // Read the value from the last lane, which has accumulated the values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">        // of each active lane in the wavefront. This will be our new value</td>
    <td class="lineNumber">717</td>
    <td class="codeline">        // of each active lane in the wavefront. This will be our new value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">        // which we will provide to the atomic operation.</td>
    <td class="lineNumber">718</td>
    <td class="codeline">        // which we will provide to the atomic operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">        Value *const LastLaneIdx = B.getInt32(ST->getWavefrontSize() - 1);</td>
    <td class="lineNumber">719</td>
    <td class="codeline">        Value *const LastLaneIdx = B.getInt32(ST->getWavefrontSize() - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">        assert(TyBitWidth == 32);</td>
    <td class="lineNumber">720</td>
    <td class="codeline">        assert(TyBitWidth == 32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">        NewV = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td class="lineNumber">721</td>
    <td class="codeline">        NewV = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">                                 {NewV, LastLaneIdx});</td>
    <td class="lineNumber">722</td>
    <td class="codeline">                                 {NewV, LastLaneIdx});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">723</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">      // Finally mark the readlanes in the WWM section.</td>
    <td class="lineNumber">724</td>
    <td class="codeline">      // Finally mark the readlanes in the WWM section.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">      NewV = B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, NewV);</td>
    <td class="lineNumber">725</td>
    <td class="codeline">      NewV = B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    } else if (ScanImpl == ScanOptions::Iterative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">      // Alternative implementation for scan</td>
    <td class="lineNumber">727</td>
    <td class="codeline">      // Alternative implementation for scan</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">      ComputeLoop = BasicBlock::Create(C, "ComputeLoop", F);</td>
    <td class="lineNumber">728</td>
    <td class="codeline">      ComputeLoop = BasicBlock::Create(C, "ComputeLoop", F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">      ComputeEnd = BasicBlock::Create(C, "ComputeEnd", F);</td>
    <td class="lineNumber">729</td>
    <td class="codeline">      ComputeEnd = BasicBlock::Create(C, "ComputeEnd", F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">      std::tie(ExclScan, NewV) = buildScanIteratively(B, ScanOp, Identity, V, I,</td>
    <td class="lineNumber">730</td>
    <td class="codeline">      std::tie(ExclScan, NewV) = buildScanIteratively(B, ScanOp, Identity, V, I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">                                                      ComputeLoop, ComputeEnd);</td>
    <td class="lineNumber">731</td>
    <td class="codeline">                                                      ComputeLoop, ComputeEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">732</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">      llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td class="lineNumber">733</td>
    <td class="codeline">      llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">    switch (Op) {</td>
    <td class="lineNumber">736</td>
    <td class="codeline">    switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">737</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">      llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">738</td>
    <td class="codeline">      llvm_unreachable("Unhandled atomic op");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    case AtomicRMWInst::Add:</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    case AtomicRMWInst::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    case AtomicRMWInst::Sub: {</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    case AtomicRMWInst::Sub: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">      // The new value we will be contributing to the atomic operation is the</td>
    <td class="lineNumber">742</td>
    <td class="codeline">      // The new value we will be contributing to the atomic operation is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">      // old value times the number of active lanes.</td>
    <td class="lineNumber">743</td>
    <td class="codeline">      // old value times the number of active lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">      Value *const Ctpop = B.CreateIntCast(</td>
    <td class="lineNumber">744</td>
    <td class="codeline">      Value *const Ctpop = B.CreateIntCast(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td class="lineNumber">745</td>
    <td class="codeline">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">      NewV = buildMul(B, V, Ctpop);</td>
    <td class="lineNumber">746</td>
    <td class="codeline">      NewV = buildMul(B, V, Ctpop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">747</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline"></td>
    <td class="lineNumber">749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    case AtomicRMWInst::And:</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    case AtomicRMWInst::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    case AtomicRMWInst::Or:</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    case AtomicRMWInst::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    case AtomicRMWInst::Max:</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    case AtomicRMWInst::Max:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">    case AtomicRMWInst::Min:</td>
    <td class="lineNumber">753</td>
    <td class="codeline">    case AtomicRMWInst::Min:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    case AtomicRMWInst::UMax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">    case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">755</td>
    <td class="codeline">    case AtomicRMWInst::UMin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">      // These operations with a uniform value are idempotent: doing the atomic</td>
    <td class="lineNumber">756</td>
    <td class="codeline">      // These operations with a uniform value are idempotent: doing the atomic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">      // operation multiple times has the same effect as doing it once.</td>
    <td class="lineNumber">757</td>
    <td class="codeline">      // operation multiple times has the same effect as doing it once.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">      NewV = V;</td>
    <td class="lineNumber">758</td>
    <td class="codeline">      NewV = V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">759</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">    case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">761</td>
    <td class="codeline">    case AtomicRMWInst::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">      // The new value we will be contributing to the atomic operation is the</td>
    <td class="lineNumber">762</td>
    <td class="codeline">      // The new value we will be contributing to the atomic operation is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">      // old value times the parity of the number of active lanes.</td>
    <td class="lineNumber">763</td>
    <td class="codeline">      // old value times the parity of the number of active lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">      Value *const Ctpop = B.CreateIntCast(</td>
    <td class="lineNumber">764</td>
    <td class="codeline">      Value *const Ctpop = B.CreateIntCast(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td class="lineNumber">765</td>
    <td class="codeline">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">      NewV = buildMul(B, V, B.CreateAnd(Ctpop, 1));</td>
    <td class="lineNumber">766</td>
    <td class="codeline">      NewV = buildMul(B, V, B.CreateAnd(Ctpop, 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">767</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline"></td>
    <td class="lineNumber">770</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">  // We only want a single lane to enter our new control flow, and we do this</td>
    <td class="lineNumber">771</td>
    <td class="codeline">  // We only want a single lane to enter our new control flow, and we do this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  // by checking if there are any active lanes below us. Only one lane will</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  // by checking if there are any active lanes below us. Only one lane will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">  // have 0 active lanes below us, so that will be the only one to progress.</td>
    <td class="lineNumber">773</td>
    <td class="codeline">  // have 0 active lanes below us, so that will be the only one to progress.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  Value *const Cond = B.CreateICmpEQ(Mbcnt, B.getIntN(TyBitWidth, 0));</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  Value *const Cond = B.CreateICmpEQ(Mbcnt, B.getIntN(TyBitWidth, 0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  // Store I's original basic block before we split the block.</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  // Store I's original basic block before we split the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  BasicBlock *const EntryBB = I.getParent();</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  BasicBlock *const EntryBB = I.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  // We need to introduce some new control flow to force a single lane to be</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  // We need to introduce some new control flow to force a single lane to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">  // active. We do this by splitting I's basic block at I, and introducing the</td>
    <td class="lineNumber">780</td>
    <td class="codeline">  // active. We do this by splitting I's basic block at I, and introducing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  // new block such that:</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  // new block such that:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  // entry --> single_lane -\</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  // entry --> single_lane -\</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  //       \------------------> exit</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  //       \------------------> exit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">  Instruction *const SingleLaneTerminator =</td>
    <td class="lineNumber">784</td>
    <td class="codeline">  Instruction *const SingleLaneTerminator =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">      SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td class="lineNumber">785</td>
    <td class="codeline">      SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  // At this point, we have split the I's block to allow one lane in wavefront</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  // At this point, we have split the I's block to allow one lane in wavefront</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">  // to update the precomputed reduced value. Also, completed the codegen for</td>
    <td class="lineNumber">788</td>
    <td class="codeline">  // to update the precomputed reduced value. Also, completed the codegen for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  // new control flow i.e. iterative loop which perform reduction and scan using</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  // new control flow i.e. iterative loop which perform reduction and scan using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  // ComputeLoop and ComputeEnd.</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  // ComputeLoop and ComputeEnd.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  // For the new control flow, we need to move branch instruction i.e.</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  // For the new control flow, we need to move branch instruction i.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  // terminator created during SplitBlockAndInsertIfThen from I's block to</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  // terminator created during SplitBlockAndInsertIfThen from I's block to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  // ComputeEnd block. We also need to set up predecessor to next block when</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  // ComputeEnd block. We also need to set up predecessor to next block when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  // single lane done updating the final reduced value.</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  // single lane done updating the final reduced value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">  BasicBlock *Predecessor = nullptr;</td>
    <td class="lineNumber">795</td>
    <td class="codeline">  BasicBlock *Predecessor = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  if (ValDivergent && ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  if (ValDivergent && ScanImpl == ScanOptions::Iterative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">    // Move terminator from I's block to ComputeEnd block.</td>
    <td class="lineNumber">797</td>
    <td class="codeline">    // Move terminator from I's block to ComputeEnd block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">    Instruction *Terminator = EntryBB->getTerminator();</td>
    <td class="lineNumber">798</td>
    <td class="codeline">    Instruction *Terminator = EntryBB->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">    B.SetInsertPoint(ComputeEnd);</td>
    <td class="lineNumber">799</td>
    <td class="codeline">    B.SetInsertPoint(ComputeEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">    Terminator->removeFromParent();</td>
    <td class="lineNumber">800</td>
    <td class="codeline">    Terminator->removeFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">    B.Insert(Terminator);</td>
    <td class="lineNumber">801</td>
    <td class="codeline">    B.Insert(Terminator);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">    // Branch to ComputeLoop Block unconditionally from the I's block for</td>
    <td class="lineNumber">803</td>
    <td class="codeline">    // Branch to ComputeLoop Block unconditionally from the I's block for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">    // iterative approach.</td>
    <td class="lineNumber">804</td>
    <td class="codeline">    // iterative approach.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">    B.SetInsertPoint(EntryBB);</td>
    <td class="lineNumber">805</td>
    <td class="codeline">    B.SetInsertPoint(EntryBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    B.CreateBr(ComputeLoop);</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    B.CreateBr(ComputeLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">    // Update the dominator tree for new control flow.</td>
    <td class="lineNumber">808</td>
    <td class="codeline">    // Update the dominator tree for new control flow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">    DTU.applyUpdates(</td>
    <td class="lineNumber">809</td>
    <td class="codeline">    DTU.applyUpdates(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">        {{DominatorTree::Insert, EntryBB, ComputeLoop},</td>
    <td class="lineNumber">810</td>
    <td class="codeline">        {{DominatorTree::Insert, EntryBB, ComputeLoop},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">         {DominatorTree::Insert, ComputeLoop, ComputeEnd},</td>
    <td class="lineNumber">811</td>
    <td class="codeline">         {DominatorTree::Insert, ComputeLoop, ComputeEnd},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">         {DominatorTree::Delete, EntryBB, SingleLaneTerminator->getParent()}});</td>
    <td class="lineNumber">812</td>
    <td class="codeline">         {DominatorTree::Delete, EntryBB, SingleLaneTerminator->getParent()}});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline"></td>
    <td class="lineNumber">813</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    Predecessor = ComputeEnd;</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    Predecessor = ComputeEnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">815</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">    Predecessor = EntryBB;</td>
    <td class="lineNumber">816</td>
    <td class="codeline">    Predecessor = EntryBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  // Move the IR builder into single_lane next.</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  // Move the IR builder into single_lane next.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  B.SetInsertPoint(SingleLaneTerminator);</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  B.SetInsertPoint(SingleLaneTerminator);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline"></td>
    <td class="lineNumber">820</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  // Clone the original atomic operation into single lane, replacing the</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  // Clone the original atomic operation into single lane, replacing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  // original value with our newly created one.</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  // original value with our newly created one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  Instruction *const NewI = I.clone();</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  Instruction *const NewI = I.clone();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  B.Insert(NewI);</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  B.Insert(NewI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  NewI->setOperand(ValIdx, NewV);</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  NewI->setOperand(ValIdx, NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  // Move the IR builder into exit next, and start inserting just before the</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  // Move the IR builder into exit next, and start inserting just before the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  // original instruction.</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  // original instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  B.SetInsertPoint(&I);</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  B.SetInsertPoint(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  if (NeedResult) {</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  if (NeedResult) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">    // Create a PHI node to get our new atomic result into the exit block.</td>
    <td class="lineNumber">832</td>
    <td class="codeline">    // Create a PHI node to get our new atomic result into the exit block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">    PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td class="lineNumber">833</td>
    <td class="codeline">    PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">    PHI->addIncoming(PoisonValue::get(Ty), Predecessor);</td>
    <td class="lineNumber">834</td>
    <td class="codeline">    PHI->addIncoming(PoisonValue::get(Ty), Predecessor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">    PHI->addIncoming(NewI, SingleLaneTerminator->getParent());</td>
    <td class="lineNumber">835</td>
    <td class="codeline">    PHI->addIncoming(NewI, SingleLaneTerminator->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">    // We need to broadcast the value who was the lowest active lane (the first</td>
    <td class="lineNumber">837</td>
    <td class="codeline">    // We need to broadcast the value who was the lowest active lane (the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">    // lane) to all other lanes in the wavefront. We use an intrinsic for this,</td>
    <td class="lineNumber">838</td>
    <td class="codeline">    // lane) to all other lanes in the wavefront. We use an intrinsic for this,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">    // but have to handle 64-bit broadcasts with two calls to this intrinsic.</td>
    <td class="lineNumber">839</td>
    <td class="codeline">    // but have to handle 64-bit broadcasts with two calls to this intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">    Value *BroadcastI = nullptr;</td>
    <td class="lineNumber">840</td>
    <td class="codeline">    Value *BroadcastI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline"></td>
    <td class="lineNumber">841</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">    if (TyBitWidth == 64) {</td>
    <td class="lineNumber">842</td>
    <td class="codeline">    if (TyBitWidth == 64) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">      Value *const ExtractLo = B.CreateTrunc(PHI, B.getInt32Ty());</td>
    <td class="lineNumber">843</td>
    <td class="codeline">      Value *const ExtractLo = B.CreateTrunc(PHI, B.getInt32Ty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">      Value *const ExtractHi =</td>
    <td class="lineNumber">844</td>
    <td class="codeline">      Value *const ExtractHi =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">          B.CreateTrunc(B.CreateLShr(PHI, 32), B.getInt32Ty());</td>
    <td class="lineNumber">845</td>
    <td class="codeline">          B.CreateTrunc(B.CreateLShr(PHI, 32), B.getInt32Ty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">      CallInst *const ReadFirstLaneLo =</td>
    <td class="lineNumber">846</td>
    <td class="codeline">      CallInst *const ReadFirstLaneLo =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractLo);</td>
    <td class="lineNumber">847</td>
    <td class="codeline">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractLo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">      CallInst *const ReadFirstLaneHi =</td>
    <td class="lineNumber">848</td>
    <td class="codeline">      CallInst *const ReadFirstLaneHi =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractHi);</td>
    <td class="lineNumber">849</td>
    <td class="codeline">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractHi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">      Value *const PartialInsert = B.CreateInsertElement(</td>
    <td class="lineNumber">850</td>
    <td class="codeline">      Value *const PartialInsert = B.CreateInsertElement(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">          PoisonValue::get(VecTy), ReadFirstLaneLo, B.getInt32(0));</td>
    <td class="lineNumber">851</td>
    <td class="codeline">          PoisonValue::get(VecTy), ReadFirstLaneLo, B.getInt32(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">      Value *const Insert =</td>
    <td class="lineNumber">852</td>
    <td class="codeline">      Value *const Insert =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">          B.CreateInsertElement(PartialInsert, ReadFirstLaneHi, B.getInt32(1));</td>
    <td class="lineNumber">853</td>
    <td class="codeline">          B.CreateInsertElement(PartialInsert, ReadFirstLaneHi, B.getInt32(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">      BroadcastI = B.CreateBitCast(Insert, Ty);</td>
    <td class="lineNumber">854</td>
    <td class="codeline">      BroadcastI = B.CreateBitCast(Insert, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">    } else if (TyBitWidth == 32) {</td>
    <td class="lineNumber">855</td>
    <td class="codeline">    } else if (TyBitWidth == 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline"></td>
    <td class="lineNumber">856</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">      BroadcastI = B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, PHI);</td>
    <td class="lineNumber">857</td>
    <td class="codeline">      BroadcastI = B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, PHI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">858</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">      llvm_unreachable("Unhandled atomic bit width");</td>
    <td class="lineNumber">859</td>
    <td class="codeline">      llvm_unreachable("Unhandled atomic bit width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">860</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    // Now that we have the result of our single atomic operation, we need to</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    // Now that we have the result of our single atomic operation, we need to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    // get our individual lane's slice into the result. We use the lane offset</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    // get our individual lane's slice into the result. We use the lane offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">    // we previously calculated combined with the atomic result value we got</td>
    <td class="lineNumber">864</td>
    <td class="codeline">    // we previously calculated combined with the atomic result value we got</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    // from the first lane, to get our lane's index into the atomic result.</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    // from the first lane, to get our lane's index into the atomic result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    Value *LaneOffset = nullptr;</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    Value *LaneOffset = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    if (ValDivergent) {</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    if (ValDivergent) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">      if (ScanImpl == ScanOptions::DPP) {</td>
    <td class="lineNumber">868</td>
    <td class="codeline">      if (ScanImpl == ScanOptions::DPP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">        LaneOffset =</td>
    <td class="lineNumber">869</td>
    <td class="codeline">        LaneOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">            B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, ExclScan);</td>
    <td class="lineNumber">870</td>
    <td class="codeline">            B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, ExclScan);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">      } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">871</td>
    <td class="codeline">      } else if (ScanImpl == ScanOptions::Iterative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">        LaneOffset = ExclScan;</td>
    <td class="lineNumber">872</td>
    <td class="codeline">        LaneOffset = ExclScan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">873</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">        llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td class="lineNumber">874</td>
    <td class="codeline">        llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">875</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">876</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">      switch (Op) {</td>
    <td class="lineNumber">877</td>
    <td class="codeline">      switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">      default:</td>
    <td class="lineNumber">878</td>
    <td class="codeline">      default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">        llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">879</td>
    <td class="codeline">        llvm_unreachable("Unhandled atomic op");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">      case AtomicRMWInst::Add:</td>
    <td class="lineNumber">880</td>
    <td class="codeline">      case AtomicRMWInst::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">      case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">881</td>
    <td class="codeline">      case AtomicRMWInst::Sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">        LaneOffset = buildMul(B, V, Mbcnt);</td>
    <td class="lineNumber">882</td>
    <td class="codeline">        LaneOffset = buildMul(B, V, Mbcnt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">883</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">      case AtomicRMWInst::And:</td>
    <td class="lineNumber">884</td>
    <td class="codeline">      case AtomicRMWInst::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">      case AtomicRMWInst::Or:</td>
    <td class="lineNumber">885</td>
    <td class="codeline">      case AtomicRMWInst::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">      case AtomicRMWInst::Max:</td>
    <td class="lineNumber">886</td>
    <td class="codeline">      case AtomicRMWInst::Max:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">      case AtomicRMWInst::Min:</td>
    <td class="lineNumber">887</td>
    <td class="codeline">      case AtomicRMWInst::Min:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">      case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">888</td>
    <td class="codeline">      case AtomicRMWInst::UMax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">      case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">889</td>
    <td class="codeline">      case AtomicRMWInst::UMin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">        LaneOffset = B.CreateSelect(Cond, Identity, V);</td>
    <td class="lineNumber">890</td>
    <td class="codeline">        LaneOffset = B.CreateSelect(Cond, Identity, V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">891</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">      case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">892</td>
    <td class="codeline">      case AtomicRMWInst::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">        LaneOffset = buildMul(B, V, B.CreateAnd(Mbcnt, 1));</td>
    <td class="lineNumber">893</td>
    <td class="codeline">        LaneOffset = buildMul(B, V, B.CreateAnd(Mbcnt, 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">894</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">895</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">    Value *const Result = buildNonAtomicBinOp(B, Op, BroadcastI, LaneOffset);</td>
    <td class="lineNumber">897</td>
    <td class="codeline">    Value *const Result = buildNonAtomicBinOp(B, Op, BroadcastI, LaneOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">    if (IsPixelShader) {</td>
    <td class="lineNumber">899</td>
    <td class="codeline">    if (IsPixelShader) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">      // Need a final PHI to reconverge to above the helper lane branch mask.</td>
    <td class="lineNumber">900</td>
    <td class="codeline">      // Need a final PHI to reconverge to above the helper lane branch mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">      B.SetInsertPoint(PixelExitBB->getFirstNonPHI());</td>
    <td class="lineNumber">901</td>
    <td class="codeline">      B.SetInsertPoint(PixelExitBB->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">      PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td class="lineNumber">903</td>
    <td class="codeline">      PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">      PHI->addIncoming(PoisonValue::get(Ty), PixelEntryBB);</td>
    <td class="lineNumber">904</td>
    <td class="codeline">      PHI->addIncoming(PoisonValue::get(Ty), PixelEntryBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">      PHI->addIncoming(Result, I.getParent());</td>
    <td class="lineNumber">905</td>
    <td class="codeline">      PHI->addIncoming(Result, I.getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">      I.replaceAllUsesWith(PHI);</td>
    <td class="lineNumber">906</td>
    <td class="codeline">      I.replaceAllUsesWith(PHI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">      // Replace the original atomic instruction with the new one.</td>
    <td class="lineNumber">908</td>
    <td class="codeline">      // Replace the original atomic instruction with the new one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">      I.replaceAllUsesWith(Result);</td>
    <td class="lineNumber">909</td>
    <td class="codeline">      I.replaceAllUsesWith(Result);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">910</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  // And delete the original.</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  // And delete the original.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  I.eraseFromParent();</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">}</td>
    <td class="lineNumber">915</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td class="lineNumber">917</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">                      "AMDGPU atomic optimizations", false, false)</td>
    <td class="lineNumber">918</td>
    <td class="codeline">                      "AMDGPU atomic optimizations", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td class="lineNumber">919</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">920</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">INITIALIZE_PASS_END(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td class="lineNumber">921</td>
    <td class="codeline">INITIALIZE_PASS_END(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">                    "AMDGPU atomic optimizations", false, false)</td>
    <td class="lineNumber">922</td>
    <td class="codeline">                    "AMDGPU atomic optimizations", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">FunctionPass *llvm::createAMDGPUAtomicOptimizerPass(ScanOptions ScanStrategy) {</td>
    <td class="lineNumber">924</td>
    <td class="codeline">FunctionPass *llvm::createAMDGPUAtomicOptimizerPass(ScanOptions ScanStrategy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  return new AMDGPUAtomicOptimizer(ScanStrategy);</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  return new AMDGPUAtomicOptimizer(ScanStrategy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">}</td>
    <td class="lineNumber">926</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- AMDGPUAtomicOptimizer.cpp -----------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- AMDGPUAtomicOptimizer.cpp -----------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This pass optimizes atomic operations by using a single lane of a wavefront</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This pass optimizes atomic operations by using a single lane of a wavefront</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// to perform the atomic operation, thus reducing contention on that memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// to perform the atomic operation, thus reducing contention on that memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">/// location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">/// location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">/// Atomic optimizer uses following strategies to compute scan and reduced</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">/// Atomic optimizer uses following strategies to compute scan and reduced</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">/// values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">/// values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">/// 1. DPP -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">/// 1. DPP -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">///   This is the most efficient implementation for scan. DPP uses Whole Wave</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">///   This is the most efficient implementation for scan. DPP uses Whole Wave</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">///   Mode (WWM)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">///   Mode (WWM)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">/// 2. Iterative -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">/// 2. Iterative -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">//    An alternative implementation iterates over all active lanes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">//    An alternative implementation iterates over all active lanes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">///   of Wavefront using llvm.cttz and performs scan  using readlane & writelane</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">///   of Wavefront using llvm.cttz and performs scan  using readlane & writelane</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">///   intrinsics</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">///   intrinsics</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "AMDGPU.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "AMDGPU.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "GCNSubtarget.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "GCNSubtarget.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#define DEBUG_TYPE "amdgpu-atomic-optimizer"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#define DEBUG_TYPE "amdgpu-atomic-optimizer"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">using namespace llvm::AMDGPU;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">using namespace llvm::AMDGPU;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">struct ReplacementInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">struct ReplacementInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">  Instruction *I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">  Instruction *I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">  AtomicRMWInst::BinOp Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">  AtomicRMWInst::BinOp Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">  unsigned ValIdx;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">  unsigned ValIdx;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">  bool ValDivergent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">  bool ValDivergent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">class AMDGPUAtomicOptimizer : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">class AMDGPUAtomicOptimizer : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">  ScanOptions ScanImpl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">  ScanOptions ScanImpl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">  AMDGPUAtomicOptimizer(ScanOptions ScanImpl)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">  AMDGPUAtomicOptimizer(ScanOptions ScanImpl)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">      : FunctionPass(ID), ScanImpl(ScanImpl) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">      : FunctionPass(ID), ScanImpl(ScanImpl) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">class AMDGPUAtomicOptimizerImpl</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">class AMDGPUAtomicOptimizerImpl</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">    : public InstVisitor<AMDGPUAtomicOptimizerImpl> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">    : public InstVisitor<AMDGPUAtomicOptimizerImpl> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">  SmallVector<ReplacementInfo, 8> ToReplace;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">  SmallVector<ReplacementInfo, 8> ToReplace;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">  const UniformityInfo *UA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">  const UniformityInfo *UA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">  const DataLayout *DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">  const DataLayout *DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  DomTreeUpdater &DTU;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  DomTreeUpdater &DTU;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">  const GCNSubtarget *ST;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">  const GCNSubtarget *ST;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">  bool IsPixelShader;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">  bool IsPixelShader;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">  ScanOptions ScanImpl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">  ScanOptions ScanImpl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  Value *buildReduction(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  Value *buildReduction(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">                        Value *const Identity) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">                        Value *const Identity) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  Value *buildScan(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  Value *buildScan(IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">                   Value *const Identity) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">                   Value *const Identity) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  Value *buildShiftRight(IRBuilder<> &B, Value *V, Value *const Identity) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  Value *buildShiftRight(IRBuilder<> &B, Value *V, Value *const Identity) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  std::pair<Value *, Value *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  std::pair<Value *, Value *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  buildScanIteratively(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  buildScanIteratively(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">                       Value *const Identity, Value *V, Instruction &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">                       Value *const Identity, Value *V, Instruction &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">                       BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">                       BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  void optimizeAtomic(Instruction &I, AtomicRMWInst::BinOp Op, unsigned ValIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  void optimizeAtomic(Instruction &I, AtomicRMWInst::BinOp Op, unsigned ValIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">                      bool ValDivergent) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">                      bool ValDivergent) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  AMDGPUAtomicOptimizerImpl() = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  AMDGPUAtomicOptimizerImpl() = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  AMDGPUAtomicOptimizerImpl(const UniformityInfo *UA, const DataLayout *DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  AMDGPUAtomicOptimizerImpl(const UniformityInfo *UA, const DataLayout *DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">                            DomTreeUpdater &DTU, const GCNSubtarget *ST,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">                            DomTreeUpdater &DTU, const GCNSubtarget *ST,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">                            bool IsPixelShader, ScanOptions ScanImpl)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">                            bool IsPixelShader, ScanOptions ScanImpl)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">      : UA(UA), DL(DL), DTU(DTU), ST(ST), IsPixelShader(IsPixelShader),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">      : UA(UA), DL(DL), DTU(DTU), ST(ST), IsPixelShader(IsPixelShader),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">        ScanImpl(ScanImpl) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">        ScanImpl(ScanImpl) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  bool run(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  bool run(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  void visitAtomicRMWInst(AtomicRMWInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  void visitAtomicRMWInst(AtomicRMWInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  void visitIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  void visitIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">char AMDGPUAtomicOptimizer::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">char AMDGPUAtomicOptimizer::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">char &llvm::AMDGPUAtomicOptimizerID = AMDGPUAtomicOptimizer::ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">char &llvm::AMDGPUAtomicOptimizerID = AMDGPUAtomicOptimizer::ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">bool AMDGPUAtomicOptimizer::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">bool AMDGPUAtomicOptimizer::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  if (skipFunction(F)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  if (skipFunction(F)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  const UniformityInfo *UA =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  const UniformityInfo *UA =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">      &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">      &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  DominatorTreeWrapperPass *const DTW =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  DominatorTreeWrapperPass *const DTW =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">      getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">      getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  DomTreeUpdater DTU(DTW ? &DTW->getDomTree() : nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  DomTreeUpdater DTU(DTW ? &DTW->getDomTree() : nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  const TargetPassConfig &TPC = getAnalysis<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  const TargetPassConfig &TPC = getAnalysis<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  const TargetMachine &TM = TPC.getTM<TargetMachine>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  const TargetMachine &TM = TPC.getTM<TargetMachine>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  return AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  return AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">      .run(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">      .run(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">PreservedAnalyses AMDGPUAtomicOptimizerPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">PreservedAnalyses AMDGPUAtomicOptimizerPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">                                                 FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">                                                 FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  const auto *UA = &AM.getResult<UniformityInfoAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  const auto *UA = &AM.getResult<UniformityInfoAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  const DataLayout *DL = &F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  DomTreeUpdater DTU(&AM.getResult<DominatorTreeAnalysis>(F),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  DomTreeUpdater DTU(&AM.getResult<DominatorTreeAnalysis>(F),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">                     DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  const GCNSubtarget *ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  bool IsPixelShader = F.getCallingConv() == CallingConv::AMDGPU_PS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  bool IsChanged =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  bool IsChanged =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">      AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">      AMDGPUAtomicOptimizerImpl(UA, DL, DTU, ST, IsPixelShader, ScanImpl)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">          .run(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">          .run(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  if (!IsChanged) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  if (!IsChanged) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  return PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  return PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">bool AMDGPUAtomicOptimizerImpl::run(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">bool AMDGPUAtomicOptimizerImpl::run(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  // Scan option None disables the Pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  // Scan option None disables the Pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  if (ScanImpl == ScanOptions::None) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  if (ScanImpl == ScanOptions::None) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  visit(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  visit(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  const bool Changed = !ToReplace.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  const bool Changed = !ToReplace.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  for (ReplacementInfo &Info : ToReplace) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  for (ReplacementInfo &Info : ToReplace) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    optimizeAtomic(*Info.I, Info.Op, Info.ValIdx, Info.ValDivergent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    optimizeAtomic(*Info.I, Info.Op, Info.ValIdx, Info.ValDivergent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  ToReplace.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  ToReplace.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">void AMDGPUAtomicOptimizerImpl::visitAtomicRMWInst(AtomicRMWInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">void AMDGPUAtomicOptimizerImpl::visitAtomicRMWInst(AtomicRMWInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  // Early exit for unhandled address space atomic instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  // Early exit for unhandled address space atomic instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  switch (I.getPointerAddressSpace()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  switch (I.getPointerAddressSpace()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  case AMDGPUAS::GLOBAL_ADDRESS:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  case AMDGPUAS::GLOBAL_ADDRESS:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  case AMDGPUAS::LOCAL_ADDRESS:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  case AMDGPUAS::LOCAL_ADDRESS:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  AtomicRMWInst::BinOp Op = I.getOperation();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  AtomicRMWInst::BinOp Op = I.getOperation();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  const unsigned PtrIdx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  const unsigned PtrIdx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  const unsigned ValIdx = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  const unsigned ValIdx = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  // If the pointer operand is divergent, then each lane is doing an atomic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  // If the pointer operand is divergent, then each lane is doing an atomic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  // operation on a different address, and we cannot optimize that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  // operation on a different address, and we cannot optimize that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  if (UA->isDivergentUse(I.getOperandUse(PtrIdx))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  if (UA->isDivergentUse(I.getOperandUse(PtrIdx))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  // If the value operand is divergent, each lane is contributing a different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  // If the value operand is divergent, each lane is contributing a different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  // bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  // bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  if (ValDivergent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  if (ValDivergent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  // remember the instruction so we can come back to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  // remember the instruction so we can come back to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  ToReplace.push_back(Info);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  ToReplace.push_back(Info);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">void AMDGPUAtomicOptimizerImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">void AMDGPUAtomicOptimizerImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  AtomicRMWInst::BinOp Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  AtomicRMWInst::BinOp Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  switch (I.getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  switch (I.getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">    Op = AtomicRMWInst::Add;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">    Op = AtomicRMWInst::Add;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_sub:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_sub:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">    Op = AtomicRMWInst::Sub;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">    Op = AtomicRMWInst::Sub;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_and:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_and:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_and:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    Op = AtomicRMWInst::And;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    Op = AtomicRMWInst::And;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_or:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_or:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    Op = AtomicRMWInst::Or;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    Op = AtomicRMWInst::Or;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_xor:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_xor:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">    Op = AtomicRMWInst::Xor;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">    Op = AtomicRMWInst::Xor;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_smin:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_smin:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">    Op = AtomicRMWInst::Min;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">    Op = AtomicRMWInst::Min;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_umin:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_umin:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    Op = AtomicRMWInst::UMin;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    Op = AtomicRMWInst::UMin;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_smax:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_smax:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_smax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    Op = AtomicRMWInst::Max;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    Op = AtomicRMWInst::Max;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_umax:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  case Intrinsic::amdgcn_buffer_atomic_umax:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  case Intrinsic::amdgcn_struct_ptr_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  case Intrinsic::amdgcn_raw_ptr_buffer_atomic_umax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">    Op = AtomicRMWInst::UMax;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">    Op = AtomicRMWInst::UMax;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  const unsigned ValIdx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  const unsigned ValIdx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  const bool ValDivergent = UA->isDivergentUse(I.getOperandUse(ValIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  // If the value operand is divergent, each lane is contributing a different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  // If the value operand is divergent, each lane is contributing a different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  // value to the atomic calculation. We can only optimize divergent values if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  // we have DPP available on our subtarget, and the atomic operation is 32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  // bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  // bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">  if (ValDivergent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">  if (ValDivergent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">      (!ST->hasDPP() || DL->getTypeSizeInBits(I.getType()) != 32)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  // If any of the other arguments to the intrinsic are divergent, we can't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  // If any of the other arguments to the intrinsic are divergent, we can't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">  // optimize the operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">  // optimize the operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">  for (unsigned Idx = 1; Idx < I.getNumOperands(); Idx++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">  for (unsigned Idx = 1; Idx < I.getNumOperands(); Idx++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">    if (UA->isDivergentUse(I.getOperandUse(Idx))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">    if (UA->isDivergentUse(I.getOperandUse(Idx))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  // If we get here, we can optimize the atomic using a single wavefront-wide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  // atomic operation to do the calculation for the entire wavefront, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  // remember the instruction so we can come back to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  // remember the instruction so we can come back to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  const ReplacementInfo Info = {&I, Op, ValIdx, ValDivergent};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  ToReplace.push_back(Info);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  ToReplace.push_back(Info);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">// Use the builder to create the non-atomic counterpart of the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">// Use the builder to create the non-atomic counterpart of the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">// atomicrmw binary op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">// atomicrmw binary op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">static Value *buildNonAtomicBinOp(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">static Value *buildNonAtomicBinOp(IRBuilder<> &B, AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">                                  Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">                                  Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">  CmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">  CmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">  switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">  switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">    llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">    llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Add, LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Add, LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Sub, LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Sub, LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::And, LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::And, LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Or, LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Or, LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Xor, LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">    return B.CreateBinOp(Instruction::Xor, LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_SLT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_SLT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_UGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_UGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_ULT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">    Pred = CmpInst::ICMP_ULT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  Value *Cond = B.CreateICmp(Pred, LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  Value *Cond = B.CreateICmp(Pred, LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  return B.CreateSelect(Cond, LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  return B.CreateSelect(Cond, LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">// Use the builder to create a reduction of V across the wavefront, with all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">// Use the builder to create a reduction of V across the wavefront, with all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">// lanes active, returning the same result in all lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">// lanes active, returning the same result in all lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">Value *AMDGPUAtomicOptimizerImpl::buildReduction(IRBuilder<> &B,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">Value *AMDGPUAtomicOptimizerImpl::buildReduction(IRBuilder<> &B,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">                                                 AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">                                                 AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">                                                 Value *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">                                                 Value *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">                                                 Value *const Identity) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">                                                 Value *const Identity) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  Function *UpdateDPP =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  Function *UpdateDPP =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  // Reduce within each row of 16 lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  // Reduce within each row of 16 lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::ROW_XMASK0 | 1 << Idx),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::ROW_XMASK0 | 1 << Idx),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  // Reduce within each pair of rows (i.e. 32 lanes).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  // Reduce within each pair of rows (i.e. 32 lanes).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  assert(ST->hasPermLaneX16());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  assert(ST->hasPermLaneX16());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">      B, Op, V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">      B, Op, V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">      B.CreateIntrinsic(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">      B.CreateIntrinsic(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">          Intrinsic::amdgcn_permlanex16, {},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">          Intrinsic::amdgcn_permlanex16, {},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">          {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">          {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  if (ST->isWave32())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  if (ST->isWave32())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  if (ST->hasPermLane64()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  if (ST->hasPermLane64()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    // Reduce across the upper and lower 32 lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    // Reduce across the upper and lower 32 lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    return buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    return buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">        B, Op, V, B.CreateIntrinsic(Intrinsic::amdgcn_permlane64, {}, V));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">        B, Op, V, B.CreateIntrinsic(Intrinsic::amdgcn_permlane64, {}, V));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  // Pick an arbitrary lane from 0..31 and an arbitrary lane from 32..63 and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  // Pick an arbitrary lane from 0..31 and an arbitrary lane from 32..63 and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  // combine them with a scalar operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  // combine them with a scalar operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  Function *ReadLane =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  Function *ReadLane =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  Value *const Lane0 = B.CreateCall(ReadLane, {V, B.getInt32(0)});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  Value *const Lane0 = B.CreateCall(ReadLane, {V, B.getInt32(0)});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  Value *const Lane32 = B.CreateCall(ReadLane, {V, B.getInt32(32)});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  Value *const Lane32 = B.CreateCall(ReadLane, {V, B.getInt32(32)});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  return buildNonAtomicBinOp(B, Op, Lane0, Lane32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  return buildNonAtomicBinOp(B, Op, Lane0, Lane32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">// Use the builder to create an inclusive scan of V across the wavefront, with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">// Use the builder to create an inclusive scan of V across the wavefront, with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">// all lanes active.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">// all lanes active.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">Value *AMDGPUAtomicOptimizerImpl::buildScan(IRBuilder<> &B,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">Value *AMDGPUAtomicOptimizerImpl::buildScan(IRBuilder<> &B,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">                                            AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">                                            AtomicRMWInst::BinOp Op, Value *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">                                            Value *const Identity) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">                                            Value *const Identity) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  Function *UpdateDPP =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  Function *UpdateDPP =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  for (unsigned Idx = 0; Idx < 4; Idx++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 | 1 << Idx),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 | 1 << Idx),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  if (ST->hasDPPBroadcasts()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  if (ST->hasDPPBroadcasts()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">    // GFX9 has DPP row broadcast operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">    // GFX9 has DPP row broadcast operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::BCAST15), B.getInt32(0xa),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::BCAST15), B.getInt32(0xa),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::BCAST31), B.getInt32(0xc),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::BCAST31), B.getInt32(0xc),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">    // row operations we have to use permlane or readlane.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">    // row operations we have to use permlane or readlane.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">    // Combine lane 15 into lanes 16..31 (and, for wave 64, lane 47 into lanes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">    // Combine lane 15 into lanes 16..31 (and, for wave 64, lane 47 into lanes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">    // 48..63).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">    // 48..63).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">    assert(ST->hasPermLaneX16());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">    assert(ST->hasPermLaneX16());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">    Value *const PermX = B.CreateIntrinsic(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">    Value *const PermX = B.CreateIntrinsic(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">        Intrinsic::amdgcn_permlanex16, {},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">        Intrinsic::amdgcn_permlanex16, {},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">        {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">        {V, V, B.getInt32(-1), B.getInt32(-1), B.getFalse(), B.getFalse()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">    V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">        B, Op, V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">        B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">                     {Identity, PermX, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">                     {Identity, PermX, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">                      B.getInt32(0xa), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">                      B.getInt32(0xa), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">    if (!ST->isWave32()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">    if (!ST->isWave32()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">      // Combine lane 31 into lanes 32..63.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">      // Combine lane 31 into lanes 32..63.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">      Value *const Lane31 = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">      Value *const Lane31 = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">                                              {V, B.getInt32(31)});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">                                              {V, B.getInt32(31)});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">      V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">      V = buildNonAtomicBinOp(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">          B, Op, V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">          B, Op, V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">          B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">          B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">                       {Identity, Lane31, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">                       {Identity, Lane31, B.getInt32(DPP::QUAD_PERM_ID),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">                        B.getInt32(0xc), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">                        B.getInt32(0xc), B.getInt32(0xf), B.getFalse()}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">// Use the builder to create a shift right of V across the wavefront, with all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">// Use the builder to create a shift right of V across the wavefront, with all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">// lanes active, to turn an inclusive scan into an exclusive scan.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">// lanes active, to turn an inclusive scan into an exclusive scan.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">Value *AMDGPUAtomicOptimizerImpl::buildShiftRight(IRBuilder<> &B, Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">Value *AMDGPUAtomicOptimizerImpl::buildShiftRight(IRBuilder<> &B, Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">                                                  Value *const Identity) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">                                                  Value *const Identity) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  Type *const Ty = V->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  Module *M = B.GetInsertBlock()->getModule();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">  Function *UpdateDPP =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">  Function *UpdateDPP =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">      Intrinsic::getDeclaration(M, Intrinsic::amdgcn_update_dpp, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  if (ST->hasDPPWavefrontShifts()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  if (ST->hasDPPWavefrontShifts()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">    // GFX9 has DPP wavefront shift operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    // GFX9 has DPP wavefront shift operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">    V = B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">    V = B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::WAVE_SHR1), B.getInt32(0xf),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::WAVE_SHR1), B.getInt32(0xf),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getFalse()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getFalse()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">    Function *ReadLane =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">    Function *ReadLane =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_readlane, {});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">    Function *WriteLane =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    Function *WriteLane =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_writelane, {});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">        Intrinsic::getDeclaration(M, Intrinsic::amdgcn_writelane, {});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    // On GFX10 all DPP operations are confined to a single row. To get cross-</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">    // row operations we have to use permlane or readlane.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">    // row operations we have to use permlane or readlane.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    Value *Old = V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    Value *Old = V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    V = B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    V = B.CreateCall(UpdateDPP,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 + 1),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">                     {Identity, V, B.getInt32(DPP::ROW_SHR0 + 1),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">                      B.getInt32(0xf), B.getInt32(0xf), B.getFalse()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">    // Copy the old lane 15 to the new lane 16.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">    // Copy the old lane 15 to the new lane 16.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">    V = B.CreateCall(WriteLane, {B.CreateCall(ReadLane, {Old, B.getInt32(15)}),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">    V = B.CreateCall(WriteLane, {B.CreateCall(ReadLane, {Old, B.getInt32(15)}),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">                                 B.getInt32(16), V});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">                                 B.getInt32(16), V});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">    if (!ST->isWave32()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">    if (!ST->isWave32()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">      // Copy the old lane 31 to the new lane 32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">      // Copy the old lane 31 to the new lane 32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">      V = B.CreateCall(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">      V = B.CreateCall(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">          WriteLane,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">          WriteLane,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">          {B.CreateCall(ReadLane, {Old, B.getInt32(31)}), B.getInt32(32), V});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">          {B.CreateCall(ReadLane, {Old, B.getInt32(31)}), B.getInt32(32), V});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">      // Copy the old lane 47 to the new lane 48.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">      // Copy the old lane 47 to the new lane 48.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">      V = B.CreateCall(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">      V = B.CreateCall(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">          WriteLane,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">          WriteLane,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">          {B.CreateCall(ReadLane, {Old, B.getInt32(47)}), B.getInt32(48), V});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">          {B.CreateCall(ReadLane, {Old, B.getInt32(47)}), B.getInt32(48), V});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">// Use the builder to create an exclusive scan and compute the final reduced</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">// Use the builder to create an exclusive scan and compute the final reduced</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">// value using an iterative approach. This provides an alternative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">// value using an iterative approach. This provides an alternative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">// implementation to DPP which uses WMM for scan computations. This API iterate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">// implementation to DPP which uses WMM for scan computations. This API iterate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">// over active lanes to read, compute and update the value using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">// over active lanes to read, compute and update the value using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">// readlane and writelane intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">// readlane and writelane intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">std::pair<Value *, Value *> AMDGPUAtomicOptimizerImpl::buildScanIteratively(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">std::pair<Value *, Value *> AMDGPUAtomicOptimizerImpl::buildScanIteratively(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *const Identity, Value *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    IRBuilder<> &B, AtomicRMWInst::BinOp Op, Value *const Identity, Value *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">    Instruction &I, BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">    Instruction &I, BasicBlock *ComputeLoop, BasicBlock *ComputeEnd) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  auto *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  auto *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  auto *WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  auto *WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  auto *EntryBB = I.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  auto *EntryBB = I.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  auto NeedResult = !I.use_empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  auto NeedResult = !I.use_empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  auto *Ballot =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  auto *Ballot =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  // Start inserting instructions for ComputeLoop block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  // Start inserting instructions for ComputeLoop block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  B.SetInsertPoint(ComputeLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  B.SetInsertPoint(ComputeLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  // Phi nodes for Accumulator, Scan results destination, and Active Lanes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  // Phi nodes for Accumulator, Scan results destination, and Active Lanes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  auto *Accumulator = B.CreatePHI(Ty, 2, "Accumulator");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  auto *Accumulator = B.CreatePHI(Ty, 2, "Accumulator");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  Accumulator->addIncoming(Identity, EntryBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  Accumulator->addIncoming(Identity, EntryBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  PHINode *OldValuePhi = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  PHINode *OldValuePhi = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  if (NeedResult) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  if (NeedResult) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">    OldValuePhi = B.CreatePHI(Ty, 2, "OldValuePhi");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">    OldValuePhi = B.CreatePHI(Ty, 2, "OldValuePhi");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">    OldValuePhi->addIncoming(PoisonValue::get(Ty), EntryBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">    OldValuePhi->addIncoming(PoisonValue::get(Ty), EntryBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  auto *ActiveBits = B.CreatePHI(WaveTy, 2, "ActiveBits");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  auto *ActiveBits = B.CreatePHI(WaveTy, 2, "ActiveBits");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  ActiveBits->addIncoming(Ballot, EntryBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  ActiveBits->addIncoming(Ballot, EntryBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  // Use llvm.cttz instrinsic to find the lowest remaining active lane.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  // Use llvm.cttz instrinsic to find the lowest remaining active lane.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  auto *FF1 =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  auto *FF1 =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::cttz, WaveTy, {ActiveBits, B.getTrue()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::cttz, WaveTy, {ActiveBits, B.getTrue()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">  auto *LaneIdxInt = B.CreateTrunc(FF1, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">  auto *LaneIdxInt = B.CreateTrunc(FF1, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">  // Get the value required for atomic operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">  // Get the value required for atomic operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">  auto *LaneValue =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">  auto *LaneValue =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {}, {V, LaneIdxInt});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {}, {V, LaneIdxInt});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  // Perform writelane if intermediate scan results are required later in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  // Perform writelane if intermediate scan results are required later in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  // kernel computations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  // kernel computations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">  Value *OldValue = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">  Value *OldValue = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  if (NeedResult) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  if (NeedResult) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">    OldValue = B.CreateIntrinsic(Intrinsic::amdgcn_writelane, {},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">    OldValue = B.CreateIntrinsic(Intrinsic::amdgcn_writelane, {},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">                                 {Accumulator, LaneIdxInt, OldValuePhi});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">                                 {Accumulator, LaneIdxInt, OldValuePhi});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">    OldValuePhi->addIncoming(OldValue, ComputeLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">    OldValuePhi->addIncoming(OldValue, ComputeLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">  // Accumulate the results</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">  // Accumulate the results</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  auto *NewAccumulator = buildNonAtomicBinOp(B, Op, Accumulator, LaneValue);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  auto *NewAccumulator = buildNonAtomicBinOp(B, Op, Accumulator, LaneValue);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  Accumulator->addIncoming(NewAccumulator, ComputeLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  Accumulator->addIncoming(NewAccumulator, ComputeLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  // Set bit to zero of current active lane so that for next iteration llvm.cttz</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  // Set bit to zero of current active lane so that for next iteration llvm.cttz</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  // return the next active lane</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  // return the next active lane</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">  auto *Mask = B.CreateShl(ConstantInt::get(WaveTy, 1), FF1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">  auto *Mask = B.CreateShl(ConstantInt::get(WaveTy, 1), FF1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  auto *InverseMask = B.CreateXor(Mask, ConstantInt::get(WaveTy, -1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  auto *InverseMask = B.CreateXor(Mask, ConstantInt::get(WaveTy, -1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  auto *NewActiveBits = B.CreateAnd(ActiveBits, InverseMask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  auto *NewActiveBits = B.CreateAnd(ActiveBits, InverseMask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">  ActiveBits->addIncoming(NewActiveBits, ComputeLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">  ActiveBits->addIncoming(NewActiveBits, ComputeLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  // Branch out of the loop when all lanes are processed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  // Branch out of the loop when all lanes are processed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  auto *IsEnd = B.CreateICmpEQ(NewActiveBits, ConstantInt::get(WaveTy, 0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  auto *IsEnd = B.CreateICmpEQ(NewActiveBits, ConstantInt::get(WaveTy, 0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  B.CreateCondBr(IsEnd, ComputeEnd, ComputeLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  B.CreateCondBr(IsEnd, ComputeEnd, ComputeLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">  B.SetInsertPoint(ComputeEnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">  B.SetInsertPoint(ComputeEnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  return {OldValue, NewAccumulator};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  return {OldValue, NewAccumulator};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">static APInt getIdentityValueForAtomicOp(AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">static APInt getIdentityValueForAtomicOp(AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">                                         unsigned BitWidth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">                                         unsigned BitWidth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    return APInt::getMinValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    return APInt::getMinValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  case AtomicRMWInst::Max:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    return APInt::getSignedMinValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    return APInt::getSignedMinValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  case AtomicRMWInst::Min:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    return APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    return APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">static Value *buildMul(IRBuilder<> &B, Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">static Value *buildMul(IRBuilder<> &B, Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  const ConstantInt *CI = dyn_cast<ConstantInt>(LHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  const ConstantInt *CI = dyn_cast<ConstantInt>(LHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  return (CI && CI->isOne()) ? RHS : B.CreateMul(LHS, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  return (CI && CI->isOne()) ? RHS : B.CreateMul(LHS, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">void AMDGPUAtomicOptimizerImpl::optimizeAtomic(Instruction &I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">void AMDGPUAtomicOptimizerImpl::optimizeAtomic(Instruction &I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">                                               AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">                                               AtomicRMWInst::BinOp Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">                                               unsigned ValIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">                                               unsigned ValIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">                                               bool ValDivergent) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">                                               bool ValDivergent) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  // Start building just before the instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  // Start building just before the instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  IRBuilder<> B(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  IRBuilder<> B(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  // If we are in a pixel shader, because of how we have to mask out helper</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  // If we are in a pixel shader, because of how we have to mask out helper</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  // lane invocations, we need to record the entry and exit BB's.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  // lane invocations, we need to record the entry and exit BB's.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  BasicBlock *PixelEntryBB = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  BasicBlock *PixelEntryBB = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  BasicBlock *PixelExitBB = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  BasicBlock *PixelExitBB = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  // If we're optimizing an atomic within a pixel shader, we need to wrap the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  // If we're optimizing an atomic within a pixel shader, we need to wrap the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  // entire atomic operation in a helper-lane check. We do not want any helper</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  // entire atomic operation in a helper-lane check. We do not want any helper</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  // lanes that are around only for the purposes of derivatives to take part</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  // lanes that are around only for the purposes of derivatives to take part</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  // in any cross-lane communication, and we use a branch on whether the lane is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  // in any cross-lane communication, and we use a branch on whether the lane is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  // live to do this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  // live to do this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">  if (IsPixelShader) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">  if (IsPixelShader) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">    // Record I's original position as the entry block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">    // Record I's original position as the entry block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">    PixelEntryBB = I.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">    PixelEntryBB = I.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    Value *const Cond = B.CreateIntrinsic(Intrinsic::amdgcn_ps_live, {}, {});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    Value *const Cond = B.CreateIntrinsic(Intrinsic::amdgcn_ps_live, {}, {});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    Instruction *const NonHelperTerminator =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    Instruction *const NonHelperTerminator =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">        SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">        SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">    // Record I's new position as the exit block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">    // Record I's new position as the exit block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">    PixelExitBB = I.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">    PixelExitBB = I.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">    I.moveBefore(NonHelperTerminator);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">    I.moveBefore(NonHelperTerminator);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">    B.SetInsertPoint(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">    B.SetInsertPoint(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  Type *const Ty = I.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  Type *const Ty = I.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  const unsigned TyBitWidth = DL->getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  const unsigned TyBitWidth = DL->getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  auto *const VecTy = FixedVectorType::get(B.getInt32Ty(), 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  auto *const VecTy = FixedVectorType::get(B.getInt32Ty(), 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  // This is the value in the atomic operation we need to combine in order to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  // This is the value in the atomic operation we need to combine in order to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  // reduce the number of atomic operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  // reduce the number of atomic operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  Value *const V = I.getOperand(ValIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  Value *const V = I.getOperand(ValIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  // We need to know how many lanes are active within the wavefront, and we do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  // We need to know how many lanes are active within the wavefront, and we do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  // this by doing a ballot of active lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  // this by doing a ballot of active lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  Type *const WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  Type *const WaveTy = B.getIntNTy(ST->getWavefrontSize());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  CallInst *const Ballot =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  CallInst *const Ballot =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">      B.CreateIntrinsic(Intrinsic::amdgcn_ballot, WaveTy, B.getTrue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  // We need to know how many lanes are active within the wavefront that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  // We need to know how many lanes are active within the wavefront that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  // below us. If we counted each lane linearly starting from 0, a lane is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  // below us. If we counted each lane linearly starting from 0, a lane is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  // below us only if its associated index was less than ours. We do this by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  // below us only if its associated index was less than ours. We do this by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  // using the mbcnt intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  // using the mbcnt intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  Value *Mbcnt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  Value *Mbcnt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  if (ST->isWave32()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  if (ST->isWave32()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">                              {Ballot, B.getInt32(0)});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">                              {Ballot, B.getInt32(0)});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    Value *const BitCast = B.CreateBitCast(Ballot, VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    Value *const BitCast = B.CreateBitCast(Ballot, VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">    Value *const ExtractLo = B.CreateExtractElement(BitCast, B.getInt32(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">    Value *const ExtractLo = B.CreateExtractElement(BitCast, B.getInt32(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    Value *const ExtractHi = B.CreateExtractElement(BitCast, B.getInt32(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    Value *const ExtractHi = B.CreateExtractElement(BitCast, B.getInt32(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">    Mbcnt = B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">                              {ExtractLo, B.getInt32(0)});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">                              {ExtractLo, B.getInt32(0)});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">    Mbcnt =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">    Mbcnt =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">        B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {ExtractHi, Mbcnt});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">        B.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {ExtractHi, Mbcnt});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  Mbcnt = B.CreateIntCast(Mbcnt, Ty, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  Mbcnt = B.CreateIntCast(Mbcnt, Ty, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  Value *const Identity = B.getInt(getIdentityValueForAtomicOp(Op, TyBitWidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  Value *const Identity = B.getInt(getIdentityValueForAtomicOp(Op, TyBitWidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  Value *ExclScan = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  Value *ExclScan = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  Value *NewV = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  Value *NewV = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  const bool NeedResult = !I.use_empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  const bool NeedResult = !I.use_empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  Function *F = I.getFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  Function *F = I.getFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  LLVMContext &C = F->getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  LLVMContext &C = F->getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  BasicBlock *ComputeLoop = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  BasicBlock *ComputeLoop = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  BasicBlock *ComputeEnd = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  BasicBlock *ComputeEnd = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  // If we have a divergent value in each lane, we need to combine the value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  // If we have a divergent value in each lane, we need to combine the value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  // using DPP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  // using DPP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">  if (ValDivergent) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">  if (ValDivergent) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">    const AtomicRMWInst::BinOp ScanOp =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">    const AtomicRMWInst::BinOp ScanOp =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">        Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">        Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">    if (ScanImpl == ScanOptions::DPP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">    if (ScanImpl == ScanOptions::DPP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">      // First we need to set all inactive invocations to the identity value, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">      // First we need to set all inactive invocations to the identity value, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">      // that they can correctly contribute to the final result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">      // that they can correctly contribute to the final result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">      NewV =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">      NewV =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">          B.CreateIntrinsic(Intrinsic::amdgcn_set_inactive, Ty, {V, Identity});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">          B.CreateIntrinsic(Intrinsic::amdgcn_set_inactive, Ty, {V, Identity});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">      const AtomicRMWInst::BinOp ScanOp =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">      const AtomicRMWInst::BinOp ScanOp =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">          Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">          Op == AtomicRMWInst::Sub ? AtomicRMWInst::Add : Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">      if (!NeedResult && ST->hasPermLaneX16()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">      if (!NeedResult && ST->hasPermLaneX16()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">        // On GFX10 the permlanex16 instruction helps us build a reduction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">        // On GFX10 the permlanex16 instruction helps us build a reduction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">        // without too many readlanes and writelanes, which are generally bad</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">        // without too many readlanes and writelanes, which are generally bad</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">        // for performance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">        // for performance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">        NewV = buildReduction(B, ScanOp, NewV, Identity);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">        NewV = buildReduction(B, ScanOp, NewV, Identity);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">        NewV = buildScan(B, ScanOp, NewV, Identity);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">        NewV = buildScan(B, ScanOp, NewV, Identity);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">        if (NeedResult)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">        if (NeedResult)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">          ExclScan = buildShiftRight(B, NewV, Identity);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">          ExclScan = buildShiftRight(B, NewV, Identity);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">        // Read the value from the last lane, which has accumulated the values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">        // Read the value from the last lane, which has accumulated the values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">        // of each active lane in the wavefront. This will be our new value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">        // of each active lane in the wavefront. This will be our new value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">        // which we will provide to the atomic operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">        // which we will provide to the atomic operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">        Value *const LastLaneIdx = B.getInt32(ST->getWavefrontSize() - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">        Value *const LastLaneIdx = B.getInt32(ST->getWavefrontSize() - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">        assert(TyBitWidth == 32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">        assert(TyBitWidth == 32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">        NewV = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">        NewV = B.CreateIntrinsic(Intrinsic::amdgcn_readlane, {},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">                                 {NewV, LastLaneIdx});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">                                 {NewV, LastLaneIdx});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">      // Finally mark the readlanes in the WWM section.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">      // Finally mark the readlanes in the WWM section.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">      NewV = B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, NewV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">      NewV = B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, NewV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">      // Alternative implementation for scan</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">      // Alternative implementation for scan</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">      ComputeLoop = BasicBlock::Create(C, "ComputeLoop", F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">      ComputeLoop = BasicBlock::Create(C, "ComputeLoop", F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">      ComputeEnd = BasicBlock::Create(C, "ComputeEnd", F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">      ComputeEnd = BasicBlock::Create(C, "ComputeEnd", F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">      std::tie(ExclScan, NewV) = buildScanIteratively(B, ScanOp, Identity, V, I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">      std::tie(ExclScan, NewV) = buildScanIteratively(B, ScanOp, Identity, V, I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">                                                      ComputeLoop, ComputeEnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">                                                      ComputeLoop, ComputeEnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">      llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">      llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">    switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">    switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">      llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">      llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    case AtomicRMWInst::Sub: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    case AtomicRMWInst::Sub: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">      // The new value we will be contributing to the atomic operation is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">      // The new value we will be contributing to the atomic operation is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">      // old value times the number of active lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">      // old value times the number of active lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">      Value *const Ctpop = B.CreateIntCast(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">      Value *const Ctpop = B.CreateIntCast(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">      NewV = buildMul(B, V, Ctpop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">      NewV = buildMul(B, V, Ctpop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    case AtomicRMWInst::Max:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    case AtomicRMWInst::Max:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">    case AtomicRMWInst::Min:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">    case AtomicRMWInst::Min:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">    case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">    case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">      // These operations with a uniform value are idempotent: doing the atomic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">      // These operations with a uniform value are idempotent: doing the atomic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">      // operation multiple times has the same effect as doing it once.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">      // operation multiple times has the same effect as doing it once.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">      NewV = V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">      NewV = V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">    case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">    case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">      // The new value we will be contributing to the atomic operation is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">      // The new value we will be contributing to the atomic operation is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">      // old value times the parity of the number of active lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">      // old value times the parity of the number of active lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">      Value *const Ctpop = B.CreateIntCast(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">      Value *const Ctpop = B.CreateIntCast(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">          B.CreateUnaryIntrinsic(Intrinsic::ctpop, Ballot), Ty, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">      NewV = buildMul(B, V, B.CreateAnd(Ctpop, 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">      NewV = buildMul(B, V, B.CreateAnd(Ctpop, 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">  // We only want a single lane to enter our new control flow, and we do this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">  // We only want a single lane to enter our new control flow, and we do this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  // by checking if there are any active lanes below us. Only one lane will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  // by checking if there are any active lanes below us. Only one lane will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">  // have 0 active lanes below us, so that will be the only one to progress.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">  // have 0 active lanes below us, so that will be the only one to progress.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  Value *const Cond = B.CreateICmpEQ(Mbcnt, B.getIntN(TyBitWidth, 0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  Value *const Cond = B.CreateICmpEQ(Mbcnt, B.getIntN(TyBitWidth, 0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  // Store I's original basic block before we split the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  // Store I's original basic block before we split the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  BasicBlock *const EntryBB = I.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  BasicBlock *const EntryBB = I.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  // We need to introduce some new control flow to force a single lane to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  // We need to introduce some new control flow to force a single lane to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">  // active. We do this by splitting I's basic block at I, and introducing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">  // active. We do this by splitting I's basic block at I, and introducing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  // new block such that:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  // new block such that:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  // entry --> single_lane -\</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  // entry --> single_lane -\</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  //       \------------------> exit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  //       \------------------> exit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">  Instruction *const SingleLaneTerminator =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">  Instruction *const SingleLaneTerminator =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">      SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">      SplitBlockAndInsertIfThen(Cond, &I, false, nullptr, &DTU, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  // At this point, we have split the I's block to allow one lane in wavefront</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  // At this point, we have split the I's block to allow one lane in wavefront</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">  // to update the precomputed reduced value. Also, completed the codegen for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">  // to update the precomputed reduced value. Also, completed the codegen for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  // new control flow i.e. iterative loop which perform reduction and scan using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  // new control flow i.e. iterative loop which perform reduction and scan using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  // ComputeLoop and ComputeEnd.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  // ComputeLoop and ComputeEnd.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  // For the new control flow, we need to move branch instruction i.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  // For the new control flow, we need to move branch instruction i.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  // terminator created during SplitBlockAndInsertIfThen from I's block to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  // terminator created during SplitBlockAndInsertIfThen from I's block to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  // ComputeEnd block. We also need to set up predecessor to next block when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  // ComputeEnd block. We also need to set up predecessor to next block when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  // single lane done updating the final reduced value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  // single lane done updating the final reduced value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">  BasicBlock *Predecessor = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">  BasicBlock *Predecessor = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  if (ValDivergent && ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  if (ValDivergent && ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">    // Move terminator from I's block to ComputeEnd block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">    // Move terminator from I's block to ComputeEnd block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">    Instruction *Terminator = EntryBB->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">    Instruction *Terminator = EntryBB->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">    B.SetInsertPoint(ComputeEnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">    B.SetInsertPoint(ComputeEnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">    Terminator->removeFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">    Terminator->removeFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">    B.Insert(Terminator);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">    B.Insert(Terminator);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">    // Branch to ComputeLoop Block unconditionally from the I's block for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">    // Branch to ComputeLoop Block unconditionally from the I's block for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">    // iterative approach.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">    // iterative approach.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">    B.SetInsertPoint(EntryBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">    B.SetInsertPoint(EntryBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    B.CreateBr(ComputeLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    B.CreateBr(ComputeLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">    // Update the dominator tree for new control flow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">    // Update the dominator tree for new control flow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">    DTU.applyUpdates(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">    DTU.applyUpdates(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">        {{DominatorTree::Insert, EntryBB, ComputeLoop},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">        {{DominatorTree::Insert, EntryBB, ComputeLoop},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">         {DominatorTree::Insert, ComputeLoop, ComputeEnd},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">         {DominatorTree::Insert, ComputeLoop, ComputeEnd},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">         {DominatorTree::Delete, EntryBB, SingleLaneTerminator->getParent()}});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">         {DominatorTree::Delete, EntryBB, SingleLaneTerminator->getParent()}});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">    Predecessor = ComputeEnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">    Predecessor = ComputeEnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">    Predecessor = EntryBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">    Predecessor = EntryBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  // Move the IR builder into single_lane next.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  // Move the IR builder into single_lane next.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  B.SetInsertPoint(SingleLaneTerminator);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  B.SetInsertPoint(SingleLaneTerminator);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  // Clone the original atomic operation into single lane, replacing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  // Clone the original atomic operation into single lane, replacing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  // original value with our newly created one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  // original value with our newly created one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  Instruction *const NewI = I.clone();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  Instruction *const NewI = I.clone();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  B.Insert(NewI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  B.Insert(NewI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  NewI->setOperand(ValIdx, NewV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  NewI->setOperand(ValIdx, NewV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  // Move the IR builder into exit next, and start inserting just before the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  // Move the IR builder into exit next, and start inserting just before the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  // original instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  // original instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  B.SetInsertPoint(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  B.SetInsertPoint(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  if (NeedResult) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  if (NeedResult) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">    // Create a PHI node to get our new atomic result into the exit block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">    // Create a PHI node to get our new atomic result into the exit block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">    PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">    PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">    PHI->addIncoming(PoisonValue::get(Ty), Predecessor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">    PHI->addIncoming(PoisonValue::get(Ty), Predecessor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">    PHI->addIncoming(NewI, SingleLaneTerminator->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">    PHI->addIncoming(NewI, SingleLaneTerminator->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">    // We need to broadcast the value who was the lowest active lane (the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">    // We need to broadcast the value who was the lowest active lane (the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">    // lane) to all other lanes in the wavefront. We use an intrinsic for this,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">    // lane) to all other lanes in the wavefront. We use an intrinsic for this,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">    // but have to handle 64-bit broadcasts with two calls to this intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">    // but have to handle 64-bit broadcasts with two calls to this intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">    Value *BroadcastI = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">    Value *BroadcastI = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">    if (TyBitWidth == 64) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">    if (TyBitWidth == 64) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">      Value *const ExtractLo = B.CreateTrunc(PHI, B.getInt32Ty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">      Value *const ExtractLo = B.CreateTrunc(PHI, B.getInt32Ty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">      Value *const ExtractHi =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">      Value *const ExtractHi =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">          B.CreateTrunc(B.CreateLShr(PHI, 32), B.getInt32Ty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">          B.CreateTrunc(B.CreateLShr(PHI, 32), B.getInt32Ty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">      CallInst *const ReadFirstLaneLo =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">      CallInst *const ReadFirstLaneLo =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractLo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractLo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">      CallInst *const ReadFirstLaneHi =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">      CallInst *const ReadFirstLaneHi =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractHi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">          B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, ExtractHi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">      Value *const PartialInsert = B.CreateInsertElement(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">      Value *const PartialInsert = B.CreateInsertElement(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">          PoisonValue::get(VecTy), ReadFirstLaneLo, B.getInt32(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">          PoisonValue::get(VecTy), ReadFirstLaneLo, B.getInt32(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">      Value *const Insert =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">      Value *const Insert =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">          B.CreateInsertElement(PartialInsert, ReadFirstLaneHi, B.getInt32(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">          B.CreateInsertElement(PartialInsert, ReadFirstLaneHi, B.getInt32(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">      BroadcastI = B.CreateBitCast(Insert, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">      BroadcastI = B.CreateBitCast(Insert, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">    } else if (TyBitWidth == 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">    } else if (TyBitWidth == 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">      BroadcastI = B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, PHI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">      BroadcastI = B.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, PHI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">      llvm_unreachable("Unhandled atomic bit width");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">      llvm_unreachable("Unhandled atomic bit width");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    // Now that we have the result of our single atomic operation, we need to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    // Now that we have the result of our single atomic operation, we need to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    // get our individual lane's slice into the result. We use the lane offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    // get our individual lane's slice into the result. We use the lane offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">    // we previously calculated combined with the atomic result value we got</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">    // we previously calculated combined with the atomic result value we got</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    // from the first lane, to get our lane's index into the atomic result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    // from the first lane, to get our lane's index into the atomic result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    Value *LaneOffset = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    Value *LaneOffset = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    if (ValDivergent) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    if (ValDivergent) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">      if (ScanImpl == ScanOptions::DPP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">      if (ScanImpl == ScanOptions::DPP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">        LaneOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">        LaneOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">            B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, ExclScan);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">            B.CreateIntrinsic(Intrinsic::amdgcn_strict_wwm, Ty, ExclScan);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">      } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">      } else if (ScanImpl == ScanOptions::Iterative) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">        LaneOffset = ExclScan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">        LaneOffset = ExclScan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">        llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">        llvm_unreachable("Atomic Optimzer is disabled for None strategy");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">      switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">      switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">        llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">        llvm_unreachable("Unhandled atomic op");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">      case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">      case AtomicRMWInst::Add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">      case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">      case AtomicRMWInst::Sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">        LaneOffset = buildMul(B, V, Mbcnt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">        LaneOffset = buildMul(B, V, Mbcnt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">      case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">      case AtomicRMWInst::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">      case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">      case AtomicRMWInst::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">      case AtomicRMWInst::Max:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">      case AtomicRMWInst::Max:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">      case AtomicRMWInst::Min:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">      case AtomicRMWInst::Min:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">      case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">      case AtomicRMWInst::UMax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">      case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">      case AtomicRMWInst::UMin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">        LaneOffset = B.CreateSelect(Cond, Identity, V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">        LaneOffset = B.CreateSelect(Cond, Identity, V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">      case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">      case AtomicRMWInst::Xor:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">        LaneOffset = buildMul(B, V, B.CreateAnd(Mbcnt, 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">        LaneOffset = buildMul(B, V, B.CreateAnd(Mbcnt, 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">    Value *const Result = buildNonAtomicBinOp(B, Op, BroadcastI, LaneOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">    Value *const Result = buildNonAtomicBinOp(B, Op, BroadcastI, LaneOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">    if (IsPixelShader) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">    if (IsPixelShader) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">      // Need a final PHI to reconverge to above the helper lane branch mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">      // Need a final PHI to reconverge to above the helper lane branch mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">      B.SetInsertPoint(PixelExitBB->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">      B.SetInsertPoint(PixelExitBB->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">      PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">      PHINode *const PHI = B.CreatePHI(Ty, 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">      PHI->addIncoming(PoisonValue::get(Ty), PixelEntryBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">      PHI->addIncoming(PoisonValue::get(Ty), PixelEntryBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">      PHI->addIncoming(Result, I.getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">      PHI->addIncoming(Result, I.getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">      I.replaceAllUsesWith(PHI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">      I.replaceAllUsesWith(PHI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">      // Replace the original atomic instruction with the new one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">      // Replace the original atomic instruction with the new one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">      I.replaceAllUsesWith(Result);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">      I.replaceAllUsesWith(Result);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  // And delete the original.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  // And delete the original.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">917</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">                      "AMDGPU atomic optimizations", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">                      "AMDGPU atomic optimizations", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">919</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">920</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">921</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(AMDGPUAtomicOptimizer, DEBUG_TYPE,</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">                    "AMDGPU atomic optimizations", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">                    "AMDGPU atomic optimizations", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">FunctionPass *llvm::createAMDGPUAtomicOptimizerPass(ScanOptions ScanStrategy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">FunctionPass *llvm::createAMDGPUAtomicOptimizerPass(ScanOptions ScanStrategy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  return new AMDGPUAtomicOptimizer(ScanStrategy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  return new AMDGPUAtomicOptimizer(ScanStrategy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>