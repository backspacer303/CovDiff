<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>TargetLowering.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- llvm/CodeGen/TargetLowering.h - Target Lowering Info -----*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// This file describes how to lower LLVM code to machine code.  This has two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// main components:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">///  1. Which ValueTypes are natively supported by the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">///  2. Which operations are supported for supported ValueTypes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">///  3. Cost thresholds for alternative implementations of certain operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">/// In addition it has a few other components, like information about FP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">/// immediates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#ifndef LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#define LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/ADT/StringRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/CodeGen/ComplexDeinterleavingPass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/CodeGen/DAGCombine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/CodeGen/LowLevelTypeUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/CodeGen/RuntimeLibcalls.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/CodeGen/SelectionDAG.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/CodeGen/SelectionDAGNodes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/CodeGen/TargetCallingConv.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/IR/Attributes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/IR/CallingConv.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/IR/InlineAsm.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/Support/Alignment.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/Support/AtomicOrdering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include <climits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">#include <map></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include <string></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">class AssumptionCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">class CCState;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">class CCValAssign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">class Constant;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">class FastISel;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">class FunctionLoweringInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">class GlobalValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">class Loop;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">class GISelKnownBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">class IntrinsicInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">class IRBuilderBase;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">struct KnownBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">class LLVMContext;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">class MachineBasicBlock;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">class MachineFunction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">class MachineInstr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">class MachineJumpTableInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">class MachineLoop;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">class MachineRegisterInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">class MCContext;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">class MCExpr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">class Module;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">class ProfileSummaryInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">class TargetLibraryInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">class TargetMachine;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">class TargetRegisterClass;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">class TargetRegisterInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">class TargetTransformInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">class Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">namespace Sched {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">enum Preference {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  None,        // No preference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  Source,      // Follow source order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  RegPressure, // Scheduling for lowest register pressure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  Hybrid,      // Scheduling for both latency and register pressure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  ILP,         // Scheduling for ILP in low register pressure mode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  VLIW,        // Scheduling for VLIW targets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  Fast,        // Fast suboptimal list scheduling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  Linearize    // Linearize DAG, no scheduling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">} // end namespace Sched</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">// MemOp models a memory operation, either memset or memcpy/memmove.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">struct MemOp {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  // Shared</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">  uint64_t Size;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">  bool DstAlignCanChange; // true if destination alignment can satisfy any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">                          // constraint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  Align DstAlign;         // Specified alignment of the memory operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  bool AllowOverlap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  // memset only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  bool IsMemset;   // If setthis memory operation is a memset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  bool ZeroMemset; // If set clears out memory with zeros.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  // memcpy only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  bool MemcpyStrSrc; // Indicates whether the memcpy source is an in-register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">                     // constant so it does not need to be loaded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  Align SrcAlign;    // Inferred alignment of the source or default value if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">                     // memory operation does not need to load the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  static MemOp Copy(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">                    Align SrcAlign, bool IsVolatile,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">                    bool MemcpyStrSrc = false) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">    MemOp Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">    Op.Size = Size;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">    Op.DstAlign = DstAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">    Op.AllowOverlap = !IsVolatile;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">    Op.IsMemset = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">    Op.ZeroMemset = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">    Op.MemcpyStrSrc = MemcpyStrSrc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">    Op.SrcAlign = SrcAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">    return Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">  static MemOp Set(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">                   bool IsZeroMemset, bool IsVolatile) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">    MemOp Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">    Op.Size = Size;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">    Op.DstAlign = DstAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">    Op.AllowOverlap = !IsVolatile;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">    Op.IsMemset = true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">    Op.ZeroMemset = IsZeroMemset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">    Op.MemcpyStrSrc = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">    return Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">  uint64_t size() const { return Size; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  Align getDstAlign() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">    assert(!DstAlignCanChange);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">    return DstAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  bool isFixedDstAlign() const { return !DstAlignCanChange; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  bool allowOverlap() const { return AllowOverlap; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">  bool isMemset() const { return IsMemset; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">  bool isMemcpy() const { return !IsMemset; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  bool isMemcpyWithFixedDstAlign() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">    return isMemcpy() && !DstAlignCanChange;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">  bool isZeroMemset() const { return isMemset() && ZeroMemset; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">  bool isMemcpyStrSrc() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">    return MemcpyStrSrc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  Align getSrcAlign() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">    return SrcAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">  bool isSrcAligned(Align AlignCheck) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">    return isMemset() || llvm::isAligned(AlignCheck, SrcAlign.value());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">  bool isDstAligned(Align AlignCheck) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">    return DstAlignCanChange || llvm::isAligned(AlignCheck, DstAlign.value());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">  bool isAligned(Align AlignCheck) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">    return isSrcAligned(AlignCheck) && isDstAligned(AlignCheck);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">/// This base class for TargetLowering contains the SelectionDAG-independent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">/// parts that can be used from the rest of CodeGen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">class TargetLoweringBase {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">  /// This enum indicates whether operations are valid for a target, and if not,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  /// what action should be used to make them valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">  enum LegalizeAction : uint8_t {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">    Legal,      // The target natively supports this operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">    Promote,    // This operation should be executed in a larger type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">    Expand,     // Try to expand this to other ops, otherwise use a libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">    LibCall,    // Don't try to expand this to other ops, always use a libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">    Custom      // Use the LowerOperation hook to implement custom lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  /// This enum indicates whether a types are legal for a target, and if not,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  /// what action should be used to make them valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  enum LegalizeTypeAction : uint8_t {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">    TypeLegal,           // The target natively supports this type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">    TypePromoteInteger,  // Replace this integer with a larger one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">    TypeExpandInteger,   // Split this integer into two of half the size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">    TypeSoftenFloat,     // Convert this float to a same size integer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">    TypeExpandFloat,     // Split this float into two of half the size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">    TypeScalarizeVector, // Replace this one-element vector with its element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">    TypeSplitVector,     // Split this vector into two of half the size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">    TypeWidenVector,     // This vector should be widened into a larger vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">    TypePromoteFloat,    // Replace this float with a larger one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">    TypeSoftPromoteHalf, // Soften half to i16 and use float to do arithmetic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">    TypeScalarizeScalableVector, // This action is explicitly left unimplemented.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">                                 // While it is theoretically possible to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">                                 // legalize operations on scalable types with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">                                 // loop that handles the vscale * #lanes of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">                                 // vector, this is non-trivial at SelectionDAG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">                                 // level and these types are better to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">                                 // widened or promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  /// LegalizeKind holds the legalization kind that needs to happen to EVT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">  /// in order to type-legalize it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  using LegalizeKind = std::pair<LegalizeTypeAction, EVT>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  /// Enum that describes how the target represents true/false values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  enum BooleanContent {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">    UndefinedBooleanContent,    // Only bit 0 counts, the rest can hold garbage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">    ZeroOrOneBooleanContent,        // All bits zero except for bit 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">    ZeroOrNegativeOneBooleanContent // All bits equal to bit 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  /// Enum that describes what type of support for selects the target has.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  enum SelectSupportKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">    ScalarValSelect,      // The target supports scalar selects (ex: cmov).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">    ScalarCondVectorVal,  // The target supports selects with a scalar condition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">                          // and vector values (ex: cmov).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">    VectorMaskSelect      // The target supports vector selects with a vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">                          // mask (ex: x86 blends).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  /// Enum that specifies what an atomic load/AtomicRMWInst is expanded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">  /// to, if at all. Exists because different targets have different levels of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  /// support for these atomic instructions, and also have different options</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">  /// w.r.t. what they should expand to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  enum class AtomicExpansionKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">    None,    // Don't expand the instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">    CastToInteger,    // Cast the atomic instruction to another type, e.g. from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">                      // floating-point to integer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">    LLSC,    // Expand the instruction into loadlinked/storeconditional; used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">             // by ARM/AArch64.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">    LLOnly,  // Expand the (load) instruction into just a load-linked, which has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">             // greater atomic guarantees than a normal load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">    CmpXChg, // Expand the instruction into cmpxchg; used by at least X86.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">    MaskedIntrinsic,  // Use a target-specific intrinsic for the LL/SC loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">    BitTestIntrinsic, // Use a target-specific intrinsic for special bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">                      // operations; used by X86.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">    CmpArithIntrinsic,// Use a target-specific intrinsic for special compare</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">                      // operations; used by X86.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">    Expand,           // Generic expansion in terms of other atomic operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">    // Rewrite to a non-atomic form for use in a known non-preemptible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">    // environment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">    NotAtomic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  /// Enum that specifies when a multiplication should be expanded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  enum class MulExpansionKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">    Always,            // Always expand the instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">    OnlyLegalOrCustom, // Only expand when the resulting instructions are legal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">                       // or custom.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">  /// Enum that specifies when a float negation is beneficial.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">  enum class NegatibleCost {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">    Cheaper = 0,    // Negated expression is cheaper.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">    Neutral = 1,    // Negated expression has the same cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">    Expensive = 2   // Negated expression is more expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  /// Enum of different potentially desirable ways to fold (and/or (setcc ...),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  /// (setcc ...)).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  enum AndOrSETCCFoldKind : uint8_t {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">    None = 0,   // No fold is preferable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">    AddAnd = 1, // Fold with `Add` op and `And` op is preferable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">    NotAnd = 2, // Fold with `Not` op and `And` op is preferable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">    ABS = 4,    // Fold with `llvm.abs` op is preferable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  class ArgListEntry {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">    Value *Val = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">    SDValue Node = SDValue();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">    Type *Ty = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">    bool IsSExt : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">    bool IsZExt : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">    bool IsInReg : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">    bool IsSRet : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">    bool IsNest : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">    bool IsByVal : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">    bool IsByRef : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">    bool IsInAlloca : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">    bool IsPreallocated : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">    bool IsReturned : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">    bool IsSwiftSelf : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">    bool IsSwiftAsync : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">    bool IsSwiftError : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">    bool IsCFGuardTarget : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">    MaybeAlign Alignment = std::nullopt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">    Type *IndirectType = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">    ArgListEntry()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">        : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">          IsNest(false), IsByVal(false), IsByRef(false), IsInAlloca(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">          IsPreallocated(false), IsReturned(false), IsSwiftSelf(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">          IsSwiftAsync(false), IsSwiftError(false), IsCFGuardTarget(false) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">    void setAttributes(const CallBase *Call, unsigned ArgIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">  using ArgListTy = std::vector<ArgListEntry>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">  virtual void markLibCallAttributes(MachineFunction *MF, unsigned CC,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">                                     ArgListTy &Args) const {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="coveredLine">  static ISD::NodeType getExtendForContent(BooleanContent Content) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="coveredLine">    switch (Content) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">    case UndefinedBooleanContent:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">      // Extend by adding rubbish bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">      return ISD::ANY_EXTEND;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="coveredLine">    case ZeroOrOneBooleanContent:</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">      // Extend by adding zero bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="coveredLine">      return ISD::ZERO_EXTEND;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">    case ZeroOrNegativeOneBooleanContent:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">      // Extend by copying the sign bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">      return ISD::SIGN_EXTEND;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">    llvm_unreachable("Invalid content kind");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">  explicit TargetLoweringBase(const TargetMachine &TM);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  TargetLoweringBase(const TargetLoweringBase &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">  TargetLoweringBase &operator=(const TargetLoweringBase &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="coveredLine">  virtual ~TargetLoweringBase() = default;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  /// Return true if the target support strict float operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="coveredLine">  bool isStrictFPEnabled() const {</td>
    <td>56</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="coveredLine">    return IsStrictFPEnabled;</td>
    <td>56</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  /// Initialize all of the actions to default values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">  void initActions();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">  const TargetMachine &getTargetMachine() const { return TM; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">  virtual bool useSoftFloat() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  /// Return the pointer type for the given address space, defaults to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">  /// the pointer type from the data layout.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">  /// FIXME: The default needs to be removed once all the code is updated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="coveredLine">  virtual MVT getPointerTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="coveredLine">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">  /// Return the in-memory pointer type for the given address space, defaults to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">  /// the pointer type from the data layout.  FIXME: The default needs to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">  /// removed once all the code is updated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">  virtual MVT getPointerMemTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">  /// Return the type for frame index, which is determined by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">  /// the alloca address space specified through the data layout.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">  MVT getFrameIndexTy(const DataLayout &DL) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">    return getPointerTy(DL, DL.getAllocaAddrSpace());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  /// Return the type for code pointers, which is determined by the program</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  /// address space specified through the data layout.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">  MVT getProgramPointerTy(const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">    return getPointerTy(DL, DL.getProgramAddressSpace());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">  /// Return the type for operands of fence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  /// TODO: Let fence operands be of i32 type and remove this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">  virtual MVT getFenceOperandTy(const DataLayout &DL) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">    return getPointerTy(DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  /// Return the type to use for a scalar shift opcode, given the shifted amount</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  /// type. Targets should return a legal type if the input type is legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">  /// Targets can return a type that is too small if the input type is illegal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  virtual MVT getScalarShiftAmountTy(const DataLayout &, EVT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  /// Returns the type for the shift amount of a shift opcode. For vectors,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  /// returns the input type. For scalars, behavior depends on \p LegalTypes. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  /// \p LegalTypes is true, calls getScalarShiftAmountTy, otherwise uses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  /// pointer type. If getScalarShiftAmountTy or pointer type cannot represent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  /// all possible shift amounts, returns MVT::i32. In general, \p LegalTypes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">  /// should be set to true for calls during type legalization and after type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">  /// legalization has been completed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">  EVT getShiftAmountTy(EVT LHSTy, const DataLayout &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">                       bool LegalTypes = true) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  /// Return the preferred type to use for a shift opcode, given the shifted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  /// amount type is \p ShiftValueTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  LLVM_READONLY</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">  virtual LLT getPreferredShiftAmountTy(LLT ShiftValueTy) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">    return ShiftValueTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">  /// Returns the type to be used for the index operand of:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  /// ISD::INSERT_VECTOR_ELT, ISD::EXTRACT_VECTOR_ELT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  /// ISD::INSERT_SUBVECTOR, and ISD::EXTRACT_SUBVECTOR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">  virtual MVT getVectorIdxTy(const DataLayout &DL) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">    return getPointerTy(DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  /// Returns the type to be used for the EVL/AVL operand of VP nodes:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  /// ISD::VP_ADD, ISD::VP_SUB, etc. It must be a legal scalar integer type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  /// and must be at least as large as i32. The EVL is implicitly zero-extended</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  /// to any larger type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">  virtual MVT getVPExplicitVectorLengthTy() const { return MVT::i32; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  /// This callback is used to inspect load/store instructions and add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  /// target-specific MachineMemOperand flags to them.  The default</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  /// implementation does nothing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="coveredLine">  virtual MachineMemOperand::Flags getTargetMMOFlags(const Instruction &I) const {</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="coveredLine">    return MachineMemOperand::MONone;</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  /// This callback is used to inspect load/store SDNode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">  /// The default implementation does nothing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">  virtual MachineMemOperand::Flags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">  getTargetMMOFlags(const MemSDNode &Node) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">    return MachineMemOperand::MONone;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">  MachineMemOperand::Flags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  getLoadMemOperandFlags(const LoadInst &LI, const DataLayout &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">                         AssumptionCache *AC = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">                         const TargetLibraryInfo *LibInfo = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  MachineMemOperand::Flags getStoreMemOperandFlags(const StoreInst &SI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">                                                   const DataLayout &DL) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">  MachineMemOperand::Flags getAtomicMemOperandFlags(const Instruction &AI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">                                                    const DataLayout &DL) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">  virtual bool isSelectSupported(SelectSupportKind /*kind*/) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">  /// Return true if the @llvm.get.active.lane.mask intrinsic should be expanded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">  /// using generic code in SelectionDAGBuilder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">  virtual bool shouldExpandGetActiveLaneMask(EVT VT, EVT OpVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">  virtual bool shouldExpandGetVectorLength(EVT CountVT, unsigned VF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">                                           bool IsScalable) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  // Return true if op(vecreduce(x), vecreduce(y)) should be reassociated to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">  // vecreduce(op(x, y)) for the reduction opcode RedOpc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">  virtual bool shouldReassociateReduction(unsigned RedOpc, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  /// Return true if it is profitable to convert a select of FP constants into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  /// a constant pool load whose address depends on the select condition. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">  /// parameter may be used to differentiate a select with FP compare from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  /// integer compare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="uncoveredLine">  virtual bool reduceSelectOfFPConstantLoads(EVT CmpOpVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  /// Return true if multiple condition registers are available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">  bool hasMultipleConditionRegisters() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">    return HasMultipleConditionRegisters;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  /// Return true if the target has BitExtract instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">  bool hasExtractBitsInsn() const { return HasExtractBitsInsn; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">  /// Return the preferred vector type legalization action.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  virtual TargetLoweringBase::LegalizeTypeAction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="coveredLine">  getPreferredVectorAction(MVT VT) const {</td>
    <td>1710</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">    // The default action for one element vectors is to scalarize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="coveredLine">    if (VT.getVectorElementCount().isScalar())</td>
    <td>1710</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="coveredLine">      return TypeScalarizeVector;</td>
    <td>90</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">    // The default action for an odd-width vector is to widen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="coveredLine">    if (!VT.isPow2VectorType())</td>
    <td>1620</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="coveredLine">      return TypeWidenVector;</td>
    <td>210</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    // The default action for other vectors is to promote</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="coveredLine">    return TypePromoteInteger;</td>
    <td>1410</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  // Return true if the half type should be passed around as i16, but promoted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">  // to float around arithmetic. The default behavior is to pass around as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">  // float and convert around loads/stores/bitcasts and other places where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">  // the size matters.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="coveredLine">  virtual bool softPromoteHalfType() const { return false; }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  // There are two general methods for expanding a BUILD_VECTOR node:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  //  1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  //     them together.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  //  2. Build the vector on the stack and then load it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  // If this function returns true, then method (1) will be used, subject to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  // the constraint that all of the necessary shuffles are legal (as determined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">  // by isShuffleMaskLegal). If this function returns false, then method (2) is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">  // always used. The vector type, and the number of defined values, are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">  // provided.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">  shouldExpandBuildVectorWithShuffles(EVT /* VT */,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">                                      unsigned DefinedValues) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">    return DefinedValues < 3;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  /// Return true if integer divide is usually cheaper than a sequence of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  /// several shifts, adds, and multiplies for this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  /// The definition of "cheaper" may depend on whether we're optimizing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  /// for speed or for size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">  virtual bool isIntDivCheap(EVT VT, AttributeList Attr) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  /// Return true if the target can handle a standalone remainder operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">  virtual bool hasStandaloneRem(EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">  /// Return true if SQRT(X) shouldn't be replaced with X*RSQRT(X).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">  virtual bool isFsqrtCheap(SDValue X, SelectionDAG &DAG) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">    // Default behavior is to replace SQRT(X) with X*RSQRT(X).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  /// Reciprocal estimate status values used by the functions below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  enum ReciprocalEstimate : int {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">    Unspecified = -1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">    Disabled = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">    Enabled = 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  /// Return a ReciprocalEstimate enum value for a square root of the given type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  /// are expected to be used for instruction selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  int getRecipEstimateSqrtEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  /// Return a ReciprocalEstimate enum value for a division of the given type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">  /// are expected to be used for instruction selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">  int getRecipEstimateDivEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">  /// Return the refinement step count for a square root of the given type based</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  /// on the function's attributes. If the operation is not overridden by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  /// are expected to be used for instruction selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  int getSqrtRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">  /// Return the refinement step count for a division of the given type based</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">  /// on the function's attributes. If the operation is not overridden by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">  /// are expected to be used for instruction selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">  int getDivRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">  /// Returns true if target has indicated at least one type should be bypassed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="uncoveredLine">  bool isSlowDivBypassed() const { return !BypassSlowDivWidths.empty(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">  /// Returns map of slow types for division or remainder with corresponding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  /// fast types</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  const DenseMap<unsigned int, unsigned int> &getBypassSlowDivWidths() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">    return BypassSlowDivWidths;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">  /// Return true only if vscale must be a power of two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">  virtual bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">  /// Return true if Flow Control is an expensive operation that should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">  /// avoided.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="coveredLine">  bool isJumpExpensive() const { return JumpIsExpensive; }</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">  /// Return true if selects are only cheaper than branches if the branch is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  /// unlikely to be predicted right.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">  bool isPredictableSelectExpensive() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">    return PredictableSelectIsExpensive;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">  virtual bool fallBackToDAGISel(const Instruction &Inst) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">  /// Return true if the following transform is beneficial:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">  /// fold (conv (load x)) -> (load (conv*)x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  /// On architectures that don't natively support some vector loads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">  /// efficiently, casting the load to a smaller vector of larger types and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  /// loading is more efficient, however, this can be undone by optimizations in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  /// dag combiner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  virtual bool isLoadBitCastBeneficial(EVT LoadVT, EVT BitcastVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">                                       const SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">                                       const MachineMemOperand &MMO) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">  /// Return true if the following transform is beneficial:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">  /// (store (y (conv x)), y*)) -> (store x, (x*))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">  virtual bool isStoreBitCastBeneficial(EVT StoreVT, EVT BitcastVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">                                        const SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">                                        const MachineMemOperand &MMO) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">    // Default to the same logic as loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">    return isLoadBitCastBeneficial(StoreVT, BitcastVT, DAG, MMO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  /// Return true if it is expected to be cheaper to do a store of vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">  /// constant with the given size and type for the address space than to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">  /// store the individual scalar element constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">  virtual bool storeOfVectorConstantIsCheap(bool IsZero, EVT MemVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">                                            unsigned NumElem,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">                                            unsigned AddrSpace) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">    return IsZero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  /// Allow store merging for the specified type after legalization in addition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  /// to before legalization. This may transform stores that do not exist</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">  /// earlier (for example, stores created from intrinsics).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="coveredLine">  virtual bool mergeStoresAfterLegalization(EVT MemVT) const {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="coveredLine">    return true;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  /// Returns if it's reasonable to merge stores to MemVT size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">  virtual bool canMergeStoresTo(unsigned AS, EVT MemVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">                                const MachineFunction &MF) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">  /// Return true if it is cheap to speculate a call to intrinsic cttz.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">  virtual bool isCheapToSpeculateCttz(Type *Ty) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">  /// Return true if it is cheap to speculate a call to intrinsic ctlz.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">  virtual bool isCheapToSpeculateCtlz(Type *Ty) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  /// Return true if ctlz instruction is fast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">  virtual bool isCtlzFast() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  /// Return the maximum number of "x & (x - 1)" operations that can be done</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  /// instead of deferring to a custom CTPOP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">  virtual unsigned getCustomCtpopCost(EVT VT, ISD::CondCode Cond) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">    return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  /// Return true if instruction generated for equality comparison is folded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">  /// with instruction generated for signed comparison.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">  virtual bool isEqualityCmpFoldedWithSignedCmp() const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">  /// Return true if the heuristic to prefer icmp eq zero should be used in code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">  /// gen prepare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">  virtual bool preferZeroCompareBranch() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">  /// Return true if it is cheaper to split the store of a merged int val</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">  /// from a pair of smaller values into multiple stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">  virtual bool isMultiStoresCheaperThanBitsMerge(EVT LTy, EVT HTy) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  /// Return if the target supports combining a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">  /// chain like:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">  /// \code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  ///   %andResult = and %val1, #mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">  ///   %icmpResult = icmp %andResult, 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  /// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  /// into a single machine instruction of a form like:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  /// \code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  ///   cc = test %register, #mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">  /// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  virtual bool isMaskAndCmp0FoldingBeneficial(const Instruction &AndI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  /// Return true if it is valid to merge the TargetMMOFlags in two SDNodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">  areTwoSDNodeTargetMMOFlagsMergeable(const MemSDNode &NodeX,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">                                      const MemSDNode &NodeY) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  /// Use bitwise logic to make pairs of compares more efficient. For example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">  /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">  /// This should be true when it takes more than one instruction to lower</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">  virtual bool convertSetCCLogicToBitwiseLogic(EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">  /// Return the preferred operand type if the target has a quick way to compare</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">  /// integer values of the given size. Assume that any legal integer type can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  /// be compared efficiently. Targets may override this to allow illegal wide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">  /// types to return a vector type if there is support to compare that type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">  virtual MVT hasFastEqualityCompare(unsigned NumBits) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">    MVT VT = MVT::getIntegerVT(NumBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">    return isTypeLegal(VT) ? VT : MVT::INVALID_SIMPLE_VALUE_TYPE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  /// Return true if the target should transform:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  /// (X & Y) == Y ---> (~X & Y) == 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">  /// (X & Y) != Y ---> (~X & Y) != 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">  /// This may be profitable if the target has a bitwise and-not operation that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">  /// sets comparison flags. A target may want to limit the transformation based</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">  /// on the type of Y or if Y is a constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  /// Note that the transform will not occur if Y is known to be a power-of-2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">  /// because a mask and compare of a single bit can be handled by inverting the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">  /// predicate, for example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">  /// (X & 8) == 8 ---> (X & 8) != 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">  virtual bool hasAndNotCompare(SDValue Y) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  /// Return true if the target has a bitwise and-not operation:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">  /// X = ~A & B</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  /// This can be used to simplify select or other instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">  virtual bool hasAndNot(SDValue X) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">    // If the target has the more complex version of this operation, assume that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    // it has this operation too.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">    return hasAndNotCompare(X);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">  /// Return true if the target has a bit-test instruction:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">  ///   (X & (1 << Y)) ==/!= 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">  /// This knowledge can be used to prevent breaking the pattern,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">  /// or creating it if it could be recognized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">  virtual bool hasBitTest(SDValue X, SDValue Y) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  /// There are two ways to clear extreme bits (either low or high):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  /// Mask:    x &  (-1 << y)  (the instcombine canonical form)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  /// Shifts:  x >> y << y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">  /// Return true if the variant with 2 variable shifts is preferred.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  /// Return false if there is no preference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">  virtual bool shouldFoldMaskToVariableShiftPair(SDValue X) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">    // By default, let's assume that no one prefers shifts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">  /// Return true if it is profitable to fold a pair of shifts into a mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">  /// This is usually true on most targets. But some targets, like Thumb1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  /// have immediate shift instructions, but no immediate "and" instruction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">  /// this makes the fold unprofitable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">  virtual bool shouldFoldConstantShiftPairToMask(const SDNode *N,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">                                                 CombineLevel Level) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">  /// Should we tranform the IR-optimal check for whether given truncation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">  /// down into KeptBits would be truncating or not:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">  ///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">  /// Into it's more traditional form:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">  ///   ((%x << C) a>> C) dstcond %x</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">  /// Return true if we should transform.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  /// Return false if there is no preference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">  virtual bool shouldTransformSignedTruncationCheck(EVT XVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">                                                    unsigned KeptBits) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">    // By default, let's assume that no one prefers shifts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">  /// Given the pattern</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">  ///   (X & (C l>>/<< Y)) ==/!= 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">  /// return true if it should be transformed into:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">  ///   ((X <</l>> Y) & C) ==/!= 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">  /// WARNING: if 'X' is a constant, the fold may deadlock!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">  /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  ///        here because it can end up being not linked in.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">  virtual bool shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">      SDValue X, ConstantSDNode *XC, ConstantSDNode *CC, SDValue Y,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">      unsigned OldShiftOpcode, unsigned NewShiftOpcode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">      SelectionDAG &DAG) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">    if (hasBitTest(X, Y)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">      // One interesting pattern that we'd want to form is 'bit test':</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">      //   ((1 << Y) & C) ==/!= 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">      // But we also need to be careful not to try to reverse that fold.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">      // Is this '1 << Y' ?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">      if (OldShiftOpcode == ISD::SHL && CC->isOne())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">        return false; // Keep the 'bit test' pattern.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">      // Will it be '1 << Y' after the transform ?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">      if (XC && NewShiftOpcode == ISD::SHL && XC->isOne())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">        return true; // Do form the 'bit test' pattern.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">    // If 'X' is a constant, and we transform, then we will immediately</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">    // try to undo the fold, thus causing endless combine loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">    // So by default, let's assume everyone prefers the fold</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">    // iff 'X' is not a constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">    return !XC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">  /// These two forms are equivalent:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">  ///   sub %y, (xor %x, -1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">  ///   add (add %x, 1), %y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  /// The variant with two add's is IR-canonical.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  /// Some targets may prefer one to the other.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="coveredLine">  virtual bool preferIncOfAddToSubOfNot(EVT VT) const {</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">    // By default, let's assume that everyone prefers the form with two add's.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="coveredLine">    return true;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  // By default prefer folding (abs (sub nsw x, y)) -> abds(x, y). Some targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  // may want to avoid this to prevent loss of sub_nsw pattern.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">  virtual bool preferABDSToABSWithNSW(EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">  // Return true if the target wants to transform Op(Splat(X)) -> Splat(Op(X))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">  virtual bool preferScalarizeSplat(SDNode *N) const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  /// Return true if the target wants to use the optimization that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  /// turns ext(promotableInst1(...(promotableInstN(load)))) into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">  /// promotedInst1(...(promotedInstN(ext(load)))).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">  bool enableExtLdPromotion() const { return EnableExtLdPromotion; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  /// Return true if the target can combine store(extractelement VectorTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">  /// Idx).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">  /// \p Cost[out] gives the cost of that transformation when this is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">  virtual bool canCombineStoreAndExtract(Type *VectorTy, Value *Idx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">                                         unsigned &Cost) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">  /// Return true if inserting a scalar into a variable element of an undef</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">  /// vector is more efficiently handled by splatting the scalar instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">  virtual bool shouldSplatInsEltVarIndex(EVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">  /// Return true if target always benefits from combining into FMA for a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  /// given value type. This must typically return false on targets where FMA</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">  /// takes more cycles to execute than FADD.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">  virtual bool enableAggressiveFMAFusion(EVT VT) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">  /// Return true if target always benefits from combining into FMA for a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  /// given value type. This must typically return false on targets where FMA</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  /// takes more cycles to execute than FADD.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">  virtual bool enableAggressiveFMAFusion(LLT Ty) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">  /// Return the ValueType of the result of SETCC operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">  virtual EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">                                 EVT VT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  /// Return the ValueType for comparison libcalls. Comparison libcalls include</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  /// floating point comparison calls, and Ordered/Unordered check calls on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">  /// floating point numbers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">  virtual</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">  MVT::SimpleValueType getCmpLibcallReturnType() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">  /// For targets without i1 registers, this gives the nature of the high-bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">  /// of boolean values held in types wider than i1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">  /// "Boolean values" are special true/false values produced by nodes like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  /// Not to be confused with general values promoted from i1.  Some cpus</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">  /// distinguish between vectors of boolean and scalars; the isVec parameter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  /// selects between the two kinds.  For example on X86 a scalar boolean should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">  /// be zero extended from i1, while the elements of a vector of booleans</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  /// should be sign extended from i1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">  /// Some cpus also treat floating point types the same way as they treat</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">  /// vectors instead of the way they treat scalars.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="coveredLine">  BooleanContent getBooleanContents(bool isVec, bool isFloat) const {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="coveredLine">    if (isVec)</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">      return BooleanVectorContents;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="coveredLine">    return isFloat ? BooleanFloatContents : BooleanContents;</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="coveredLine">  BooleanContent getBooleanContents(EVT Type) const {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="coveredLine">    return getBooleanContents(Type.isVector(), Type.isFloatingPoint());</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">  /// Promote the given target boolean to a target boolean of the given type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">  /// A target boolean is an integer value, not necessarily of type i1, the bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  /// of which conform to getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">  /// ValVT is the type of values that produced the boolean.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="coveredLine">  SDValue promoteTargetBoolean(SelectionDAG &DAG, SDValue Bool,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">                               EVT ValVT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="coveredLine">    SDLoc dl(Bool);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">    EVT BoolVT =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="coveredLine">        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), ValVT);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="coveredLine">    ISD::NodeType ExtendCode = getExtendForContent(getBooleanContents(ValVT));</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="coveredLine">    return DAG.getNode(ExtendCode, dl, BoolVT, Bool);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="coveredLine">  }</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">  /// Return target scheduling preference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">  Sched::Preference getSchedulingPreference() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">    return SchedPreferenceInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">  /// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">  /// for different nodes. This function returns the preference (or none) for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">  /// the given node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="coveredLine">  virtual Sched::Preference getSchedulingPreference(SDNode *) const {</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="coveredLine">    return Sched::None;</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  /// Return the register class that should be used for the specified value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">  /// type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="coveredLine">  virtual const TargetRegisterClass *getRegClassFor(MVT VT, bool isDivergent = false) const {</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">    (void)isDivergent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="coveredLine">    const TargetRegisterClass *RC = RegClassForVT[VT.SimpleTy];</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="coveredLine">    assert(RC && "This value type is not natively supported!");</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="coveredLine">    return RC;</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">  /// Allows target to decide about the register class of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">  /// specific value that is live outside the defining block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">  /// Returns true if the value needs uniform register class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">  virtual bool requiresUniformRegister(MachineFunction &MF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">                                       const Value *) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">  /// Return the 'representative' register class for the specified value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  /// type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">  /// The 'representative' register class is the largest legal super-reg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">  /// register class for the register class of the value type.  For example, on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  /// i386 the rep register class for i8, i16, and i32 are GR32; while the rep</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">  /// register class is GR64 on x86_64.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">  virtual const TargetRegisterClass *getRepRegClassFor(MVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">    const TargetRegisterClass *RC = RepRegClassForVT[VT.SimpleTy];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">    return RC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  /// Return the cost of the 'representative' register class for the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">  /// value type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">  virtual uint8_t getRepRegClassCostFor(MVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">    return RepRegClassCostForVT[VT.SimpleTy];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">  /// Return the preferred strategy to legalize tihs SHIFT instruction, with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">  /// \p ExpansionFactor being the recursion depth - how many expansion needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">  enum class ShiftLegalizationStrategy {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">    ExpandToParts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">    ExpandThroughStack,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">    LowerToLibcall</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">  virtual ShiftLegalizationStrategy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">  preferredShiftLegalizationStrategy(SelectionDAG &DAG, SDNode *N,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">                                     unsigned ExpansionFactor) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">    if (ExpansionFactor == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">      return ShiftLegalizationStrategy::ExpandToParts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="uncoveredLine">    return ShiftLegalizationStrategy::ExpandThroughStack;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">  /// Return true if the target has native support for the specified value type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  /// This means that it has a register that directly holds it without</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  /// promotions or expansions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="coveredLine">  bool isTypeLegal(EVT VT) const {</td>
    <td>20702</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="coveredLine">    assert(!VT.isSimple() ||</td>
    <td>20702</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">           (unsigned)VT.getSimpleVT().SimpleTy < std::size(RegClassForVT));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="coveredLine">    return VT.isSimple() && RegClassForVT[VT.getSimpleVT().SimpleTy] != nullptr;</td>
    <td>20702</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">  class ValueTypeActionImpl {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">    /// ValueTypeActions - For each value type, keep a LegalizeTypeAction enum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">    /// that indicates how instruction selection should deal with the type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">    LegalizeTypeAction ValueTypeActions[MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="coveredLine">    ValueTypeActionImpl() {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="coveredLine">      std::fill(std::begin(ValueTypeActions), std::end(ValueTypeActions),</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="coveredLine">                TypeLegal);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="coveredLine">    }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="coveredLine">    LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td>868</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="coveredLine">      return ValueTypeActions[VT.SimpleTy];</td>
    <td>868</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="coveredLine">    void setTypeAction(MVT VT, LegalizeTypeAction Action) {</td>
    <td>1834</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="coveredLine">      ValueTypeActions[VT.SimpleTy] = Action;</td>
    <td>1834</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="coveredLine">    }</td>
    <td>1834</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="coveredLine">  const ValueTypeActionImpl &getValueTypeActions() const {</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="coveredLine">    return ValueTypeActions;</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  /// Return pair that represents the legalization kind (first) that needs to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">  /// happen to EVT (second) in order to type-legalize it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">  /// First: how we should legalize values of this type, either it is already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">  /// Second: for types supported by the target, this is an identity function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">  /// For types that must be promoted to larger types, this returns the larger</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">  /// type to promote to.  For integer types that are larger than the largest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">  /// integer register, this contains one step in the expansion to get to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">  /// smaller register. For illegal floating point types, this returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  /// integer type to transform to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">  LegalizeKind getTypeConversion(LLVMContext &Context, EVT VT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  /// Return how we should legalize values of this type, either it is already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="coveredLine">  LegalizeTypeAction getTypeAction(LLVMContext &Context, EVT VT) const {</td>
    <td>854</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="coveredLine">    return getTypeConversion(Context, VT).first;</td>
    <td>854</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">  LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">    return ValueTypeActions.getTypeAction(VT);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">  /// For types supported by the target, this is an identity function.  For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">  /// types that must be promoted to larger types, this returns the larger type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  /// to promote to.  For integer types that are larger than the largest integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  /// register, this contains one step in the expansion to get to the smaller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">  /// register. For illegal floating point types, this returns the integer type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">  /// to transform to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="coveredLine">  virtual EVT getTypeToTransformTo(LLVMContext &Context, EVT VT) const {</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="coveredLine">    return getTypeConversion(Context, VT).second;</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">  /// For types supported by the target, this is an identity function.  For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">  /// types that must be expanded (i.e. integer types that are larger than the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">  /// largest integer register or illegal floating point types), this returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  /// the largest legal type it will be expanded to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">  EVT getTypeToExpandTo(LLVMContext &Context, EVT VT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">    assert(!VT.isVector());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">    while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">      switch (getTypeAction(Context, VT)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">      case TypeLegal:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">        return VT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">      case TypeExpandInteger:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">        VT = getTypeToTransformTo(Context, VT);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">        break;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">      default:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">        llvm_unreachable("Type is not legal nor is it to be expanded!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  /// Vector types are broken down into some number of legal first class types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  /// promoted EVT::f64 values with the X86 FP stack.  Similarly, EVT::v2i64</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  /// turns into 4 EVT::i32 values with both PPC and X86.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  /// This method returns the number of registers needed, and the VT for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  /// register.  It also returns the VT and quantity of the intermediate values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  /// before they are promoted/expanded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">  unsigned getVectorTypeBreakdown(LLVMContext &Context, EVT VT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">                                  EVT &IntermediateVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">                                  unsigned &NumIntermediates,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">                                  MVT &RegisterVT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  /// Certain targets such as MIPS require that some types such as vectors are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">  /// always broken down into scalars in some contexts. This occurs even if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">  /// vector type is legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">  virtual unsigned getVectorTypeBreakdownForCallingConv(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">      LLVMContext &Context, CallingConv::ID CC, EVT VT, EVT &IntermediateVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">      unsigned &NumIntermediates, MVT &RegisterVT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="uncoveredLine">    return getVectorTypeBreakdown(Context, VT, IntermediateVT, NumIntermediates,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">                                  RegisterVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="">  struct IntrinsicInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">    unsigned     opc = 0;          // target opcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">    EVT          memVT;            // memory VT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">    // value representing memory location</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">    PointerUnion<const Value *, const PseudoSourceValue *> ptrVal;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">    // Fallback address space for use if ptrVal is nullptr. std::nullopt means</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">    // unknown address space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">    std::optional<unsigned> fallbackAddressSpace;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">    int          offset = 0;       // offset off of ptrVal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">    uint64_t     size = 0;         // the size of the memory location</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">                                   // (taken from memVT if zero)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">    MaybeAlign align = Align(1);   // alignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">    MachineMemOperand::Flags flags = MachineMemOperand::MONone;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">    IntrinsicInfo() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">  /// Given an intrinsic, checks if on the target the intrinsic will need to map</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">  /// to a MemIntrinsicNode (touches memory). If this is the case, it returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">  /// true and store the intrinsic information into the IntrinsicInfo that was</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">  /// passed to the function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">  virtual bool getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">                                  MachineFunction &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">                                  unsigned /*Intrinsic*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">  /// Returns true if the target can instruction select the specified FP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">  /// immediate natively. If false, the legalizer will materialize the FP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">  /// immediate as a load from a constant pool.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">  virtual bool isFPImmLegal(const APFloat & /*Imm*/, EVT /*VT*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">                            bool ForCodeSize = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">  /// Targets can use this to indicate that they only support *some*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">  /// VECTOR_SHUFFLE operations, those with specific masks.  By default, if a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">  /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">  /// legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">  virtual bool isShuffleMaskLegal(ArrayRef<int> /*Mask*/, EVT /*VT*/) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="">  /// Returns true if the operation can trap for the value type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">  /// VT must be a legal type. By default, we optimistically assume most</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  /// operations don't trap except for integer divide and remainder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">  virtual bool canOpTrap(unsigned Op, EVT VT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">  /// Similar to isShuffleMaskLegal. Targets can use this to indicate if there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">  /// is a suitable VECTOR_SHUFFLE that can be used to replace a VAND with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">  /// constant pool entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">  virtual bool isVectorClearMaskLegal(ArrayRef<int> /*Mask*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">                                      EVT /*VT*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">  /// How to legalize this custom operation?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="coveredLine">  virtual LegalizeAction getCustomOperationAction(SDNode &Op) const {</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="coveredLine">    return Legal;</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">  /// Return how this operation should be treated: either it is legal, needs to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">  /// be promoted to a larger size, needs to be expanded to some other code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">  /// sequence, or the target has a custom expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="coveredLine">  LegalizeAction getOperationAction(unsigned Op, EVT VT) const {</td>
    <td>166</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="coveredLine">    if (VT.isExtended()) return Expand;</td>
    <td>166</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">    // If a target-specific SDNode requires legalization, require the target</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">    // to provide custom legalization for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="coveredLine">    if (Op >= std::size(OpActions[0]))</td>
    <td>166</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">      return Custom;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="coveredLine">    return OpActions[(unsigned)VT.getSimpleVT().SimpleTy][Op];</td>
    <td>166</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">  /// Custom method defined by each target to indicate if an operation which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">  /// may require a scale is supported natively by the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">  /// If not, the operation is illegal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">  virtual bool isSupportedFixedPointOperation(unsigned Op, EVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">                                              unsigned Scale) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">  /// Some fixed point operations may be natively supported by the target but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  /// only for specific scales. This method allows for checking</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">  /// if the width is supported by the target for a given operation that may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  /// depend on scale.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">  LegalizeAction getFixedPointOperationAction(unsigned Op, EVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">                                              unsigned Scale) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">    auto Action = getOperationAction(Op, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">    if (Action != Legal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">      return Action;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">    // This operation is supported in this type but may only work on specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">    // scales.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">    bool Supported;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">    switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">      llvm_unreachable("Unexpected fixed point operation.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">    case ISD::SMULFIX:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">    case ISD::SMULFIXSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">    case ISD::UMULFIX:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="">    case ISD::UMULFIXSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">    case ISD::SDIVFIX:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">    case ISD::SDIVFIXSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">    case ISD::UDIVFIX:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">    case ISD::UDIVFIXSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">      Supported = isSupportedFixedPointOperation(Op, VT, Scale);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">    return Supported ? Action : Expand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">  // If Op is a strict floating-point operation, return the result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">  // of getOperationAction for the equivalent non-strict operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">  LegalizeAction getStrictFPOperationAction(unsigned Op, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">    unsigned EqOpc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">    switch (Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">      default: llvm_unreachable("Unexpected FP pseudo-opcode");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">      case ISD::STRICT_##DAGN: EqOpc = ISD::DAGN; break;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">      case ISD::STRICT_##DAGN: EqOpc = ISD::SETCC; break;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">#include "llvm/IR/ConstrainedOps.def"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">    return getOperationAction(EqOpc, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">  /// Return true if the specified operation is legal on this target or can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">  /// made legal with custom lowering. This is used to help guide high-level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">  /// lowering decisions. LegalOnly is an optional convenience for code paths</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">  /// traversed pre and post legalisation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="coveredLine">  bool isOperationLegalOrCustom(unsigned Op, EVT VT,</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">                                bool LegalOnly = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="coveredLine">    if (LegalOnly)</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">      return isOperationLegal(Op, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="coveredLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td>22</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="coveredLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="coveredLine">       getOperationAction(Op, VT) == Custom);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  /// Return true if the specified operation is legal on this target or can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">  /// made legal using promotion. This is used to help guide high-level lowering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">  /// decisions. LegalOnly is an optional convenience for code paths traversed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  /// pre and post legalisation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="uncoveredLine">  bool isOperationLegalOrPromote(unsigned Op, EVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">                                 bool LegalOnly = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">    if (LegalOnly)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">      return isOperationLegal(Op, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">       getOperationAction(Op, VT) == Promote);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  /// Return true if the specified operation is legal on this target or can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">  /// made legal with custom lowering or using promotion. This is used to help</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">  /// guide high-level lowering decisions. LegalOnly is an optional convenience</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  /// for code paths traversed pre and post legalisation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">  bool isOperationLegalOrCustomOrPromote(unsigned Op, EVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">                                         bool LegalOnly = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">    if (LegalOnly)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">      return isOperationLegal(Op, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="uncoveredLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">       getOperationAction(Op, VT) == Custom ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="uncoveredLine">       getOperationAction(Op, VT) == Promote);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  /// Return true if the operation uses custom lowering, regardless of whether</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  /// the type is legal or not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">  bool isOperationCustom(unsigned Op, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">    return getOperationAction(Op, VT) == Custom;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  /// Return true if lowering to a jump table is allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">  virtual bool areJTsAllowed(const Function *Fn) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">    if (Fn->getFnAttribute("no-jump-tables").getValueAsBool())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">    return isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">           isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">  /// Check whether the range [Low,High] fits in a machine word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">  bool rangeFitsInWord(const APInt &Low, const APInt &High,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">                       const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">    // FIXME: Using the pointer type doesn't seem ideal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">    uint64_t BW = DL.getIndexSizeInBits(0u);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">    uint64_t Range = (High - Low).getLimitedValue(UINT64_MAX - 1) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">    return Range <= BW;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">  /// Return true if lowering to a jump table is suitable for a set of case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">  /// clusters which may contain \p NumCases cases, \p Range range of values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">  virtual bool isSuitableForJumpTable(const SwitchInst *SI, uint64_t NumCases,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">                                      uint64_t Range, ProfileSummaryInfo *PSI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">                                      BlockFrequencyInfo *BFI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  /// Returns preferred type for switch condition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">  virtual MVT getPreferredSwitchConditionType(LLVMContext &Context,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">                                              EVT ConditionVT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  /// Return true if lowering to a bit test is suitable for a set of case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  /// clusters which contains \p NumDests unique destinations, \p Low and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">  /// \p High as its lowest and highest case values, and expects \p NumCmps</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">  /// case value comparisons. Check if the number of destinations, comparison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  /// metric, and range are all suitable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">  bool isSuitableForBitTests(unsigned NumDests, unsigned NumCmps,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">                             const APInt &Low, const APInt &High,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">                             const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">    // FIXME: I don't think NumCmps is the correct metric: a single case and a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">    // range of cases both require only one branch to lower. Just looking at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">    // number of clusters and destinations should be enough to decide whether to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">    // build bit tests.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">    // To lower a range with bit tests, the range must fit the bitwidth of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">    // machine word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">    if (!rangeFitsInWord(Low, High, DL))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">    // Decide whether it's profitable to lower this range with bit tests. Each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">    // destination requires a bit test and branch, and there is an overall range</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">    // check branch. For a small number of clusters, separate comparisons might</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">    // be cheaper, and for many destinations, splitting the range might be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">    // better.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">    return (NumDests == 1 && NumCmps >= 3) || (NumDests == 2 && NumCmps >= 5) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">           (NumDests == 3 && NumCmps >= 6);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  /// Return true if the specified operation is illegal on this target or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">  /// unlikely to be made legal with custom lowering. This is used to help guide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">  /// high-level lowering decisions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="uncoveredLine">  bool isOperationExpand(unsigned Op, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="uncoveredLine">    return (!isTypeLegal(VT) || getOperationAction(Op, VT) == Expand);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  /// Return true if the specified operation is legal on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">  bool isOperationLegal(unsigned Op, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="uncoveredLine">           getOperationAction(Op, VT) == Legal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">  /// Return how this load with extension should be treated: either it is legal,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  /// needs to be promoted to a larger size, needs to be expanded to some other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">  /// code sequence, or the target has a custom expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">  LegalizeAction getLoadExtAction(unsigned ExtType, EVT ValVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">                                  EVT MemVT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="uncoveredLine">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="uncoveredLine">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::VALUETYPE_SIZE &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">           MemI < MVT::VALUETYPE_SIZE && "Table isn't big enough!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">    unsigned Shift = 4 * ExtType;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">    return (LegalizeAction)((LoadExtActions[ValI][MemI] >> Shift) & 0xf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">  /// Return true if the specified load with extension is legal on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">  bool isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">  /// Return true if the specified load with extension is legal or custom</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">  /// on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">  bool isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">           getLoadExtAction(ExtType, ValVT, MemVT) == Custom;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">  /// Return how this store with truncation should be treated: either it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">  /// legal, needs to be promoted to a larger size, needs to be expanded to some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">  /// other code sequence, or the target has a custom expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">  LegalizeAction getTruncStoreAction(EVT ValVT, EVT MemVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">    assert(ValI < MVT::VALUETYPE_SIZE && MemI < MVT::VALUETYPE_SIZE &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">           "Table isn't big enough!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">    return TruncStoreActions[ValI][MemI];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">  /// Return true if the specified store with truncation is legal on this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">  /// target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">  bool isTruncStoreLegal(EVT ValVT, EVT MemVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">    return isTypeLegal(ValVT) && getTruncStoreAction(ValVT, MemVT) == Legal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">  /// Return true if the specified store with truncation has solution on this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">  /// target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">  bool isTruncStoreLegalOrCustom(EVT ValVT, EVT MemVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">    return isTypeLegal(ValVT) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">      (getTruncStoreAction(ValVT, MemVT) == Legal ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">       getTruncStoreAction(ValVT, MemVT) == Custom);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="uncoveredLine">  virtual bool canCombineTruncStore(EVT ValVT, EVT MemVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">                                    bool LegalOnly) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">    if (LegalOnly)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">      return isTruncStoreLegal(ValVT, MemVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">    return isTruncStoreLegalOrCustom(ValVT, MemVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">  /// sequence, or the target has a custom expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="coveredLine">  LegalizeAction getIndexedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td>80</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="coveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_Load);</td>
    <td>80</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">  /// Return true if the specified indexed load is legal on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="coveredLine">  bool isIndexedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="coveredLine">    return VT.isSimple() &&</td>
    <td>120</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="coveredLine">      (getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td>80</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="coveredLine">       getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td>80</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">  /// sequence, or the target has a custom expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="coveredLine">  LegalizeAction getIndexedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td>64</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="coveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_Store);</td>
    <td>64</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">  /// Return true if the specified indexed load is legal on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="coveredLine">  bool isIndexedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="coveredLine">    return VT.isSimple() &&</td>
    <td>96</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="coveredLine">      (getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td>64</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="coveredLine">       getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td>64</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">  /// sequence, or the target has a custom expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">  LegalizeAction getIndexedMaskedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="uncoveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">  /// Return true if the specified indexed load is legal on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">  bool isIndexedMaskedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">    return VT.isSimple() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="uncoveredLine">           (getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">            getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">  /// sequence, or the target has a custom expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="uncoveredLine">  LegalizeAction getIndexedMaskedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedStore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">  /// Return true if the specified indexed load is legal on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">  bool isIndexedMaskedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">    return VT.isSimple() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">           (getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">            getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">  /// Returns true if the index type for a masked gather/scatter requires</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">  /// extending</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">  virtual bool shouldExtendGSIndex(EVT VT, EVT &EltTy) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">  // Returns true if VT is a legal index type for masked gathers/scatters</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="">  // on this target</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">  virtual bool shouldRemoveExtendFromGSIndex(EVT IndexVT, EVT DataVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">  // Return true if the target supports a scatter/gather instruction with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">  // indices which are scaled by the particular value.  Note that all targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">  // must by definition support scale of 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">  virtual bool isLegalScaleForGatherScatter(uint64_t Scale,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">                                            uint64_t ElemSize) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">    // MGATHER/MSCATTER are only required to support scaling by one or by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    // element size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">    if (Scale != ElemSize && Scale != 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  /// Return how the condition code should be treated: either it is legal, needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">  /// to be expanded to some other code sequence, or the target has a custom</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">  /// expander for it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">  LegalizeAction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="coveredLine">  getCondCodeAction(ISD::CondCode CC, MVT VT) const {</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="coveredLine">    assert((unsigned)CC < std::size(CondCodeActions) &&</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">           ((unsigned)VT.SimpleTy >> 3) < std::size(CondCodeActions[0]) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">           "Table isn't big enough!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">    // See setCondCodeAction for how this is encoded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="coveredLine">    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="coveredLine">    uint32_t Value = CondCodeActions[CC][VT.SimpleTy >> 3];</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="coveredLine">    LegalizeAction Action = (LegalizeAction) ((Value >> Shift) & 0xF);</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="coveredLine">    assert(Action != Promote && "Can't promote condition code!");</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="coveredLine">    return Action;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">  /// Return true if the specified condition code is legal on this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="coveredLine">  bool isCondCodeLegal(ISD::CondCode CC, MVT VT) const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="coveredLine">    return getCondCodeAction(CC, VT) == Legal;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">  /// Return true if the specified condition code is legal or custom on this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">  /// target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">  bool isCondCodeLegalOrCustom(ISD::CondCode CC, MVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="uncoveredLine">    return getCondCodeAction(CC, VT) == Legal ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="uncoveredLine">           getCondCodeAction(CC, VT) == Custom;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">  /// If the action for this operation is to promote, this method returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  /// ValueType to promote to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">  MVT getTypeToPromoteTo(unsigned Op, MVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="uncoveredLine">    assert(getOperationAction(Op, VT) == Promote &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">           "This operation isn't promoted!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">    // See if this has an explicit type specified.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">    std::map<std::pair<unsigned, MVT::SimpleValueType>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">             MVT::SimpleValueType>::const_iterator PTTI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">      PromoteToType.find(std::make_pair(Op, VT.SimpleTy));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">    if (PTTI != PromoteToType.end()) return PTTI->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">    assert((VT.isInteger() || VT.isFloatingPoint()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">           "Cannot autopromote this type, add it with AddPromotedToType.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">    MVT NVT = VT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">      NVT = (MVT::SimpleValueType)(NVT.SimpleTy+1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">      assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">             "Didn't find type to promote to!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">    } while (!isTypeLegal(NVT) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">              getOperationAction(Op, NVT) == Promote);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">    return NVT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">  virtual EVT getAsmOperandValueType(const DataLayout &DL, Type *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">                                     bool AllowUnknown = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">  /// Return the EVT corresponding to this LLVM type.  This is fixed by the LLVM</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="">  /// operations except for the pointer size.  If AllowUnknown is true, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">  /// will return MVT::Other for types with no EVT counterpart (e.g. structs),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">  /// otherwise it will assert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="coveredLine">  EVT getValueType(const DataLayout &DL, Type *Ty,</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">                   bool AllowUnknown = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">    // Lower scalar pointers to native pointer types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="coveredLine">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="coveredLine">      return getPointerTy(DL, PTy->getAddressSpace());</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="coveredLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td>54</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">      Type *EltTy = VTy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">      // Lower vectors of pointers to native pointer types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="uncoveredLine">        EVT PointerTy(getPointerTy(DL, PTy->getAddressSpace()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">                              VTy->getElementCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="coveredLine">    return EVT::getEVT(Ty, AllowUnknown);</td>
    <td>54</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="coveredLine">  EVT getMemValueType(const DataLayout &DL, Type *Ty,</td>
    <td>22</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">                      bool AllowUnknown = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">    // Lower scalar pointers to native pointer types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="coveredLine">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td>22</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">      return getPointerMemTy(DL, PTy->getAddressSpace());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="coveredLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td>22</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">      Type *EltTy = VTy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">        EVT PointerTy(getPointerMemTy(DL, PTy->getAddressSpace()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="uncoveredLine">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">                              VTy->getElementCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="coveredLine">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td>22</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">  /// Return the MVT corresponding to this LLVM type. See getValueType.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">  MVT getSimpleValueType(const DataLayout &DL, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">                         bool AllowUnknown = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">    return getValueType(DL, Ty, AllowUnknown).getSimpleVT();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">  /// Return the desired alignment for ByVal or InAlloca aggregate function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">  /// arguments in the caller parameter area.  This is the actual alignment, not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">  /// its logarithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">  virtual uint64_t getByValTypeAlignment(Type *Ty, const DataLayout &DL) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="coveredLine">  MVT getRegisterType(MVT VT) const {</td>
    <td>1722</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="coveredLine">    assert((unsigned)VT.SimpleTy < std::size(RegisterTypeForVT));</td>
    <td>1722</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="coveredLine">    return RegisterTypeForVT[VT.SimpleTy];</td>
    <td>1722</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="coveredLine">  MVT getRegisterType(LLVMContext &Context, EVT VT) const {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="coveredLine">    if (VT.isSimple())</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="coveredLine">      return getRegisterType(VT.getSimpleVT());</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">    if (VT.isVector()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="uncoveredLine">      EVT VT1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">      MVT RegisterVT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">      unsigned NumIntermediates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="uncoveredLine">      (void)getVectorTypeBreakdown(Context, VT, VT1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">                                   NumIntermediates, RegisterVT);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">      return RegisterVT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">    if (VT.isInteger()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="uncoveredLine">      return getRegisterType(Context, getTypeToTransformTo(Context, VT));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">    llvm_unreachable("Unsupported extended type!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">  /// Return the number of registers that this ValueType will eventually</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">  /// require.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="">  /// This is one for any types promoted to live in larger registers, but may be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">  /// more than one for types (like i64) that are split into pieces.  For types</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="">  /// like i140, which are first promoted then expanded, it is the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">  /// registers needed to hold all the bits of the original type.  For an i140</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">  /// on a 32 bit machine this means 5 registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="">  /// RegisterVT may be passed as a way to override the default settings, for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">  /// instance with i128 inline assembly operands on SystemZ.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">  virtual unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="coveredLine">  getNumRegisters(LLVMContext &Context, EVT VT,</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">                  std::optional<MVT> RegisterVT = std::nullopt) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="coveredLine">    if (VT.isSimple()) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="coveredLine">      assert((unsigned)VT.getSimpleVT().SimpleTy <</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">             std::size(NumRegistersForVT));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="coveredLine">      return NumRegistersForVT[VT.getSimpleVT().SimpleTy];</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">    if (VT.isVector()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">      EVT VT1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="uncoveredLine">      MVT VT2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">      unsigned NumIntermediates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">      return getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">    if (VT.isInteger()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">      unsigned BitWidth = VT.getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">      unsigned RegWidth = getRegisterType(Context, VT).getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">      return (BitWidth + RegWidth - 1) / RegWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">    llvm_unreachable("Unsupported extended type!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">  /// Certain combinations of ABIs, Targets and features require that types</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">  /// are legal for some operations and not for other operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">  /// For MIPS all vector types must be passed through the integer register set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">  virtual MVT getRegisterTypeForCallingConv(LLVMContext &Context,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">                                            CallingConv::ID CC, EVT VT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="uncoveredLine">    return getRegisterType(Context, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">  /// Certain targets require unusual breakdowns of certain types. For MIPS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">  /// this occurs when a vector type is used, as vector are passed through the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">  /// integer register set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">  virtual unsigned getNumRegistersForCallingConv(LLVMContext &Context,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="">                                                 CallingConv::ID CC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">                                                 EVT VT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="uncoveredLine">    return getNumRegisters(Context, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">  /// Certain targets have context sensitive alignment requirements, where one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">  /// type has the alignment requirement of another type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">  virtual Align getABIAlignmentForCallingConv(Type *ArgTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="">                                              const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">    return DL.getABITypeAlign(ArgTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">  /// If true, then instruction selection should seek to shrink the FP constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">  /// of the specified type to a smaller type in order to save space and / or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">  /// reduce runtime.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">  virtual bool ShouldShrinkFPConstant(EVT) const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="">  /// Return true if it is profitable to reduce a load to a smaller type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">  /// Example: (i16 (trunc (i32 (load x))) -> i16 load x</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="uncoveredLine">  virtual bool shouldReduceLoadWidth(SDNode *Load, ISD::LoadExtType ExtTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="">                                     EVT NewVT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">    // By default, assume that it is cheaper to extract a subvector from a wide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">    // vector load rather than creating multiple narrow vector loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">    if (NewVT.isVector() && !Load->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="">  /// Return true (the default) if it is profitable to remove a sext_inreg(x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="">  /// where the sext is redundant, and use x directly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">  virtual bool shouldRemoveRedundantExtend(SDValue Op) const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">  /// When splitting a value of the specified type into parts, does the Lo</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="">  /// or Hi part come first?  This usually follows the endianness, except</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">  /// for ppcf128, where the Hi part always comes first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="uncoveredLine">  bool hasBigEndianPartOrdering(EVT VT, const DataLayout &DL) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">    return DL.isBigEndian() || VT == MVT::ppcf128;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="">  /// If true, the target has custom DAG combine transformations that it can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">  /// perform for the specified node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="coveredLine">  bool hasTargetDAGCombine(ISD::NodeType NT) const {</td>
    <td>198</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="coveredLine">    assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td>198</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="coveredLine">    return TargetDAGCombineArray[NT >> 3] & (1 << (NT&7));</td>
    <td>198</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">  unsigned getGatherAllAliasesMaxDepth() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">    return GatherAllAliasesMaxDepth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">  /// Returns the size of the platform's va_list object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">  virtual unsigned getVaListSizeInBits(const DataLayout &DL) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">    return getPointerTy(DL).getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">  /// Get maximum # of store operations permitted for llvm.memset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">  /// This function returns the maximum number of store operations permitted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">  /// to replace a call to llvm.memset. The value is set by the target at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">  /// return the limit for functions that have OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">  unsigned getMaxStoresPerMemset(bool OptSize) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">    return OptSize ? MaxStoresPerMemsetOptSize : MaxStoresPerMemset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">  /// Get maximum # of store operations permitted for llvm.memcpy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">  /// This function returns the maximum number of store operations permitted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">  /// to replace a call to llvm.memcpy. The value is set by the target at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">  /// return the limit for functions that have OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">  unsigned getMaxStoresPerMemcpy(bool OptSize) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">    return OptSize ? MaxStoresPerMemcpyOptSize : MaxStoresPerMemcpy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">  /// \brief Get maximum # of store operations to be glued together</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">  /// This function returns the maximum number of store operations permitted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">  /// to glue together during lowering of llvm.memcpy. The value is set by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">  //  the target at the performance threshold for such a replacement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">  virtual unsigned getMaxGluedStoresPerMemcpy() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">    return MaxGluedStoresPerMemcpy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="">  /// Get maximum # of load operations permitted for memcmp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">  /// This function returns the maximum number of load operations permitted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">  /// to replace a call to memcmp. The value is set by the target at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">  /// return the limit for functions that have OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="uncoveredLine">  unsigned getMaxExpandSizeMemcmp(bool OptSize) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">    return OptSize ? MaxLoadsPerMemcmpOptSize : MaxLoadsPerMemcmp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">  /// Get maximum # of store operations permitted for llvm.memmove</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">  /// This function returns the maximum number of store operations permitted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">  /// to replace a call to llvm.memmove. The value is set by the target at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">  /// return the limit for functions that have OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">  unsigned getMaxStoresPerMemmove(bool OptSize) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">    return OptSize ? MaxStoresPerMemmoveOptSize : MaxStoresPerMemmove;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="">  /// Determine if the target supports unaligned memory accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="">  /// This function returns true if the target allows unaligned memory accesses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">  /// of the specified type in the given address space. If true, it also returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">  /// a relative speed of the unaligned memory access in the last argument by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="">  /// reference. The higher the speed number the faster the operation comparing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">  /// to a number returned by another such call. This is used, for example, in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">  /// situations where an array copy/move/set is converted to a sequence of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">  /// store operations. Its use helps to ensure that such replacements don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">  /// generate code that causes an alignment error (trap) on the target machine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="uncoveredLine">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">      EVT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">  /// LLT handling variant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="uncoveredLine">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="">      LLT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="">  /// This function returns true if the memory access is aligned or if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">  /// target allows this specific unaligned memory access. If the access is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">  /// allowed, the optional final parameter returns a relative speed of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">  /// access (as defined by the target).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">  bool allowsMemoryAccessForAlignment(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">      LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">      unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">      unsigned *Fast = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">  /// Return true if the memory access of this type is aligned or if the target</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">  /// allows this specific unaligned access for the given MachineMemOperand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">  /// If the access is allowed, the optional final parameter returns a relative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">  /// speed of the access (as defined by the target).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">  bool allowsMemoryAccessForAlignment(LLVMContext &Context,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">                                      const DataLayout &DL, EVT VT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">                                      const MachineMemOperand &MMO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="">                                      unsigned *Fast = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  /// Return true if the target supports a memory access of this type for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">  /// given address space and alignment. If the access is allowed, the optional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="">  /// final parameter returns the relative speed of the access (as defined by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="">  /// the target).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">  allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">                     unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">                     MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="">                     unsigned *Fast = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">  /// Return true if the target supports a memory access of this type for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="">  /// given MachineMemOperand. If the access is allowed, the optional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">  /// final parameter returns the relative access speed (as defined by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">  /// target).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">                          const MachineMemOperand &MMO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">                          unsigned *Fast = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">  /// LLT handling variant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, LLT Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">                          const MachineMemOperand &MMO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">                          unsigned *Fast = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">  /// Returns the target specific optimal type for load and store operations as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="">  /// a result of memset, memcpy, and memmove lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="">  /// It returns EVT::Other if the type should be determined using generic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">  /// target-independent logic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="">  virtual EVT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">  getOptimalMemOpType(const MemOp &Op,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">                      const AttributeList & /*FuncAttributes*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">    return MVT::Other;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">  /// LLT returning variant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">  virtual LLT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">  getOptimalMemOpLLT(const MemOp &Op,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">                     const AttributeList & /*FuncAttributes*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">    return LLT();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">  /// Returns true if it's safe to use load / store of the specified type to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">  /// expand memcpy / memset inline.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">  /// This is mostly true for all types except for some special cases. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">  /// example, on X86 targets without SSE2 f64 load / store are done with fldl /</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">  /// fstpl which also does type conversion. Note the specified type doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">  /// have to be legal as the hook is used before type legalization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="uncoveredLine">  virtual bool isSafeMemOpType(MVT /*VT*/) const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">  /// Return lower limit for number of blocks in a jump table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">  virtual unsigned getMinimumJumpTableEntries() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="">  /// Return lower limit of the density in a jump table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">  unsigned getMinimumJumpTableDensity(bool OptForSize) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">  /// Return upper limit for number of entries in a jump table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">  /// Zero if no limit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">  unsigned getMaximumJumpTableSize() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">  virtual bool isJumpTableRelative() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">  /// If a physical register, this specifies the register that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="coveredLine">  Register getStackPointerRegisterToSaveRestore() const {</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="coveredLine">    return StackPointerRegisterToSaveRestore;</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">  /// If a physical register, this returns the register that receives the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">  /// exception address on entry to an EH pad.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">  virtual Register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">  getExceptionPointerRegister(const Constant *PersonalityFn) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">    return Register();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">  /// If a physical register, this returns the register that receives the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">  /// exception typeid on entry to a landing pad.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="">  virtual Register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">  getExceptionSelectorRegister(const Constant *PersonalityFn) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">    return Register();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="uncoveredLine">  virtual bool needsFixedCatchObjects() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="uncoveredLine">    report_fatal_error("Funclet EH is not implemented for this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">  /// Return the minimum stack alignment of an argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">  Align getMinStackArgumentAlignment() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">    return MinStackArgumentAlignment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="">  /// Return the minimum function alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="coveredLine">  Align getMinFunctionAlignment() const { return MinFunctionAlignment; }</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">  /// Return the preferred function alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="coveredLine">  Align getPrefFunctionAlignment() const { return PrefFunctionAlignment; }</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">  /// Return the preferred loop alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">  virtual Align getPrefLoopAlignment(MachineLoop *ML = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">  /// Return the maximum amount of bytes allowed to be emitted when padding for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  /// alignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">  virtual unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">  getMaxPermittedBytesForAlignment(MachineBasicBlock *MBB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">  /// Should loops be aligned even when the function is marked OptSize (but not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">  /// MinSize).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="uncoveredLine">  virtual bool alignLoopsWithOptSize() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">  /// If the target has a standard location for the stack protector guard,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">  /// returns the address of that location. Otherwise, returns nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">  /// DEPRECATED: please override useLoadStackGuardNode and customize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">  ///             LOAD_STACK_GUARD, or customize \@llvm.stackguard().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">  virtual Value *getIRStackGuard(IRBuilderBase &IRB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">  /// Inserts necessary declarations for SSP (stack protection) purpose.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">  virtual void insertSSPDeclarations(Module &M) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="">  /// Return the variable that's previously inserted by insertSSPDeclarations,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="">  /// if any, otherwise return nullptr. Should be used only when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">  /// getIRStackGuard returns nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="">  virtual Value *getSDagStackGuard(const Module &M) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="">  /// If this function returns true, stack protection checks should XOR the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">  /// frame pointer (or whichever pointer is used to address locals) into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="">  /// stack guard value before checking it. getIRStackGuard must return nullptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="">  /// if this returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">  virtual bool useStackGuardXorFP() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="">  /// If the target has a standard stack protection check function that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="">  /// performs validation and error handling, returns the function. Otherwise,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">  /// returns nullptr. Must be previously inserted by insertSSPDeclarations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">  virtual Function *getSSPStackGuardCheck(const Module &M) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">  /// \returns true if a constant G_UBFX is legal on the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="uncoveredLine">  virtual bool isConstantUnsignedBitfieldExtractLegal(unsigned Opc, LLT Ty1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="">                                                      LLT Ty2) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">  Value *getDefaultSafeStackPointerLocation(IRBuilderBase &IRB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">                                            bool UseTLS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">  /// Returns the target-specific address of the unsafe stack pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">  virtual Value *getSafeStackPointerLocation(IRBuilderBase &IRB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">  /// Returns the name of the symbol used to emit stack probes or the empty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">  /// string if not applicable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">  virtual bool hasStackProbeSymbol(const MachineFunction &MF) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">  virtual bool hasInlineStackProbe(const MachineFunction &MF) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">  virtual StringRef getStackProbeSymbolName(const MachineFunction &MF) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">    return "";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">  /// Returns true if a cast from SrcAS to DestAS is "cheap", such that e.g. we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">  /// are happy to sink it into basic blocks. A cast may be free, but not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">  /// necessarily a no-op. e.g. a free truncate from a 64-bit to 32-bit pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">  virtual bool isFreeAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">  /// Return true if the pointer arguments to CI should be aligned by aligning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  /// the object whose address is being passed. If so then MinSize is set to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  /// minimum size the object must be to be aligned and PrefAlign is set to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">  /// preferred alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="uncoveredLine">  virtual bool shouldAlignPointerArgs(CallInst * /*CI*/, unsigned & /*MinSize*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">                                      Align & /*PrefAlign*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">  /// \name Helpers for TargetTransformInfo implementations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">  /// Get the ISD node that corresponds to the Instruction class opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="">  int InstructionOpcodeToISD(unsigned Opcode) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">  /// \name Helpers for atomic expansion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">  /// Returns the maximum atomic operation size (in bits) supported by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">  /// the backend. Atomic operations greater than this size (as well</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">  /// as ones that are not naturally aligned), will be expanded by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">  unsigned getMaxAtomicSizeInBitsSupported() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">    return MaxAtomicSizeInBitsSupported;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="">  /// Returns the size in bits of the maximum div/rem the backend supports.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="coveredLine">  unsigned getMaxDivRemBitWidthSupported() const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="coveredLine">    return MaxDivRemBitWidthSupported;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">  /// Returns the size in bits of the maximum larget fp convert the backend</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="coveredLine">  unsigned getMaxLargeFPConvertBitWidthSupported() const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="coveredLine">    return MaxLargeFPConvertBitWidthSupported;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">  /// Returns the size of the smallest cmpxchg or ll/sc instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">  /// the backend supports.  Any smaller operations are widened in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">  /// AtomicExpandPass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">  /// Note that *unlike* operations above the maximum size, atomic ops</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">  /// are still natively supported below the minimum; they just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">  /// require a more complex expansion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">  unsigned getMinCmpXchgSizeInBits() const { return MinCmpXchgSizeInBits; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">  /// Whether the target supports unaligned atomic operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="">  bool supportsUnalignedAtomics() const { return SupportsUnalignedAtomics; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">  /// Whether AtomicExpandPass should automatically insert fences and reduce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">  /// ordering for this atomic. This should be true for most architectures with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">  /// weak memory ordering. Defaults to false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">  virtual bool shouldInsertFencesForAtomic(const Instruction *I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="">  /// Whether AtomicExpandPass should automatically insert a trailing fence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">  /// without reducing the ordering for this atomic. Defaults to false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">  shouldInsertTrailingFenceForAtomicStore(const Instruction *I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">  /// Perform a load-linked operation on Addr, returning a "Value *" with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">  /// corresponding pointee type. This may entail some non-trivial operations to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">  /// truncate or reconstruct types that will be illegal in the backend. See</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="">  /// ARMISelLowering for an example implementation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">  virtual Value *emitLoadLinked(IRBuilderBase &Builder, Type *ValueTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="">                                Value *Addr, AtomicOrdering Ord) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">    llvm_unreachable("Load linked unimplemented on this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">  /// Perform a store-conditional operation to Addr. Return the status of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">  /// store. This should be 0 if the store succeeded, non-zero otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">  virtual Value *emitStoreConditional(IRBuilderBase &Builder, Value *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="">                                      Value *Addr, AtomicOrdering Ord) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="uncoveredLine">    llvm_unreachable("Store conditional unimplemented on this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">  /// Perform a masked atomicrmw using a target-specific intrinsic. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">  /// is not responsible for masking and shifting the result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="uncoveredLine">  virtual Value *emitMaskedAtomicRMWIntrinsic(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="">                                              AtomicRMWInst *AI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">                                              Value *AlignedAddr, Value *Incr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">                                              Value *Mask, Value *ShiftAmt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">                                              AtomicOrdering Ord) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">    llvm_unreachable("Masked atomicrmw expansion unimplemented on this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  /// Perform a atomicrmw expansion using a target-specific way. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">  /// expected to be called when masked atomicrmw and bit test atomicrmw don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">  /// work, and the target supports another way to lower atomicrmw.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">  virtual void emitExpandAtomicRMW(AtomicRMWInst *AI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">    llvm_unreachable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">        "Generic atomicrmw expansion unimplemented on this target");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="">  /// Perform a bit test atomicrmw using a target-specific intrinsic. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">  /// represents the combined bit test intrinsic which will be lowered at a late</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">  /// stage by the backend.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">  virtual void emitBitTestAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">    llvm_unreachable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">        "Bit test atomicrmw expansion unimplemented on this target");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">  /// Perform a atomicrmw which the result is only used by comparison, using a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">  /// target-specific intrinsic. This represents the combined atomic and compare</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">  /// intrinsic which will be lowered at a late stage by the backend.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="uncoveredLine">  virtual void emitCmpArithAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="uncoveredLine">    llvm_unreachable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">        "Compare arith atomicrmw expansion unimplemented on this target");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="">  /// Perform a masked cmpxchg using a target-specific intrinsic. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="">  /// is not responsible for masking and shifting the result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">  virtual Value *emitMaskedAtomicCmpXchgIntrinsic(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="">      IRBuilderBase &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">      Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">    llvm_unreachable("Masked cmpxchg expansion unimplemented on this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">  /// \name KCFI check lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="uncoveredLine">  virtual MachineInstr *EmitKCFICheck(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">                                      MachineBasicBlock::instr_iterator &MBBI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">                                      const TargetInstrInfo *TII) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">    llvm_unreachable("KCFI is not supported on this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="">  /// Inserts in the IR a target-specific intrinsic specifying a fence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">  /// It is called by AtomicExpandPass before expanding an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  ///   AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">  ///   if shouldInsertFencesForAtomic returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="">  /// Inst is the original atomic instruction, prior to other expansions that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">  /// may be performed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">  /// This function should either return a nullptr, or a pointer to an IR-level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">  ///   Instruction*. Even complex fence sequences can be represented by a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">  ///   single Instruction* through an intrinsic to be lowered later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">  /// Backends should override this method to produce target-specific intrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">  ///   for their fences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">  /// FIXME: Please note that the default implementation here in terms of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="">  ///   IR-level fences exists for historical/compatibility reasons and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">  ///   *unsound* ! Fences cannot, in general, be used to restore sequential</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">  ///   consistency. For example, consider the following example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">  /// atomic<int> x = y = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">  /// int r1, r2, r3, r4;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="">  /// Thread 0:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">  ///   x.store(1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">  /// Thread 1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">  ///   y.store(1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">  /// Thread 2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">  ///   r1 = x.load();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">  ///   r2 = y.load();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">  /// Thread 3:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="">  ///   r3 = y.load();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">  ///   r4 = x.load();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">  ///  r1 = r3 = 1 and r2 = r4 = 0 is impossible as long as the accesses are all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">  ///  seq_cst. But if they are lowered to monotonic accesses, no amount of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">  ///  IR-level fences can prevent it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">  virtual Instruction *emitLeadingFence(IRBuilderBase &Builder,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">                                        Instruction *Inst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">                                        AtomicOrdering Ord) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">  virtual Instruction *emitTrailingFence(IRBuilderBase &Builder,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">                                         Instruction *Inst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="">                                         AtomicOrdering Ord) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">  // Emits code that executes when the comparison result in the ll/sc</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="">  // expansion of a cmpxchg instruction is such that the store-conditional will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">  // not execute.  This makes it possible to balance out the load-linked with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">  // a dedicated instruction, if desired.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">  // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="">  // be unnecessarily held, except if clrex, inserted by this hook, is executed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="uncoveredLine">  virtual void emitAtomicCmpXchgNoStoreLLBalance(IRBuilderBase &Builder) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">  /// Returns true if arguments should be sign-extended in lib calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">  virtual bool shouldSignExtendTypeInLibCall(EVT Type, bool IsSigned) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="uncoveredLine">    return IsSigned;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="">  /// Returns true if arguments should be extended in lib calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">  virtual bool shouldExtendTypeInLibCall(EVT Type) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="">  /// Returns how the given (atomic) load should be expanded by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="">  /// IR-level AtomicExpand pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">  virtual AtomicExpansionKind shouldExpandAtomicLoadInIR(LoadInst *LI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="uncoveredLine">    return AtomicExpansionKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="">  /// Returns how the given (atomic) load should be cast by the IR-level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">  /// AtomicExpand pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  virtual AtomicExpansionKind shouldCastAtomicLoadInIR(LoadInst *LI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">    if (LI->getType()->isFloatingPointTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="uncoveredLine">    return AtomicExpansionKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">  /// Returns how the given (atomic) store should be expanded by the IR-level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">  /// AtomicExpand pass into. For instance AtomicExpansionKind::Expand will try</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="">  /// to use an atomicrmw xchg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">  virtual AtomicExpansionKind shouldExpandAtomicStoreInIR(StoreInst *SI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">    return AtomicExpansionKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">  /// Returns how the given (atomic) store should be cast by the IR-level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">  /// AtomicExpand pass into. For instance AtomicExpansionKind::CastToInteger</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="">  /// will try to cast the operands to integer values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">  virtual AtomicExpansionKind shouldCastAtomicStoreInIR(StoreInst *SI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">    if (SI->getValueOperand()->getType()->isFloatingPointTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">    return AtomicExpansionKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="">  /// Returns how the given atomic cmpxchg should be expanded by the IR-level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">  /// AtomicExpand pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="">  virtual AtomicExpansionKind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="uncoveredLine">  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *AI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">    return AtomicExpansionKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="">  /// Returns how the IR-level AtomicExpand pass should expand the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="">  /// AtomicRMW, if at all. Default is to never expand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="uncoveredLine">  virtual AtomicExpansionKind shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">    return RMW->isFloatingPointOperation() ?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">      AtomicExpansionKind::CmpXChg : AtomicExpansionKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">  /// Returns how the given atomic atomicrmw should be cast by the IR-level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">  /// AtomicExpand pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">  virtual AtomicExpansionKind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="uncoveredLine">  shouldCastAtomicRMWIInIR(AtomicRMWInst *RMWI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">    if (RMWI->getOperation() == AtomicRMWInst::Xchg &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="uncoveredLine">        (RMWI->getValOperand()->getType()->isFloatingPointTy() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="uncoveredLine">         RMWI->getValOperand()->getType()->isPointerTy()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">    return AtomicExpansionKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="">  /// On some platforms, an AtomicRMW that never actually modifies the value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="">  /// (such as fetch_add of 0) can be turned into a fence followed by an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">  /// atomic load. This may sound useless, but it makes it possible for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">  /// processor to keep the cacheline shared, dramatically improving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="">  /// performance. And such idempotent RMWs are useful for implementing some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">  /// kinds of locks, see for example (justification + benchmarks):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="">  /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">  /// This method tries doing that transformation, returning the atomic load if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="">  /// it succeeds, and nullptr otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="">  /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">  /// another round of expansion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">  virtual LoadInst *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">  lowerIdempotentRMWIntoFencedLoad(AtomicRMWInst *RMWI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">  /// Returns how the platform's atomic operations are extended (ZERO_EXTEND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="">  /// SIGN_EXTEND, or ANY_EXTEND).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="uncoveredLine">  virtual ISD::NodeType getExtendForAtomicOps() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">    return ISD::ZERO_EXTEND;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">  /// Returns how the platform's atomic compare and swap expects its comparison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="">  /// separate from getExtendForAtomicOps, which is concerned with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">  /// sign-extension of the instruction's output, whereas here we are concerned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">  /// with the sign-extension of the input. For targets with compare-and-swap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">  /// instructions (or sub-word comparisons in their LL/SC loop expansions),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">  /// the input can be ANY_EXTEND, but the output will still have a specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="">  /// extension.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="uncoveredLine">  virtual ISD::NodeType getExtendForAtomicCmpSwapArg() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="uncoveredLine">    return ISD::ANY_EXTEND;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">  /// Returns true if we should normalize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="">  /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">  /// that it saves us from materializing N0 and N1 in an integer register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">  /// Targets that are able to perform and/or on flags should return false here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="uncoveredLine">  virtual bool shouldNormalizeToSelectSequence(LLVMContext &Context,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">                                               EVT VT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="">    // If a target has multiple condition registers, then it likely has logical</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">    // operations on those registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="uncoveredLine">    if (hasMultipleConditionRegisters())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">    // Only do the transform if the value won't be split into multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">    // registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">    LegalizeTypeAction Action = getTypeAction(Context, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">    return Action != TypeExpandInteger && Action != TypeExpandFloat &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">      Action != TypeSplitVector;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="uncoveredLine">  virtual bool isProfitableToCombineMinNumMaxNum(EVT VT) const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">  /// Return true if a select of constants (select Cond, C1, C2) should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">  /// transformed into simple math ops with the condition value. For example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">  /// select Cond, C1, C1-1 --> add (zext Cond), C1-1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="uncoveredLine">  virtual bool convertSelectOfConstantsToMath(EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">  /// Return true if it is profitable to transform an integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="">  /// multiplication-by-constant into simpler operations like shifts and adds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="">  /// This may be true if the target does not directly support the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="">  /// multiplication operation for the specified type or the sequence of simpler</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">  /// ops is faster than the multiply.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">  virtual bool decomposeMulByConstant(LLVMContext &Context,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="">                                      EVT VT, SDValue C) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="">  /// Return true if it may be profitable to transform</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="">  /// (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">  /// This may not be true if c1 and c2 can be represented as immediates but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="">  /// c1*c2 cannot, for example.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="">  /// The target should check if c1, c2 and c1*c2 can be represented as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="">  /// immediates, or have to be materialized into registers. If it is not sure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">  /// about some cases, a default true can be returned to let the DAGCombiner</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">  /// decide.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">  /// AddNode is (add x, c1), and ConstNode is c2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="uncoveredLine">  virtual bool isMulAddWithConstProfitable(SDValue AddNode,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="">                                           SDValue ConstNode) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="">  /// Return true if it is more correct/profitable to use strict FP_TO_INT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">  /// conversion operations - canonicalizing the FP source value instead of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">  /// converting all cases and then selecting based on value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">  /// This may be true if the target throws exceptions for out of bounds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">  /// conversions or has fast FP CMOV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="uncoveredLine">  virtual bool shouldUseStrictFP_TO_INT(EVT FpVT, EVT IntVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="">                                        bool IsSigned) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="">  /// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="">  /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">  /// considered beneficial.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">  /// If optimizing for size, expansion is only considered beneficial for upto</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="">  /// 5 multiplies and a divide (if the exponent is negative).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="uncoveredLine">  bool isBeneficialToExpandPowI(int64_t Exponent, bool OptForSize) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">    if (Exponent < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="uncoveredLine">      Exponent = -Exponent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="uncoveredLine">    uint64_t E = static_cast<uint64_t>(Exponent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="uncoveredLine">    return !OptForSize || (llvm::popcount(E) + Log2_64(E) < 7);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">  // TargetLowering Configuration Methods - These methods should be invoked by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">  // the derived class constructor to configure this object for the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="">  /// Specify how the target extends the result of integer and floating point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="coveredLine">  void setBooleanContents(BooleanContent Ty) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="coveredLine">    BooleanContents = Ty;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="coveredLine">    BooleanFloatContents = Ty;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="coveredLine">  }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="">  /// Specify how the target extends the result of integer and floating point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="">  void setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">    BooleanContents = IntTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="">    BooleanFloatContents = FloatTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="">  /// Specify how the target extends the result of a vector boolean value from a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">  /// vector of i1 to a wider type.  See getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="coveredLine">  void setBooleanVectorContents(BooleanContent Ty) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="coveredLine">    BooleanVectorContents = Ty;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="coveredLine">  }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="">  /// Specify the target scheduling preference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="uncoveredLine">  void setSchedulingPreference(Sched::Preference Pref) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="uncoveredLine">    SchedPreferenceInfo = Pref;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">  /// Indicate the minimum number of blocks to generate jump tables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">  void setMinimumJumpTableEntries(unsigned Val);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="">  /// Indicate the maximum number of entries in jump tables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="">  /// Set to zero to generate unlimited jump tables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="">  void setMaximumJumpTableSize(unsigned);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">  /// If set to a physical register, this specifies the register that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="coveredLine">  void setStackPointerRegisterToSaveRestore(Register R) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="coveredLine">    StackPointerRegisterToSaveRestore = R;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="coveredLine">  }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="">  /// condition registers that can be used to store the results of comparisons</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="">  /// for use by selects and conditional branches. With multiple condition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="">  /// the blocks of their users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="uncoveredLine">  void setHasMultipleConditionRegisters(bool hasManyRegs = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">    HasMultipleConditionRegisters = hasManyRegs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="">  /// their users if the users will generate "and" instructions which can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="">  /// combined with "shift" to BitExtract instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="uncoveredLine">  void setHasExtractBitsInsn(bool hasExtractInsn = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">    HasExtractBitsInsn = hasExtractInsn;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">  /// Tells the code generator not to expand logic operations on comparison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">  /// predicates into separate sequences that increase the amount of flow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">  /// control.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="">  void setJumpIsExpensive(bool isExpensive = true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="">  /// Tells the code generator which bitwidths to bypass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">  void addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">    BypassSlowDivWidths[SlowBitWidth] = FastBitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="">  /// Add the specified register class as an available regclass for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="">  /// specified value type. This indicates the selector can handle values of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="">  /// that class natively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="coveredLine">  void addRegisterClass(MVT VT, const TargetRegisterClass *RC) {</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="coveredLine">    assert((unsigned)VT.SimpleTy < std::size(RegClassForVT));</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="coveredLine">    RegClassForVT[VT.SimpleTy] = RC;</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="coveredLine">  }</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">  /// Return the largest legal super-reg register class of the register class</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="">  /// for the specified type and its associated "cost".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="">  virtual std::pair<const TargetRegisterClass *, uint8_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="">  findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="">  /// Once all of the register classes are added, this allows us to compute</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="">  /// derived properties we expose.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">  void computeRegisterProperties(const TargetRegisterInfo *TRI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="">  /// Indicate that the specified operation does not work with the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="">  /// type and indicate what to do about it. Note that VT may refer to either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">  /// the type of a result or that of an operand of Op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="coveredLine">  void setOperationAction(unsigned Op, MVT VT, LegalizeAction Action) {</td>
    <td>423626</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="coveredLine">    assert(Op < std::size(OpActions[0]) && "Table isn't big enough!");</td>
    <td>423626</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="coveredLine">    OpActions[(unsigned)VT.SimpleTy][Op] = Action;</td>
    <td>423626</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="coveredLine">  }</td>
    <td>423626</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="coveredLine">  void setOperationAction(ArrayRef<unsigned> Ops, MVT VT,</td>
    <td>21490</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">                          LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="coveredLine">    for (auto Op : Ops)</td>
    <td>189850</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="coveredLine">      setOperationAction(Op, VT, Action);</td>
    <td>168360</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="coveredLine">  }</td>
    <td>21490</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="coveredLine">  void setOperationAction(ArrayRef<unsigned> Ops, ArrayRef<MVT> VTs,</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">                          LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="coveredLine">    for (auto VT : VTs)</td>
    <td>100</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="coveredLine">      setOperationAction(Ops, VT, Action);</td>
    <td>80</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="coveredLine">  }</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">  /// Indicate that the specified load with extension does not work with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="">  /// specified type and indicate what to do about it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="coveredLine">  void setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT,</td>
    <td>16540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="">                        LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="coveredLine">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() &&</td>
    <td>16540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="">           MemVT.isValid() && "Table isn't big enough!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="coveredLine">    assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td>16540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="coveredLine">    unsigned Shift = 4 * ExtType;</td>
    <td>16540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="coveredLine">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] &= ~((uint16_t)0xF << Shift);</td>
    <td>16540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="coveredLine">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] |= (uint16_t)Action << Shift;</td>
    <td>16540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="coveredLine">  }</td>
    <td>16540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="uncoveredLine">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT, MVT MemVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="">                        LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="uncoveredLine">    for (auto ExtType : ExtTypes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="uncoveredLine">      setLoadExtAction(ExtType, ValVT, MemVT, Action);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="">                        ArrayRef<MVT> MemVTs, LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="">    for (auto MemVT : MemVTs)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="">      setLoadExtAction(ExtTypes, ValVT, MemVT, Action);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="">  /// Indicate that the specified truncating store does not work with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">  /// specified type and indicate what to do about it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="coveredLine">  void setTruncStoreAction(MVT ValVT, MVT MemVT, LegalizeAction Action) {</td>
    <td>7910</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="coveredLine">    assert(ValVT.isValid() && MemVT.isValid() && "Table isn't big enough!");</td>
    <td>7910</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="coveredLine">    TruncStoreActions[(unsigned)ValVT.SimpleTy][MemVT.SimpleTy] = Action;</td>
    <td>7910</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="coveredLine">  }</td>
    <td>7910</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="">  /// Indicate that the specified indexed load does or does not work with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">  /// specified type and indicate what to do abort it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="">  /// NOTE: All indexed mode loads are initialized to Expand in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">  /// TargetLowering.cpp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="coveredLine">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="">                            LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="coveredLine">    for (auto IdxMode : IdxModes)</td>
    <td>15920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="coveredLine">      setIndexedModeAction(IdxMode, VT, IMAB_Load, Action);</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="coveredLine">  }</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="">                            LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">    for (auto VT : VTs)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">      setIndexedLoadAction(IdxModes, VT, Action);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="">  /// Indicate that the specified indexed store does or does not work with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="">  /// specified type and indicate what to do about it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">  /// NOTE: All indexed mode stores are initialized to Expand in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="">  /// TargetLowering.cpp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="coveredLine">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">                             LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="coveredLine">    for (auto IdxMode : IdxModes)</td>
    <td>15920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="coveredLine">      setIndexedModeAction(IdxMode, VT, IMAB_Store, Action);</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="coveredLine">  }</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="">                             LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="">    for (auto VT : VTs)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">      setIndexedStoreAction(IdxModes, VT, Action);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="">  /// Indicate that the specified indexed masked load does or does not work with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="">  /// the specified type and indicate what to do about it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="">  /// NOTE: All indexed mode masked loads are initialized to Expand in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="">  /// TargetLowering.cpp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="coveredLine">  void setIndexedMaskedLoadAction(unsigned IdxMode, MVT VT,</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="">                                  LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="coveredLine">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad, Action);</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="coveredLine">  }</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">  /// Indicate that the specified indexed masked store does or does not work</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="">  /// with the specified type and indicate what to do about it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="">  /// NOTE: All indexed mode masked stores are initialized to Expand in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="">  /// TargetLowering.cpp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="coveredLine">  void setIndexedMaskedStoreAction(unsigned IdxMode, MVT VT,</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="">                                   LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="coveredLine">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedStore, Action);</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="coveredLine">  }</td>
    <td>7960</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="">  /// Indicate that the specified condition code is or isn't supported on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">  /// target and indicate what to do about it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, MVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="">                         LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">    for (auto CC : CCs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="uncoveredLine">      assert(VT.isValid() && (unsigned)CC < std::size(CondCodeActions) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="">             "Table isn't big enough!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="uncoveredLine">      assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="">      /// The lower 3 bits of the SimpleTy index into Nth 4bit set from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="">      /// 32-bit value and the upper 29 bits index into the second dimension of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="">      /// the array to select what 32-bit value to use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="uncoveredLine">      uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="uncoveredLine">      CondCodeActions[CC][VT.SimpleTy >> 3] &= ~((uint32_t)0xF << Shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">      CondCodeActions[CC][VT.SimpleTy >> 3] |= (uint32_t)Action << Shift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, ArrayRef<MVT> VTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="">                         LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="">    for (auto VT : VTs)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="">      setCondCodeAction(CCs, VT, Action);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="">  /// If Opc/OrigVT is specified as being promoted, the promotion code defaults</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="">  /// to trying a larger integer/fp until it can find one that works. If that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="">  /// default is insufficient, this method can be used by the target to override</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="">  /// the default.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="coveredLine">  void AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td>70</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="coveredLine">    PromoteToType[std::make_pair(Opc, OrigVT.SimpleTy)] = DestVT.SimpleTy;</td>
    <td>70</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="coveredLine">  }</td>
    <td>70</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="">  /// Convenience method to set an operation to Promote and specify the type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="">  /// in a single call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="uncoveredLine">  void setOperationPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="uncoveredLine">    setOperationAction(Opc, OrigVT, Promote);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="uncoveredLine">    AddPromotedToType(Opc, OrigVT, DestVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="">  /// Targets should invoke this method for each target independent node that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="">  /// they want to provide a custom DAG combiner for by implementing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="">  /// PerformDAGCombine virtual method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="coveredLine">  void setTargetDAGCombine(ArrayRef<ISD::NodeType> NTs) {</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="coveredLine">    for (auto NT : NTs) {</td>
    <td>116</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="coveredLine">      assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="coveredLine">      TargetDAGCombineArray[NT >> 3] |= 1 << (NT & 7);</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="coveredLine">  }</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="">  /// Set the target's minimum function alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="coveredLine">  void setMinFunctionAlignment(Align Alignment) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="coveredLine">    MinFunctionAlignment = Alignment;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="coveredLine">  }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="">  /// Set the target's preferred function alignment.  This should be set if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="">  /// there is a performance benefit to higher-than-minimum alignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">  void setPrefFunctionAlignment(Align Alignment) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="uncoveredLine">    PrefFunctionAlignment = Alignment;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="">  /// Set the target's preferred loop alignment. Default alignment is one, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="">  /// means the target does not care about loop alignment. The target may also</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="">  /// override getPrefLoopAlignment to provide per-loop values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="uncoveredLine">  void setPrefLoopAlignment(Align Alignment) { PrefLoopAlignment = Alignment; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="uncoveredLine">  void setMaxBytesForAlignment(unsigned MaxBytes) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="uncoveredLine">    MaxBytesForAlignment = MaxBytes;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="">  /// Set the minimum stack alignment of an argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="coveredLine">  void setMinStackArgumentAlignment(Align Alignment) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="coveredLine">    MinStackArgumentAlignment = Alignment;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="coveredLine">  }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="">  /// Set the maximum atomic operation size supported by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="">  /// backend. Atomic operations greater than this size (as well as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="">  /// ones that are not naturally aligned), will be expanded by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="coveredLine">  void setMaxAtomicSizeInBitsSupported(unsigned SizeInBits) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="coveredLine">    MaxAtomicSizeInBitsSupported = SizeInBits;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="coveredLine">  }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="">  /// Set the size in bits of the maximum div/rem the backend supports.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">  void setMaxDivRemBitWidthSupported(unsigned SizeInBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="uncoveredLine">    MaxDivRemBitWidthSupported = SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="">  /// Set the size in bits of the maximum fp convert the backend supports.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="">  /// Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">  void setMaxLargeFPConvertBitWidthSupported(unsigned SizeInBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="uncoveredLine">    MaxLargeFPConvertBitWidthSupported = SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="">  /// Sets the minimum cmpxchg or ll/sc size supported by the backend.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="uncoveredLine">  void setMinCmpXchgSizeInBits(unsigned SizeInBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="uncoveredLine">    MinCmpXchgSizeInBits = SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="">  /// Sets whether unaligned atomic operations are supported.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="uncoveredLine">  void setSupportsUnalignedAtomics(bool UnalignedSupported) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="uncoveredLine">    SupportsUnalignedAtomics = UnalignedSupported;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="">  // Addressing mode description hooks (used by LSR etc).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="">  /// CodeGenPrepare sinks address calculations into the same BB as Load/Store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="">  /// instructions reading the address. This allows as much computation as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="">  /// possible to be done in the address mode for that operand. This hook lets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="">  /// targets also pass back when this should be done on intrinsics which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="">  /// load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="uncoveredLine">  virtual bool getAddrModeArguments(IntrinsicInst * /*I*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="">                                    SmallVectorImpl<Value*> &/*Ops*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="">                                    Type *&/*AccessTy*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="">  /// This represents an addressing mode of:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="">  ///    BaseGV + BaseOffs + BaseReg + Scale*ScaleReg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="">  /// If BaseGV is null,  there is no BaseGV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="">  /// If BaseOffs is zero, there is no base offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="">  /// If HasBaseReg is false, there is no base register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="">  /// If Scale is zero, there is no ScaleReg.  Scale of 1 indicates a reg with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="">  /// no scale.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="">  struct AddrMode {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="">    GlobalValue *BaseGV = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="">    int64_t      BaseOffs = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="">    bool         HasBaseReg = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="">    int64_t      Scale = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="">    AddrMode() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="">  /// Return true if the addressing mode represented by AM is legal for this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="">  /// target, for a load/store of the specified type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="">  /// mode is legal for a load/store of any legal type.  TODO: Handle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="">  /// pre/postinc as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="">  /// If the address space cannot be determined, it will be -1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="">  /// TODO: Remove default argument</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="">  virtual bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="">                                     Type *Ty, unsigned AddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="">                                     Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="">  /// Return true if the specified immediate is legal icmp immediate, that is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="">  /// the target has icmp instructions which can compare a register against the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="">  /// immediate without having to materialize the immediate into a register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="uncoveredLine">  virtual bool isLegalICmpImmediate(int64_t) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="">  /// Return true if the specified immediate is legal add immediate, that is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="">  /// target has add instructions which can add a register with the immediate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="">  /// without having to materialize the immediate into a register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="uncoveredLine">  virtual bool isLegalAddImmediate(int64_t) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="">  /// Return true if the specified immediate is legal for the value input of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="">  /// store instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="uncoveredLine">  virtual bool isLegalStoreImmediate(int64_t Value) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="">    // Default implementation assumes that at least 0 works since it is likely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="">    // that a zero register exists or a zero immediate is allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="uncoveredLine">    return Value == 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="">  /// Return true if it's significantly cheaper to shift a vector by a uniform</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="">  /// scalar than by an amount which will vary across each lane. On x86 before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="">  /// AVX2 for example, there is a "psllw" instruction for the former case, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="">  /// no simple instruction for a general "a << b" operation on vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="">  /// This should also apply to lowering for vector funnel shifts (rotates).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="uncoveredLine">  virtual bool isVectorShiftByScalarCheap(Type *Ty) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="">  /// Given a shuffle vector SVI representing a vector splat, return a new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="">  /// scalar type of size equal to SVI's scalar type if the new type is more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="">  /// profitable. Returns nullptr otherwise. For example under MVE float splats</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="">  /// are converted to integer to prevent the need to move from SPR to GPR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="">  /// registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="uncoveredLine">  virtual Type* shouldConvertSplatType(ShuffleVectorInst* SVI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="">  /// Given a set in interconnected phis of type 'From' that are loaded/stored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="">  /// or bitcast to type 'To', return true if the set should be converted to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="">  /// 'To'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="uncoveredLine">  virtual bool shouldConvertPhiType(Type *From, Type *To) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="uncoveredLine">    return (From->isIntegerTy() || From->isFloatingPointTy()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="uncoveredLine">           (To->isIntegerTy() || To->isFloatingPointTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="">  /// Returns true if the opcode is a commutative binary operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="coveredLine">  virtual bool isCommutativeBinOp(unsigned Opcode) const {</td>
    <td>258</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="">    // FIXME: This should get its info from the td file.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="coveredLine">    switch (Opcode) {</td>
    <td>258</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="coveredLine">    case ISD::ADD:</td>
    <td>44</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="">    case ISD::SMIN:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="">    case ISD::SMAX:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="">    case ISD::UMIN:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="">    case ISD::UMAX:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="">    case ISD::MUL:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="">    case ISD::MULHU:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="">    case ISD::MULHS:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="">    case ISD::SMUL_LOHI:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="">    case ISD::UMUL_LOHI:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="">    case ISD::FADD:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="">    case ISD::FMUL:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="">    case ISD::AND:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="">    case ISD::OR:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="">    case ISD::XOR:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="">    case ISD::SADDO:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="">    case ISD::UADDO:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="">    case ISD::ADDC:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="">    case ISD::ADDE:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="">    case ISD::SADDSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="">    case ISD::UADDSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="">    case ISD::FMINNUM:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="">    case ISD::FMAXNUM:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="">    case ISD::FMINNUM_IEEE:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="">    case ISD::FMAXNUM_IEEE:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="">    case ISD::FMINIMUM:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="">    case ISD::FMAXIMUM:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="">    case ISD::AVGFLOORS:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="">    case ISD::AVGFLOORU:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="">    case ISD::AVGCEILS:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="">    case ISD::AVGCEILU:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="">    case ISD::ABDS:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="">    case ISD::ABDU:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="coveredLine">      return true;</td>
    <td>44</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="coveredLine">    default: return false;</td>
    <td>214</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="">  /// Return true if the node is a math/logic binary operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="coveredLine">  virtual bool isBinOp(unsigned Opcode) const {</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="">    // A commutative binop must be a binop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="coveredLine">    if (isCommutativeBinOp(Opcode))</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="coveredLine">      return true;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="">    // These are non-commutative binops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="uncoveredLine">    switch (Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="uncoveredLine">    case ISD::SUB:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="">    case ISD::SHL:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="">    case ISD::SRL:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="">    case ISD::SRA:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="">    case ISD::ROTL:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="">    case ISD::ROTR:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="">    case ISD::SDIV:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="">    case ISD::UDIV:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="">    case ISD::SREM:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="">    case ISD::UREM:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="">    case ISD::SSUBSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="">    case ISD::USUBSAT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="">    case ISD::FSUB:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="">    case ISD::FDIV:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="">    case ISD::FREM:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="">  /// Return true if it's free to truncate a value of type FromTy to type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="">  /// ToTy. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="">  /// by referencing its sub-register AX.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="">  /// Targets must return false when FromTy <= ToTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="uncoveredLine">  virtual bool isTruncateFree(Type *FromTy, Type *ToTy) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="">  /// Return true if a truncation from FromTy to ToTy is permitted when deciding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="">  /// whether a call is in tail position. Typically this means that both results</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="">  /// would be assigned to the same register or stack slot, but it could mean</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="">  /// the target performs adequate checks of its own before proceeding with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="">  /// tail call.  Targets must return false when FromTy <= ToTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="uncoveredLine">  virtual bool allowTruncateForTailCall(Type *FromTy, Type *ToTy) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="uncoveredLine">  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="uncoveredLine">  virtual bool isTruncateFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="">                              LLVMContext &Ctx) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="uncoveredLine">    return isTruncateFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="uncoveredLine">                          getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="uncoveredLine">  virtual bool isProfitableToHoist(Instruction *I) const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="">  /// Return true if the extension represented by \p I is free.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="">  /// Unlikely the is[Z|FP]ExtFree family which is based on types,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="">  /// this method can use the context provided by \p I to decide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="">  /// whether or not \p I is free.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="">  /// This method extends the behavior of the is[Z|FP]ExtFree family.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="">  /// In other words, if is[Z|FP]Free returns true, then this method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="">  /// returns true as well. The converse is not true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="">  /// The target can perform the adequate checks by overriding isExtFreeImpl.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="">  /// \pre \p I must be a sign, zero, or fp extension.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="uncoveredLine">  bool isExtFree(const Instruction *I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="uncoveredLine">    switch (I->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="uncoveredLine">    case Instruction::FPExt:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="uncoveredLine">      if (isFPExtFree(EVT::getEVT(I->getType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="">                      EVT::getEVT(I->getOperand(0)->getType())))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="uncoveredLine">    case Instruction::ZExt:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="uncoveredLine">      if (isZExtFree(I->getOperand(0)->getType(), I->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="uncoveredLine">    case Instruction::SExt:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="uncoveredLine">      llvm_unreachable("Instruction is not an extension");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="uncoveredLine">    return isExtFreeImpl(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="">  /// Return true if \p Load and \p Ext can form an ExtLoad.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="">  /// For example, in AArch64</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="">  ///   %L = load i8, i8* %ptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="">  ///   %E = zext i8 %L to i32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="">  /// can be lowered into one load instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="">  ///   ldrb w0, [x0]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="uncoveredLine">  bool isExtLoad(const LoadInst *Load, const Instruction *Ext,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="">                 const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="uncoveredLine">    EVT VT = getValueType(DL, Ext->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="uncoveredLine">    EVT LoadVT = getValueType(DL, Load->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="">    // If the load has other users and the truncate is not free, the ext</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="">    // probably isn't free.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="uncoveredLine">    if (!Load->hasOneUse() && (isTypeLegal(LoadVT) || !isTypeLegal(VT)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="uncoveredLine">        !isTruncateFree(Ext->getType(), Load->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="">    // Check whether the target supports casts folded into loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="">    unsigned LType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="uncoveredLine">    if (isa<ZExtInst>(Ext))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="uncoveredLine">      LType = ISD::ZEXTLOAD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="">    else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="uncoveredLine">      assert(isa<SExtInst>(Ext) && "Unexpected ext type!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="uncoveredLine">      LType = ISD::SEXTLOAD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="uncoveredLine">    return isLoadExtLegal(LType, VT, LoadVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="">  /// Return true if any actual instruction that defines a value of type FromTy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="">  /// implicitly zero-extends the value to ToTy in the result register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="">  /// The function should return true when it is likely that the truncate can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="">  /// be freely folded with an instruction defining a value of FromTy. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="">  /// the defining instruction is unknown (because you're looking at a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="">  /// function argument, PHI, etc.) then the target may require an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="">  /// explicit truncate, which is not necessarily free, but this function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="">  /// does not deal with those cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="">  /// Targets must return false when FromTy >= ToTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="uncoveredLine">  virtual bool isZExtFree(Type *FromTy, Type *ToTy) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="uncoveredLine">  virtual bool isZExtFree(EVT FromTy, EVT ToTy) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="uncoveredLine">  virtual bool isZExtFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="">                          LLVMContext &Ctx) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="uncoveredLine">    return isZExtFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="uncoveredLine">                      getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="">  /// Return true if zero-extending the specific node Val to type VT2 is free</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="">  /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="">  /// because it's folded such as X86 zero-extending loads).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="uncoveredLine">  virtual bool isZExtFree(SDValue Val, EVT VT2) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="uncoveredLine">    return isZExtFree(Val.getValueType(), VT2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="">  /// Return true if sign-extension from FromTy to ToTy is cheaper than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="">  /// zero-extension.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="uncoveredLine">  virtual bool isSExtCheaperThanZExt(EVT FromTy, EVT ToTy) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="">  /// Return true if this constant should be sign extended when promoting to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="">  /// a larger type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="uncoveredLine">  virtual bool signExtendConstant(const ConstantInt *C) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="">  /// Return true if sinking I's operands to the same basic block as I is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="">  /// profitable, e.g. because the operands can be folded into a target</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="">  /// instruction during instruction selection. After calling the function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="">  /// \p Ops contains the Uses to sink ordered by dominance (dominating users</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="">  /// come first).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="uncoveredLine">  virtual bool shouldSinkOperands(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="">                                  SmallVectorImpl<Use *> &Ops) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="">  /// Try to optimize extending or truncating conversion instructions (like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="">  /// zext, trunc, fptoui, uitofp) for the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="uncoveredLine">  optimizeExtendOrTruncateConversion(Instruction *I, Loop *L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="">                                     const TargetTransformInfo &TTI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="">  /// Return true if the target supplies and combines to a paired load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="">  /// two loaded values of type LoadedType next to each other in memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="">  /// RequiredAlignment gives the minimal alignment constraints that must be met</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="">  /// to be able to select this paired load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="">  /// This information is *not* used to generate actual paired loads, but it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="">  /// used to generate a sequence of loads that is easier to combine into a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="">  /// paired load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="">  /// For instance, something like this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="">  /// a = load i64* addr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="">  /// b = trunc i64 a to i32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="">  /// c = lshr i64 a, 32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="">  /// d = trunc i64 c to i32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="">  /// will be optimized into:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="">  /// b = load i32* addr1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="">  /// d = load i32* addr2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="">  /// Where addr1 = addr2 +/- sizeof(i32).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="">  /// In other words, unless the target performs a post-isel load combining,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="">  /// this information should not be provided because it will generate more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="">  /// loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="uncoveredLine">  virtual bool hasPairedLoad(EVT /*LoadedType*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="">                             Align & /*RequiredAlignment*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="">  /// Return true if the target has a vector blend instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="uncoveredLine">  virtual bool hasVectorBlend() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="">  /// Get the maximum supported factor for interleaved memory accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="">  /// Default to be the minimum interleave factor: 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="uncoveredLine">  virtual unsigned getMaxSupportedInterleaveFactor() const { return 2; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="">  /// Lower an interleaved load to target specific intrinsics. Return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="">  /// true on success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="">  /// \p LI is the vector load instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="">  /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="">  /// \p Indices is the corresponding indices for each shufflevector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="">  /// \p Factor is the interleave factor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="uncoveredLine">  virtual bool lowerInterleavedLoad(LoadInst *LI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="">                                    ArrayRef<ShuffleVectorInst *> Shuffles,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="">                                    ArrayRef<unsigned> Indices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="">                                    unsigned Factor) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="">  /// Lower an interleaved store to target specific intrinsics. Return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="">  /// true on success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="">  /// \p SI is the vector store instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="">  /// \p SVI is the shufflevector to RE-interleave the stored vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="">  /// \p Factor is the interleave factor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="uncoveredLine">  virtual bool lowerInterleavedStore(StoreInst *SI, ShuffleVectorInst *SVI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="">                                     unsigned Factor) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="">  /// Lower a deinterleave intrinsic to a target specific load intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="">  /// Return true on success. Currently only supports</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="">  /// llvm.experimental.vector.deinterleave2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="">  /// \p DI is the deinterleave intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="">  /// \p LI is the accompanying load instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="uncoveredLine">  virtual bool lowerDeinterleaveIntrinsicToLoad(IntrinsicInst *DI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="">                                                LoadInst *LI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="">  /// Lower an interleave intrinsic to a target specific store intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="">  /// Return true on success. Currently only supports</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="">  /// llvm.experimental.vector.interleave2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="">  /// \p II is the interleave intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="">  /// \p SI is the accompanying store instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="uncoveredLine">  virtual bool lowerInterleaveIntrinsicToStore(IntrinsicInst *II,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="">                                               StoreInst *SI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="">  /// Return true if an fpext operation is free (for instance, because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="">  /// single-precision floating-point numbers are implicitly extended to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="">  /// double-precision).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="uncoveredLine">  virtual bool isFPExtFree(EVT DestVT, EVT SrcVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="uncoveredLine">    assert(SrcVT.isFloatingPoint() && DestVT.isFloatingPoint() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="">           "invalid fpext types");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="">  /// (for instance, because half-precision floating-point numbers are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="uncoveredLine">  virtual bool isFPExtFoldable(const MachineInstr &MI, unsigned Opcode,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="">                               LLT DestTy, LLT SrcTy) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="">  /// (for instance, because half-precision floating-point numbers are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="uncoveredLine">  virtual bool isFPExtFoldable(const SelectionDAG &DAG, unsigned Opcode,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="">                               EVT DestVT, EVT SrcVT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="uncoveredLine">    assert(DestVT.isFloatingPoint() && SrcVT.isFloatingPoint() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="">           "invalid fpext types");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="uncoveredLine">    return isFPExtFree(DestVT, SrcVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="">  /// Return true if folding a vector load into ExtVal (a sign, zero, or any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="">  /// extend node) is profitable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="uncoveredLine">  virtual bool isVectorLoadExtDesirable(SDValue ExtVal) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="">  /// Return true if an fneg operation is free to the point where it is never</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="">  /// worthwhile to replace it with a bitwise operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="uncoveredLine">  virtual bool isFNegFree(EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="uncoveredLine">    assert(VT.isFloatingPoint());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="">  /// Return true if an fabs operation is free to the point where it is never</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="">  /// worthwhile to replace it with a bitwise operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="uncoveredLine">  virtual bool isFAbsFree(EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="uncoveredLine">    assert(VT.isFloatingPoint());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="">  /// not legal, but should return true if those types will eventually legalize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="uncoveredLine">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="">                                          EVT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="">  /// not legal, but should return true if those types will eventually legalize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="uncoveredLine">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="">                                          LLT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="">  /// IR version</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="uncoveredLine">  virtual bool isFMAFasterThanFMulAndFAdd(const Function &F, Type *) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="">  /// Returns true if \p MI can be combined with another instruction to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="">  /// form TargetOpcode::G_FMAD. \p N may be an TargetOpcode::G_FADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="">  /// TargetOpcode::G_FSUB, or an TargetOpcode::G_FMUL which will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="">  /// distributed into an fadd/fsub.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="uncoveredLine">  virtual bool isFMADLegal(const MachineInstr &MI, LLT Ty) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="uncoveredLine">    assert((MI.getOpcode() == TargetOpcode::G_FADD ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="">            MI.getOpcode() == TargetOpcode::G_FSUB ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="">            MI.getOpcode() == TargetOpcode::G_FMUL) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="">           "unexpected node in FMAD forming combine");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="uncoveredLine">    switch (Ty.getScalarSizeInBits()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="uncoveredLine">    case 16:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="uncoveredLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f16);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="uncoveredLine">    case 32:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="uncoveredLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="uncoveredLine">    case 64:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="uncoveredLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f64);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="">  /// Returns true if be combined with to form an ISD::FMAD. \p N may be an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="">  /// ISD::FADD, ISD::FSUB, or an ISD::FMUL which will be distributed into an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="">  /// fadd/fsub.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="uncoveredLine">  virtual bool isFMADLegal(const SelectionDAG &DAG, const SDNode *N) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="uncoveredLine">    assert((N->getOpcode() == ISD::FADD || N->getOpcode() == ISD::FSUB ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="">            N->getOpcode() == ISD::FMUL) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="">           "unexpected node in FMAD forming combine");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="uncoveredLine">    return isOperationLegal(ISD::FMAD, N->getValueType(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="">  // Return true when the decision to generate FMA's (or FMS, FMLA etc) rather</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="">  // than FMUL and ADD is delegated to the machine combiner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="uncoveredLine">  virtual bool generateFMAsInMachineCombiner(EVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="">                                             CodeGenOpt::Level OptLevel) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="">  /// Return true if it's profitable to narrow operations of type SrcVT to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="">  /// DestVT. e.g. on x86, it's profitable to narrow from i32 to i8 but not from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="">  /// i32 to i16.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="uncoveredLine">  virtual bool isNarrowingProfitable(EVT SrcVT, EVT DestVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="">  /// Return true if pulling a binary operation into a select with an identity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="">  /// constant is profitable. This is the inverse of an IR transform.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="">  /// Example: X + (Cond ? Y : 0) --> Cond ? (X + Y) : X</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="coveredLine">  virtual bool shouldFoldSelectWithIdentityConstant(unsigned BinOpcode,</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="">                                                    EVT VT) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="coveredLine">    return false;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="">  /// Return true if it is beneficial to convert a load of a constant to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="">  /// just the constant itself.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="">  /// On some targets it might be more efficient to use a combination of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="">  /// arithmetic instructions to materialize the constant instead of loading it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="">  /// from a constant pool.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="uncoveredLine">  virtual bool shouldConvertConstantLoadToIntImm(const APInt &Imm,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="">                                                 Type *Ty) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="">  /// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="">  /// from this source type with this index. This is needed because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="">  /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="">  /// the first element, and only the target knows which lowering is cheap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="uncoveredLine">  virtual bool isExtractSubvectorCheap(EVT ResVT, EVT SrcVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="">                                       unsigned Index) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="">  /// Try to convert an extract element of a vector binary operation into an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="">  /// extract element followed by a scalar operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="uncoveredLine">  virtual bool shouldScalarizeBinop(SDValue VecOp) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="">  /// Return true if extraction of a scalar element from the given vector type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="">  /// at the given index is cheap. For example, if scalar operations occur on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="">  /// the same register file as vector operations, then an extract element may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="">  /// be a sub-register rename rather than an actual instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="uncoveredLine">  virtual bool isExtractVecEltCheap(EVT VT, unsigned Index) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="">  /// Try to convert math with an overflow comparison into the corresponding DAG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="">  /// node operation. Targets may want to override this independently of whether</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="">  /// the operation is legal/custom for the given type because it may obscure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="">  /// matching of other patterns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="uncoveredLine">  virtual bool shouldFormOverflowOp(unsigned Opcode, EVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="">                                    bool MathUsed) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="">    // TODO: The default logic is inherited from code in CodeGenPrepare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="">    // The opcode should not make a difference by default?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="uncoveredLine">    if (Opcode != ISD::UADDO)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="">    // Allow the transform as long as we have an integer type that is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="">    // obviously illegal and unsupported and if the math result is used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="">    // besides the overflow check. On some targets (e.g. SPARC), it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="">    // not profitable to form on overflow op if the math result has no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="">    // concrete users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="uncoveredLine">    if (VT.isVector())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="uncoveredLine">    return MathUsed && (VT.isSimple() || !isOperationExpand(Opcode, VT));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="">  // Return true if it is profitable to use a scalar input to a BUILD_VECTOR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="">  // even if the vector itself has multiple uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="uncoveredLine">  virtual bool aggressivelyPreferBuildVectorSources(EVT VecVT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="">  // Return true if CodeGenPrepare should consider splitting large offset of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="">  // GEP to make the GEP fit into the addressing mode and can be sunk into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="">  // same blocks of its users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="uncoveredLine">  virtual bool shouldConsiderGEPOffsetSplit() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="">  /// Return true if creating a shift of the type by the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="">  /// amount is not profitable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="uncoveredLine">  virtual bool shouldAvoidTransformToShift(EVT VT, unsigned Amount) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="">  /// Does this target require the clearing of high-order bits in a register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="">  /// passed to the fp16 to fp conversion library function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="uncoveredLine">  virtual bool shouldKeepZExtForFP16Conv() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="">  /// Should we generate fp_to_si_sat and fp_to_ui_sat from type FPVT to type VT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="">  /// from min(max(fptoi)) saturation patterns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="uncoveredLine">  virtual bool shouldConvertFpToSat(unsigned Op, EVT FPVT, EVT VT) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="uncoveredLine">    return isOperationLegalOrCustom(Op, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="">  /// Does this target support complex deinterleaving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="uncoveredLine">  virtual bool isComplexDeinterleavingSupported() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="">  /// Does this target support complex deinterleaving with the given operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="">  /// and type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="uncoveredLine">  virtual bool isComplexDeinterleavingOperationSupported(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="">      ComplexDeinterleavingOperation Operation, Type *Ty) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="">  /// Create the IR node for the given complex deinterleaving operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="">  /// If one cannot be created using all the given inputs, nullptr should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="">  /// returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="uncoveredLine">  virtual Value *createComplexDeinterleavingIR(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="">      IRBuilderBase &B, ComplexDeinterleavingOperation OperationType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="">      ComplexDeinterleavingRotation Rotation, Value *InputA, Value *InputB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="">      Value *Accumulator = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="">  // Runtime Library hooks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="">  /// Rename the default libcall routine name for the specified libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="coveredLine">  void setLibcallName(RTLIB::Libcall Call, const char *Name) {</td>
    <td>6640</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="coveredLine">    LibcallRoutineNames[Call] = Name;</td>
    <td>6640</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="coveredLine">  }</td>
    <td>6640</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="">  void setLibcallName(ArrayRef<RTLIB::Libcall> Calls, const char *Name) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="">    for (auto Call : Calls)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="">      setLibcallName(Call, Name);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="">  /// Get the libcall routine name for the specified libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="uncoveredLine">  const char *getLibcallName(RTLIB::Libcall Call) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="uncoveredLine">    return LibcallRoutineNames[Call];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="">  /// Override the default CondCode to be used to test the result of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="">  /// comparison libcall against zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="uncoveredLine">  void setCmpLibcallCC(RTLIB::Libcall Call, ISD::CondCode CC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="uncoveredLine">    CmpLibcallCCs[Call] = CC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="">  /// Get the CondCode that's to be used to test the result of the comparison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="">  /// libcall against zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="">  ISD::CondCode getCmpLibcallCC(RTLIB::Libcall Call) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="">    return CmpLibcallCCs[Call];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="">  /// Set the CallingConv that should be used for the specified libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="coveredLine">  void setLibcallCallingConv(RTLIB::Libcall Call, CallingConv::ID CC) {</td>
    <td>6440</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="coveredLine">    LibcallCallingConvs[Call] = CC;</td>
    <td>6440</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="coveredLine">  }</td>
    <td>6440</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="">  /// Get the CallingConv that should be used for the specified libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="uncoveredLine">  CallingConv::ID getLibcallCallingConv(RTLIB::Libcall Call) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="uncoveredLine">    return LibcallCallingConvs[Call];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="">  /// Execute target specific actions to finalize target lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="">  /// This is used to set extra flags in MachineFrameInformation and freezing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="">  /// the set of reserved registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="">  /// The default implementation just freezes the set of reserved registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="">  virtual void finalizeLowering(MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="">  //===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="">  //  GlobalISel Hooks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="">  //===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="">  /// Check whether or not \p MI needs to be moved close to its uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="">  virtual bool shouldLocalize(const MachineInstr &MI, const TargetTransformInfo *TTI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="">  const TargetMachine &TM;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="">  /// condition registers that can be used to store the results of comparisons</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="">  /// for use by selects and conditional branches. With multiple condition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="">  /// the blocks of their users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="">  bool HasMultipleConditionRegisters;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="">  /// their users if the users will generate "and" instructions which can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="">  /// combined with "shift" to BitExtract instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="">  bool HasExtractBitsInsn;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="">  /// Tells the code generator to bypass slow divide or remainder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="">  /// instructions. For example, BypassSlowDivWidths[32,8] tells the code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="">  /// generator to bypass 32-bit integer div/rem with an 8-bit unsigned integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="">  /// div/rem when the operands are positive and less than 256.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class="">  DenseMap <unsigned int, unsigned int> BypassSlowDivWidths;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="">  /// Tells the code generator that it shouldn't generate extra flow control</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="">  /// instructions and should attempt to combine flow control instructions via</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="">  /// predication.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="">  bool JumpIsExpensive;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="">  /// a type wider than i1. See getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="">  BooleanContent BooleanContents;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="">  /// a type wider than i1. See getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="">  BooleanContent BooleanFloatContents;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="">  /// Information about the contents of the high-bits in boolean vector values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="">  /// when the element type is wider than i1. See getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="">  BooleanContent BooleanVectorContents;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="">  /// The target scheduling preference: shortest possible total cycles or lowest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="">  /// register usage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="">  Sched::Preference SchedPreferenceInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="">  /// The minimum alignment that any argument on the stack needs to have.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="">  Align MinStackArgumentAlignment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="">  /// The minimum function alignment (used when optimizing for size, and to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="">  /// prevent explicitly provided alignment from leading to incorrect code).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="">  Align MinFunctionAlignment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="">  /// The preferred function alignment (used when alignment unspecified and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="">  /// optimizing for speed).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class="">  Align PrefFunctionAlignment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="">  /// The preferred loop alignment (in log2 bot in bytes).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="">  Align PrefLoopAlignment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="">  /// The maximum amount of bytes permitted to be emitted for alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="">  unsigned MaxBytesForAlignment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="">  /// Size in bits of the maximum atomics size the backend supports.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="">  /// Accesses larger than this will be expanded by AtomicExpandPass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="">  unsigned MaxAtomicSizeInBitsSupported;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="">  /// Size in bits of the maximum div/rem size the backend supports.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="">  unsigned MaxDivRemBitWidthSupported;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="">  /// Size in bits of the maximum larget fp convert size the backend</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="">  unsigned MaxLargeFPConvertBitWidthSupported;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class="">  /// Size in bits of the minimum cmpxchg or ll/sc operation the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="">  /// backend supports.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="">  unsigned MinCmpXchgSizeInBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="">  /// This indicates if the target supports unaligned atomic operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="">  bool SupportsUnalignedAtomics;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="">  /// If set to a physical register, this specifies the register that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="">  Register StackPointerRegisterToSaveRestore;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="">  /// This indicates the default register class to use for each ValueType the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class="">  /// target supports natively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="">  const TargetRegisterClass *RegClassForVT[MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="">  uint16_t NumRegistersForVT[MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="">  MVT RegisterTypeForVT[MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="">  /// This indicates the "representative" register class to use for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="">  /// ValueType the target supports natively. This information is used by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="">  /// scheduler to track register pressure. By default, the representative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="">  /// register class is the largest legal super-reg register class of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="">  /// register class of the specified type. e.g. On x86, i8, i16, and i32's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="">  /// representative class would be GR32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="">  const TargetRegisterClass *RepRegClassForVT[MVT::VALUETYPE_SIZE] = {0};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="">  /// This indicates the "cost" of the "representative" register class for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="">  /// ValueType. The cost is used by the scheduler to approximate register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="">  /// pressure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="">  uint8_t RepRegClassCostForVT[MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="">  /// For any value types we are promoting or expanding, this contains the value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="">  /// type that we are changing to.  For Expanded types, this contains one step</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="">  /// of the expand (e.g. i64 -> i32), even if there are multiple steps required</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="">  /// (e.g. i64 -> i16).  For types natively supported by the system, this holds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="">  /// the same type (e.g. i32 -> i32).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="">  MVT TransformToType[MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="">  /// For each operation and each value type, keep a LegalizeAction that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="">  /// indicates how instruction selection should deal with the operation.  Most</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="">  /// operations are Legal (aka, supported natively by the target), but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="">  /// operations that are not should be described.  Note that operations on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="">  /// non-legal value types are not described here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="">  LegalizeAction OpActions[MVT::VALUETYPE_SIZE][ISD::BUILTIN_OP_END];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="">  /// For each load extension type and each value type, keep a LegalizeAction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="">  /// that indicates how instruction selection should deal with a load of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="">  /// specific value type and extension type. Uses 4-bits to store the action</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="">  /// for each of the 4 load ext types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="">  uint16_t LoadExtActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="">  /// For each value type pair keep a LegalizeAction that indicates whether a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="">  /// truncating store of a specific value type and truncating type is legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="">  LegalizeAction TruncStoreActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="">  /// For each indexed mode and each value type, keep a quad of LegalizeAction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="">  /// that indicates how instruction selection should deal with the load /</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="">  /// store / maskedload / maskedstore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="">  /// The first dimension is the value_type for the reference. The second</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="">  /// dimension represents the various modes for load store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class="">  uint16_t IndexedModeActions[MVT::VALUETYPE_SIZE][ISD::LAST_INDEXED_MODE];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="">  /// For each condition code (ISD::CondCode) keep a LegalizeAction that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="">  /// indicates how instruction selection should deal with the condition code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="">  /// Because each CC action takes up 4 bits, we need to have the array size be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="">  /// large enough to fit all of the value types. This can be done by rounding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="">  /// up the MVT::VALUETYPE_SIZE value to the next multiple of 8.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="">  uint32_t CondCodeActions[ISD::SETCC_INVALID][(MVT::VALUETYPE_SIZE + 7) / 8];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="">  ValueTypeActionImpl ValueTypeActions;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="">  /// Targets can specify ISD nodes that they would like PerformDAGCombine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="">  /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="">  /// array.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="">  unsigned char</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="">  TargetDAGCombineArray[(ISD::BUILTIN_OP_END+CHAR_BIT-1)/CHAR_BIT];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="">  /// For operations that must be promoted to a specific type, this holds the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="">  /// destination type.  This map should be sparse, so don't hold it as an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="">  /// array.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="">  /// Targets add entries to this map with AddPromotedToType(..), clients access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="">  /// this with getTypeToPromoteTo(..).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="">  std::map<std::pair<unsigned, MVT::SimpleValueType>, MVT::SimpleValueType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class="">    PromoteToType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="">  /// Stores the name each libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="">  const char *LibcallRoutineNames[RTLIB::UNKNOWN_LIBCALL + 1];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="">  /// The ISD::CondCode that should be used to test the result of each of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="">  /// comparison libcall against zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class="">  ISD::CondCode CmpLibcallCCs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="">  /// Stores the CallingConv that should be used for each libcall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="">  CallingConv::ID LibcallCallingConvs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="">  /// Set default libcall names and calling conventions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="">  void InitLibcalls(const Triple &TT);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="">  /// The bits of IndexedModeActions used to store the legalisation actions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="">  /// We store the data as   | ML | MS |  L |  S | each taking 4 bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="">  enum IndexedModeActionsBits {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="">    IMAB_Store = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="">    IMAB_Load = 4,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="">    IMAB_MaskedStore = 8,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="">    IMAB_MaskedLoad = 12</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="coveredLine">  void setIndexedModeAction(unsigned IdxMode, MVT VT, unsigned Shift,</td>
    <td>31840</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="">                            LegalizeAction Action) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="coveredLine">    assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE &&</td>
    <td>31840</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="">           (unsigned)Action < 0xf && "Table isn't big enough!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="coveredLine">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td>31840</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="coveredLine">    IndexedModeActions[Ty][IdxMode] &= ~(0xf << Shift);</td>
    <td>31840</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="coveredLine">    IndexedModeActions[Ty][IdxMode] |= ((uint16_t)Action) << Shift;</td>
    <td>31840</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="coveredLine">  }</td>
    <td>31840</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="coveredLine">  LegalizeAction getIndexedModeAction(unsigned IdxMode, MVT VT,</td>
    <td>144</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="">                                      unsigned Shift) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="coveredLine">    assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() &&</td>
    <td>144</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="">           "Table isn't big enough!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="coveredLine">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td>144</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="coveredLine">    return (LegalizeAction)((IndexedModeActions[Ty][IdxMode] >> Shift) & 0xf);</td>
    <td>144</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="">  /// Return true if the extension represented by \p I is free.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="">  /// \pre \p I is a sign, zero, or fp extension and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="">  ///      is[Z|FP]ExtFree of the related types is not true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="uncoveredLine">  virtual bool isExtFreeImpl(const Instruction *I) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="">  /// Depth that GatherAllAliases should should continue looking for chain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="">  /// dependencies when trying to find a more preferable chain. As an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="">  /// approximation, this should be more than the number of consecutive stores</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="">  /// expected to be merged.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="">  unsigned GatherAllAliasesMaxDepth;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="">  /// \brief Specify maximum number of store instructions per memset call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="">  /// When lowering \@llvm.memset this field specifies the maximum number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class="">  /// store operations that may be substituted for the call to memset. Targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="">  /// should assume that the memset will be done using as many of the largest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="">  /// alignment restrictions. For example, storing 9 bytes on a 32-bit machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="">  /// with 16-bit alignment would result in four 2-byte stores and one 1-byte</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="">  /// store.  This only applies to setting a constant array of a constant size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="">  unsigned MaxStoresPerMemset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="">  /// Likewise for functions with the OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="">  unsigned MaxStoresPerMemsetOptSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="">  /// \brief Specify maximum number of store instructions per memcpy call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="">  /// When lowering \@llvm.memcpy this field specifies the maximum number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="">  /// store operations that may be substituted for a call to memcpy. Targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="">  /// should assume that the memcpy will be done using as many of the largest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="">  /// alignment restrictions. For example, storing 7 bytes on a 32-bit machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="">  /// with 32-bit alignment would result in one 4-byte store, a one 2-byte store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="">  /// and one 1-byte store. This only applies to copying a constant array of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="">  /// constant size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="">  unsigned MaxStoresPerMemcpy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="">  /// Likewise for functions with the OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="">  unsigned MaxStoresPerMemcpyOptSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="">  /// \brief Specify max number of store instructions to glue in inlined memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="">  /// When memcpy is inlined based on MaxStoresPerMemcpy, specify maximum number</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="">  /// of store instructions to keep together. This helps in pairing and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="">  //  vectorization later on.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="">  unsigned MaxGluedStoresPerMemcpy = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="">  /// \brief Specify maximum number of load instructions per memcmp call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="">  /// When lowering \@llvm.memcmp this field specifies the maximum number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="">  /// pairs of load operations that may be substituted for a call to memcmp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="">  /// Targets must set this value based on the cost threshold for that target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="">  /// Targets should assume that the memcmp will be done using as many of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="">  /// largest load operations first, followed by smaller ones, if necessary, per</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="">  /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="">  /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="">  /// and one 1-byte load. This only applies to copying a constant array of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="">  /// constant size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="">  unsigned MaxLoadsPerMemcmp;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="">  /// Likewise for functions with the OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="">  unsigned MaxLoadsPerMemcmpOptSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="">  /// \brief Specify maximum number of store instructions per memmove call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="">  /// When lowering \@llvm.memmove this field specifies the maximum number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="">  /// store instructions that may be substituted for a call to memmove. Targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="">  /// should assume that the memmove will be done using as many of the largest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="">  /// alignment restrictions. For example, moving 9 bytes on a 32-bit machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="">  /// with 8-bit alignment would result in nine 1-byte stores.  This only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="">  /// applies to copying a constant array of constant size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="">  unsigned MaxStoresPerMemmove;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="">  /// Likewise for functions with the OptSize attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="">  unsigned MaxStoresPerMemmoveOptSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="">  /// Tells the code generator that select is more expensive than a branch if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class="">  /// the branch is usually predicted right.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="">  bool PredictableSelectIsExpensive;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="">  /// \see enableExtLdPromotion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="">  bool EnableExtLdPromotion;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="">  /// Return true if the value types that can be represented by the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="">  /// register class are all legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="">  bool isLegalRC(const TargetRegisterInfo &TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="">                 const TargetRegisterClass &RC) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="">  /// Replace/modify any TargetFrameIndex operands with a targte-dependent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="">  /// sequence of memory operands that is recognized by PrologEpilogInserter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="">  MachineBasicBlock *emitPatchPoint(MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="">                                    MachineBasicBlock *MBB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="">  bool IsStrictFPEnabled;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="">/// This class defines information used to lower LLVM code to legal SelectionDAG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="">/// operators that the target instruction selector can accept natively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="">/// This class also defines callbacks that targets must implement to lower</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="">/// target-specific constructs to SelectionDAG operators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="">class TargetLowering : public TargetLoweringBase {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="">  struct DAGCombinerInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="">  struct MakeLibCallOptions;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="">  TargetLowering(const TargetLowering &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class="">  TargetLowering &operator=(const TargetLowering &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="">  explicit TargetLowering(const TargetMachine &TM);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="">  bool isPositionIndependent() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="coveredLine">  virtual bool isSDNodeSourceOfDivergence(const SDNode *N,</td>
    <td>88</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="">                                          FunctionLoweringInfo *FLI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="">                                          UniformityInfo *UA) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="coveredLine">    return false;</td>
    <td>88</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="">  // default consider profitable any case where N0 has single use.  This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class="">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="">  // DAGCombiner.  Any particular target can implement its own heuristic to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="">  // restrict common combiner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="uncoveredLine">  virtual bool isReassocProfitable(SelectionDAG &DAG, SDValue N0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="">                                   SDValue N1) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="uncoveredLine">    return N0.hasOneUse();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="">  // default consider profitable any case where N0 has single use.  This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="">  // combiner.  Any particular target can implement its own heuristic to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="">  // restrict common combiner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="uncoveredLine">  virtual bool isReassocProfitable(MachineRegisterInfo &MRI, Register N0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="">                                   Register N1) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="uncoveredLine">    return MRI.hasOneNonDBGUse(N0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="coveredLine">  virtual bool isSDNodeAlwaysUniform(const SDNode * N) const {</td>
    <td>80</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="coveredLine">    return false;</td>
    <td>80</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="">  /// by reference if the node's address can be legally represented as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="">  /// pre-indexed load / store address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="uncoveredLine">  virtual bool getPreIndexedAddressParts(SDNode * /*N*/, SDValue &/*Base*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="">                                         SDValue &/*Offset*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="">                                         ISD::MemIndexedMode &/*AM*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="">                                         SelectionDAG &/*DAG*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="">  /// by reference if this node can be combined with a load / store to form a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="">  /// post-indexed load / store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="uncoveredLine">  virtual bool getPostIndexedAddressParts(SDNode * /*N*/, SDNode * /*Op*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="">                                          SDValue &/*Base*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="">                                          SDValue &/*Offset*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class="">                                          ISD::MemIndexedMode &/*AM*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="">                                          SelectionDAG &/*DAG*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="">  /// Returns true if the specified base+offset is a legal indexed addressing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class="">  /// mode for this target. \p MI is the load or store instruction that is being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="">  /// considered for transformation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="uncoveredLine">  virtual bool isIndexingLegal(MachineInstr &MI, Register Base, Register Offset,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="">                               bool IsPre, MachineRegisterInfo &MRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="">  /// Return the entry encoding for a jump table in the current function.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="">  /// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="">  virtual unsigned getJumpTableEncoding() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="">  virtual const MCExpr *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="uncoveredLine">  LowerCustomJumpTableEntry(const MachineJumpTableInfo * /*MJTI*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="">                            const MachineBasicBlock * /*MBB*/, unsigned /*uid*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="">                            MCContext &/*Ctx*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="uncoveredLine">    llvm_unreachable("Need to implement this hook if target has custom JTIs");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="">  /// Returns relocation base for the given PIC jumptable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="">  virtual SDValue getPICJumpTableRelocBase(SDValue Table,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="">                                           SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="">  /// This returns the relocation base for the given PIC jumptable, the same as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="">  /// getPICJumpTableRelocBase, but as an MCExpr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="">  virtual const MCExpr *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="">  getPICJumpTableRelocBaseExpr(const MachineFunction *MF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="">                               unsigned JTI, MCContext &Ctx) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="">  /// Return true if folding a constant offset with the given GlobalAddress is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="">  /// legal.  It is frequently not legal in PIC relocation models.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="">  virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="">  /// On x86, return true if the operand with index OpNo is a CALL or JUMP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="">  /// instruction, which can use either a memory constraint or an address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="">  /// constraint. -fasm-blocks "__asm call foo" lowers to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="">  /// call void asm sideeffect inteldialect "call ${0:P}", "*m..."</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="">  /// This function is used by a hack to choose the address constraint,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="">  /// lowering to a direct call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="uncoveredLine">  isInlineAsmTargetBranch(const SmallVectorImpl<StringRef> &AsmStrs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="">                          unsigned OpNo) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="">  bool isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="">                            SDValue &Chain) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="">                           const SDValue OldRHS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="">                           const SDValue OldRHS, SDValue &Chain,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="">                           bool IsSignaling = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="">  /// Returns a pair of (return value, chain).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="">  /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \p LC.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="">  std::pair<SDValue, SDValue> makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="">                                          EVT RetVT, ArrayRef<SDValue> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="">                                          MakeLibCallOptions CallOptions,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="">                                          const SDLoc &dl,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="">                                          SDValue Chain = SDValue()) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="">  /// Check whether parameters to a call that are passed in callee saved</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="">  /// registers are the same as from the calling function.  This needs to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="">  /// checked for tail call eligibility.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="">  bool parametersInCSRMatch(const MachineRegisterInfo &MRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="">      const uint32_t *CallerPreservedMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="">      const SmallVectorImpl<CCValAssign> &ArgLocs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="">      const SmallVectorImpl<SDValue> &OutVals) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="">  // TargetLowering Optimization Methods</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="">  /// A convenience struct that encapsulates a DAG, and two SDValues for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="">  /// returning information from TargetLowering to its clients that want to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="">  /// combine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="">  struct TargetLoweringOpt {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="">    SelectionDAG &DAG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="">    bool LegalTys;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="">    bool LegalOps;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="">    SDValue Old;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="">    SDValue New;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="coveredLine">    explicit TargetLoweringOpt(SelectionDAG &InDAG,</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="">                               bool LT, bool LO) :</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="coveredLine">      DAG(InDAG), LegalTys(LT), LegalOps(LO) {}</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="">    bool LegalTypes() const { return LegalTys; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="">    bool LegalOperations() const { return LegalOps; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="coveredLine">    bool CombineTo(SDValue O, SDValue N) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="coveredLine">      Old = O;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="coveredLine">      New = N;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="coveredLine">      return true;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="">  /// Determines the optimal series of memory ops to replace the memset / memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="">  /// Return true if the number of memory ops is below the threshold (Limit).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="">  /// Note that this is always the case when Limit is ~0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="">  /// It returns the types of the sequence of memory ops to perform</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="">  /// memset / memcpy by reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="">  findOptimalMemOpLowering(std::vector<EVT> &MemOps, unsigned Limit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="">                           const MemOp &Op, unsigned DstAS, unsigned SrcAS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="">                           const AttributeList &FuncAttributes) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="">  /// Check to see if the specified operand of the specified instruction is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="">  /// constant integer.  If so, check to see if there are any bits set in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="">  /// constant that are not demanded.  If so, shrink the constant and return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class="">                              const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="">                              TargetLoweringOpt &TLO) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="">  /// Helper wrapper around ShrinkDemandedConstant, demanding all elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class="">                              TargetLoweringOpt &TLO) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class="">  // Target hook to do target-specific const optimization, which is called by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="">  // ShrinkDemandedConstant. This function should return true if the target</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="">  // doesn't want ShrinkDemandedConstant to further optimize the constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="uncoveredLine">  virtual bool targetShrinkDemandedConstant(SDValue Op,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="">                                            const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="">                                            const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="">                                            TargetLoweringOpt &TLO) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="">  /// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.  This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="">  /// uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="">  /// generalized for targets with other types of implicit widening casts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="">  bool ShrinkDemandedOp(SDValue Op, unsigned BitWidth,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="">                        const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="">                        TargetLoweringOpt &TLO) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="">  /// Look at Op.  At this point, we know that only the DemandedBits bits of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="">  /// result of Op are ever used downstream.  If we can use this information to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="">  /// simplify Op, create a new simplified DAG node and return true, returning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="">  /// the original and new nodes in Old and New.  Otherwise, analyze the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="">  /// be accurate for those bits in the Demanded masks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="">  ///    has multiple uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="">                            const APInt &DemandedElts, KnownBits &Known,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="">                            TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="">                            bool AssumeSingleUse = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="">  /// Helper wrapper around SimplifyDemandedBits, demanding all elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="">  /// Adds Op back to the worklist upon success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="">                            KnownBits &Known, TargetLoweringOpt &TLO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="">                            unsigned Depth = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="">                            bool AssumeSingleUse = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="">  /// Adds Op back to the worklist upon success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="">                            DAGCombinerInfo &DCI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="">  /// Adds Op back to the worklist upon success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="">                            const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="">                            DAGCombinerInfo &DCI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="">  /// bitwise ops etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="">                                          const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="">                                          SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="">                                          unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="">  /// elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="">                                          SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="">                                          unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="">  /// bits from only some vector elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="">  SDValue SimplifyMultipleUseDemandedVectorElts(SDValue Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="">                                                const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="">                                                SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="">                                                unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="">  /// Look at Vector Op. At this point, we know that only the DemandedElts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="">  /// elements of the result of Op are ever used downstream.  If we can use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="">  /// this information to simplify Op, create a new simplified DAG node and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="">  /// return true, storing the original and new nodes in TLO.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="">  /// Otherwise, analyze the expression and return a mask of KnownUndef and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="">  /// KnownZero elements for the expression (used to simplify the caller).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="">  /// The KnownUndef/Zero elements may only be accurate for those bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="">  /// in the DemandedMask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="">  ///    has multiple uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedEltMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="">                                  APInt &KnownUndef, APInt &KnownZero,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="">                                  TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="">                                  bool AssumeSingleUse = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="">  /// Helper wrapper around SimplifyDemandedVectorElts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="">  /// Adds Op back to the worklist upon success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="">                                  DAGCombinerInfo &DCI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="">  /// Return true if the target supports simplifying demanded vector elements by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="">  /// converting them to undefs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="uncoveredLine">  shouldSimplifyDemandedVectorElts(SDValue Op,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="">                                   const TargetLoweringOpt &TLO) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="">  /// requested vector elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="">  virtual void computeKnownBitsForTargetNode(const SDValue Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="">                                             KnownBits &Known,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="">                                             const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="">                                             const SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="">                                             unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="">  /// requested vector elements. This is for GISel.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="">  virtual void computeKnownBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="">                                              Register R, KnownBits &Known,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="">                                              const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="">                                              const MachineRegisterInfo &MRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="">                                              unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="">  /// Determine the known alignment for the pointer value \p R. This is can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="">  /// typically be inferred from the number of low known 0 bits. However, for a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="">  /// pointer with a non-integral address space, the alignment value may be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="">  /// independent from the known low bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="">  virtual Align computeKnownAlignForTargetInstr(GISelKnownBits &Analysis,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="">                                                Register R,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="">                                                const MachineRegisterInfo &MRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="">                                                unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="">  /// Determine which of the bits of FrameIndex \p FIOp are known to be 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="">  /// Default implementation computes low bits based on alignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="">  /// information. This should preserve known bits passed into it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="">  virtual void computeKnownBitsForFrameIndex(int FIOp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="">                                             KnownBits &Known,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="">                                             const MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="">  /// This method can be implemented by targets that want to expose additional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="">  /// information about sign bits to the DAG Combiner. The DemandedElts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="">  /// by the requested vector elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="">  virtual unsigned ComputeNumSignBitsForTargetNode(SDValue Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="">                                                   const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="">                                                   const SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="">                                                   unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="">  /// This method can be implemented by targets that want to expose additional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="">  /// information about sign bits to GlobalISel combiners. The DemandedElts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="">  /// by the requested vector elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="">  virtual unsigned computeNumSignBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="">                                                    Register R,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="">                                                    const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="">                                                    const MachineRegisterInfo &MRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="">                                                    unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="">  /// Attempt to simplify any target nodes based on the demanded vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="">  /// elements, returning true on success. Otherwise, analyze the expression and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="">  /// return a mask of KnownUndef and KnownZero elements for the expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="">  /// (used to simplify the caller). The KnownUndef/Zero elements may only be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="">  /// accurate for those bits in the DemandedMask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="">  virtual bool SimplifyDemandedVectorEltsForTargetNode(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="">      SDValue Op, const APInt &DemandedElts, APInt &KnownUndef,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="">      APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="">  /// Attempt to simplify any target nodes based on the demanded bits/elts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="">  /// returning true on success. Otherwise, analyze the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="">  /// be accurate for those bits in the Demanded masks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="">  virtual bool SimplifyDemandedBitsForTargetNode(SDValue Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="">                                                 const APInt &DemandedBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="">                                                 const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="">                                                 KnownBits &Known,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="">                                                 TargetLoweringOpt &TLO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class="">                                                 unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="">  /// bitwise ops etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="">  virtual SDValue SimplifyMultipleUseDemandedBitsForTargetNode(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="">      SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="">      SelectionDAG &DAG, unsigned Depth) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="">  /// Return true if this function can prove that \p Op is never poison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="">  /// and, if \p PoisonOnly is false, does not have undef bits. The DemandedElts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="">  /// argument limits the check to the requested vector elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="">  virtual bool isGuaranteedNotToBeUndefOrPoisonForTargetNode(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class="">      SDValue Op, const APInt &DemandedElts, const SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="">      bool PoisonOnly, unsigned Depth) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="">  /// Return true if Op can create undef or poison from non-undef & non-poison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="">  /// operands. The DemandedElts argument limits the check to the requested</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="">  /// vector elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="">  canCreateUndefOrPoisonForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="">                                      const SelectionDAG &DAG, bool PoisonOnly,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="">                                      bool ConsiderFlags, unsigned Depth) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class="">  /// Tries to build a legal vector shuffle using the provided parameters</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="">  /// or equivalent variations. The Mask argument maybe be modified as the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="">  /// function tries different variations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class="">  /// Returns an empty SDValue if the operation fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="">  SDValue buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="">                                  SDValue N1, MutableArrayRef<int> Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="">                                  SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="">  /// This method returns the constant pool value that will be loaded by LD.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="">  /// NOTE: You must check for implicit extensions of the constant by LD.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="">  virtual const Constant *getTargetConstantFromLoad(LoadSDNode *LD) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="">  /// If \p SNaN is false, \returns true if \p Op is known to never be any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="">  /// NaN. If \p sNaN is true, returns if \p Op is known to never be a signaling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="">  /// NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="">  virtual bool isKnownNeverNaNForTargetNode(SDValue Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="">                                            const SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="">                                            bool SNaN = false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="">                                            unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="">  /// Return true if vector \p Op has the same value across all \p DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="">  /// indicating any elements which may be undef in the output \p UndefElts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="">  virtual bool isSplatValueForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="">                                         APInt &UndefElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="">                                         const SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="">                                         unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="">  /// Returns true if the given Opc is considered a canonical constant for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="">  /// target, which should not be transformed back into a BUILD_VECTOR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="coveredLine">  virtual bool isTargetCanonicalConstantNode(SDValue Op) const {</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="coveredLine">    return Op.getOpcode() == ISD::SPLAT_VECTOR;</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class="">  struct DAGCombinerInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="">    void *DC;  // The DAG Combiner object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="">    CombineLevel Level;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="">    bool CalledByLegalizer;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="">    SelectionDAG &DAG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="coveredLine">    DAGCombinerInfo(SelectionDAG &dag, CombineLevel level,  bool cl, void *dc)</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="coveredLine">      : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag) {}</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class="uncoveredLine">    bool isBeforeLegalize() const { return Level == BeforeLegalizeTypes; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="coveredLine">    bool isBeforeLegalizeOps() const { return Level < AfterLegalizeVectorOps; }</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="uncoveredLine">    bool isAfterLegalizeDAG() const { return Level >= AfterLegalizeDAG; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="uncoveredLine">    CombineLevel getDAGCombineLevel() { return Level; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="uncoveredLine">    bool isCalledByLegalizer() const { return CalledByLegalizer; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="">    void AddToWorklist(SDNode *N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="">    SDValue CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="">    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="">    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="">    bool recursivelyDeleteUnusedNodes(SDNode *N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="">    void CommitTargetLoweringOpt(const TargetLoweringOpt &TLO);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="">  /// Return if the N is a constant or constant vector equal to the true value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="">  /// from getBooleanContents().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="">  bool isConstTrueVal(SDValue N) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="">  /// Return if the N is a constant or constant vector equal to the false value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="">  /// from getBooleanContents().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="">  bool isConstFalseVal(SDValue N) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="">  /// Return if \p N is a True value when extended to \p VT.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="">  bool isExtendedTrueVal(const ConstantSDNode *N, EVT VT, bool SExt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="">  /// Try to simplify a setcc built with the specified operands and cc. If it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="">  /// unable to simplify it, return a null SDValue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="">  SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="">                        bool foldBooleans, DAGCombinerInfo &DCI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="">                        const SDLoc &dl) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="">  // For targets which wrap address, unwrap for analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="uncoveredLine">  virtual SDValue unwrapAddress(SDValue N) const { return N; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="">  /// Returns true (and the GlobalValue and the offset) if the node is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="">  /// GlobalAddress + offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="">  isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="">  /// This method will be invoked for all target nodes and for any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="">  /// target-independent nodes that the target has registered with invoke it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="">  /// for.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="">  /// The semantics are as follows:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="">  /// Return Value:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="">  ///   SDValue.Val == 0   - No change was made</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="">  ///   SDValue.Val == N   - N was replaced, is dead, and is already handled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="">  ///   otherwise          - N should be replaced by the returned Operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="">  /// In addition, methods provided by DAGCombinerInfo may be used to perform</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="">  /// more complex transformations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="">  virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="">  /// Return true if it is profitable to move this shift by a constant amount</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="">  /// through its operand, adjusting any immediate operands as necessary to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="">  /// preserve semantics. This transformation may not be desirable if it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="">  /// disrupts a particularly auspicious target-specific tree (e.g. bitfield</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="">  /// extraction in AArch64). By default, it returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="">  /// @param N the shift node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="">  /// @param Level the current DAGCombine legalization level.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="uncoveredLine">  virtual bool isDesirableToCommuteWithShift(const SDNode *N,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="">                                             CombineLevel Level) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="">  /// GlobalISel - return true if it is profitable to move this shift by a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="">  /// constant amount through its operand, adjusting any immediate operands as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="">  /// necessary to preserve semantics. This transformation may not be desirable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="">  /// bitfield extraction in AArch64). By default, it returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="">  /// @param MI the shift instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="">  /// @param IsAfterLegal true if running after legalization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="uncoveredLine">  virtual bool isDesirableToCommuteWithShift(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="">                                             bool IsAfterLegal) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="">  // Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class="">  // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="">  // writing this) is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="">  //    With C as a power of 2 and C != 0 and C != INT_MIN:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="">  //    AddAnd:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="">  //            -> (icmp eq and(add(A, C), ~(C + C)), 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="">  //            -> (icmp ne and(add(A, C), ~(C + C)), 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="">  //    ABS:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="">  //            -> (icmp eq Abs(A), C)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="">  //            -> (icmp ne Abs(A), C)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="">  // @param LogicOp the logic op</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="">  // @param SETCC0 the first of the SETCC nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="">  // @param SETCC0 the second of the SETCC nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="uncoveredLine">  virtual AndOrSETCCFoldKind isDesirableToCombineLogicOpOfSETCC(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="">      const SDNode *LogicOp, const SDNode *SETCC0, const SDNode *SETCC1) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="uncoveredLine">    return AndOrSETCCFoldKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="">  /// Return true if it is profitable to combine an XOR of a logical shift</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="">  /// to create a logical shift of NOT. This transformation may not be desirable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="">  /// BIC on ARM/AArch64). By default, it returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="uncoveredLine">  virtual bool isDesirableToCommuteXorWithShift(const SDNode *N) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="">  /// Return true if the target has native support for the specified value type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="">  /// and it is 'desirable' to use the type for the given node type. e.g. On x86</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="">  /// i16 is legal, but undesirable since i16 instruction encodings are longer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="">  /// and some i16 instructions are slow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="coveredLine">  virtual bool isTypeDesirableForOp(unsigned /*Opc*/, EVT VT) const {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="">    // By default, assume all legal types are desirable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="coveredLine">    return isTypeLegal(VT);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="">  /// Return true if it is profitable for dag combiner to transform a floating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="">  /// point op of specified opcode to a equivalent op of an integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="">  /// type. e.g. f32 load -> i32 load can be profitable on ARM.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="uncoveredLine">  virtual bool isDesirableToTransformToIntegerOp(unsigned /*Opc*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="">                                                 EVT /*VT*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="">  /// This method query the target whether it is beneficial for dag combiner to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="">  /// promote the specified node. If true, it should return the desired</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="">  /// promotion type by reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="uncoveredLine">  virtual bool IsDesirableToPromoteOp(SDValue /*Op*/, EVT &/*PVT*/) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="">  /// Return true if the target supports swifterror attribute. It optimizes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="">  /// loads and stores to reading and writing a specific register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="coveredLine">  virtual bool supportSwiftError() const {</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class="coveredLine">    return false;</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="">  /// Return true if the target supports that a subset of CSRs for the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="">  /// machine function is handled explicitly via copies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="uncoveredLine">  virtual bool supportSplitCSR(MachineFunction *MF) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="">  /// Return true if the target supports kcfi operand bundles.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="uncoveredLine">  virtual bool supportKCFIBundles() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="">  /// Perform necessary initialization to handle a subset of CSRs explicitly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="">  /// via copies. This function is called at the beginning of instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="">  /// selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="uncoveredLine">  virtual void initializeSplitCSR(MachineBasicBlock *Entry) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="uncoveredLine">    llvm_unreachable("Not Implemented");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="">  /// Insert explicit copies in entry and exit blocks. We copy a subset of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="">  /// CSRs to virtual registers in the entry block, and copy them back to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="">  /// physical registers in the exit blocks. This function is called at the end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="">  /// of instruction selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="uncoveredLine">  virtual void insertCopiesSplitCSR(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="">      MachineBasicBlock *Entry,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="">      const SmallVectorImpl<MachineBasicBlock *> &Exits) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="uncoveredLine">    llvm_unreachable("Not Implemented");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="">  /// Return the newly negated expression if the cost is not expensive and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="">  /// set the cost in \p Cost to indicate that if it is cheaper or neutral to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="">  /// do the negation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="">  virtual SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="">                                       bool LegalOps, bool OptForSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="">                                       NegatibleCost &Cost,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="">                                       unsigned Depth = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="uncoveredLine">  SDValue getCheaperOrNeutralNegatedExpression(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="">      SDValue Op, SelectionDAG &DAG, bool LegalOps, bool OptForSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="">      const NegatibleCost CostThreshold = NegatibleCost::Neutral,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="">      unsigned Depth = 0) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="uncoveredLine">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="">    SDValue Neg =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="uncoveredLine">        getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="uncoveredLine">    if (!Neg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="uncoveredLine">      return SDValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="uncoveredLine">    if (Cost <= CostThreshold)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="uncoveredLine">      return Neg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="">    // Remove the new created node to avoid the side effect to the DAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="uncoveredLine">    if (Neg->use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="uncoveredLine">      DAG.RemoveDeadNode(Neg.getNode());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="uncoveredLine">    return SDValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="">  /// This is the helper function to return the newly negated expression only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="">  /// when the cost is cheaper.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="uncoveredLine">  SDValue getCheaperNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="">                                      bool LegalOps, bool OptForSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="">                                      unsigned Depth = 0) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="uncoveredLine">    return getCheaperOrNeutralNegatedExpression(Op, DAG, LegalOps, OptForSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="uncoveredLine">                                                NegatibleCost::Cheaper, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="">  /// This is the helper function to return the newly negated expression if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="">  /// the cost is not expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="uncoveredLine">  SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG, bool LegalOps,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="">                               bool OptForSize, unsigned Depth = 0) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="uncoveredLine">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="uncoveredLine">    return getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="">  // Lowering methods - These methods must be implemented by targets so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="">  // the SelectionDAGBuilder code knows how to lower these.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="">  /// Target-specific splitting of values into parts that fit a register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="">  /// storing a legal type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="coveredLine">  virtual bool splitValueIntoRegisterParts(</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="">      SelectionDAG & DAG, const SDLoc &DL, SDValue Val, SDValue *Parts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="">      unsigned NumParts, MVT PartVT, std::optional<CallingConv::ID> CC) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="coveredLine">    return false;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="">  /// Allows the target to handle physreg-carried dependency</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="">  /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="">  /// to add the edge to the dependency graph.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="">  /// Def - input: Selection DAG node defininfg physical register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="">  /// User - input: Selection DAG node using physical register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="">  /// Op - input: Number of User operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="">  /// PhysReg - inout: set to the physical register if the edge is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="">  /// necessary, unchanged otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="">  /// Cost - inout: physical register copy cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="">  /// Returns 'true' is the edge is necessary, 'false' otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="coveredLine">  virtual bool checkForPhysRegDependency(SDNode *Def, SDNode *User, unsigned Op,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="">                                         const TargetRegisterInfo *TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="">                                         const TargetInstrInfo *TII,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="">                                         unsigned &PhysReg, int &Cost) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="coveredLine">    return false;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="">  /// Target-specific combining of register parts into its original value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="">  virtual SDValue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class="coveredLine">  joinRegisterPartsIntoValue(SelectionDAG &DAG, const SDLoc &DL,</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="">                             const SDValue *Parts, unsigned NumParts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="">                             MVT PartVT, EVT ValueVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="">                             std::optional<CallingConv::ID> CC) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="coveredLine">    return SDValue();</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="">  /// This hook must be implemented to lower the incoming (formal) arguments,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="">  /// described by the Ins array, into the specified DAG. The implementation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="">  /// should fill in the InVals array with legal-type argument values, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="">  /// return the resulting token chain value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="uncoveredLine">  virtual SDValue LowerFormalArguments(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="">      SDValue /*Chain*/, CallingConv::ID /*CallConv*/, bool /*isVarArg*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="">      const SmallVectorImpl<ISD::InputArg> & /*Ins*/, const SDLoc & /*dl*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="">      SelectionDAG & /*DAG*/, SmallVectorImpl<SDValue> & /*InVals*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="uncoveredLine">    llvm_unreachable("Not Implemented");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="">  /// This structure contains all information that is necessary for lowering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="">  /// calls. It is passed to TLI::LowerCallTo when the SelectionDAG builder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class="">  /// needs to lower a call, and targets will see this struct in their LowerCall</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="">  /// implementation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="">  struct CallLoweringInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="">    SDValue Chain;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="">    Type *RetTy = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="">    bool RetSExt           : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="">    bool RetZExt           : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="">    bool IsVarArg          : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="">    bool IsInReg           : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class="">    bool DoesNotReturn     : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="">    bool IsReturnValueUsed : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="">    bool IsConvergent      : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="">    bool IsPatchPoint      : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="">    bool IsPreallocated : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="">    bool NoMerge           : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="">    // IsTailCall should be modified by implementations of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="">    // TargetLowering::LowerCall that perform tail call conversions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="">    bool IsTailCall = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="">    // Is Call lowering done post SelectionDAG type legalization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="">    bool IsPostTypeLegalization = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="">    unsigned NumFixedArgs = -1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="">    CallingConv::ID CallConv = CallingConv::C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="">    SDValue Callee;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="">    ArgListTy Args;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="">    SelectionDAG &DAG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="">    SDLoc DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="">    const CallBase *CB = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="">    SmallVector<ISD::OutputArg, 32> Outs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="">    SmallVector<SDValue, 32> OutVals;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class="">    SmallVector<ISD::InputArg, 32> Ins;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="">    SmallVector<SDValue, 4> InVals;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="">    const ConstantInt *CFIType = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="uncoveredLine">    CallLoweringInfo(SelectionDAG &DAG)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="uncoveredLine">        : RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="uncoveredLine">          DoesNotReturn(false), IsReturnValueUsed(true), IsConvergent(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="uncoveredLine">          IsPatchPoint(false), IsPreallocated(false), NoMerge(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="uncoveredLine">          DAG(DAG) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="uncoveredLine">    CallLoweringInfo &setDebugLoc(const SDLoc &dl) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="uncoveredLine">      DL = dl;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="uncoveredLine">    CallLoweringInfo &setChain(SDValue InChain) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="uncoveredLine">      Chain = InChain;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="">    // setCallee with target/module-specific attributes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="uncoveredLine">    CallLoweringInfo &setLibCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="">                                   SDValue Target, ArgListTy &&ArgsList) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="uncoveredLine">      RetTy = ResultType;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="uncoveredLine">      Callee = Target;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="uncoveredLine">      CallConv = CC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="uncoveredLine">      NumFixedArgs = ArgsList.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="uncoveredLine">      Args = std::move(ArgsList);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="uncoveredLine">      DAG.getTargetLoweringInfo().markLibCallAttributes(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="uncoveredLine">          &(DAG.getMachineFunction()), CC, Args);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="uncoveredLine">    CallLoweringInfo &setCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="">                                SDValue Target, ArgListTy &&ArgsList) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="uncoveredLine">      RetTy = ResultType;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="uncoveredLine">      Callee = Target;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="uncoveredLine">      CallConv = CC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="uncoveredLine">      NumFixedArgs = ArgsList.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="uncoveredLine">      Args = std::move(ArgsList);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="">    CallLoweringInfo &setCallee(Type *ResultType, FunctionType *FTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="">                                SDValue Target, ArgListTy &&ArgsList,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="">                                const CallBase &Call) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="">      RetTy = ResultType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="">      IsInReg = Call.hasRetAttr(Attribute::InReg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="">      DoesNotReturn =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="">          Call.doesNotReturn() ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="">          (!isa<InvokeInst>(Call) && isa<UnreachableInst>(Call.getNextNode()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="">      IsVarArg = FTy->isVarArg();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="">      IsReturnValueUsed = !Call.use_empty();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="">      RetSExt = Call.hasRetAttr(Attribute::SExt);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="">      RetZExt = Call.hasRetAttr(Attribute::ZExt);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="">      NoMerge = Call.hasFnAttr(Attribute::NoMerge);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="">      Callee = Target;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="">      CallConv = Call.getCallingConv();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="">      NumFixedArgs = FTy->getNumParams();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="">      Args = std::move(ArgsList);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="">      CB = &Call;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="uncoveredLine">    CallLoweringInfo &setInRegister(bool Value = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="uncoveredLine">      IsInReg = Value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="">    CallLoweringInfo &setNoReturn(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="">      DoesNotReturn = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="">    CallLoweringInfo &setVarArg(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="">      IsVarArg = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="uncoveredLine">    CallLoweringInfo &setTailCall(bool Value = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="uncoveredLine">      IsTailCall = Value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="uncoveredLine">    CallLoweringInfo &setDiscardResult(bool Value = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="uncoveredLine">      IsReturnValueUsed = !Value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="">    CallLoweringInfo &setConvergent(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="">      IsConvergent = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="uncoveredLine">    CallLoweringInfo &setSExtResult(bool Value = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="uncoveredLine">      RetSExt = Value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="uncoveredLine">    CallLoweringInfo &setZExtResult(bool Value = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="uncoveredLine">      RetZExt = Value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="">    CallLoweringInfo &setIsPatchPoint(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="">      IsPatchPoint = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="">    CallLoweringInfo &setIsPreallocated(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="">      IsPreallocated = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="uncoveredLine">    CallLoweringInfo &setIsPostTypeLegalization(bool Value=true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="uncoveredLine">      IsPostTypeLegalization = Value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="">    CallLoweringInfo &setCFIType(const ConstantInt *Type) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="">      CFIType = Type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="">    ArgListTy &getArgs() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="">      return Args;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="">  /// This structure is used to pass arguments to makeLibCall function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="">  struct MakeLibCallOptions {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="">    // By passing type list before soften to makeLibCall, the target hook</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="">    // shouldExtendTypeInLibCall can get the original type before soften.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="">    ArrayRef<EVT> OpsVTBeforeSoften;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="">    EVT RetVTBeforeSoften;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="">    bool IsSExt : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="">    bool DoesNotReturn : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="">    bool IsReturnValueUsed : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="">    bool IsPostTypeLegalization : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="">    bool IsSoften : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="uncoveredLine">    MakeLibCallOptions()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="uncoveredLine">        : IsSExt(false), DoesNotReturn(false), IsReturnValueUsed(true),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="uncoveredLine">          IsPostTypeLegalization(false), IsSoften(false) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="uncoveredLine">    MakeLibCallOptions &setSExt(bool Value = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="uncoveredLine">      IsSExt = Value;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="">    MakeLibCallOptions &setNoReturn(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="">      DoesNotReturn = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="">    MakeLibCallOptions &setDiscardResult(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="">      IsReturnValueUsed = !Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="">    MakeLibCallOptions &setIsPostTypeLegalization(bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="">      IsPostTypeLegalization = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="">    MakeLibCallOptions &setTypeListBeforeSoften(ArrayRef<EVT> OpsVT, EVT RetVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="">                                                bool Value = true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="">      OpsVTBeforeSoften = OpsVT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="">      RetVTBeforeSoften = RetVT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="">      IsSoften = Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="">  /// This function lowers an abstract call to a function into an actual call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="">  /// This returns a pair of operands.  The first element is the return value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="">  /// for the function (if RetTy is not VoidTy).  The second element is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="">  /// outgoing token chain. It calls LowerCall to do the actual lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="">  std::pair<SDValue, SDValue> LowerCallTo(CallLoweringInfo &CLI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="">  /// This hook must be implemented to lower calls into the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="">  /// DAG. The outgoing arguments to the call are described by the Outs array,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="">  /// and the values to be returned by the call are described by the Ins</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="">  /// array. The implementation should fill in the InVals array with legal-type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="">  /// return values from the call, and return the resulting token chain value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="">  virtual SDValue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="">    LowerCall(CallLoweringInfo &/*CLI*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="">              SmallVectorImpl<SDValue> &/*InVals*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="">    llvm_unreachable("Not Implemented");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="">  /// Target-specific cleanup for formal ByVal parameters.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="uncoveredLine">  virtual void HandleByVal(CCState *, unsigned &, Align) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="">  /// This hook should be implemented to check whether the return values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="">  /// described by the Outs array can fit into the return registers.  If false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="">  /// is returned, an sret-demotion is performed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="uncoveredLine">  virtual bool CanLowerReturn(CallingConv::ID /*CallConv*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="">                              MachineFunction &/*MF*/, bool /*isVarArg*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="">               const SmallVectorImpl<ISD::OutputArg> &/*Outs*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="">               LLVMContext &/*Context*/) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="">  {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="">    // Return true by default to get preexisting behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="">  /// This hook must be implemented to lower outgoing return values, described</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="">  /// by the Outs array, into the specified DAG. The implementation should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="">  /// return the resulting token chain value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="">  virtual SDValue LowerReturn(SDValue /*Chain*/, CallingConv::ID /*CallConv*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="">                              bool /*isVarArg*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="">                              const SmallVectorImpl<ISD::OutputArg> & /*Outs*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="">                              const SmallVectorImpl<SDValue> & /*OutVals*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="">                              const SDLoc & /*dl*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="">                              SelectionDAG & /*DAG*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="">    llvm_unreachable("Not Implemented");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="">  /// Return true if result of the specified node is used by a return node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="">  /// only. It also compute and return the input chain for the tail call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="">  /// This is used to determine whether it is possible to codegen a libcall as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="">  /// tail call at legalization time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="uncoveredLine">  virtual bool isUsedByReturnOnly(SDNode *, SDValue &/*Chain*/) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="">  /// Return true if the target may be able emit the call instruction as a tail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="">  /// call. This is used by optimization passes to determine if it's profitable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="">  /// to duplicate return instructions to enable tailcall optimization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="uncoveredLine">  virtual bool mayBeEmittedAsTailCall(const CallInst *) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="">  /// Return the builtin name for the __builtin___clear_cache intrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="">  /// Default is to invoke the clear cache library call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="uncoveredLine">  virtual const char * getClearCacheBuiltinName() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="uncoveredLine">    return "__clear_cache";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="">  /// Return the register ID of the name passed in. Used by named register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="">  /// global variables extension. There is no target-independent behaviour</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="">  /// so the default action is to bail.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="uncoveredLine">  virtual Register getRegisterByName(const char* RegName, LLT Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="">                                     const MachineFunction &MF) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="uncoveredLine">    report_fatal_error("Named registers not implemented for this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="">  /// Return the type that should be used to zero or sign extend a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="">  /// zeroext/signext integer return value.  FIXME: Some C calling conventions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="">  /// require the return type to be promoted, but this is not true all the time,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="">  /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="">  /// conventions. The frontend should handle this and include all of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="">  /// necessary information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="uncoveredLine">  virtual EVT getTypeForExtReturn(LLVMContext &Context, EVT VT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="">                                       ISD::NodeType /*ExtendKind*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="uncoveredLine">    EVT MinVT = getRegisterType(MVT::i32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="uncoveredLine">    return VT.bitsLT(MinVT) ? MinVT : VT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="">  /// For some targets, an LLVM struct type must be broken down into multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="">  /// simple types, but the calling convention specifies that the entire struct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="">  /// must be passed in a block of consecutive registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="coveredLine">  functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv,</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="">                                            bool isVarArg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="">                                            const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="coveredLine">    return false;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="">  /// For most targets, an LLVM type must be broken down into multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="">  /// smaller types. Usually the halves are ordered according to the endianness</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="">  /// but for some platform that would break. So this method will default to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="">  /// matching the endianness but can be overridden.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="uncoveredLine">  shouldSplitFunctionArgumentsAsLittleEndian(const DataLayout &DL) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="uncoveredLine">    return DL.isLittleEndian();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="">  /// Returns a 0 terminated array of registers that can be safely used as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="">  /// scratch registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="uncoveredLine">  virtual const MCPhysReg *getScratchRegisters(CallingConv::ID CC) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="">  /// Returns a 0 terminated array of rounding control registers that can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="">  /// attached into strict FP call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="uncoveredLine">  virtual ArrayRef<MCPhysReg> getRoundingControlRegisters() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="uncoveredLine">    return ArrayRef<MCPhysReg>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="">  /// This callback is used to prepare for a volatile or atomic load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="">  /// It takes a chain node as input and returns the chain for the load itself.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="">  /// Having a callback like this is necessary for targets like SystemZ,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="">  /// which allows a CPU to reuse the result of a previous load indefinitely,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="">  /// even if a cache-coherent store is performed by another CPU.  The default</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="">  /// implementation does nothing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="uncoveredLine">  virtual SDValue prepareVolatileOrAtomicLoad(SDValue Chain, const SDLoc &DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="">                                              SelectionDAG &DAG) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="uncoveredLine">    return Chain;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="">  /// Should SelectionDAG lower an atomic store of the given kind as a normal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="">  /// StoreSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="">  /// eventually migrate all targets to the using StoreSDNodes, but porting is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="">  /// being done target at a time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="uncoveredLine">  virtual bool lowerAtomicStoreAsStoreSDNode(const StoreInst &SI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="uncoveredLine">    assert(SI.isAtomic() && "violated precondition");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="">  /// Should SelectionDAG lower an atomic load of the given kind as a normal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="">  /// LoadSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="">  /// eventually migrate all targets to the using LoadSDNodes, but porting is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="">  /// being done target at a time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="uncoveredLine">  virtual bool lowerAtomicLoadAsLoadSDNode(const LoadInst &LI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="uncoveredLine">    assert(LI.isAtomic() && "violated precondition");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="">  /// This callback is invoked by the type legalizer to legalize nodes with an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="">  /// illegal operand type but legal result types.  It replaces the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="">  /// LowerOperation callback in the type Legalizer.  The reason we can not do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="">  /// away with LowerOperation entirely is that LegalizeDAG isn't yet ready to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="">  /// use this callback.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="">  /// TODO: Consider merging with ReplaceNodeResults.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="">  /// The target places new result values for the node in Results (their number</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="">  /// and types must exactly match those of the original return values of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="">  /// the node), or leaves Results empty, which indicates that the node is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="">  /// to be custom lowered after all.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="">  /// The default implementation calls LowerOperation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="">  virtual void LowerOperationWrapper(SDNode *N,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="">                                     SmallVectorImpl<SDValue> &Results,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="">                                     SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="">  /// This callback is invoked for operations that are unsupported by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="">  /// target, which are registered to use 'custom' lowering, and whose defined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="">  /// values are all legal.  If the target has no operations that require custom</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="">  /// lowering, it need not implement this.  The default implementation of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="">  /// aborts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="">  virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="">  /// This callback is invoked when a node result type is illegal for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="">  /// target, and the operation was registered to use 'custom' lowering for that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="">  /// result type.  The target places new result values for the node in Results</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="">  /// (their number and types must exactly match those of the original return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="">  /// values of the node), or leaves Results empty, which indicates that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="">  /// node is not to be custom lowered after all.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="">  /// If the target has no operations that require custom lowering, it need not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="">  /// implement this.  The default implementation aborts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="uncoveredLine">  virtual void ReplaceNodeResults(SDNode * /*N*/,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="">                                  SmallVectorImpl<SDValue> &/*Results*/,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="">                                  SelectionDAG &/*DAG*/) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="uncoveredLine">    llvm_unreachable("ReplaceNodeResults not implemented for this target!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="">  /// This method returns the name of a target specific DAG node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="">  virtual const char *getTargetNodeName(unsigned Opcode) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="">  /// This method returns a target specific FastISel object, or null if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="">  /// target does not support "fast" ISel.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="uncoveredLine">  virtual FastISel *createFastISel(FunctionLoweringInfo &,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="">                                   const TargetLibraryInfo *) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="">  bool verifyReturnAddressArgumentIsConstant(SDValue Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="">                                             SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="">  // Inline Asm Support hooks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="">  /// This hook allows the target to expand an inline asm call to be explicit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="">  /// llvm code if it wants to.  This is useful for turning simple inline asms</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="">  /// into LLVM intrinsics, which gives the compiler more information about the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="">  /// behavior of the code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="uncoveredLine">  virtual bool ExpandInlineAsm(CallInst *) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="">  enum ConstraintType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="">    C_Register,            // Constraint represents specific register(s).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="">    C_RegisterClass,       // Constraint represents any of register(s) in class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="">    C_Memory,              // Memory constraint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="">    C_Address,             // Address constraint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="">    C_Immediate,           // Requires an immediate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="">    C_Other,               // Something else.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="">    C_Unknown              // Unsupported constraint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="">  enum ConstraintWeight {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="">    // Generic weights.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="">    CW_Invalid  = -1,     // No match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="">    CW_Okay     = 0,      // Acceptable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="">    CW_Good     = 1,      // Good weight.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="">    CW_Better   = 2,      // Better weight.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="">    CW_Best     = 3,      // Best weight.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="">    // Well-known weights.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="">    CW_SpecificReg  = CW_Okay,    // Specific register operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="">    CW_Register     = CW_Good,    // Register operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="">    CW_Memory       = CW_Better,  // Memory operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="">    CW_Constant     = CW_Best,    // Constant operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="">    CW_Default      = CW_Okay     // Default or don't know type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="">  /// This contains information for each constraint that we are lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="">  struct AsmOperandInfo : public InlineAsm::ConstraintInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="">    /// This contains the actual string for the code, like "m".  TargetLowering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="">    /// picks the 'best' code from ConstraintInfo::Codes that most closely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="">    /// matches the operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="">    std::string ConstraintCode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class="">    /// Information about the constraint code, e.g. Register, RegisterClass,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="">    /// Memory, Other, Unknown.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="">    TargetLowering::ConstraintType ConstraintType = TargetLowering::C_Unknown;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="">    /// If this is the result output operand or a clobber, this is null,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="">    /// otherwise it is the incoming operand to the CallInst.  This gets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="">    /// modified as the asm is processed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="">    Value *CallOperandVal = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="">    /// The ValueType for the operand value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="">    MVT ConstraintVT = MVT::Other;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="">    /// Copy constructor for copying from a ConstraintInfo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="">    AsmOperandInfo(InlineAsm::ConstraintInfo Info)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="">        : InlineAsm::ConstraintInfo(std::move(Info)) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="">    /// Return true of this is an input operand that is a matching constraint</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="">    /// like "4".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="">    bool isMatchingInputConstraint() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="">    /// If this is an input matching constraint, this method returns the output</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="">    /// operand it matches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="">    unsigned getMatchedOperand() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="">  using AsmOperandInfoVector = std::vector<AsmOperandInfo>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="">  /// Split up the constraint string from the inline assembly value into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="">  /// specific constraints and their prefixes, and also tie in the associated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="">  /// operand values.  If this returns an empty vector, and if the constraint</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="">  /// string itself isn't empty, there was an error parsing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="">  virtual AsmOperandInfoVector ParseConstraints(const DataLayout &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="">                                                const TargetRegisterInfo *TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="">                                                const CallBase &Call) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="">  /// Examine constraint type and operand type and determine a weight value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="">  /// The operand object must already have been set up with the operand type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="">  virtual ConstraintWeight getMultipleConstraintMatchWeight(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="">      AsmOperandInfo &info, int maIndex) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="">  /// Examine constraint string and operand type and determine a weight value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="">  /// The operand object must already have been set up with the operand type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="">  virtual ConstraintWeight getSingleConstraintMatchWeight(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="">      AsmOperandInfo &info, const char *constraint) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="">  /// Determines the constraint code and constraint type to use for the specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="">  /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="">  /// If the actual operand being passed in is available, it can be passed in as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="">  /// Op, otherwise an empty SDValue can be passed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="">  virtual void ComputeConstraintToUse(AsmOperandInfo &OpInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="">                                      SDValue Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="">                                      SelectionDAG *DAG = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="">  /// Given a constraint, return the type of constraint it is for this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="">  virtual ConstraintType getConstraintType(StringRef Constraint) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="">  /// Given a physical register constraint (e.g.  {edx}), return the register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="">  /// number and the register class for the register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="">  /// Given a register class constraint, like 'r', if this corresponds directly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="">  /// to an LLVM register class, return a register of 0 and the register class</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="">  /// pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="">  /// This should only be used for C_Register constraints.  On error, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="">  /// returns a register number of 0 and a null register class pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="">  virtual std::pair<unsigned, const TargetRegisterClass *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class="">  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="">                               StringRef Constraint, MVT VT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="uncoveredLine">  virtual unsigned getInlineAsmMemConstraint(StringRef ConstraintCode) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="uncoveredLine">    if (ConstraintCode == "m")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="uncoveredLine">      return InlineAsm::Constraint_m;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="uncoveredLine">    if (ConstraintCode == "o")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="uncoveredLine">      return InlineAsm::Constraint_o;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="uncoveredLine">    if (ConstraintCode == "X")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="uncoveredLine">      return InlineAsm::Constraint_X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="uncoveredLine">    if (ConstraintCode == "p")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="uncoveredLine">      return InlineAsm::Constraint_p;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="uncoveredLine">    return InlineAsm::Constraint_Unknown;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="">  /// Try to replace an X constraint, which matches anything, with another that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="">  /// has more specific requirements based on the type of the corresponding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="">  /// operand.  This returns null if there is no replacement to make.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="">  virtual const char *LowerXConstraint(EVT ConstraintVT) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="">  /// Lower the specified operand into the Ops vector.  If it is invalid, don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="">  /// add anything to Ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="">  virtual void LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="">                                            std::vector<SDValue> &Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="">                                            SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="">  // Lower custom output constraints. If invalid, return SDValue().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="">  virtual SDValue LowerAsmOutputForConstraint(SDValue &Chain, SDValue &Glue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="">                                              const SDLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="">                                              const AsmOperandInfo &OpInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="">                                              SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="">  // Targets may override this function to collect operands from the CallInst</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="">  // and for example, lower them into the SelectionDAG operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="">  virtual void CollectTargetIntrinsicOperands(const CallInst &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="">                                              SmallVectorImpl<SDValue> &Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="">                                              SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class="">  // Div utility functions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="">  SDValue BuildSDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="">  SDValue BuildUDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="">  /// Targets may override this function to provide custom SDIV lowering for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="">  /// assumes SDIV is expensive and replaces it with a series of other integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="">  /// operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="">  virtual SDValue BuildSDIVPow2(SDNode *N, const APInt &Divisor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="">                                SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="">  /// Targets may override this function to provide custom SREM lowering for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="">  /// assumes SREM is expensive and replaces it with a series of other integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="">  /// operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="">  virtual SDValue BuildSREMPow2(SDNode *N, const APInt &Divisor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="">                                SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="">  /// Indicate whether this target prefers to combine FDIVs with the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="">  /// divisor. If the transform should never be done, return zero. If the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="">  /// transform should be done, return the minimum number of divisor uses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="">  /// that must exist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="uncoveredLine">  virtual unsigned combineRepeatedFPDivisors() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="">  /// Hooks for building estimates in place of slower divisions and square</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="">  /// roots.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="">  /// Return either a square root or its reciprocal estimate value for the input</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="">  /// operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="">  /// refinement iterations required to generate a sufficient (though not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="">  /// The boolean UseOneConstNR output is used to select a Newton-Raphson</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="">  /// algorithm implementation that uses either one or two constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="">  /// The boolean Reciprocal is used to select whether the estimate is for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="">  /// square root of the input operand or the reciprocal of its square root.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="">  /// A target may choose to implement its own refinement within this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="">  /// any further refinement of the estimate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="uncoveredLine">  virtual SDValue getSqrtEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="">                                  int Enabled, int &RefinementSteps,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="">                                  bool &UseOneConstNR, bool Reciprocal) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="uncoveredLine">    return SDValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="">  /// Try to convert the fminnum/fmaxnum to a compare/select sequence. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="">  /// required for correctness since InstCombine might have canonicalized a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="">  /// fcmp+select sequence to a FMINNUM/FMAXNUM intrinsic.  If we were to fall</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="">  /// through to the default expansion/soften to libcall, we might introduce a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="">  /// link-time dependency on libm into a file that originally did not have one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="">  SDValue createSelectForFMINNUM_FMAXNUM(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="">  /// Return a reciprocal estimate value for the input operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="">  /// refinement iterations required to generate a sufficient (though not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="">  /// A target may choose to implement its own refinement within this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="">  /// any further refinement of the estimate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="uncoveredLine">  virtual SDValue getRecipEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="">                                   int Enabled, int &RefinementSteps) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="uncoveredLine">    return SDValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="">  /// Return a target-dependent comparison result if the input operand is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="">  /// suitable for use with a square root estimate calculation. For example, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="">  /// comparison may check if the operand is NAN, INF, zero, normal, etc. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="">  /// result should be used as the condition operand for a select or branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="">  virtual SDValue getSqrtInputTest(SDValue Operand, SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="">                                   const DenormalMode &Mode) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="">  /// Return a target-dependent result if the input operand is not suitable for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="">  /// use with a square root estimate calculation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="uncoveredLine">  virtual SDValue getSqrtResultForDenormInput(SDValue Operand,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="">                                              SelectionDAG &DAG) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="uncoveredLine">    return DAG.getConstantFP(0.0, SDLoc(Operand), Operand.getValueType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="">  // Legalization utility functions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="">  /// Expand a MUL or [US]MUL_LOHI of n-bit values into two or four nodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="">  /// respectively, each computing an n/2-bit part of the result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="">  /// \param Result A vector that will be filled with the parts of the result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="">  ///        in little-endian order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class="">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="">  /// \returns true if the node has been expanded, false if it has not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="">  bool expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl, SDValue LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="">                      SDValue RHS, SmallVectorImpl<SDValue> &Result, EVT HiLoVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="">                      SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class="">                      SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="">                      SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="">  /// Expand a MUL into two nodes.  One that computes the high bits of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="">  /// the result and one that computes the low bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="">  /// \param HiLoVT The value type to use for the Lo and Hi nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class="">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="">  /// \returns true if the node has been expanded. false if it has not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="">  bool expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="">                 SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="">                 SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="">                 SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="">  /// Attempt to expand an n-bit div/rem/divrem by constant using a n/2-bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class="">  /// urem by constant and other arithmetic ops. The n/2-bit urem by constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="">  /// will be expanded by DAGCombiner. This is not possible for all constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="">  /// divisors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="">  /// \param Result A vector that will be filled with the lo and high parts of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="">  ///        the results. For *DIVREM, this will be the quotient parts followed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="">  ///        by the remainder parts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="">  /// \param HiLoVT The value type to use for the Lo and Hi parts. Should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="">  ///        half of VT.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="">  /// \param LL Low bits of the LHS of the operation. You can use this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="">  ///        parameter if you want to control how low bits are extracted from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="">  ///        the LHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="">  /// \param LH High bits of the LHS of the operation. See LL for meaning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="">  /// \returns true if the node has been expanded, false if it has not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="">  bool expandDIVREMByConstant(SDNode *N, SmallVectorImpl<SDValue> &Result,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="">                              EVT HiLoVT, SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="">                              SDValue LL = SDValue(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="">                              SDValue LH = SDValue()) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="">  /// Expand funnel shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="">  SDValue expandFunnelShift(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="">  /// Expand rotations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="">  /// \param AllowVectorOps expand vector rotate, this should only be performed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="">  ///        if the legalization is happening outside of LegalizeVectorOps</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="">  SDValue expandROT(SDNode *N, bool AllowVectorOps, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="">  /// Expand shift-by-parts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="">  /// \param Lo lower-output-part after conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="">  /// \param Hi upper-output-part after conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="">  void expandShiftParts(SDNode *N, SDValue &Lo, SDValue &Hi,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="">                        SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="">  /// Expand float(f32) to SINT(i64) conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="">  /// \param Result output after conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="">  bool expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="">  /// Expand float to UINT conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="">  /// \param Result output after conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="">  /// \param Chain output chain after conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="">  bool expandFP_TO_UINT(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="">                        SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="">  /// Expand UINT(i64) to double(f64) conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="">  /// \param Result output after conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="">  /// \param Chain output chain after conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="">  bool expandUINT_TO_FP(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="">                        SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="">  /// Expand fminnum/fmaxnum into fminnum_ieee/fmaxnum_ieee with quieted inputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="">  SDValue expandFMINNUM_FMAXNUM(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="">  /// Expand FP_TO_[US]INT_SAT into FP_TO_[US]INT and selects or min/max.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="">  /// \returns The expansion result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="">  SDValue expandFP_TO_INT_SAT(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="">  /// Expand check for floating point class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="">  /// \param ResultVT The type of intrinsic call result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="">  /// \param Op The tested value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="">  /// \param Test The test to perform.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="">  /// \param Flags The optimization flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="">  SDValue expandIS_FPCLASS(EVT ResultVT, SDValue Op, FPClassTest Test,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="">                           SDNodeFlags Flags, const SDLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="">                           SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="">  /// Expand CTPOP nodes. Expands vector/scalar CTPOP nodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="">  SDValue expandCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="">  /// Expand VP_CTPOP nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="">  SDValue expandVPCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="">  /// Expand CTLZ/CTLZ_ZERO_UNDEF nodes. Expands vector/scalar CTLZ nodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="">  SDValue expandCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="">  /// Expand VP_CTLZ/VP_CTLZ_ZERO_UNDEF nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="">  SDValue expandVPCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="">  /// Expand CTTZ via Table Lookup.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="">  SDValue CTTZTableLookup(SDNode *N, SelectionDAG &DAG, const SDLoc &DL, EVT VT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="">                          SDValue Op, unsigned NumBitsPerElt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="">  /// Expand CTTZ/CTTZ_ZERO_UNDEF nodes. Expands vector/scalar CTTZ nodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="">  SDValue expandCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="">  /// Expand VP_CTTZ/VP_CTTZ_ZERO_UNDEF nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="">  SDValue expandVPCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="">  /// Expand ABS nodes. Expands vector/scalar ABS nodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="">  /// (ABS x) -> (XOR (ADD x, (SRA x, type_size)), (SRA x, type_size))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="">  /// \param IsNegative indicate negated abs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="">  SDValue expandABS(SDNode *N, SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="">                    bool IsNegative = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="">  /// Expand ABDS/ABDU nodes. Expands vector/scalar ABDS/ABDU nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="">  SDValue expandABD(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="">  /// Expand BSWAP nodes. Expands scalar/vector BSWAP nodes with i16/i32/i64</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="">  /// scalar types. Returns SDValue() if expand fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class="">  SDValue expandBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="">  /// Expand VP_BSWAP nodes. Expands VP_BSWAP nodes with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="">  /// i16/i32/i64 scalar types. Returns SDValue() if expand fails. \param N Node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="">  /// to expand \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="">  SDValue expandVPBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="">  /// Expand BITREVERSE nodes. Expands scalar/vector BITREVERSE nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="">  /// Returns SDValue() if expand fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="">  /// \param N Node to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="">  SDValue expandBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="">  /// Expand VP_BITREVERSE nodes. Expands VP_BITREVERSE nodes with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="">  /// i8/i16/i32/i64 scalar types. \param N Node to expand \returns The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="">  /// expansion result or SDValue() if it fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="">  SDValue expandVPBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="">  /// Turn load of vector type into a load of the individual elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="">  /// \param LD load to expand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="">  /// \returns BUILD_VECTOR and TokenFactor nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="">  std::pair<SDValue, SDValue> scalarizeVectorLoad(LoadSDNode *LD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="">                                                  SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="">  // Turn a store of a vector type into stores of the individual elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="">  /// \param ST Store with a vector value type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="">  /// \returns TokenFactor of the individual store chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="">  SDValue scalarizeVectorStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="">  /// Expands an unaligned load to 2 half-size loads for an integer, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="">  /// possibly more for vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="">  std::pair<SDValue, SDValue> expandUnalignedLoad(LoadSDNode *LD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="">                                                  SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="">  /// Expands an unaligned store to 2 half-size stores for integer values, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="">  /// possibly more for vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="">  SDValue expandUnalignedStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="">  /// Increments memory address \p Addr according to the type of the value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="">  /// \p DataVT that should be stored. If the data is stored in compressed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="">  /// form, the memory address should be incremented according to the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="">  /// the stored elements. This number is equal to the number of '1's bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="">  /// in the \p Mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="">  /// \p DataVT is a vector type. \p Mask is a vector value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="">  /// \p DataVT and \p Mask have the same number of vector elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="">  SDValue IncrementMemoryAddress(SDValue Addr, SDValue Mask, const SDLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="">                                 EVT DataVT, SelectionDAG &DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="">                                 bool IsCompressedMemory) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="">  /// Get a pointer to vector element \p Idx located in memory for a vector of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="">  /// type \p VecVT starting at a base address of \p VecPtr. If \p Idx is out of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="">  /// bounds the returned pointer is unspecified, but will be within the vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="">  /// bounds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="">  SDValue getVectorElementPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="">                                  SDValue Index) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="">  /// Get a pointer to a sub-vector of type \p SubVecVT at index \p Idx located</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="">  /// in memory for a vector of type \p VecVT starting at a base address of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="">  /// \p VecPtr. If \p Idx plus the size of \p SubVecVT is out of bounds the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="">  /// returned pointer is unspecified, but the value returned will be such that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="">  /// the entire subvector would be within the vector bounds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="">  SDValue getVectorSubVecPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="">                                 EVT SubVecVT, SDValue Index) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="">  /// Method for building the DAG expansion of ISD::[US][MIN|MAX]. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="">  /// method accepts integers as its arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="">  SDValue expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="">  /// Method for building the DAG expansion of ISD::[US][ADD|SUB]SAT. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="">  /// method accepts integers as its arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="">  SDValue expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="">  /// Method for building the DAG expansion of ISD::[US]SHLSAT. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class="">  /// method accepts integers as its arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="">  SDValue expandShlSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="">  /// Method for building the DAG expansion of ISD::[U|S]MULFIX[SAT]. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="">  /// method accepts integers as its arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="">  SDValue expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="">  /// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="">  /// method accepts integers as its arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="">  /// Note: This method may fail if the division could not be performed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class="">  /// within the type. Clients must retry with a wider type if this happens.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="">  SDValue expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="">                              SDValue LHS, SDValue RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="">                              unsigned Scale, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="">  /// Method for building the DAG expansion of ISD::U(ADD|SUB)O. Expansion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="">  void expandUADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="">                      SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="">  /// Method for building the DAG expansion of ISD::S(ADD|SUB)O. Expansion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="">  void expandSADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="">                      SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5206</td>
    <td class="">  /// Method for building the DAG expansion of ISD::[US]MULO. Returns whether</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5207</td>
    <td class="">  /// expansion was successful and populates the Result and Overflow arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5208</td>
    <td class="">  bool expandMULO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5209</td>
    <td class="">                  SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5211</td>
    <td class="">  /// Expand a VECREDUCE_* into an explicit calculation. If Count is specified,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5212</td>
    <td class="">  /// only the first Count elements of the vector are used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5213</td>
    <td class="">  SDValue expandVecReduce(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5215</td>
    <td class="">  /// Expand a VECREDUCE_SEQ_* into an explicit ordered calculation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5216</td>
    <td class="">  SDValue expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5218</td>
    <td class="">  /// Expand an SREM or UREM using SDIV/UDIV or SDIVREM/UDIVREM, if legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5219</td>
    <td class="">  /// Returns true if the expansion was successful.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5220</td>
    <td class="">  bool expandREM(SDNode *Node, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5222</td>
    <td class="">  /// Method for building the DAG expansion of ISD::VECTOR_SPLICE. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5223</td>
    <td class="">  /// method accepts vectors as its arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5224</td>
    <td class="">  SDValue expandVectorSplice(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5226</td>
    <td class="">  /// Legalize a SETCC or VP_SETCC with given LHS and RHS and condition code CC</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5227</td>
    <td class="">  /// on the current target. A VP_SETCC will additionally be given a Mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5228</td>
    <td class="">  /// and/or EVL not equal to SDValue().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5229</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5230</td>
    <td class="">  /// If the SETCC has been legalized using AND / OR, then the legalized node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5231</td>
    <td class="">  /// will be stored in LHS. RHS and CC will be set to SDValue(). NeedInvert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5232</td>
    <td class="">  /// will be set to false. This will also hold if the VP_SETCC has been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5233</td>
    <td class="">  /// legalized using VP_AND / VP_OR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5234</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5235</td>
    <td class="">  /// If the SETCC / VP_SETCC has been legalized by using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5236</td>
    <td class="">  /// getSetCCSwappedOperands(), then the values of LHS and RHS will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5237</td>
    <td class="">  /// swapped, CC will be set to the new condition, and NeedInvert will be set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5238</td>
    <td class="">  /// to false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5239</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5240</td>
    <td class="">  /// If the SETCC / VP_SETCC has been legalized using the inverse condcode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5241</td>
    <td class="">  /// then LHS and RHS will be unchanged, CC will set to the inverted condcode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5242</td>
    <td class="">  /// and NeedInvert will be set to true. The caller must invert the result of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5243</td>
    <td class="">  /// the SETCC with SelectionDAG::getLogicalNOT() or take equivalent action to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5244</td>
    <td class="">  /// swap the effect of a true/false result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5245</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5246</td>
    <td class="">  /// \returns true if the SETCC / VP_SETCC has been legalized, false if it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5247</td>
    <td class="">  /// hasn't.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5248</td>
    <td class="">  bool LegalizeSetCCCondCode(SelectionDAG &DAG, EVT VT, SDValue &LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5249</td>
    <td class="">                             SDValue &RHS, SDValue &CC, SDValue Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5250</td>
    <td class="">                             SDValue EVL, bool &NeedInvert, const SDLoc &dl,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5251</td>
    <td class="">                             SDValue &Chain, bool IsSignaling = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5253</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5254</td>
    <td class="">  // Instruction Emitting Hooks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5255</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5257</td>
    <td class="">  /// This method should be implemented by targets that mark instructions with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5258</td>
    <td class="">  /// the 'usesCustomInserter' flag.  These instructions are special in various</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5259</td>
    <td class="">  /// ways, which require special support to insert.  The specified MachineInstr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5260</td>
    <td class="">  /// is created but not inserted into any basic blocks, and this method is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5261</td>
    <td class="">  /// called to expand it into a sequence of instructions, potentially also</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5262</td>
    <td class="">  /// creating new basic blocks and control flow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5263</td>
    <td class="">  /// As long as the returned basic block is different (i.e., we created a new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5264</td>
    <td class="">  /// one), the custom inserter is free to modify the rest of \p MBB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5265</td>
    <td class="">  virtual MachineBasicBlock *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5266</td>
    <td class="">  EmitInstrWithCustomInserter(MachineInstr &MI, MachineBasicBlock *MBB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5268</td>
    <td class="">  /// This method should be implemented by targets that mark instructions with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5269</td>
    <td class="">  /// the 'hasPostISelHook' flag. These instructions must be adjusted after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5270</td>
    <td class="">  /// instruction selection by target hooks.  e.g. To fill in optional defs for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5271</td>
    <td class="">  /// ARM 's' setting instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5272</td>
    <td class="">  virtual void AdjustInstrPostInstrSelection(MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5273</td>
    <td class="">                                             SDNode *Node) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5275</td>
    <td class="">  /// If this function returns true, SelectionDAGBuilder emits a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5276</td>
    <td class="">  /// LOAD_STACK_GUARD node when it is lowering Intrinsic::stackprotector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5277</td>
    <td class="uncoveredLine">  virtual bool useLoadStackGuardNode() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5278</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5279</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5281</td>
    <td class="uncoveredLine">  virtual SDValue emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5282</td>
    <td class="">                                      const SDLoc &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5283</td>
    <td class="uncoveredLine">    llvm_unreachable("not implemented for this target");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5284</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5286</td>
    <td class="">  /// Lower TLS global address SDNode for target independent emulated TLS model.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5287</td>
    <td class="">  virtual SDValue LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5288</td>
    <td class="">                                          SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5290</td>
    <td class="">  /// Expands target specific indirect branch for the case of JumpTable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5291</td>
    <td class="">  /// expanasion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5292</td>
    <td class="uncoveredLine">  virtual SDValue expandIndirectJTBranch(const SDLoc& dl, SDValue Value, SDValue Addr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5293</td>
    <td class="">                                         SelectionDAG &DAG) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5294</td>
    <td class="uncoveredLine">    return DAG.getNode(ISD::BRIND, dl, MVT::Other, Value, Addr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5295</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5296</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5297</td>
    <td class="">  // seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5298</td>
    <td class="">  // If we're comparing for equality to zero and isCtlzFast is true, expose the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5299</td>
    <td class="">  // fact that this can be implemented as a ctlz/srl pair, so that the dag</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5300</td>
    <td class="">  // combiner can fold the new nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5301</td>
    <td class="">  SDValue lowerCmpEqZeroToCtlzSrl(SDValue Op, SelectionDAG &DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5303</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5304</td>
    <td class="">  SDValue foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5305</td>
    <td class="">                           const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5306</td>
    <td class="">  SDValue foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5307</td>
    <td class="">                             const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5309</td>
    <td class="">  SDValue optimizeSetCCOfSignedTruncationCheck(EVT SCCVT, SDValue N0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5310</td>
    <td class="">                                               SDValue N1, ISD::CondCode Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5311</td>
    <td class="">                                               DAGCombinerInfo &DCI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5312</td>
    <td class="">                                               const SDLoc &DL) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5314</td>
    <td class="">  // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5315</td>
    <td class="">  SDValue optimizeSetCCByHoistingAndByConstFromLogicalShift(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5316</td>
    <td class="">      EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5317</td>
    <td class="">      DAGCombinerInfo &DCI, const SDLoc &DL) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5319</td>
    <td class="">  SDValue prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5320</td>
    <td class="">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5321</td>
    <td class="">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5322</td>
    <td class="">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5323</td>
    <td class="">  SDValue buildUREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5324</td>
    <td class="">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5325</td>
    <td class="">                          const SDLoc &DL) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5327</td>
    <td class="">  SDValue prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5328</td>
    <td class="">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5329</td>
    <td class="">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5330</td>
    <td class="">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5331</td>
    <td class="">  SDValue buildSREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5332</td>
    <td class="">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5333</td>
    <td class="">                          const SDLoc &DL) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5334</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5336</td>
    <td class="">/// Given an LLVM IR type and return type attributes, compute the return value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5337</td>
    <td class="">/// EVTs and flags, and optionally also the offsets, if the return value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5338</td>
    <td class="">/// being lowered to memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5339</td>
    <td class="">void GetReturnInfo(CallingConv::ID CC, Type *ReturnType, AttributeList attr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5340</td>
    <td class="">                   SmallVectorImpl<ISD::OutputArg> &Outs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5341</td>
    <td class="">                   const TargetLowering &TLI, const DataLayout &DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5343</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5345</td>
    <td class="">#endif // LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase12ArgListEntryC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17isStrictFPEnabledEv</td>
    <td class="numberOfCalls">56</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase11isTypeLegalENS_3EVTE</td>
    <td class="numberOfCalls">20702</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase13getTypeActionERNS_11LLVMContextENS_3EVTE</td>
    <td class="numberOfCalls">854</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18getOperationActionEjNS_3EVTE</td>
    <td class="numberOfCalls">166</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28getFixedPointOperationActionEjNS_3EVTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26getStrictFPOperationActionEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24isOperationLegalOrCustomEjNS_3EVTEb</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25isOperationLegalOrPromoteEjNS_3EVTEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17isOperationExpandEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase16isOperationLegalEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase16getLoadExtActionEjNS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14isLoadExtLegalEjNS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22isLoadExtLegalOrCustomEjNS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19getTruncStoreActionENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25isTruncStoreLegalOrCustomENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17getCondCodeActionENS_3ISD8CondCodeENS_3MVTE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15isCondCodeLegalENS_3ISD8CondCodeENS_3MVTE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase23isCondCodeLegalOrCustomENS_3ISD8CondCodeENS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18getTypeToPromoteToEjNS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15getRegisterTypeENS_3MVTE</td>
    <td class="numberOfCalls">1722</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase36getStackPointerRegisterToSaveRestoreEv</td>
    <td class="numberOfCalls">21</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14getLibcallNameENS_5RTLIB7LibcallE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21getLibcallCallingConvENS_5RTLIB7LibcallE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfoC2ERNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo11setDebugLocERKNS_5SDLocE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo8setChainENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo12setLibCalleeEjPNS_4TypeENS_7SDValueEOSt6vectorINS_18TargetLoweringBase12ArgListEntryESaIS7_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo11setTailCallEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo13setSExtResultEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo13setZExtResultEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo25setIsPostTypeLegalizationEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering18MakeLibCallOptionsC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering18MakeLibCallOptions7setSExtEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase19getExtendForContentENS0_14BooleanContentE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18getBooleanContentsEbb</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18getBooleanContentsENS_3EVTE</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20promoteTargetBooleanERNS_12SelectionDAGENS_7SDValueENS_3EVTE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase33isOperationLegalOrCustomOrPromoteEjNS_3EVTEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17isOperationCustomEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17isTruncStoreLegalENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20getIndexedLoadActionEjNS_3MVTE</td>
    <td class="numberOfCalls">80</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18isIndexedLoadLegalEjNS_3EVTE</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21getIndexedStoreActionEjNS_3MVTE</td>
    <td class="numberOfCalls">64</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19isIndexedStoreLegalEjNS_3EVTE</td>
    <td class="numberOfCalls">32</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26getIndexedMaskedLoadActionEjNS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24isIndexedMaskedLoadLegalEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27getIndexedMaskedStoreActionEjNS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25isIndexedMaskedStoreLegalEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24hasBigEndianPartOrderingENS_3EVTERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19hasTargetDAGCombineENS_3ISD8NodeTypeE</td>
    <td class="numberOfCalls">198</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27getGatherAllAliasesMaxDepthEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20getIndexedModeActionEjNS_3MVTEj</td>
    <td class="numberOfCalls">144</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering17TargetLoweringOptC2ERNS_12SelectionDAGEbb</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering15DAGCombinerInfoC2ERNS_12SelectionDAGENS_12CombineLevelEbPv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering36getCheaperOrNeutralNegatedExpressionENS_7SDValueERNS_12SelectionDAGEbbNS_18TargetLoweringBase13NegatibleCostEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering27getCheaperNegatedExpressionENS_7SDValueERNS_12SelectionDAGEbbj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering20getNegatedExpressionENS_7SDValueERNS_12SelectionDAGEbbj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19getValueTypeActionsEv</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase16getTargetMachineEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29hasMultipleConditionRegistersEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18hasExtractBitsInsnEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17isSlowDivBypassedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22getBypassSlowDivWidthsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15isJumpExpensiveEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28isPredictableSelectExpensiveEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20enableExtLdPromotionEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase12getValueTypeERKNS_10DataLayoutEPNS_4TypeEb</td>
    <td class="numberOfCalls">68</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase9isExtFreeEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase9isExtLoadEPKNS_8LoadInstEPKNS_11InstructionERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21markLibCallAttributesEPNS_15MachineFunctionEjRSt6vectorINS0_12ArgListEntryESaIS4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBaseD2Ev</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBaseD0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase12useSoftFloatEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase12getPointerTyERKNS_10DataLayoutEj</td>
    <td class="numberOfCalls">14</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15getPointerMemTyERKNS_10DataLayoutEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17getFenceOperandTyERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25getPreferredShiftAmountTyENS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14getVectorIdxTyERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27getVPExplicitVectorLengthTyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17getTargetMMOFlagsERKNS_11InstructionE</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17getTargetMMOFlagsERKNS_9MemSDNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17isSelectSupportedENS0_17SelectSupportKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29shouldExpandGetActiveLaneMaskENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27shouldExpandGetVectorLengthENS_3EVTEjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26shouldReassociateReductionEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29reduceSelectOfFPConstantLoadsENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24getPreferredVectorActionENS_3MVTE</td>
    <td class="numberOfCalls">1710</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19softPromoteHalfTypeEv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase35shouldExpandBuildVectorWithShufflesENS_3EVTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase13isIntDivCheapENS_3EVTENS_13AttributeListE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase16hasStandaloneRemENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase12isFsqrtCheapENS_7SDValueERNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28isVScaleKnownToBeAPowerOfTwoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17fallBackToDAGISelERKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24isStoreBitCastBeneficialENS_3EVTES1_RKNS_12SelectionDAGERKNS_17MachineMemOperandE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28storeOfVectorConstantIsCheapEbNS_3EVTEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28mergeStoresAfterLegalizationENS_3EVTE</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase16canMergeStoresToEjNS_3EVTERKNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22isCheapToSpeculateCttzEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22isCheapToSpeculateCtlzEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10isCtlzFastEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18getCustomCtpopCostENS_3EVTENS_3ISD8CondCodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase32isEqualityCmpFoldedWithSignedCmpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase23preferZeroCompareBranchEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase33isMultiStoresCheaperThanBitsMergeENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase30isMaskAndCmp0FoldingBeneficialERKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase35areTwoSDNodeTargetMMOFlagsMergeableERKNS_9MemSDNodeES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase31convertSetCCLogicToBitwiseLogicENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22hasFastEqualityCompareEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase16hasAndNotCompareENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase9hasAndNotENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10hasBitTestENS_7SDValueES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase33shouldFoldMaskToVariableShiftPairENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase33shouldFoldConstantShiftPairToMaskEPKNS_6SDNodeENS_12CombineLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase36shouldTransformSignedTruncationCheckENS_3EVTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase56shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAndENS_7SDValueEPNS_14ConstantSDNodeES3_S1_jjRNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24preferIncOfAddToSubOfNotENS_3EVTE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22preferABDSToABSWithNSWENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20preferScalarizeSplatEPNS_6SDNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25canCombineStoreAndExtractEPNS_4TypeEPNS_5ValueERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25shouldSplatInsEltVarIndexENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25enableAggressiveFMAFusionENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25enableAggressiveFMAFusionENS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase23getSchedulingPreferenceEPNS_6SDNodeE</td>
    <td class="numberOfCalls">34</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14getRegClassForENS_3MVTEb</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase23requiresUniformRegisterERNS_15MachineFunctionEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase17getRepRegClassForENS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21getRepRegClassCostForENS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase34preferredShiftLegalizationStrategyERNS_12SelectionDAGEPNS_6SDNodeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase19ValueTypeActionImplC2Ev</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19ValueTypeActionImpl13getTypeActionENS_3MVTE</td>
    <td class="numberOfCalls">868</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase19ValueTypeActionImpl13setTypeActionENS_3MVTENS0_18LegalizeTypeActionE</td>
    <td class="numberOfCalls">1834</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20getTypeToTransformToERNS_11LLVMContextENS_3EVTE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase36getVectorTypeBreakdownForCallingConvERNS_11LLVMContextEjNS_3EVTERS3_RjRNS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18getTgtMemIntrinsicERNS0_13IntrinsicInfoERKNS_8CallInstERNS_15MachineFunctionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase12isFPImmLegalERKNS_7APFloatENS_3EVTEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18isShuffleMaskLegalENS_8ArrayRefIiEENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22isVectorClearMaskLegalENS_8ArrayRefIiEENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24getCustomOperationActionERNS_6SDNodeE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase30isSupportedFixedPointOperationEjNS_3EVTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase13areJTsAllowedEPKNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20canCombineTruncStoreENS_3EVTES1_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19shouldExtendGSIndexENS_3EVTERS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29shouldRemoveExtendFromGSIndexENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28isLegalScaleForGatherScatterEmm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22getAsmOperandValueTypeERKNS_10DataLayoutEPNS_4TypeEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15getRegisterTypeERNS_11LLVMContextENS_3EVTE</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15getNumRegistersERNS_11LLVMContextENS_3EVTESt8optionalINS_3MVTEE</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29getRegisterTypeForCallingConvERNS_11LLVMContextEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29getNumRegistersForCallingConvERNS_11LLVMContextEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29getABIAlignmentForCallingConvEPNS_4TypeERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22ShouldShrinkFPConstantENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21shouldReduceLoadWidthEPNS_6SDNodeENS_3ISD11LoadExtTypeENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27shouldRemoveRedundantExtendENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19getVaListSizeInBitsERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26getMaxGluedStoresPerMemcpyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase30allowsMisalignedMemoryAccessesENS_3EVTEjNS_5AlignENS_17MachineMemOperand5FlagsEPj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase30allowsMisalignedMemoryAccessesENS_3LLTEjNS_5AlignENS_17MachineMemOperand5FlagsEPj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19getOptimalMemOpTypeERKNS_5MemOpERKNS_13AttributeListE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18getOptimalMemOpLLTERKNS_5MemOpERKNS_13AttributeListE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15isSafeMemOpTypeENS_3MVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27getExceptionPointerRegisterEPKNS_8ConstantE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28getExceptionSelectorRegisterEPKNS_8ConstantE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22needsFixedCatchObjectsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21alignLoopsWithOptSizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18useStackGuardXorFPEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase38isConstantUnsignedBitfieldExtractLegalEjNS_3LLTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19hasStackProbeSymbolERKNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19hasInlineStackProbeERKNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase23getStackProbeSymbolNameERKNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22shouldAlignPointerArgsEPNS_8CallInstERjRNS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27shouldInsertFencesForAtomicEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase39shouldInsertTrailingFenceForAtomicStoreEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14emitLoadLinkedERNS_13IRBuilderBaseEPNS_4TypeEPNS_5ValueENS_14AtomicOrderingE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20emitStoreConditionalERNS_13IRBuilderBaseEPNS_5ValueES4_NS_14AtomicOrderingE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28emitMaskedAtomicRMWIntrinsicERNS_13IRBuilderBaseEPNS_13AtomicRMWInstEPNS_5ValueES6_S6_S6_NS_14AtomicOrderingE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19emitExpandAtomicRMWEPNS_13AtomicRMWInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29emitBitTestAtomicRMWIntrinsicEPNS_13AtomicRMWInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase30emitCmpArithAtomicRMWIntrinsicEPNS_13AtomicRMWInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase32emitMaskedAtomicCmpXchgIntrinsicERNS_13IRBuilderBaseEPNS_17AtomicCmpXchgInstEPNS_5ValueES6_S6_S6_NS_14AtomicOrderingE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase13EmitKCFICheckERNS_17MachineBasicBlockERNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEPKNS_15TargetInstrInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase33emitAtomicCmpXchgNoStoreLLBalanceERNS_13IRBuilderBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29shouldSignExtendTypeInLibCallENS_3EVTEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25shouldExtendTypeInLibCallENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26shouldExpandAtomicLoadInIREPNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24shouldCastAtomicLoadInIREPNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27shouldExpandAtomicStoreInIREPNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25shouldCastAtomicStoreInIREPNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29shouldExpandAtomicCmpXchgInIREPNS_17AtomicCmpXchgInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25shouldExpandAtomicRMWInIREPNS_13AtomicRMWInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24shouldCastAtomicRMWIInIREPNS_13AtomicRMWInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase32lowerIdempotentRMWIntoFencedLoadEPNS_13AtomicRMWInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21getExtendForAtomicOpsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28getExtendForAtomicCmpSwapArgEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase31shouldNormalizeToSelectSequenceERNS_11LLVMContextENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase33isProfitableToCombineMinNumMaxNumENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase30convertSelectOfConstantsToMathENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22decomposeMulByConstantERNS_11LLVMContextENS_3EVTENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27isMulAddWithConstProfitableENS_7SDValueES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24shouldUseStrictFP_TO_INTENS_3EVTES1_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase18setOperationActionEjNS_3MVTENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">423626</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase18setOperationActionENS_8ArrayRefIjEENS_3MVTENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">21490</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase18setOperationActionENS_8ArrayRefIjEENS1_INS_3MVTEEENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase16setLoadExtActionEjNS_3MVTES1_NS0_14LegalizeActionE</td>
    <td class="numberOfCalls">16540</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase19setTruncStoreActionENS_3MVTES1_NS0_14LegalizeActionE</td>
    <td class="numberOfCalls">7910</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase20setIndexedLoadActionENS_8ArrayRefIjEENS_3MVTENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">7960</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase21setIndexedStoreActionENS_8ArrayRefIjEENS_3MVTENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">7960</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase26setIndexedMaskedLoadActionEjNS_3MVTENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">7960</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase27setIndexedMaskedStoreActionEjNS_3MVTENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">7960</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase17AddPromotedToTypeEjNS_3MVTES1_</td>
    <td class="numberOfCalls">70</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20getAddrModeArgumentsEPNS_13IntrinsicInstERNS_15SmallVectorImplIPNS_5ValueEEERPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20isLegalICmpImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19isLegalAddImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21isLegalStoreImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26isVectorShiftByScalarCheapEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22shouldConvertSplatTypeEPNS_17ShuffleVectorInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20shouldConvertPhiTypeEPNS_4TypeES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18isCommutativeBinOpEj</td>
    <td class="numberOfCalls">258</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase7isBinOpEj</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14isTruncateFreeEPNS_4TypeES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24allowTruncateForTailCallEPNS_4TypeES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14isTruncateFreeENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14isTruncateFreeENS_3LLTES1_RKNS_10DataLayoutERNS_11LLVMContextE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase19isProfitableToHoistEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10isZExtFreeEPNS_4TypeES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10isZExtFreeENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10isZExtFreeENS_3LLTES1_RKNS_10DataLayoutERNS_11LLVMContextE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10isZExtFreeENS_7SDValueENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21isSExtCheaperThanZExtENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18signExtendConstantEPKNS_11ConstantIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase18shouldSinkOperandsEPNS_11InstructionERNS_15SmallVectorImplIPNS_3UseEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase34optimizeExtendOrTruncateConversionEPNS_11InstructionEPNS_4LoopERKNS_19TargetTransformInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase13hasPairedLoadENS_3EVTERNS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase14hasVectorBlendEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase31getMaxSupportedInterleaveFactorEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20lowerInterleavedLoadEPNS_8LoadInstENS_8ArrayRefIPNS_17ShuffleVectorInstEEENS3_IjEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21lowerInterleavedStoreEPNS_9StoreInstEPNS_17ShuffleVectorInstEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase32lowerDeinterleaveIntrinsicToLoadEPNS_13IntrinsicInstEPNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase31lowerInterleaveIntrinsicToStoreEPNS_13IntrinsicInstEPNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase11isFPExtFreeENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15isFPExtFoldableERKNS_12MachineInstrEjNS_3LLTES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15isFPExtFoldableERKNS_12SelectionDAGEjNS_3EVTES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24isVectorLoadExtDesirableENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10isFNegFreeENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase10isFAbsFreeENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26isFMAFasterThanFMulAndFAddERKNS_15MachineFunctionENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26isFMAFasterThanFMulAndFAddERKNS_15MachineFunctionENS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase26isFMAFasterThanFMulAndFAddERKNS_8FunctionEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase11isFMADLegalERKNS_12MachineInstrENS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase11isFMADLegalERKNS_12SelectionDAGEPKNS_6SDNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29generateFMAsInMachineCombinerENS_3EVTENS_10CodeGenOpt5LevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21isNarrowingProfitableENS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase36shouldFoldSelectWithIdentityConstantEjNS_3EVTE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase33shouldConvertConstantLoadToIntImmERKNS_5APIntEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase23isExtractSubvectorCheapENS_3EVTES1_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20shouldScalarizeBinopENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20isExtractVecEltCheapENS_3EVTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20shouldFormOverflowOpEjNS_3EVTEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase36aggressivelyPreferBuildVectorSourcesENS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase28shouldConsiderGEPOffsetSplitEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase27shouldAvoidTransformToShiftENS_3EVTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase25shouldKeepZExtForFP16ConvEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase20shouldConvertFpToSatEjNS_3EVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase32isComplexDeinterleavingSupportedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase41isComplexDeinterleavingOperationSupportedENS_30ComplexDeinterleavingOperationEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29createComplexDeinterleavingIRERNS_13IRBuilderBaseENS_30ComplexDeinterleavingOperationENS_29ComplexDeinterleavingRotationEPNS_5ValueES6_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase14setLibcallNameENS_5RTLIB7LibcallEPKc</td>
    <td class="numberOfCalls">6640</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase21setLibcallCallingConvENS_5RTLIB7LibcallEj</td>
    <td class="numberOfCalls">6440</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase20setIndexedModeActionEjNS_3MVTEjNS0_14LegalizeActionE</td>
    <td class="numberOfCalls">31840</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase13isExtFreeImplEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase37getMaxLargeFPConvertBitWidthSupportedEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase29getMaxDivRemBitWidthSupportedEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase23getMinFunctionAlignmentEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24getPrefFunctionAlignmentEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase18setBooleanContentsENS0_14BooleanContentE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase36setStackPointerRegisterToSaveRestoreENS_8RegisterE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase16addRegisterClassENS_3MVTEPKNS_19TargetRegisterClassE</td>
    <td class="numberOfCalls">26</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase19setTargetDAGCombineENS_8ArrayRefINS_3ISD8NodeTypeEEE</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase23setMinFunctionAlignmentENS_5AlignE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase24setPrefFunctionAlignmentENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering26isSDNodeSourceOfDivergenceEPKNS_6SDNodeEPNS_20FunctionLoweringInfoEPNS_21GenericUniformityInfoINS_17GenericSSAContextINS_8FunctionEEEEE</td>
    <td class="numberOfCalls">88</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering19isReassocProfitableERNS_12SelectionDAGENS_7SDValueES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering19isReassocProfitableERNS_19MachineRegisterInfoENS_8RegisterES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering21isSDNodeAlwaysUniformEPKNS_6SDNodeE</td>
    <td class="numberOfCalls">80</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering25getPreIndexedAddressPartsEPNS_6SDNodeERNS_7SDValueES4_RNS_3ISD14MemIndexedModeERNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering26getPostIndexedAddressPartsEPNS_6SDNodeES2_RNS_7SDValueES4_RNS_3ISD14MemIndexedModeERNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15isIndexingLegalERNS_12MachineInstrENS_8RegisterES3_bRNS_19MachineRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering25LowerCustomJumpTableEntryEPKNS_20MachineJumpTableInfoEPKNS_17MachineBasicBlockEjRNS_9MCContextE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering23isInlineAsmTargetBranchERKNS_15SmallVectorImplINS_9StringRefEEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering28targetShrinkDemandedConstantENS_7SDValueERKNS_5APIntES4_RNS0_17TargetLoweringOptE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering32shouldSimplifyDemandedVectorEltsENS_7SDValueERKNS0_17TargetLoweringOptE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering29isTargetCanonicalConstantNodeENS_7SDValueE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering13unwrapAddressENS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering29isDesirableToCommuteWithShiftEPKNS_6SDNodeENS_12CombineLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering29isDesirableToCommuteWithShiftERKNS_12MachineInstrEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering34isDesirableToCombineLogicOpOfSETCCEPKNS_6SDNodeES3_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering32isDesirableToCommuteXorWithShiftEPKNS_6SDNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering20isTypeDesirableForOpEjNS_3EVTE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering33isDesirableToTransformToIntegerOpEjNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering22IsDesirableToPromoteOpENS_7SDValueERNS_3EVTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering17supportSwiftErrorEv</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15supportSplitCSREPNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering18supportKCFIBundlesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering18initializeSplitCSREPNS_17MachineBasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering20insertCopiesSplitCSREPNS_17MachineBasicBlockERKNS_15SmallVectorImplIS2_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering27splitValueIntoRegisterPartsERNS_12SelectionDAGERKNS_5SDLocENS_7SDValueEPS6_jNS_3MVTESt8optionalIjE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering25checkForPhysRegDependencyEPNS_6SDNodeES2_jPKNS_18TargetRegisterInfoEPKNS_15TargetInstrInfoERjRi</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering26joinRegisterPartsIntoValueERNS_12SelectionDAGERKNS_5SDLocEPKNS_7SDValueEjNS_3MVTENS_3EVTESt8optionalIjE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering11HandleByValEPNS_7CCStateERjNS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering18isUsedByReturnOnlyEPNS_6SDNodeERNS_7SDValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering22mayBeEmittedAsTailCallEPKNS_8CallInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering24getClearCacheBuiltinNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering19getTypeForExtReturnERNS_11LLVMContextENS_3EVTENS_3ISD8NodeTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering41functionArgumentNeedsConsecutiveRegistersEPNS_4TypeEjbRKNS_10DataLayoutE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering42shouldSplitFunctionArgumentsAsLittleEndianERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering19getScratchRegistersEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering27getRoundingControlRegistersEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering27prepareVolatileOrAtomicLoadENS_7SDValueERKNS_5SDLocERNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering29lowerAtomicStoreAsStoreSDNodeERKNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering27lowerAtomicLoadAsLoadSDNodeERKNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering18ReplaceNodeResultsEPNS_6SDNodeERNS_15SmallVectorImplINS_7SDValueEEERNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering14createFastISelERNS_20FunctionLoweringInfoEPKNS_17TargetLibraryInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15ExpandInlineAsmEPNS_8CallInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering25getInlineAsmMemConstraintENS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering25combineRepeatedFPDivisorsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15getSqrtEstimateENS_7SDValueERNS_12SelectionDAGEiRiRbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering16getRecipEstimateENS_7SDValueERNS_12SelectionDAGEiRi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering27getSqrtResultForDenormInputENS_7SDValueERNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering21useLoadStackGuardNodeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering19emitStackGuardXorFPERNS_12SelectionDAGENS_7SDValueERKNS_5SDLocE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering22expandIndirectJTBranchERKNS_5SDLocENS_7SDValueES4_RNS_12SelectionDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp4sizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp8isMemsetEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp8isMemcpyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp12isZeroMemsetEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp14isMemcpyStrSrcEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp12isSrcAlignedENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp12isDstAlignedENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5MemOp9isAlignedENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase24setBooleanVectorContentsENS0_14BooleanContentE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase23setSchedulingPreferenceENS_5Sched10PreferenceE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase16addBypassSlowDivEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase17setCondCodeActionENS_8ArrayRefINS_3ISD8CondCodeEEENS_3MVTENS0_14LegalizeActionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase26setOperationPromotedToTypeEjNS_3MVTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase20setPrefLoopAlignmentENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase31setMaxAtomicSizeInBitsSupportedEj</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase29setMaxDivRemBitWidthSupportedEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase37setMaxLargeFPConvertBitWidthSupportedEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering17TargetLoweringOpt9CombineToENS_7SDValueES2_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15DAGCombinerInfo16isBeforeLegalizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15DAGCombinerInfo19isBeforeLegalizeOpsEv</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15DAGCombinerInfo18isAfterLegalizeDAGEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering15DAGCombinerInfo19isCalledByLegalizerEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo13setInRegisterEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15rangeFitsInWordERKNS_5APIntES3_RKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase21isSuitableForBitTestsEjjRKNS_5APIntES3_RKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase22getMaxExpandSizeMemcmpEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase24isBeneficialToExpandPowIElb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15getFrameIndexTyERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18TargetLoweringBase15getMemValueTypeERKNS_10DataLayoutEPNS_4TypeEb</td>
    <td class="numberOfCalls">22</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase21setHasExtractBitsInsnEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase23setMaxBytesForAlignmentEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase28setMinStackArgumentAlignmentENS_5AlignE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase15setCmpLibcallCCENS_5RTLIB7LibcallENS_3ISD8CondCodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo9setCalleeEjPNS_4TypeENS_7SDValueEOSt6vectorINS_18TargetLoweringBase12ArgListEntryESaIS7_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering16CallLoweringInfo16setDiscardResultEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase32setHasMultipleConditionRegistersEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase16setLoadExtActionENS_8ArrayRefIjEENS_3MVTES3_NS0_14LegalizeActionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase23setMinCmpXchgSizeInBitsEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18TargetLoweringBase27setSupportsUnalignedAtomicsEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14TargetLowering15DAGCombinerInfo18getDAGCombineLevelEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering20LowerFormalArgumentsENS_7SDValueEjbRKNS_15SmallVectorImplINS_3ISD8InputArgEEERKNS_5SDLocERNS_12SelectionDAGERNS2_IS1_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering14CanLowerReturnEjRNS_15MachineFunctionEbRKNS_15SmallVectorImplINS_3ISD9OutputArgEEERNS_11LLVMContextE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm14TargetLowering17getRegisterByNameEPKcNS_3LLTERKNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/TargetLowering.h - Target Lowering Info -----*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/TargetLowering.h - Target Lowering Info -----*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">///</td>
    <td class="lineNumber">8</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file describes how to lower LLVM code to machine code.  This has two</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file describes how to lower LLVM code to machine code.  This has two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// main components:</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// main components:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">///  1. Which ValueTypes are natively supported by the target.</td>
    <td class="lineNumber">13</td>
    <td class="codeline">///  1. Which ValueTypes are natively supported by the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">///  2. Which operations are supported for supported ValueTypes.</td>
    <td class="lineNumber">14</td>
    <td class="codeline">///  2. Which operations are supported for supported ValueTypes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">///  3. Cost thresholds for alternative implementations of certain operations.</td>
    <td class="lineNumber">15</td>
    <td class="codeline">///  3. Cost thresholds for alternative implementations of certain operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">///</td>
    <td class="lineNumber">16</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">/// In addition it has a few other components, like information about FP</td>
    <td class="lineNumber">17</td>
    <td class="codeline">/// In addition it has a few other components, like information about FP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">/// immediates.</td>
    <td class="lineNumber">18</td>
    <td class="codeline">/// immediates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">///</td>
    <td class="lineNumber">19</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">20</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline"></td>
    <td class="lineNumber">21</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_TARGETLOWERING_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#define LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#define LLVM_CODEGEN_TARGETLOWERING_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline"></td>
    <td class="lineNumber">24</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/CodeGen/ComplexDeinterleavingPass.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/CodeGen/ComplexDeinterleavingPass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/CodeGen/DAGCombine.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/CodeGen/DAGCombine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/CodeGen/ISDOpcodes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/CodeGen/LowLevelTypeUtils.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/CodeGen/LowLevelTypeUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/CodeGen/MachineValueType.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/CodeGen/RuntimeLibcalls.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/CodeGen/RuntimeLibcalls.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/CodeGen/SelectionDAG.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/CodeGen/SelectionDAG.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/CodeGen/SelectionDAGNodes.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/CodeGen/SelectionDAGNodes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/CodeGen/TargetCallingConv.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/CodeGen/TargetCallingConv.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/CallingConv.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/CallingConv.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/InlineAsm.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/InlineAsm.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Support/Alignment.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include <climits></td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include <climits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">58</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">#include <map></td>
    <td class="lineNumber">59</td>
    <td class="codeline">#include <map></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include <string></td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include <string></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">61</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">62</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">64</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">class AssumptionCache;</td>
    <td class="lineNumber">66</td>
    <td class="codeline">class AssumptionCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">class CCState;</td>
    <td class="lineNumber">67</td>
    <td class="codeline">class CCState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">class CCValAssign;</td>
    <td class="lineNumber">68</td>
    <td class="codeline">class CCValAssign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">class Constant;</td>
    <td class="lineNumber">69</td>
    <td class="codeline">class Constant;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">class FastISel;</td>
    <td class="lineNumber">70</td>
    <td class="codeline">class FastISel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">class FunctionLoweringInfo;</td>
    <td class="lineNumber">71</td>
    <td class="codeline">class FunctionLoweringInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">class GlobalValue;</td>
    <td class="lineNumber">72</td>
    <td class="codeline">class GlobalValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">class Loop;</td>
    <td class="lineNumber">73</td>
    <td class="codeline">class Loop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">class GISelKnownBits;</td>
    <td class="lineNumber">74</td>
    <td class="codeline">class GISelKnownBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">class IntrinsicInst;</td>
    <td class="lineNumber">75</td>
    <td class="codeline">class IntrinsicInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">class IRBuilderBase;</td>
    <td class="lineNumber">76</td>
    <td class="codeline">class IRBuilderBase;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">struct KnownBits;</td>
    <td class="lineNumber">77</td>
    <td class="codeline">struct KnownBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">class LLVMContext;</td>
    <td class="lineNumber">78</td>
    <td class="codeline">class LLVMContext;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">class MachineBasicBlock;</td>
    <td class="lineNumber">79</td>
    <td class="codeline">class MachineBasicBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">class MachineFunction;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">class MachineFunction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">class MachineInstr;</td>
    <td class="lineNumber">81</td>
    <td class="codeline">class MachineInstr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">class MachineJumpTableInfo;</td>
    <td class="lineNumber">82</td>
    <td class="codeline">class MachineJumpTableInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">class MachineLoop;</td>
    <td class="lineNumber">83</td>
    <td class="codeline">class MachineLoop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">class MachineRegisterInfo;</td>
    <td class="lineNumber">84</td>
    <td class="codeline">class MachineRegisterInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">class MCContext;</td>
    <td class="lineNumber">85</td>
    <td class="codeline">class MCContext;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">class MCExpr;</td>
    <td class="lineNumber">86</td>
    <td class="codeline">class MCExpr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">class Module;</td>
    <td class="lineNumber">87</td>
    <td class="codeline">class Module;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">class ProfileSummaryInfo;</td>
    <td class="lineNumber">88</td>
    <td class="codeline">class ProfileSummaryInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">class TargetLibraryInfo;</td>
    <td class="lineNumber">89</td>
    <td class="codeline">class TargetLibraryInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">class TargetMachine;</td>
    <td class="lineNumber">90</td>
    <td class="codeline">class TargetMachine;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">class TargetRegisterClass;</td>
    <td class="lineNumber">91</td>
    <td class="codeline">class TargetRegisterClass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">class TargetRegisterInfo;</td>
    <td class="lineNumber">92</td>
    <td class="codeline">class TargetRegisterInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">class TargetTransformInfo;</td>
    <td class="lineNumber">93</td>
    <td class="codeline">class TargetTransformInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">class Value;</td>
    <td class="lineNumber">94</td>
    <td class="codeline">class Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">namespace Sched {</td>
    <td class="lineNumber">96</td>
    <td class="codeline">namespace Sched {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">enum Preference {</td>
    <td class="lineNumber">98</td>
    <td class="codeline">enum Preference {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  None,        // No preference</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  None,        // No preference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  Source,      // Follow source order.</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  Source,      // Follow source order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  RegPressure, // Scheduling for lowest register pressure.</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  RegPressure, // Scheduling for lowest register pressure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  Hybrid,      // Scheduling for both latency and register pressure.</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  Hybrid,      // Scheduling for both latency and register pressure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  ILP,         // Scheduling for ILP in low register pressure mode.</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  ILP,         // Scheduling for ILP in low register pressure mode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  VLIW,        // Scheduling for VLIW targets.</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  VLIW,        // Scheduling for VLIW targets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  Fast,        // Fast suboptimal list scheduling</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  Fast,        // Fast suboptimal list scheduling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  Linearize    // Linearize DAG, no scheduling</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  Linearize    // Linearize DAG, no scheduling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">};</td>
    <td class="lineNumber">107</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">} // end namespace Sched</td>
    <td class="lineNumber">109</td>
    <td class="codeline">} // end namespace Sched</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">// MemOp models a memory operation, either memset or memcpy/memmove.</td>
    <td class="lineNumber">111</td>
    <td class="codeline">// MemOp models a memory operation, either memset or memcpy/memmove.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">struct MemOp {</td>
    <td class="lineNumber">112</td>
    <td class="codeline">struct MemOp {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">113</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  // Shared</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  // Shared</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  uint64_t Size;</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  uint64_t Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  bool DstAlignCanChange; // true if destination alignment can satisfy any</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  bool DstAlignCanChange; // true if destination alignment can satisfy any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">                          // constraint.</td>
    <td class="lineNumber">117</td>
    <td class="codeline">                          // constraint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  Align DstAlign;         // Specified alignment of the memory operation.</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  Align DstAlign;         // Specified alignment of the memory operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  bool AllowOverlap;</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  bool AllowOverlap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  // memset only</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  // memset only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  bool IsMemset;   // If setthis memory operation is a memset.</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  bool IsMemset;   // If setthis memory operation is a memset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  bool ZeroMemset; // If set clears out memory with zeros.</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  bool ZeroMemset; // If set clears out memory with zeros.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  // memcpy only</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  // memcpy only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  bool MemcpyStrSrc; // Indicates whether the memcpy source is an in-register</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  bool MemcpyStrSrc; // Indicates whether the memcpy source is an in-register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">                     // constant so it does not need to be loaded.</td>
    <td class="lineNumber">126</td>
    <td class="codeline">                     // constant so it does not need to be loaded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  Align SrcAlign;    // Inferred alignment of the source or default value if the</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  Align SrcAlign;    // Inferred alignment of the source or default value if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">                     // memory operation does not need to load the value.</td>
    <td class="lineNumber">128</td>
    <td class="codeline">                     // memory operation does not need to load the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">129</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  static MemOp Copy(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  static MemOp Copy(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">                    Align SrcAlign, bool IsVolatile,</td>
    <td class="lineNumber">131</td>
    <td class="codeline">                    Align SrcAlign, bool IsVolatile,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">                    bool MemcpyStrSrc = false) {</td>
    <td class="lineNumber">132</td>
    <td class="codeline">                    bool MemcpyStrSrc = false) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    MemOp Op;</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    MemOp Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    Op.Size = Size;</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    Op.Size = Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    Op.DstAlignCanChange = DstAlignCanChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">    Op.DstAlign = DstAlign;</td>
    <td class="lineNumber">136</td>
    <td class="codeline">    Op.DstAlign = DstAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">    Op.AllowOverlap = !IsVolatile;</td>
    <td class="lineNumber">137</td>
    <td class="codeline">    Op.AllowOverlap = !IsVolatile;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">    Op.IsMemset = false;</td>
    <td class="lineNumber">138</td>
    <td class="codeline">    Op.IsMemset = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">    Op.ZeroMemset = false;</td>
    <td class="lineNumber">139</td>
    <td class="codeline">    Op.ZeroMemset = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">    Op.MemcpyStrSrc = MemcpyStrSrc;</td>
    <td class="lineNumber">140</td>
    <td class="codeline">    Op.MemcpyStrSrc = MemcpyStrSrc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    Op.SrcAlign = SrcAlign;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    Op.SrcAlign = SrcAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    return Op;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    return Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  static MemOp Set(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  static MemOp Set(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">                   bool IsZeroMemset, bool IsVolatile) {</td>
    <td class="lineNumber">146</td>
    <td class="codeline">                   bool IsZeroMemset, bool IsVolatile) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">    MemOp Op;</td>
    <td class="lineNumber">147</td>
    <td class="codeline">    MemOp Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">    Op.Size = Size;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">    Op.Size = Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td class="lineNumber">149</td>
    <td class="codeline">    Op.DstAlignCanChange = DstAlignCanChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    Op.DstAlign = DstAlign;</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    Op.DstAlign = DstAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    Op.AllowOverlap = !IsVolatile;</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    Op.AllowOverlap = !IsVolatile;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">    Op.IsMemset = true;</td>
    <td class="lineNumber">152</td>
    <td class="codeline">    Op.IsMemset = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">    Op.ZeroMemset = IsZeroMemset;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">    Op.ZeroMemset = IsZeroMemset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">    Op.MemcpyStrSrc = false;</td>
    <td class="lineNumber">154</td>
    <td class="codeline">    Op.MemcpyStrSrc = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">    return Op;</td>
    <td class="lineNumber">155</td>
    <td class="codeline">    return Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  uint64_t size() const { return Size; }</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  uint64_t size() const { return Size; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  Align getDstAlign() const {</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  Align getDstAlign() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">    assert(!DstAlignCanChange);</td>
    <td class="lineNumber">160</td>
    <td class="codeline">    assert(!DstAlignCanChange);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">    return DstAlign;</td>
    <td class="lineNumber">161</td>
    <td class="codeline">    return DstAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  bool isFixedDstAlign() const { return !DstAlignCanChange; }</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  bool isFixedDstAlign() const { return !DstAlignCanChange; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  bool allowOverlap() const { return AllowOverlap; }</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  bool allowOverlap() const { return AllowOverlap; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  bool isMemset() const { return IsMemset; }</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  bool isMemset() const { return IsMemset; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  bool isMemcpy() const { return !IsMemset; }</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  bool isMemcpy() const { return !IsMemset; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  bool isMemcpyWithFixedDstAlign() const {</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  bool isMemcpyWithFixedDstAlign() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">    return isMemcpy() && !DstAlignCanChange;</td>
    <td class="lineNumber">168</td>
    <td class="codeline">    return isMemcpy() && !DstAlignCanChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  bool isZeroMemset() const { return isMemset() && ZeroMemset; }</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  bool isZeroMemset() const { return isMemset() && ZeroMemset; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  bool isMemcpyStrSrc() const {</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  bool isMemcpyStrSrc() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td class="lineNumber">172</td>
    <td class="codeline">    assert(isMemcpy() && "Must be a memcpy");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    return MemcpyStrSrc;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    return MemcpyStrSrc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  Align getSrcAlign() const {</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  Align getSrcAlign() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td class="lineNumber">176</td>
    <td class="codeline">    assert(isMemcpy() && "Must be a memcpy");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">    return SrcAlign;</td>
    <td class="lineNumber">177</td>
    <td class="codeline">    return SrcAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  bool isSrcAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  bool isSrcAligned(Align AlignCheck) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">    return isMemset() || llvm::isAligned(AlignCheck, SrcAlign.value());</td>
    <td class="lineNumber">180</td>
    <td class="codeline">    return isMemset() || llvm::isAligned(AlignCheck, SrcAlign.value());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  bool isDstAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  bool isDstAligned(Align AlignCheck) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">    return DstAlignCanChange || llvm::isAligned(AlignCheck, DstAlign.value());</td>
    <td class="lineNumber">183</td>
    <td class="codeline">    return DstAlignCanChange || llvm::isAligned(AlignCheck, DstAlign.value());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  bool isAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  bool isAligned(Align AlignCheck) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">    return isSrcAligned(AlignCheck) && isDstAligned(AlignCheck);</td>
    <td class="lineNumber">186</td>
    <td class="codeline">    return isSrcAligned(AlignCheck) && isDstAligned(AlignCheck);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">};</td>
    <td class="lineNumber">188</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">/// This base class for TargetLowering contains the SelectionDAG-independent</td>
    <td class="lineNumber">190</td>
    <td class="codeline">/// This base class for TargetLowering contains the SelectionDAG-independent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">/// parts that can be used from the rest of CodeGen.</td>
    <td class="lineNumber">191</td>
    <td class="codeline">/// parts that can be used from the rest of CodeGen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">class TargetLoweringBase {</td>
    <td class="lineNumber">192</td>
    <td class="codeline">class TargetLoweringBase {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">193</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  /// This enum indicates whether operations are valid for a target, and if not,</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  /// This enum indicates whether operations are valid for a target, and if not,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  /// what action should be used to make them valid.</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  /// what action should be used to make them valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  enum LegalizeAction : uint8_t {</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  enum LegalizeAction : uint8_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">    Legal,      // The target natively supports this operation.</td>
    <td class="lineNumber">197</td>
    <td class="codeline">    Legal,      // The target natively supports this operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    Promote,    // This operation should be executed in a larger type.</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    Promote,    // This operation should be executed in a larger type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">    Expand,     // Try to expand this to other ops, otherwise use a libcall.</td>
    <td class="lineNumber">199</td>
    <td class="codeline">    Expand,     // Try to expand this to other ops, otherwise use a libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">    LibCall,    // Don't try to expand this to other ops, always use a libcall.</td>
    <td class="lineNumber">200</td>
    <td class="codeline">    LibCall,    // Don't try to expand this to other ops, always use a libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">    Custom      // Use the LowerOperation hook to implement custom lowering.</td>
    <td class="lineNumber">201</td>
    <td class="codeline">    Custom      // Use the LowerOperation hook to implement custom lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline"></td>
    <td class="lineNumber">203</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  /// This enum indicates whether a types are legal for a target, and if not,</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  /// This enum indicates whether a types are legal for a target, and if not,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  /// what action should be used to make them valid.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  /// what action should be used to make them valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  enum LegalizeTypeAction : uint8_t {</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  enum LegalizeTypeAction : uint8_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">    TypeLegal,           // The target natively supports this type.</td>
    <td class="lineNumber">207</td>
    <td class="codeline">    TypeLegal,           // The target natively supports this type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    TypePromoteInteger,  // Replace this integer with a larger one.</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    TypePromoteInteger,  // Replace this integer with a larger one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    TypeExpandInteger,   // Split this integer into two of half the size.</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    TypeExpandInteger,   // Split this integer into two of half the size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    TypeSoftenFloat,     // Convert this float to a same size integer type.</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    TypeSoftenFloat,     // Convert this float to a same size integer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">    TypeExpandFloat,     // Split this float into two of half the size.</td>
    <td class="lineNumber">211</td>
    <td class="codeline">    TypeExpandFloat,     // Split this float into two of half the size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">    TypeScalarizeVector, // Replace this one-element vector with its element.</td>
    <td class="lineNumber">212</td>
    <td class="codeline">    TypeScalarizeVector, // Replace this one-element vector with its element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">    TypeSplitVector,     // Split this vector into two of half the size.</td>
    <td class="lineNumber">213</td>
    <td class="codeline">    TypeSplitVector,     // Split this vector into two of half the size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">    TypeWidenVector,     // This vector should be widened into a larger vector.</td>
    <td class="lineNumber">214</td>
    <td class="codeline">    TypeWidenVector,     // This vector should be widened into a larger vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">    TypePromoteFloat,    // Replace this float with a larger one.</td>
    <td class="lineNumber">215</td>
    <td class="codeline">    TypePromoteFloat,    // Replace this float with a larger one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">    TypeSoftPromoteHalf, // Soften half to i16 and use float to do arithmetic.</td>
    <td class="lineNumber">216</td>
    <td class="codeline">    TypeSoftPromoteHalf, // Soften half to i16 and use float to do arithmetic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">    TypeScalarizeScalableVector, // This action is explicitly left unimplemented.</td>
    <td class="lineNumber">217</td>
    <td class="codeline">    TypeScalarizeScalableVector, // This action is explicitly left unimplemented.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">                                 // While it is theoretically possible to</td>
    <td class="lineNumber">218</td>
    <td class="codeline">                                 // While it is theoretically possible to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">                                 // legalize operations on scalable types with a</td>
    <td class="lineNumber">219</td>
    <td class="codeline">                                 // legalize operations on scalable types with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">                                 // loop that handles the vscale * #lanes of the</td>
    <td class="lineNumber">220</td>
    <td class="codeline">                                 // loop that handles the vscale * #lanes of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">                                 // vector, this is non-trivial at SelectionDAG</td>
    <td class="lineNumber">221</td>
    <td class="codeline">                                 // vector, this is non-trivial at SelectionDAG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">                                 // level and these types are better to be</td>
    <td class="lineNumber">222</td>
    <td class="codeline">                                 // level and these types are better to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">                                 // widened or promoted.</td>
    <td class="lineNumber">223</td>
    <td class="codeline">                                 // widened or promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  /// LegalizeKind holds the legalization kind that needs to happen to EVT</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  /// LegalizeKind holds the legalization kind that needs to happen to EVT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  /// in order to type-legalize it.</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  /// in order to type-legalize it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  using LegalizeKind = std::pair<LegalizeTypeAction, EVT>;</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  using LegalizeKind = std::pair<LegalizeTypeAction, EVT>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  /// Enum that describes how the target represents true/false values.</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  /// Enum that describes how the target represents true/false values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  enum BooleanContent {</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  enum BooleanContent {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">    UndefinedBooleanContent,    // Only bit 0 counts, the rest can hold garbage.</td>
    <td class="lineNumber">232</td>
    <td class="codeline">    UndefinedBooleanContent,    // Only bit 0 counts, the rest can hold garbage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">    ZeroOrOneBooleanContent,        // All bits zero except for bit 0.</td>
    <td class="lineNumber">233</td>
    <td class="codeline">    ZeroOrOneBooleanContent,        // All bits zero except for bit 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    ZeroOrNegativeOneBooleanContent // All bits equal to bit 0.</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    ZeroOrNegativeOneBooleanContent // All bits equal to bit 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  /// Enum that describes what type of support for selects the target has.</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  /// Enum that describes what type of support for selects the target has.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  enum SelectSupportKind {</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  enum SelectSupportKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    ScalarValSelect,      // The target supports scalar selects (ex: cmov).</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    ScalarValSelect,      // The target supports scalar selects (ex: cmov).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    ScalarCondVectorVal,  // The target supports selects with a scalar condition</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    ScalarCondVectorVal,  // The target supports selects with a scalar condition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">                          // and vector values (ex: cmov).</td>
    <td class="lineNumber">241</td>
    <td class="codeline">                          // and vector values (ex: cmov).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    VectorMaskSelect      // The target supports vector selects with a vector</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    VectorMaskSelect      // The target supports vector selects with a vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">                          // mask (ex: x86 blends).</td>
    <td class="lineNumber">243</td>
    <td class="codeline">                          // mask (ex: x86 blends).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  /// Enum that specifies what an atomic load/AtomicRMWInst is expanded</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  /// Enum that specifies what an atomic load/AtomicRMWInst is expanded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  /// to, if at all. Exists because different targets have different levels of</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  /// to, if at all. Exists because different targets have different levels of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  /// support for these atomic instructions, and also have different options</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  /// support for these atomic instructions, and also have different options</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  /// w.r.t. what they should expand to.</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  /// w.r.t. what they should expand to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  enum class AtomicExpansionKind {</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  enum class AtomicExpansionKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">    None,    // Don't expand the instruction.</td>
    <td class="lineNumber">251</td>
    <td class="codeline">    None,    // Don't expand the instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">    CastToInteger,    // Cast the atomic instruction to another type, e.g. from</td>
    <td class="lineNumber">252</td>
    <td class="codeline">    CastToInteger,    // Cast the atomic instruction to another type, e.g. from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">                      // floating-point to integer type.</td>
    <td class="lineNumber">253</td>
    <td class="codeline">                      // floating-point to integer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">    LLSC,    // Expand the instruction into loadlinked/storeconditional; used</td>
    <td class="lineNumber">254</td>
    <td class="codeline">    LLSC,    // Expand the instruction into loadlinked/storeconditional; used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">             // by ARM/AArch64.</td>
    <td class="lineNumber">255</td>
    <td class="codeline">             // by ARM/AArch64.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    LLOnly,  // Expand the (load) instruction into just a load-linked, which has</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    LLOnly,  // Expand the (load) instruction into just a load-linked, which has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">             // greater atomic guarantees than a normal load.</td>
    <td class="lineNumber">257</td>
    <td class="codeline">             // greater atomic guarantees than a normal load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    CmpXChg, // Expand the instruction into cmpxchg; used by at least X86.</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    CmpXChg, // Expand the instruction into cmpxchg; used by at least X86.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">    MaskedIntrinsic,  // Use a target-specific intrinsic for the LL/SC loop.</td>
    <td class="lineNumber">259</td>
    <td class="codeline">    MaskedIntrinsic,  // Use a target-specific intrinsic for the LL/SC loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    BitTestIntrinsic, // Use a target-specific intrinsic for special bit</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    BitTestIntrinsic, // Use a target-specific intrinsic for special bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">                      // operations; used by X86.</td>
    <td class="lineNumber">261</td>
    <td class="codeline">                      // operations; used by X86.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    CmpArithIntrinsic,// Use a target-specific intrinsic for special compare</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    CmpArithIntrinsic,// Use a target-specific intrinsic for special compare</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">                      // operations; used by X86.</td>
    <td class="lineNumber">263</td>
    <td class="codeline">                      // operations; used by X86.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">    Expand,           // Generic expansion in terms of other atomic operations.</td>
    <td class="lineNumber">264</td>
    <td class="codeline">    Expand,           // Generic expansion in terms of other atomic operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    // Rewrite to a non-atomic form for use in a known non-preemptible</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    // Rewrite to a non-atomic form for use in a known non-preemptible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">    // environment.</td>
    <td class="lineNumber">267</td>
    <td class="codeline">    // environment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    NotAtomic</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    NotAtomic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Enum that specifies when a multiplication should be expanded.</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Enum that specifies when a multiplication should be expanded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  enum class MulExpansionKind {</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  enum class MulExpansionKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    Always,            // Always expand the instruction.</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    Always,            // Always expand the instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">    OnlyLegalOrCustom, // Only expand when the resulting instructions are legal</td>
    <td class="lineNumber">274</td>
    <td class="codeline">    OnlyLegalOrCustom, // Only expand when the resulting instructions are legal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">                       // or custom.</td>
    <td class="lineNumber">275</td>
    <td class="codeline">                       // or custom.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  /// Enum that specifies when a float negation is beneficial.</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  /// Enum that specifies when a float negation is beneficial.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  enum class NegatibleCost {</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  enum class NegatibleCost {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">    Cheaper = 0,    // Negated expression is cheaper.</td>
    <td class="lineNumber">280</td>
    <td class="codeline">    Cheaper = 0,    // Negated expression is cheaper.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    Neutral = 1,    // Negated expression has the same cost.</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    Neutral = 1,    // Negated expression has the same cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    Expensive = 2   // Negated expression is more expensive.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    Expensive = 2   // Negated expression is more expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  /// Enum of different potentially desirable ways to fold (and/or (setcc ...),</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  /// Enum of different potentially desirable ways to fold (and/or (setcc ...),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  /// (setcc ...)).</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  /// (setcc ...)).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  enum AndOrSETCCFoldKind : uint8_t {</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  enum AndOrSETCCFoldKind : uint8_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">    None = 0,   // No fold is preferable.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">    None = 0,   // No fold is preferable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    AddAnd = 1, // Fold with `Add` op and `And` op is preferable.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    AddAnd = 1, // Fold with `Add` op and `And` op is preferable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    NotAnd = 2, // Fold with `Not` op and `And` op is preferable.</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    NotAnd = 2, // Fold with `Not` op and `And` op is preferable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    ABS = 4,    // Fold with `llvm.abs` op is preferable.</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    ABS = 4,    // Fold with `llvm.abs` op is preferable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  class ArgListEntry {</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  class ArgListEntry {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    Value *Val = nullptr;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    Value *Val = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">    SDValue Node = SDValue();</td>
    <td class="lineNumber">297</td>
    <td class="codeline">    SDValue Node = SDValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">    Type *Ty = nullptr;</td>
    <td class="lineNumber">298</td>
    <td class="codeline">    Type *Ty = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">    bool IsSExt : 1;</td>
    <td class="lineNumber">299</td>
    <td class="codeline">    bool IsSExt : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">    bool IsZExt : 1;</td>
    <td class="lineNumber">300</td>
    <td class="codeline">    bool IsZExt : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">    bool IsInReg : 1;</td>
    <td class="lineNumber">301</td>
    <td class="codeline">    bool IsInReg : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    bool IsSRet : 1;</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    bool IsSRet : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    bool IsNest : 1;</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    bool IsNest : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    bool IsByVal : 1;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    bool IsByVal : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    bool IsByRef : 1;</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    bool IsByRef : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    bool IsInAlloca : 1;</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    bool IsInAlloca : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    bool IsPreallocated : 1;</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    bool IsPreallocated : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    bool IsReturned : 1;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    bool IsReturned : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    bool IsSwiftSelf : 1;</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    bool IsSwiftSelf : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    bool IsSwiftAsync : 1;</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    bool IsSwiftAsync : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    bool IsSwiftError : 1;</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    bool IsSwiftError : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    bool IsCFGuardTarget : 1;</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    bool IsCFGuardTarget : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    MaybeAlign Alignment = std::nullopt;</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    MaybeAlign Alignment = std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">    Type *IndirectType = nullptr;</td>
    <td class="lineNumber">314</td>
    <td class="codeline">    Type *IndirectType = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    ArgListEntry()</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    ArgListEntry()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">        : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),</td>
    <td class="lineNumber">317</td>
    <td class="codeline">        : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">          IsNest(false), IsByVal(false), IsByRef(false), IsInAlloca(false),</td>
    <td class="lineNumber">318</td>
    <td class="codeline">          IsNest(false), IsByVal(false), IsByRef(false), IsInAlloca(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">          IsPreallocated(false), IsReturned(false), IsSwiftSelf(false),</td>
    <td class="lineNumber">319</td>
    <td class="codeline">          IsPreallocated(false), IsReturned(false), IsSwiftSelf(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">          IsSwiftAsync(false), IsSwiftError(false), IsCFGuardTarget(false) {}</td>
    <td class="lineNumber">320</td>
    <td class="codeline">          IsSwiftAsync(false), IsSwiftError(false), IsCFGuardTarget(false) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline"></td>
    <td class="lineNumber">321</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">    void setAttributes(const CallBase *Call, unsigned ArgIdx);</td>
    <td class="lineNumber">322</td>
    <td class="codeline">    void setAttributes(const CallBase *Call, unsigned ArgIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  using ArgListTy = std::vector<ArgListEntry>;</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  using ArgListTy = std::vector<ArgListEntry>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  virtual void markLibCallAttributes(MachineFunction *MF, unsigned CC,</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  virtual void markLibCallAttributes(MachineFunction *MF, unsigned CC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">                                     ArgListTy &Args) const {};</td>
    <td class="lineNumber">327</td>
    <td class="codeline">                                     ArgListTy &Args) const {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline"></td>
    <td class="lineNumber">328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  static ISD::NodeType getExtendForContent(BooleanContent Content) {</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  static ISD::NodeType getExtendForContent(BooleanContent Content) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">    switch (Content) {</td>
    <td class="lineNumber">330</td>
    <td class="codeline">    switch (Content) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">    case UndefinedBooleanContent:</td>
    <td class="lineNumber">331</td>
    <td class="codeline">    case UndefinedBooleanContent:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">      // Extend by adding rubbish bits.</td>
    <td class="lineNumber">332</td>
    <td class="codeline">      // Extend by adding rubbish bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">      return ISD::ANY_EXTEND;</td>
    <td class="lineNumber">333</td>
    <td class="codeline">      return ISD::ANY_EXTEND;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">    case ZeroOrOneBooleanContent:</td>
    <td class="lineNumber">334</td>
    <td class="codeline">    case ZeroOrOneBooleanContent:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">      // Extend by adding zero bits.</td>
    <td class="lineNumber">335</td>
    <td class="codeline">      // Extend by adding zero bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">      return ISD::ZERO_EXTEND;</td>
    <td class="lineNumber">336</td>
    <td class="codeline">      return ISD::ZERO_EXTEND;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">    case ZeroOrNegativeOneBooleanContent:</td>
    <td class="lineNumber">337</td>
    <td class="codeline">    case ZeroOrNegativeOneBooleanContent:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">      // Extend by copying the sign bit.</td>
    <td class="lineNumber">338</td>
    <td class="codeline">      // Extend by copying the sign bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">      return ISD::SIGN_EXTEND;</td>
    <td class="lineNumber">339</td>
    <td class="codeline">      return ISD::SIGN_EXTEND;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    llvm_unreachable("Invalid content kind");</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    llvm_unreachable("Invalid content kind");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">342</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline"></td>
    <td class="lineNumber">343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  explicit TargetLoweringBase(const TargetMachine &TM);</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  explicit TargetLoweringBase(const TargetMachine &TM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  TargetLoweringBase(const TargetLoweringBase &) = delete;</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  TargetLoweringBase(const TargetLoweringBase &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  TargetLoweringBase &operator=(const TargetLoweringBase &) = delete;</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  TargetLoweringBase &operator=(const TargetLoweringBase &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  virtual ~TargetLoweringBase() = default;</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  virtual ~TargetLoweringBase() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  /// Return true if the target support strict float operation</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  /// Return true if the target support strict float operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  bool isStrictFPEnabled() const {</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  bool isStrictFPEnabled() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    return IsStrictFPEnabled;</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    return IsStrictFPEnabled;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">354</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  /// Initialize all of the actions to default values.</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  /// Initialize all of the actions to default values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  void initActions();</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  void initActions();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">358</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  const TargetMachine &getTargetMachine() const { return TM; }</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  const TargetMachine &getTargetMachine() const { return TM; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline"></td>
    <td class="lineNumber">360</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">  virtual bool useSoftFloat() const { return false; }</td>
    <td class="lineNumber">361</td>
    <td class="codeline">  virtual bool useSoftFloat() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  /// Return the pointer type for the given address space, defaults to</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  /// Return the pointer type for the given address space, defaults to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  /// the pointer type from the data layout.</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  /// the pointer type from the data layout.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  /// FIXME: The default needs to be removed once all the code is updated.</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  /// FIXME: The default needs to be removed once all the code is updated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  virtual MVT getPointerTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  virtual MVT getPointerTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td class="lineNumber">367</td>
    <td class="codeline">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  /// Return the in-memory pointer type for the given address space, defaults to</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  /// Return the in-memory pointer type for the given address space, defaults to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  /// the pointer type from the data layout.  FIXME: The default needs to be</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  /// the pointer type from the data layout.  FIXME: The default needs to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  /// removed once all the code is updated.</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  /// removed once all the code is updated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  virtual MVT getPointerMemTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  virtual MVT getPointerMemTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td class="lineNumber">374</td>
    <td class="codeline">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">  /// Return the type for frame index, which is determined by</td>
    <td class="lineNumber">377</td>
    <td class="codeline">  /// Return the type for frame index, which is determined by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  /// the alloca address space specified through the data layout.</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  /// the alloca address space specified through the data layout.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  MVT getFrameIndexTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  MVT getFrameIndexTy(const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">    return getPointerTy(DL, DL.getAllocaAddrSpace());</td>
    <td class="lineNumber">380</td>
    <td class="codeline">    return getPointerTy(DL, DL.getAllocaAddrSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  /// Return the type for code pointers, which is determined by the program</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  /// Return the type for code pointers, which is determined by the program</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  /// address space specified through the data layout.</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  /// address space specified through the data layout.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  MVT getProgramPointerTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  MVT getProgramPointerTy(const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    return getPointerTy(DL, DL.getProgramAddressSpace());</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    return getPointerTy(DL, DL.getProgramAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  /// Return the type for operands of fence.</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  /// Return the type for operands of fence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  /// TODO: Let fence operands be of i32 type and remove this.</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  /// TODO: Let fence operands be of i32 type and remove this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  virtual MVT getFenceOperandTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  virtual MVT getFenceOperandTy(const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    return getPointerTy(DL);</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    return getPointerTy(DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  /// Return the type to use for a scalar shift opcode, given the shifted amount</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  /// Return the type to use for a scalar shift opcode, given the shifted amount</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  /// type. Targets should return a legal type if the input type is legal.</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  /// type. Targets should return a legal type if the input type is legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  /// Targets can return a type that is too small if the input type is illegal.</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  /// Targets can return a type that is too small if the input type is illegal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  virtual MVT getScalarShiftAmountTy(const DataLayout &, EVT) const;</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  virtual MVT getScalarShiftAmountTy(const DataLayout &, EVT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  /// Returns the type for the shift amount of a shift opcode. For vectors,</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  /// Returns the type for the shift amount of a shift opcode. For vectors,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  /// returns the input type. For scalars, behavior depends on \p LegalTypes. If</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  /// returns the input type. For scalars, behavior depends on \p LegalTypes. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  /// \p LegalTypes is true, calls getScalarShiftAmountTy, otherwise uses</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  /// \p LegalTypes is true, calls getScalarShiftAmountTy, otherwise uses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  /// pointer type. If getScalarShiftAmountTy or pointer type cannot represent</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  /// pointer type. If getScalarShiftAmountTy or pointer type cannot represent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  /// all possible shift amounts, returns MVT::i32. In general, \p LegalTypes</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  /// all possible shift amounts, returns MVT::i32. In general, \p LegalTypes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  /// should be set to true for calls during type legalization and after type</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  /// should be set to true for calls during type legalization and after type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  /// legalization has been completed.</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  /// legalization has been completed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  EVT getShiftAmountTy(EVT LHSTy, const DataLayout &DL,</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  EVT getShiftAmountTy(EVT LHSTy, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">                       bool LegalTypes = true) const;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">                       bool LegalTypes = true) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  /// Return the preferred type to use for a shift opcode, given the shifted</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  /// Return the preferred type to use for a shift opcode, given the shifted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  /// amount type is \p ShiftValueTy.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  /// amount type is \p ShiftValueTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  LLVM_READONLY</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  LLVM_READONLY</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  virtual LLT getPreferredShiftAmountTy(LLT ShiftValueTy) const {</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  virtual LLT getPreferredShiftAmountTy(LLT ShiftValueTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">    return ShiftValueTy;</td>
    <td class="lineNumber">414</td>
    <td class="codeline">    return ShiftValueTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  /// Returns the type to be used for the index operand of:</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  /// Returns the type to be used for the index operand of:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  /// ISD::INSERT_VECTOR_ELT, ISD::EXTRACT_VECTOR_ELT,</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  /// ISD::INSERT_VECTOR_ELT, ISD::EXTRACT_VECTOR_ELT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  /// ISD::INSERT_SUBVECTOR, and ISD::EXTRACT_SUBVECTOR</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  /// ISD::INSERT_SUBVECTOR, and ISD::EXTRACT_SUBVECTOR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  virtual MVT getVectorIdxTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  virtual MVT getVectorIdxTy(const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">    return getPointerTy(DL);</td>
    <td class="lineNumber">421</td>
    <td class="codeline">    return getPointerTy(DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  /// Returns the type to be used for the EVL/AVL operand of VP nodes:</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  /// Returns the type to be used for the EVL/AVL operand of VP nodes:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  /// ISD::VP_ADD, ISD::VP_SUB, etc. It must be a legal scalar integer type,</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  /// ISD::VP_ADD, ISD::VP_SUB, etc. It must be a legal scalar integer type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  /// and must be at least as large as i32. The EVL is implicitly zero-extended</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  /// and must be at least as large as i32. The EVL is implicitly zero-extended</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  /// to any larger type.</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  /// to any larger type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  virtual MVT getVPExplicitVectorLengthTy() const { return MVT::i32; }</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  virtual MVT getVPExplicitVectorLengthTy() const { return MVT::i32; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  /// This callback is used to inspect load/store instructions and add</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  /// This callback is used to inspect load/store instructions and add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  /// target-specific MachineMemOperand flags to them.  The default</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  /// target-specific MachineMemOperand flags to them.  The default</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  /// implementation does nothing.</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  /// implementation does nothing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  virtual MachineMemOperand::Flags getTargetMMOFlags(const Instruction &I) const {</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  virtual MachineMemOperand::Flags getTargetMMOFlags(const Instruction &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">    return MachineMemOperand::MONone;</td>
    <td class="lineNumber">434</td>
    <td class="codeline">    return MachineMemOperand::MONone;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  /// This callback is used to inspect load/store SDNode.</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  /// This callback is used to inspect load/store SDNode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  /// The default implementation does nothing.</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  /// The default implementation does nothing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  virtual MachineMemOperand::Flags</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  virtual MachineMemOperand::Flags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  getTargetMMOFlags(const MemSDNode &Node) const {</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  getTargetMMOFlags(const MemSDNode &Node) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">    return MachineMemOperand::MONone;</td>
    <td class="lineNumber">441</td>
    <td class="codeline">    return MachineMemOperand::MONone;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  MachineMemOperand::Flags</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  MachineMemOperand::Flags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  getLoadMemOperandFlags(const LoadInst &LI, const DataLayout &DL,</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  getLoadMemOperandFlags(const LoadInst &LI, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">                         AssumptionCache *AC = nullptr,</td>
    <td class="lineNumber">446</td>
    <td class="codeline">                         AssumptionCache *AC = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">                         const TargetLibraryInfo *LibInfo = nullptr) const;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">                         const TargetLibraryInfo *LibInfo = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  MachineMemOperand::Flags getStoreMemOperandFlags(const StoreInst &SI,</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  MachineMemOperand::Flags getStoreMemOperandFlags(const StoreInst &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">                                                   const DataLayout &DL) const;</td>
    <td class="lineNumber">449</td>
    <td class="codeline">                                                   const DataLayout &DL) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  MachineMemOperand::Flags getAtomicMemOperandFlags(const Instruction &AI,</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  MachineMemOperand::Flags getAtomicMemOperandFlags(const Instruction &AI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">                                                    const DataLayout &DL) const;</td>
    <td class="lineNumber">451</td>
    <td class="codeline">                                                    const DataLayout &DL) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  virtual bool isSelectSupported(SelectSupportKind /*kind*/) const {</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  virtual bool isSelectSupported(SelectSupportKind /*kind*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">454</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  /// Return true if the @llvm.get.active.lane.mask intrinsic should be expanded</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  /// Return true if the @llvm.get.active.lane.mask intrinsic should be expanded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  /// using generic code in SelectionDAGBuilder.</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  /// using generic code in SelectionDAGBuilder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  virtual bool shouldExpandGetActiveLaneMask(EVT VT, EVT OpVT) const {</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  virtual bool shouldExpandGetActiveLaneMask(EVT VT, EVT OpVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  virtual bool shouldExpandGetVectorLength(EVT CountVT, unsigned VF,</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  virtual bool shouldExpandGetVectorLength(EVT CountVT, unsigned VF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">                                           bool IsScalable) const {</td>
    <td class="lineNumber">464</td>
    <td class="codeline">                                           bool IsScalable) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline"></td>
    <td class="lineNumber">467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  // Return true if op(vecreduce(x), vecreduce(y)) should be reassociated to</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  // Return true if op(vecreduce(x), vecreduce(y)) should be reassociated to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  // vecreduce(op(x, y)) for the reduction opcode RedOpc.</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  // vecreduce(op(x, y)) for the reduction opcode RedOpc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  virtual bool shouldReassociateReduction(unsigned RedOpc, EVT VT) const {</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  virtual bool shouldReassociateReduction(unsigned RedOpc, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline"></td>
    <td class="lineNumber">473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  /// Return true if it is profitable to convert a select of FP constants into</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  /// Return true if it is profitable to convert a select of FP constants into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  /// a constant pool load whose address depends on the select condition. The</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  /// a constant pool load whose address depends on the select condition. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  /// parameter may be used to differentiate a select with FP compare from</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  /// parameter may be used to differentiate a select with FP compare from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  /// integer compare.</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  /// integer compare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  virtual bool reduceSelectOfFPConstantLoads(EVT CmpOpVT) const {</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  virtual bool reduceSelectOfFPConstantLoads(EVT CmpOpVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">479</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  /// Return true if multiple condition registers are available.</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  /// Return true if multiple condition registers are available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  bool hasMultipleConditionRegisters() const {</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  bool hasMultipleConditionRegisters() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">    return HasMultipleConditionRegisters;</td>
    <td class="lineNumber">484</td>
    <td class="codeline">    return HasMultipleConditionRegisters;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  /// Return true if the target has BitExtract instructions.</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  /// Return true if the target has BitExtract instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  bool hasExtractBitsInsn() const { return HasExtractBitsInsn; }</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  bool hasExtractBitsInsn() const { return HasExtractBitsInsn; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  /// Return the preferred vector type legalization action.</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  /// Return the preferred vector type legalization action.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  virtual TargetLoweringBase::LegalizeTypeAction</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  virtual TargetLoweringBase::LegalizeTypeAction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  getPreferredVectorAction(MVT VT) const {</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  getPreferredVectorAction(MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">    // The default action for one element vectors is to scalarize</td>
    <td class="lineNumber">493</td>
    <td class="codeline">    // The default action for one element vectors is to scalarize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    if (VT.getVectorElementCount().isScalar())</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    if (VT.getVectorElementCount().isScalar())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">      return TypeScalarizeVector;</td>
    <td class="lineNumber">495</td>
    <td class="codeline">      return TypeScalarizeVector;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">    // The default action for an odd-width vector is to widen.</td>
    <td class="lineNumber">496</td>
    <td class="codeline">    // The default action for an odd-width vector is to widen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    if (!VT.isPow2VectorType())</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    if (!VT.isPow2VectorType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">      return TypeWidenVector;</td>
    <td class="lineNumber">498</td>
    <td class="codeline">      return TypeWidenVector;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    // The default action for other vectors is to promote</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    // The default action for other vectors is to promote</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    return TypePromoteInteger;</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    return TypePromoteInteger;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  // Return true if the half type should be passed around as i16, but promoted</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  // Return true if the half type should be passed around as i16, but promoted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  // to float around arithmetic. The default behavior is to pass around as</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  // to float around arithmetic. The default behavior is to pass around as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  // float and convert around loads/stores/bitcasts and other places where</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  // float and convert around loads/stores/bitcasts and other places where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  // the size matters.</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  // the size matters.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  virtual bool softPromoteHalfType() const { return false; }</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  virtual bool softPromoteHalfType() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  // There are two general methods for expanding a BUILD_VECTOR node:</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  // There are two general methods for expanding a BUILD_VECTOR node:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  //  1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  //  1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  //     them together.</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  //     them together.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  //  2. Build the vector on the stack and then load it.</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  //  2. Build the vector on the stack and then load it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  // If this function returns true, then method (1) will be used, subject to</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  // If this function returns true, then method (1) will be used, subject to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  // the constraint that all of the necessary shuffles are legal (as determined</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  // the constraint that all of the necessary shuffles are legal (as determined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  // by isShuffleMaskLegal). If this function returns false, then method (2) is</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  // by isShuffleMaskLegal). If this function returns false, then method (2) is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  // always used. The vector type, and the number of defined values, are</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  // always used. The vector type, and the number of defined values, are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  // provided.</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  // provided.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  shouldExpandBuildVectorWithShuffles(EVT /* VT */,</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  shouldExpandBuildVectorWithShuffles(EVT /* VT */,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">                                      unsigned DefinedValues) const {</td>
    <td class="lineNumber">520</td>
    <td class="codeline">                                      unsigned DefinedValues) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">    return DefinedValues < 3;</td>
    <td class="lineNumber">521</td>
    <td class="codeline">    return DefinedValues < 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  /// Return true if integer divide is usually cheaper than a sequence of</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  /// Return true if integer divide is usually cheaper than a sequence of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  /// several shifts, adds, and multiplies for this target.</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  /// several shifts, adds, and multiplies for this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  /// The definition of "cheaper" may depend on whether we're optimizing</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  /// The definition of "cheaper" may depend on whether we're optimizing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  /// for speed or for size.</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  /// for speed or for size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  virtual bool isIntDivCheap(EVT VT, AttributeList Attr) const { return false; }</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  virtual bool isIntDivCheap(EVT VT, AttributeList Attr) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  /// Return true if the target can handle a standalone remainder operation.</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  /// Return true if the target can handle a standalone remainder operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  virtual bool hasStandaloneRem(EVT VT) const {</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  virtual bool hasStandaloneRem(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  /// Return true if SQRT(X) shouldn't be replaced with X*RSQRT(X).</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  /// Return true if SQRT(X) shouldn't be replaced with X*RSQRT(X).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  virtual bool isFsqrtCheap(SDValue X, SelectionDAG &DAG) const {</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  virtual bool isFsqrtCheap(SDValue X, SelectionDAG &DAG) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">    // Default behavior is to replace SQRT(X) with X*RSQRT(X).</td>
    <td class="lineNumber">537</td>
    <td class="codeline">    // Default behavior is to replace SQRT(X) with X*RSQRT(X).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  /// Reciprocal estimate status values used by the functions below.</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  /// Reciprocal estimate status values used by the functions below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  enum ReciprocalEstimate : int {</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  enum ReciprocalEstimate : int {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">    Unspecified = -1,</td>
    <td class="lineNumber">543</td>
    <td class="codeline">    Unspecified = -1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">    Disabled = 0,</td>
    <td class="lineNumber">544</td>
    <td class="codeline">    Disabled = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    Enabled = 1</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    Enabled = 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline"></td>
    <td class="lineNumber">547</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  /// Return a ReciprocalEstimate enum value for a square root of the given type</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  /// Return a ReciprocalEstimate enum value for a square root of the given type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  /// based on the function's attributes. If the operation is not overridden by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  int getRecipEstimateSqrtEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  int getRecipEstimateSqrtEnabled(EVT VT, MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  /// Return a ReciprocalEstimate enum value for a division of the given type</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  /// Return a ReciprocalEstimate enum value for a division of the given type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  /// based on the function's attributes. If the operation is not overridden by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">  int getRecipEstimateDivEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">558</td>
    <td class="codeline">  int getRecipEstimateDivEnabled(EVT VT, MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">  /// Return the refinement step count for a square root of the given type based</td>
    <td class="lineNumber">560</td>
    <td class="codeline">  /// Return the refinement step count for a square root of the given type based</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  /// on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  /// on the function's attributes. If the operation is not overridden by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">562</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  int getSqrtRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  int getSqrtRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  /// Return the refinement step count for a division of the given type based</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  /// Return the refinement step count for a division of the given type based</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  /// on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  /// on the function's attributes. If the operation is not overridden by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">568</td>
    <td class="codeline">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  /// are expected to be used for instruction selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  int getDivRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  int getDivRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline"></td>
    <td class="lineNumber">571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  /// Returns true if target has indicated at least one type should be bypassed.</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  /// Returns true if target has indicated at least one type should be bypassed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  bool isSlowDivBypassed() const { return !BypassSlowDivWidths.empty(); }</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  bool isSlowDivBypassed() const { return !BypassSlowDivWidths.empty(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  /// Returns map of slow types for division or remainder with corresponding</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  /// Returns map of slow types for division or remainder with corresponding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  /// fast types</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  /// fast types</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  const DenseMap<unsigned int, unsigned int> &getBypassSlowDivWidths() const {</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  const DenseMap<unsigned int, unsigned int> &getBypassSlowDivWidths() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    return BypassSlowDivWidths;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    return BypassSlowDivWidths;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  /// Return true only if vscale must be a power of two.</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  /// Return true only if vscale must be a power of two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">  virtual bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td class="lineNumber">582</td>
    <td class="codeline">  virtual bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  /// Return true if Flow Control is an expensive operation that should be</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  /// Return true if Flow Control is an expensive operation that should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  /// avoided.</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  /// avoided.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  bool isJumpExpensive() const { return JumpIsExpensive; }</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  bool isJumpExpensive() const { return JumpIsExpensive; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">  /// Return true if selects are only cheaper than branches if the branch is</td>
    <td class="lineNumber">588</td>
    <td class="codeline">  /// Return true if selects are only cheaper than branches if the branch is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  /// unlikely to be predicted right.</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  /// unlikely to be predicted right.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  bool isPredictableSelectExpensive() const {</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  bool isPredictableSelectExpensive() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    return PredictableSelectIsExpensive;</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    return PredictableSelectIsExpensive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline"></td>
    <td class="lineNumber">593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  virtual bool fallBackToDAGISel(const Instruction &Inst) const {</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  virtual bool fallBackToDAGISel(const Instruction &Inst) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  /// Return true if the following transform is beneficial:</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  /// Return true if the following transform is beneficial:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  /// fold (conv (load x)) -> (load (conv*)x)</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  /// fold (conv (load x)) -> (load (conv*)x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  /// On architectures that don't natively support some vector loads</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  /// On architectures that don't natively support some vector loads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  /// efficiently, casting the load to a smaller vector of larger types and</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  /// efficiently, casting the load to a smaller vector of larger types and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  /// loading is more efficient, however, this can be undone by optimizations in</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  /// loading is more efficient, however, this can be undone by optimizations in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  /// dag combiner.</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  /// dag combiner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  virtual bool isLoadBitCastBeneficial(EVT LoadVT, EVT BitcastVT,</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  virtual bool isLoadBitCastBeneficial(EVT LoadVT, EVT BitcastVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">                                       const SelectionDAG &DAG,</td>
    <td class="lineNumber">605</td>
    <td class="codeline">                                       const SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">                                       const MachineMemOperand &MMO) const;</td>
    <td class="lineNumber">606</td>
    <td class="codeline">                                       const MachineMemOperand &MMO) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  /// Return true if the following transform is beneficial:</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  /// Return true if the following transform is beneficial:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  /// (store (y (conv x)), y*)) -> (store x, (x*))</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  /// (store (y (conv x)), y*)) -> (store x, (x*))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  virtual bool isStoreBitCastBeneficial(EVT StoreVT, EVT BitcastVT,</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  virtual bool isStoreBitCastBeneficial(EVT StoreVT, EVT BitcastVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">                                        const SelectionDAG &DAG,</td>
    <td class="lineNumber">611</td>
    <td class="codeline">                                        const SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">                                        const MachineMemOperand &MMO) const {</td>
    <td class="lineNumber">612</td>
    <td class="codeline">                                        const MachineMemOperand &MMO) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">    // Default to the same logic as loads.</td>
    <td class="lineNumber">613</td>
    <td class="codeline">    // Default to the same logic as loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">    return isLoadBitCastBeneficial(StoreVT, BitcastVT, DAG, MMO);</td>
    <td class="lineNumber">614</td>
    <td class="codeline">    return isLoadBitCastBeneficial(StoreVT, BitcastVT, DAG, MMO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  /// Return true if it is expected to be cheaper to do a store of vector</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  /// Return true if it is expected to be cheaper to do a store of vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  /// constant with the given size and type for the address space than to</td>
    <td class="lineNumber">618</td>
    <td class="codeline">  /// constant with the given size and type for the address space than to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  /// store the individual scalar element constants.</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  /// store the individual scalar element constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  virtual bool storeOfVectorConstantIsCheap(bool IsZero, EVT MemVT,</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  virtual bool storeOfVectorConstantIsCheap(bool IsZero, EVT MemVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">                                            unsigned NumElem,</td>
    <td class="lineNumber">621</td>
    <td class="codeline">                                            unsigned NumElem,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">                                            unsigned AddrSpace) const {</td>
    <td class="lineNumber">622</td>
    <td class="codeline">                                            unsigned AddrSpace) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">    return IsZero;</td>
    <td class="lineNumber">623</td>
    <td class="codeline">    return IsZero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  /// Allow store merging for the specified type after legalization in addition</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  /// Allow store merging for the specified type after legalization in addition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  /// to before legalization. This may transform stores that do not exist</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  /// to before legalization. This may transform stores that do not exist</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  /// earlier (for example, stores created from intrinsics).</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  /// earlier (for example, stores created from intrinsics).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  virtual bool mergeStoresAfterLegalization(EVT MemVT) const {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  virtual bool mergeStoresAfterLegalization(EVT MemVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline"></td>
    <td class="lineNumber">632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  /// Returns if it's reasonable to merge stores to MemVT size.</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  /// Returns if it's reasonable to merge stores to MemVT size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  virtual bool canMergeStoresTo(unsigned AS, EVT MemVT,</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  virtual bool canMergeStoresTo(unsigned AS, EVT MemVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">                                const MachineFunction &MF) const {</td>
    <td class="lineNumber">635</td>
    <td class="codeline">                                const MachineFunction &MF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  /// Return true if it is cheap to speculate a call to intrinsic cttz.</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  /// Return true if it is cheap to speculate a call to intrinsic cttz.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  virtual bool isCheapToSpeculateCttz(Type *Ty) const {</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  virtual bool isCheapToSpeculateCttz(Type *Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  /// Return true if it is cheap to speculate a call to intrinsic ctlz.</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  /// Return true if it is cheap to speculate a call to intrinsic ctlz.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  virtual bool isCheapToSpeculateCtlz(Type *Ty) const {</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  virtual bool isCheapToSpeculateCtlz(Type *Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">646</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  /// Return true if ctlz instruction is fast.</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  /// Return true if ctlz instruction is fast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  virtual bool isCtlzFast() const {</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  virtual bool isCtlzFast() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">651</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  /// Return the maximum number of "x & (x - 1)" operations that can be done</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  /// Return the maximum number of "x & (x - 1)" operations that can be done</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  /// instead of deferring to a custom CTPOP.</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  /// instead of deferring to a custom CTPOP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  virtual unsigned getCustomCtpopCost(EVT VT, ISD::CondCode Cond) const {</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  virtual unsigned getCustomCtpopCost(EVT VT, ISD::CondCode Cond) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">    return 1;</td>
    <td class="lineNumber">657</td>
    <td class="codeline">    return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline"></td>
    <td class="lineNumber">659</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  /// Return true if instruction generated for equality comparison is folded</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  /// Return true if instruction generated for equality comparison is folded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  /// with instruction generated for signed comparison.</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  /// with instruction generated for signed comparison.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  virtual bool isEqualityCmpFoldedWithSignedCmp() const { return true; }</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  virtual bool isEqualityCmpFoldedWithSignedCmp() const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  /// Return true if the heuristic to prefer icmp eq zero should be used in code</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  /// Return true if the heuristic to prefer icmp eq zero should be used in code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  /// gen prepare.</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  /// gen prepare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  virtual bool preferZeroCompareBranch() const { return false; }</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  virtual bool preferZeroCompareBranch() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  /// Return true if it is cheaper to split the store of a merged int val</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  /// Return true if it is cheaper to split the store of a merged int val</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  /// from a pair of smaller values into multiple stores.</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  /// from a pair of smaller values into multiple stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  virtual bool isMultiStoresCheaperThanBitsMerge(EVT LTy, EVT HTy) const {</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  virtual bool isMultiStoresCheaperThanBitsMerge(EVT LTy, EVT HTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline"></td>
    <td class="lineNumber">673</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  /// Return if the target supports combining a</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  /// Return if the target supports combining a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  /// chain like:</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  /// chain like:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  /// \code</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  /// \code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  ///   %andResult = and %val1, #mask</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  ///   %andResult = and %val1, #mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  ///   %icmpResult = icmp %andResult, 0</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  ///   %icmpResult = icmp %andResult, 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  /// \endcode</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  /// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  /// into a single machine instruction of a form like:</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  /// into a single machine instruction of a form like:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  /// \code</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  /// \code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  ///   cc = test %register, #mask</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  ///   cc = test %register, #mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  /// \endcode</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  /// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  virtual bool isMaskAndCmp0FoldingBeneficial(const Instruction &AndI) const {</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  virtual bool isMaskAndCmp0FoldingBeneficial(const Instruction &AndI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">685</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  /// Return true if it is valid to merge the TargetMMOFlags in two SDNodes.</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  /// Return true if it is valid to merge the TargetMMOFlags in two SDNodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  areTwoSDNodeTargetMMOFlagsMergeable(const MemSDNode &NodeX,</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  areTwoSDNodeTargetMMOFlagsMergeable(const MemSDNode &NodeX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">                                      const MemSDNode &NodeY) const {</td>
    <td class="lineNumber">691</td>
    <td class="codeline">                                      const MemSDNode &NodeY) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">692</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  /// Use bitwise logic to make pairs of compares more efficient. For example:</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  /// Use bitwise logic to make pairs of compares more efficient. For example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">  /// This should be true when it takes more than one instruction to lower</td>
    <td class="lineNumber">697</td>
    <td class="codeline">  /// This should be true when it takes more than one instruction to lower</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  virtual bool convertSetCCLogicToBitwiseLogic(EVT VT) const {</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  virtual bool convertSetCCLogicToBitwiseLogic(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline"></td>
    <td class="lineNumber">703</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  /// Return the preferred operand type if the target has a quick way to compare</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  /// Return the preferred operand type if the target has a quick way to compare</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  /// integer values of the given size. Assume that any legal integer type can</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  /// integer values of the given size. Assume that any legal integer type can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  /// be compared efficiently. Targets may override this to allow illegal wide</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  /// be compared efficiently. Targets may override this to allow illegal wide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  /// types to return a vector type if there is support to compare that type.</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  /// types to return a vector type if there is support to compare that type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  virtual MVT hasFastEqualityCompare(unsigned NumBits) const {</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  virtual MVT hasFastEqualityCompare(unsigned NumBits) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">    MVT VT = MVT::getIntegerVT(NumBits);</td>
    <td class="lineNumber">709</td>
    <td class="codeline">    MVT VT = MVT::getIntegerVT(NumBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">    return isTypeLegal(VT) ? VT : MVT::INVALID_SIMPLE_VALUE_TYPE;</td>
    <td class="lineNumber">710</td>
    <td class="codeline">    return isTypeLegal(VT) ? VT : MVT::INVALID_SIMPLE_VALUE_TYPE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Return true if the target should transform:</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Return true if the target should transform:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  /// (X & Y) == Y ---> (~X & Y) == 0</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  /// (X & Y) == Y ---> (~X & Y) == 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">  /// (X & Y) != Y ---> (~X & Y) != 0</td>
    <td class="lineNumber">715</td>
    <td class="codeline">  /// (X & Y) != Y ---> (~X & Y) != 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  /// This may be profitable if the target has a bitwise and-not operation that</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  /// This may be profitable if the target has a bitwise and-not operation that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  /// sets comparison flags. A target may want to limit the transformation based</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  /// sets comparison flags. A target may want to limit the transformation based</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  /// on the type of Y or if Y is a constant.</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  /// on the type of Y or if Y is a constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  /// Note that the transform will not occur if Y is known to be a power-of-2</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  /// Note that the transform will not occur if Y is known to be a power-of-2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  /// because a mask and compare of a single bit can be handled by inverting the</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  /// because a mask and compare of a single bit can be handled by inverting the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  /// predicate, for example:</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  /// predicate, for example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">  /// (X & 8) == 8 ---> (X & 8) != 0</td>
    <td class="lineNumber">724</td>
    <td class="codeline">  /// (X & 8) == 8 ---> (X & 8) != 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  virtual bool hasAndNotCompare(SDValue Y) const {</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  virtual bool hasAndNotCompare(SDValue Y) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  /// Return true if the target has a bitwise and-not operation:</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  /// Return true if the target has a bitwise and-not operation:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  /// X = ~A & B</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  /// X = ~A & B</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  /// This can be used to simplify select or other instructions.</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  /// This can be used to simplify select or other instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  virtual bool hasAndNot(SDValue X) const {</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  virtual bool hasAndNot(SDValue X) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    // If the target has the more complex version of this operation, assume that</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    // If the target has the more complex version of this operation, assume that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    // it has this operation too.</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    // it has this operation too.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    return hasAndNotCompare(X);</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    return hasAndNotCompare(X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Return true if the target has a bit-test instruction:</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Return true if the target has a bit-test instruction:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  ///   (X & (1 << Y)) ==/!= 0</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  ///   (X & (1 << Y)) ==/!= 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  /// This knowledge can be used to prevent breaking the pattern,</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  /// This knowledge can be used to prevent breaking the pattern,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  /// or creating it if it could be recognized.</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  /// or creating it if it could be recognized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">  virtual bool hasBitTest(SDValue X, SDValue Y) const { return false; }</td>
    <td class="lineNumber">742</td>
    <td class="codeline">  virtual bool hasBitTest(SDValue X, SDValue Y) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  /// There are two ways to clear extreme bits (either low or high):</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  /// There are two ways to clear extreme bits (either low or high):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  /// Mask:    x &  (-1 << y)  (the instcombine canonical form)</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  /// Mask:    x &  (-1 << y)  (the instcombine canonical form)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  /// Shifts:  x >> y << y</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  /// Shifts:  x >> y << y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  /// Return true if the variant with 2 variable shifts is preferred.</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  /// Return true if the variant with 2 variable shifts is preferred.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  /// Return false if there is no preference.</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  /// Return false if there is no preference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  virtual bool shouldFoldMaskToVariableShiftPair(SDValue X) const {</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  virtual bool shouldFoldMaskToVariableShiftPair(SDValue X) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    // By default, let's assume that no one prefers shifts.</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    // By default, let's assume that no one prefers shifts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">752</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">  /// Return true if it is profitable to fold a pair of shifts into a mask.</td>
    <td class="lineNumber">754</td>
    <td class="codeline">  /// Return true if it is profitable to fold a pair of shifts into a mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  /// This is usually true on most targets. But some targets, like Thumb1,</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  /// This is usually true on most targets. But some targets, like Thumb1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  /// have immediate shift instructions, but no immediate "and" instruction;</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  /// have immediate shift instructions, but no immediate "and" instruction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  /// this makes the fold unprofitable.</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  /// this makes the fold unprofitable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  virtual bool shouldFoldConstantShiftPairToMask(const SDNode *N,</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  virtual bool shouldFoldConstantShiftPairToMask(const SDNode *N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">                                                 CombineLevel Level) const {</td>
    <td class="lineNumber">759</td>
    <td class="codeline">                                                 CombineLevel Level) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  /// Should we tranform the IR-optimal check for whether given truncation</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  /// Should we tranform the IR-optimal check for whether given truncation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  /// down into KeptBits would be truncating or not:</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  /// down into KeptBits would be truncating or not:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">  ///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)</td>
    <td class="lineNumber">765</td>
    <td class="codeline">  ///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">  /// Into it's more traditional form:</td>
    <td class="lineNumber">766</td>
    <td class="codeline">  /// Into it's more traditional form:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  ///   ((%x << C) a>> C) dstcond %x</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  ///   ((%x << C) a>> C) dstcond %x</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  /// Return true if we should transform.</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  /// Return true if we should transform.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  /// Return false if there is no preference.</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  /// Return false if there is no preference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  virtual bool shouldTransformSignedTruncationCheck(EVT XVT,</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  virtual bool shouldTransformSignedTruncationCheck(EVT XVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">                                                    unsigned KeptBits) const {</td>
    <td class="lineNumber">771</td>
    <td class="codeline">                                                    unsigned KeptBits) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    // By default, let's assume that no one prefers shifts.</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    // By default, let's assume that no one prefers shifts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  /// Given the pattern</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  /// Given the pattern</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  ///   (X & (C l>>/<< Y)) ==/!= 0</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  ///   (X & (C l>>/<< Y)) ==/!= 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">  /// return true if it should be transformed into:</td>
    <td class="lineNumber">778</td>
    <td class="codeline">  /// return true if it should be transformed into:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  ///   ((X <</l>> Y) & C) ==/!= 0</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  ///   ((X <</l>> Y) & C) ==/!= 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">  /// WARNING: if 'X' is a constant, the fold may deadlock!</td>
    <td class="lineNumber">780</td>
    <td class="codeline">  /// WARNING: if 'X' is a constant, the fold may deadlock!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat()</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  ///        here because it can end up being not linked in.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  ///        here because it can end up being not linked in.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  virtual bool shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  virtual bool shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">      SDValue X, ConstantSDNode *XC, ConstantSDNode *CC, SDValue Y,</td>
    <td class="lineNumber">784</td>
    <td class="codeline">      SDValue X, ConstantSDNode *XC, ConstantSDNode *CC, SDValue Y,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">      unsigned OldShiftOpcode, unsigned NewShiftOpcode,</td>
    <td class="lineNumber">785</td>
    <td class="codeline">      unsigned OldShiftOpcode, unsigned NewShiftOpcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">      SelectionDAG &DAG) const {</td>
    <td class="lineNumber">786</td>
    <td class="codeline">      SelectionDAG &DAG) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    if (hasBitTest(X, Y)) {</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    if (hasBitTest(X, Y)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">      // One interesting pattern that we'd want to form is 'bit test':</td>
    <td class="lineNumber">788</td>
    <td class="codeline">      // One interesting pattern that we'd want to form is 'bit test':</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">      //   ((1 << Y) & C) ==/!= 0</td>
    <td class="lineNumber">789</td>
    <td class="codeline">      //   ((1 << Y) & C) ==/!= 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">      // But we also need to be careful not to try to reverse that fold.</td>
    <td class="lineNumber">790</td>
    <td class="codeline">      // But we also need to be careful not to try to reverse that fold.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">      // Is this '1 << Y' ?</td>
    <td class="lineNumber">792</td>
    <td class="codeline">      // Is this '1 << Y' ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">      if (OldShiftOpcode == ISD::SHL && CC->isOne())</td>
    <td class="lineNumber">793</td>
    <td class="codeline">      if (OldShiftOpcode == ISD::SHL && CC->isOne())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">        return false; // Keep the 'bit test' pattern.</td>
    <td class="lineNumber">794</td>
    <td class="codeline">        return false; // Keep the 'bit test' pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline"></td>
    <td class="lineNumber">795</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">      // Will it be '1 << Y' after the transform ?</td>
    <td class="lineNumber">796</td>
    <td class="codeline">      // Will it be '1 << Y' after the transform ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">      if (XC && NewShiftOpcode == ISD::SHL && XC->isOne())</td>
    <td class="lineNumber">797</td>
    <td class="codeline">      if (XC && NewShiftOpcode == ISD::SHL && XC->isOne())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">        return true; // Do form the 'bit test' pattern.</td>
    <td class="lineNumber">798</td>
    <td class="codeline">        return true; // Do form the 'bit test' pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">799</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">    // If 'X' is a constant, and we transform, then we will immediately</td>
    <td class="lineNumber">801</td>
    <td class="codeline">    // If 'X' is a constant, and we transform, then we will immediately</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">    // try to undo the fold, thus causing endless combine loop.</td>
    <td class="lineNumber">802</td>
    <td class="codeline">    // try to undo the fold, thus causing endless combine loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">    // So by default, let's assume everyone prefers the fold</td>
    <td class="lineNumber">803</td>
    <td class="codeline">    // So by default, let's assume everyone prefers the fold</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">    // iff 'X' is not a constant.</td>
    <td class="lineNumber">804</td>
    <td class="codeline">    // iff 'X' is not a constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">    return !XC;</td>
    <td class="lineNumber">805</td>
    <td class="codeline">    return !XC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  /// These two forms are equivalent:</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  /// These two forms are equivalent:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  ///   sub %y, (xor %x, -1)</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  ///   sub %y, (xor %x, -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  ///   add (add %x, 1), %y</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  ///   add (add %x, 1), %y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  /// The variant with two add's is IR-canonical.</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  /// The variant with two add's is IR-canonical.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  /// Some targets may prefer one to the other.</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  /// Some targets may prefer one to the other.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  virtual bool preferIncOfAddToSubOfNot(EVT VT) const {</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  virtual bool preferIncOfAddToSubOfNot(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    // By default, let's assume that everyone prefers the form with two add's.</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    // By default, let's assume that everyone prefers the form with two add's.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">815</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  // By default prefer folding (abs (sub nsw x, y)) -> abds(x, y). Some targets</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  // By default prefer folding (abs (sub nsw x, y)) -> abds(x, y). Some targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  // may want to avoid this to prevent loss of sub_nsw pattern.</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  // may want to avoid this to prevent loss of sub_nsw pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  virtual bool preferABDSToABSWithNSW(EVT VT) const {</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  virtual bool preferABDSToABSWithNSW(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">821</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  // Return true if the target wants to transform Op(Splat(X)) -> Splat(Op(X))</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  // Return true if the target wants to transform Op(Splat(X)) -> Splat(Op(X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  virtual bool preferScalarizeSplat(SDNode *N) const { return true; }</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  virtual bool preferScalarizeSplat(SDNode *N) const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  /// Return true if the target wants to use the optimization that</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  /// Return true if the target wants to use the optimization that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  /// turns ext(promotableInst1(...(promotableInstN(load)))) into</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  /// turns ext(promotableInst1(...(promotableInstN(load)))) into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  /// promotedInst1(...(promotedInstN(ext(load)))).</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  /// promotedInst1(...(promotedInstN(ext(load)))).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  bool enableExtLdPromotion() const { return EnableExtLdPromotion; }</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  bool enableExtLdPromotion() const { return EnableExtLdPromotion; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline"></td>
    <td class="lineNumber">831</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  /// Return true if the target can combine store(extractelement VectorTy,</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  /// Return true if the target can combine store(extractelement VectorTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  /// Idx).</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  /// Idx).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  /// \p Cost[out] gives the cost of that transformation when this is true.</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  /// \p Cost[out] gives the cost of that transformation when this is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  virtual bool canCombineStoreAndExtract(Type *VectorTy, Value *Idx,</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  virtual bool canCombineStoreAndExtract(Type *VectorTy, Value *Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">                                         unsigned &Cost) const {</td>
    <td class="lineNumber">836</td>
    <td class="codeline">                                         unsigned &Cost) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">837</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  /// Return true if inserting a scalar into a variable element of an undef</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  /// Return true if inserting a scalar into a variable element of an undef</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  /// vector is more efficiently handled by splatting the scalar instead.</td>
    <td class="lineNumber">841</td>
    <td class="codeline">  /// vector is more efficiently handled by splatting the scalar instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  virtual bool shouldSplatInsEltVarIndex(EVT) const {</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  virtual bool shouldSplatInsEltVarIndex(EVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">843</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline"></td>
    <td class="lineNumber">845</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  /// Return true if target always benefits from combining into FMA for a</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  /// Return true if target always benefits from combining into FMA for a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  /// given value type. This must typically return false on targets where FMA</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  /// given value type. This must typically return false on targets where FMA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  /// takes more cycles to execute than FADD.</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  /// takes more cycles to execute than FADD.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  virtual bool enableAggressiveFMAFusion(EVT VT) const { return false; }</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  virtual bool enableAggressiveFMAFusion(EVT VT) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">  /// Return true if target always benefits from combining into FMA for a</td>
    <td class="lineNumber">851</td>
    <td class="codeline">  /// Return true if target always benefits from combining into FMA for a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  /// given value type. This must typically return false on targets where FMA</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  /// given value type. This must typically return false on targets where FMA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  /// takes more cycles to execute than FADD.</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  /// takes more cycles to execute than FADD.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  virtual bool enableAggressiveFMAFusion(LLT Ty) const { return false; }</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  virtual bool enableAggressiveFMAFusion(LLT Ty) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  /// Return the ValueType of the result of SETCC operations.</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  /// Return the ValueType of the result of SETCC operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  virtual EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  virtual EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">                                 EVT VT) const;</td>
    <td class="lineNumber">858</td>
    <td class="codeline">                                 EVT VT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  /// Return the ValueType for comparison libcalls. Comparison libcalls include</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  /// Return the ValueType for comparison libcalls. Comparison libcalls include</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  /// floating point comparison calls, and Ordered/Unordered check calls on</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  /// floating point comparison calls, and Ordered/Unordered check calls on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  /// floating point numbers.</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  /// floating point numbers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  virtual</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  virtual</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  MVT::SimpleValueType getCmpLibcallReturnType() const;</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  MVT::SimpleValueType getCmpLibcallReturnType() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  /// For targets without i1 registers, this gives the nature of the high-bits</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  /// For targets without i1 registers, this gives the nature of the high-bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  /// of boolean values held in types wider than i1.</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  /// of boolean values held in types wider than i1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  /// "Boolean values" are special true/false values produced by nodes like</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  /// "Boolean values" are special true/false values produced by nodes like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  /// Not to be confused with general values promoted from i1.  Some cpus</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  /// Not to be confused with general values promoted from i1.  Some cpus</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  /// distinguish between vectors of boolean and scalars; the isVec parameter</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  /// distinguish between vectors of boolean and scalars; the isVec parameter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  /// selects between the two kinds.  For example on X86 a scalar boolean should</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  /// selects between the two kinds.  For example on X86 a scalar boolean should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  /// be zero extended from i1, while the elements of a vector of booleans</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  /// be zero extended from i1, while the elements of a vector of booleans</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  /// should be sign extended from i1.</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  /// should be sign extended from i1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  /// Some cpus also treat floating point types the same way as they treat</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  /// Some cpus also treat floating point types the same way as they treat</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  /// vectors instead of the way they treat scalars.</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  /// vectors instead of the way they treat scalars.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  BooleanContent getBooleanContents(bool isVec, bool isFloat) const {</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  BooleanContent getBooleanContents(bool isVec, bool isFloat) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">    if (isVec)</td>
    <td class="lineNumber">880</td>
    <td class="codeline">    if (isVec)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">      return BooleanVectorContents;</td>
    <td class="lineNumber">881</td>
    <td class="codeline">      return BooleanVectorContents;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">    return isFloat ? BooleanFloatContents : BooleanContents;</td>
    <td class="lineNumber">882</td>
    <td class="codeline">    return isFloat ? BooleanFloatContents : BooleanContents;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  BooleanContent getBooleanContents(EVT Type) const {</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  BooleanContent getBooleanContents(EVT Type) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">    return getBooleanContents(Type.isVector(), Type.isFloatingPoint());</td>
    <td class="lineNumber">886</td>
    <td class="codeline">    return getBooleanContents(Type.isVector(), Type.isFloatingPoint());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline"></td>
    <td class="lineNumber">888</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">  /// Promote the given target boolean to a target boolean of the given type.</td>
    <td class="lineNumber">889</td>
    <td class="codeline">  /// Promote the given target boolean to a target boolean of the given type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">  /// A target boolean is an integer value, not necessarily of type i1, the bits</td>
    <td class="lineNumber">890</td>
    <td class="codeline">  /// A target boolean is an integer value, not necessarily of type i1, the bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  /// of which conform to getBooleanContents.</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  /// of which conform to getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  /// ValVT is the type of values that produced the boolean.</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  /// ValVT is the type of values that produced the boolean.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">  SDValue promoteTargetBoolean(SelectionDAG &DAG, SDValue Bool,</td>
    <td class="lineNumber">894</td>
    <td class="codeline">  SDValue promoteTargetBoolean(SelectionDAG &DAG, SDValue Bool,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">                               EVT ValVT) const {</td>
    <td class="lineNumber">895</td>
    <td class="codeline">                               EVT ValVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    SDLoc dl(Bool);</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    SDLoc dl(Bool);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">    EVT BoolVT =</td>
    <td class="lineNumber">897</td>
    <td class="codeline">    EVT BoolVT =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), ValVT);</td>
    <td class="lineNumber">898</td>
    <td class="codeline">        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), ValVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">    ISD::NodeType ExtendCode = getExtendForContent(getBooleanContents(ValVT));</td>
    <td class="lineNumber">899</td>
    <td class="codeline">    ISD::NodeType ExtendCode = getExtendForContent(getBooleanContents(ValVT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">    return DAG.getNode(ExtendCode, dl, BoolVT, Bool);</td>
    <td class="lineNumber">900</td>
    <td class="codeline">    return DAG.getNode(ExtendCode, dl, BoolVT, Bool);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  /// Return target scheduling preference.</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  /// Return target scheduling preference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">  Sched::Preference getSchedulingPreference() const {</td>
    <td class="lineNumber">904</td>
    <td class="codeline">  Sched::Preference getSchedulingPreference() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">    return SchedPreferenceInfo;</td>
    <td class="lineNumber">905</td>
    <td class="codeline">    return SchedPreferenceInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">906</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline"></td>
    <td class="lineNumber">907</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  /// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  /// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">  /// for different nodes. This function returns the preference (or none) for</td>
    <td class="lineNumber">909</td>
    <td class="codeline">  /// for different nodes. This function returns the preference (or none) for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  /// the given node.</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  /// the given node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  virtual Sched::Preference getSchedulingPreference(SDNode *) const {</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  virtual Sched::Preference getSchedulingPreference(SDNode *) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">    return Sched::None;</td>
    <td class="lineNumber">912</td>
    <td class="codeline">    return Sched::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline"></td>
    <td class="lineNumber">914</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  /// Return the register class that should be used for the specified value</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  /// Return the register class that should be used for the specified value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">  /// type.</td>
    <td class="lineNumber">916</td>
    <td class="codeline">  /// type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  virtual const TargetRegisterClass *getRegClassFor(MVT VT, bool isDivergent = false) const {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  virtual const TargetRegisterClass *getRegClassFor(MVT VT, bool isDivergent = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">    (void)isDivergent;</td>
    <td class="lineNumber">918</td>
    <td class="codeline">    (void)isDivergent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    const TargetRegisterClass *RC = RegClassForVT[VT.SimpleTy];</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    const TargetRegisterClass *RC = RegClassForVT[VT.SimpleTy];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">    assert(RC && "This value type is not natively supported!");</td>
    <td class="lineNumber">920</td>
    <td class="codeline">    assert(RC && "This value type is not natively supported!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">    return RC;</td>
    <td class="lineNumber">921</td>
    <td class="codeline">    return RC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  /// Allows target to decide about the register class of the</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  /// Allows target to decide about the register class of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  /// specific value that is live outside the defining block.</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  /// specific value that is live outside the defining block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  /// Returns true if the value needs uniform register class.</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  /// Returns true if the value needs uniform register class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">  virtual bool requiresUniformRegister(MachineFunction &MF,</td>
    <td class="lineNumber">927</td>
    <td class="codeline">  virtual bool requiresUniformRegister(MachineFunction &MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">                                       const Value *) const {</td>
    <td class="lineNumber">928</td>
    <td class="codeline">                                       const Value *) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">930</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline"></td>
    <td class="lineNumber">931</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">  /// Return the 'representative' register class for the specified value</td>
    <td class="lineNumber">932</td>
    <td class="codeline">  /// Return the 'representative' register class for the specified value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  /// type.</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  /// type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">934</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">  /// The 'representative' register class is the largest legal super-reg</td>
    <td class="lineNumber">935</td>
    <td class="codeline">  /// The 'representative' register class is the largest legal super-reg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">  /// register class for the register class of the value type.  For example, on</td>
    <td class="lineNumber">936</td>
    <td class="codeline">  /// register class for the register class of the value type.  For example, on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  /// i386 the rep register class for i8, i16, and i32 are GR32; while the rep</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  /// i386 the rep register class for i8, i16, and i32 are GR32; while the rep</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  /// register class is GR64 on x86_64.</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  /// register class is GR64 on x86_64.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  virtual const TargetRegisterClass *getRepRegClassFor(MVT VT) const {</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  virtual const TargetRegisterClass *getRepRegClassFor(MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">    const TargetRegisterClass *RC = RepRegClassForVT[VT.SimpleTy];</td>
    <td class="lineNumber">940</td>
    <td class="codeline">    const TargetRegisterClass *RC = RepRegClassForVT[VT.SimpleTy];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">    return RC;</td>
    <td class="lineNumber">941</td>
    <td class="codeline">    return RC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  /// Return the cost of the 'representative' register class for the specified</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  /// Return the cost of the 'representative' register class for the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  /// value type.</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  /// value type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  virtual uint8_t getRepRegClassCostFor(MVT VT) const {</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  virtual uint8_t getRepRegClassCostFor(MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">    return RepRegClassCostForVT[VT.SimpleTy];</td>
    <td class="lineNumber">947</td>
    <td class="codeline">    return RepRegClassCostForVT[VT.SimpleTy];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline"></td>
    <td class="lineNumber">949</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  /// Return the preferred strategy to legalize tihs SHIFT instruction, with</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  /// Return the preferred strategy to legalize tihs SHIFT instruction, with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">  /// \p ExpansionFactor being the recursion depth - how many expansion needed.</td>
    <td class="lineNumber">951</td>
    <td class="codeline">  /// \p ExpansionFactor being the recursion depth - how many expansion needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">  enum class ShiftLegalizationStrategy {</td>
    <td class="lineNumber">952</td>
    <td class="codeline">  enum class ShiftLegalizationStrategy {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">    ExpandToParts,</td>
    <td class="lineNumber">953</td>
    <td class="codeline">    ExpandToParts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">    ExpandThroughStack,</td>
    <td class="lineNumber">954</td>
    <td class="codeline">    ExpandThroughStack,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    LowerToLibcall</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    LowerToLibcall</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">956</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  virtual ShiftLegalizationStrategy</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  virtual ShiftLegalizationStrategy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  preferredShiftLegalizationStrategy(SelectionDAG &DAG, SDNode *N,</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  preferredShiftLegalizationStrategy(SelectionDAG &DAG, SDNode *N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">                                     unsigned ExpansionFactor) const {</td>
    <td class="lineNumber">959</td>
    <td class="codeline">                                     unsigned ExpansionFactor) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">    if (ExpansionFactor == 1)</td>
    <td class="lineNumber">960</td>
    <td class="codeline">    if (ExpansionFactor == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">      return ShiftLegalizationStrategy::ExpandToParts;</td>
    <td class="lineNumber">961</td>
    <td class="codeline">      return ShiftLegalizationStrategy::ExpandToParts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">    return ShiftLegalizationStrategy::ExpandThroughStack;</td>
    <td class="lineNumber">962</td>
    <td class="codeline">    return ShiftLegalizationStrategy::ExpandThroughStack;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  /// Return true if the target has native support for the specified value type.</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  /// Return true if the target has native support for the specified value type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  /// This means that it has a register that directly holds it without</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  /// This means that it has a register that directly holds it without</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  /// promotions or expansions.</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  /// promotions or expansions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  bool isTypeLegal(EVT VT) const {</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  bool isTypeLegal(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">    assert(!VT.isSimple() ||</td>
    <td class="lineNumber">969</td>
    <td class="codeline">    assert(!VT.isSimple() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">           (unsigned)VT.getSimpleVT().SimpleTy < std::size(RegClassForVT));</td>
    <td class="lineNumber">970</td>
    <td class="codeline">           (unsigned)VT.getSimpleVT().SimpleTy < std::size(RegClassForVT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">    return VT.isSimple() && RegClassForVT[VT.getSimpleVT().SimpleTy] != nullptr;</td>
    <td class="lineNumber">971</td>
    <td class="codeline">    return VT.isSimple() && RegClassForVT[VT.getSimpleVT().SimpleTy] != nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">972</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  class ValueTypeActionImpl {</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  class ValueTypeActionImpl {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">    /// ValueTypeActions - For each value type, keep a LegalizeTypeAction enum</td>
    <td class="lineNumber">975</td>
    <td class="codeline">    /// ValueTypeActions - For each value type, keep a LegalizeTypeAction enum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    /// that indicates how instruction selection should deal with the type.</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    /// that indicates how instruction selection should deal with the type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    LegalizeTypeAction ValueTypeActions[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    LegalizeTypeAction ValueTypeActions[MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline"></td>
    <td class="lineNumber">978</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">    ValueTypeActionImpl() {</td>
    <td class="lineNumber">980</td>
    <td class="codeline">    ValueTypeActionImpl() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">      std::fill(std::begin(ValueTypeActions), std::end(ValueTypeActions),</td>
    <td class="lineNumber">981</td>
    <td class="codeline">      std::fill(std::begin(ValueTypeActions), std::end(ValueTypeActions),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">                TypeLegal);</td>
    <td class="lineNumber">982</td>
    <td class="codeline">                TypeLegal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">983</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    LegalizeTypeAction getTypeAction(MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">      return ValueTypeActions[VT.SimpleTy];</td>
    <td class="lineNumber">986</td>
    <td class="codeline">      return ValueTypeActions[VT.SimpleTy];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">    void setTypeAction(MVT VT, LegalizeTypeAction Action) {</td>
    <td class="lineNumber">989</td>
    <td class="codeline">    void setTypeAction(MVT VT, LegalizeTypeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">      ValueTypeActions[VT.SimpleTy] = Action;</td>
    <td class="lineNumber">990</td>
    <td class="codeline">      ValueTypeActions[VT.SimpleTy] = Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">  const ValueTypeActionImpl &getValueTypeActions() const {</td>
    <td class="lineNumber">994</td>
    <td class="codeline">  const ValueTypeActionImpl &getValueTypeActions() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    return ValueTypeActions;</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    return ValueTypeActions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  /// Return pair that represents the legalization kind (first) that needs to</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  /// Return pair that represents the legalization kind (first) that needs to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  /// happen to EVT (second) in order to type-legalize it.</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  /// happen to EVT (second) in order to type-legalize it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  /// First: how we should legalize values of this type, either it is already</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  /// First: how we should legalize values of this type, either it is already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">  /// Second: for types supported by the target, this is an identity function.</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">  /// Second: for types supported by the target, this is an identity function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  /// For types that must be promoted to larger types, this returns the larger</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  /// For types that must be promoted to larger types, this returns the larger</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">  /// type to promote to.  For integer types that are larger than the largest</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">  /// type to promote to.  For integer types that are larger than the largest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// integer register, this contains one step in the expansion to get to the</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// integer register, this contains one step in the expansion to get to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// smaller register. For illegal floating point types, this returns the</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// smaller register. For illegal floating point types, this returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  /// integer type to transform to.</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  /// integer type to transform to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  LegalizeKind getTypeConversion(LLVMContext &Context, EVT VT) const;</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  LegalizeKind getTypeConversion(LLVMContext &Context, EVT VT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  /// Return how we should legalize values of this type, either it is already</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  /// Return how we should legalize values of this type, either it is already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  LegalizeTypeAction getTypeAction(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  LegalizeTypeAction getTypeAction(LLVMContext &Context, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    return getTypeConversion(Context, VT).first;</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    return getTypeConversion(Context, VT).first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  LegalizeTypeAction getTypeAction(MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">    return ValueTypeActions.getTypeAction(VT);</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">    return ValueTypeActions.getTypeAction(VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// For types supported by the target, this is an identity function.  For</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// For types supported by the target, this is an identity function.  For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// types that must be promoted to larger types, this returns the larger type</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// types that must be promoted to larger types, this returns the larger type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// to promote to.  For integer types that are larger than the largest integer</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// to promote to.  For integer types that are larger than the largest integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  /// register, this contains one step in the expansion to get to the smaller</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  /// register, this contains one step in the expansion to get to the smaller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  /// register. For illegal floating point types, this returns the integer type</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  /// register. For illegal floating point types, this returns the integer type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">  /// to transform to.</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">  /// to transform to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  virtual EVT getTypeToTransformTo(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  virtual EVT getTypeToTransformTo(LLVMContext &Context, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">    return getTypeConversion(Context, VT).second;</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">    return getTypeConversion(Context, VT).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline"></td>
    <td class="lineNumber">1034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  /// For types supported by the target, this is an identity function.  For</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  /// For types supported by the target, this is an identity function.  For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  /// types that must be expanded (i.e. integer types that are larger than the</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  /// types that must be expanded (i.e. integer types that are larger than the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">  /// largest integer register or illegal floating point types), this returns</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">  /// largest integer register or illegal floating point types), this returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// the largest legal type it will be expanded to.</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// the largest legal type it will be expanded to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  EVT getTypeToExpandTo(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  EVT getTypeToExpandTo(LLVMContext &Context, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">    assert(!VT.isVector());</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">    assert(!VT.isVector());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">    while (true) {</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">    while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">      switch (getTypeAction(Context, VT)) {</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">      switch (getTypeAction(Context, VT)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">      case TypeLegal:</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">      case TypeLegal:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">        return VT;</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">        return VT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">      case TypeExpandInteger:</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">      case TypeExpandInteger:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">        VT = getTypeToTransformTo(Context, VT);</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">        VT = getTypeToTransformTo(Context, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">      default:</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">      default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">        llvm_unreachable("Type is not legal nor is it to be expanded!");</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">        llvm_unreachable("Type is not legal nor is it to be expanded!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline"></td>
    <td class="lineNumber">1053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// Vector types are broken down into some number of legal first class types.</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// Vector types are broken down into some number of legal first class types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// promoted EVT::f64 values with the X86 FP stack.  Similarly, EVT::v2i64</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// promoted EVT::f64 values with the X86 FP stack.  Similarly, EVT::v2i64</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  /// turns into 4 EVT::i32 values with both PPC and X86.</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  /// turns into 4 EVT::i32 values with both PPC and X86.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// This method returns the number of registers needed, and the VT for each</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// This method returns the number of registers needed, and the VT for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  /// register.  It also returns the VT and quantity of the intermediate values</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  /// register.  It also returns the VT and quantity of the intermediate values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  /// before they are promoted/expanded.</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  /// before they are promoted/expanded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  unsigned getVectorTypeBreakdown(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  unsigned getVectorTypeBreakdown(LLVMContext &Context, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">                                  EVT &IntermediateVT,</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">                                  EVT &IntermediateVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">                                  unsigned &NumIntermediates,</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">                                  unsigned &NumIntermediates,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">                                  MVT &RegisterVT) const;</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">                                  MVT &RegisterVT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// Certain targets such as MIPS require that some types such as vectors are</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// Certain targets such as MIPS require that some types such as vectors are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// always broken down into scalars in some contexts. This occurs even if the</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// always broken down into scalars in some contexts. This occurs even if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// vector type is legal.</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// vector type is legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  virtual unsigned getVectorTypeBreakdownForCallingConv(</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  virtual unsigned getVectorTypeBreakdownForCallingConv(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">      LLVMContext &Context, CallingConv::ID CC, EVT VT, EVT &IntermediateVT,</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">      LLVMContext &Context, CallingConv::ID CC, EVT VT, EVT &IntermediateVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">      unsigned &NumIntermediates, MVT &RegisterVT) const {</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">      unsigned &NumIntermediates, MVT &RegisterVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    return getVectorTypeBreakdown(Context, VT, IntermediateVT, NumIntermediates,</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    return getVectorTypeBreakdown(Context, VT, IntermediateVT, NumIntermediates,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">                                  RegisterVT);</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">                                  RegisterVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  struct IntrinsicInfo {</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  struct IntrinsicInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">    unsigned     opc = 0;          // target opcode</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">    unsigned     opc = 0;          // target opcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">    EVT          memVT;            // memory VT</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">    EVT          memVT;            // memory VT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline"></td>
    <td class="lineNumber">1080</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">    // value representing memory location</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">    // value representing memory location</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">    PointerUnion<const Value *, const PseudoSourceValue *> ptrVal;</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">    PointerUnion<const Value *, const PseudoSourceValue *> ptrVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">    // Fallback address space for use if ptrVal is nullptr. std::nullopt means</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">    // Fallback address space for use if ptrVal is nullptr. std::nullopt means</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    // unknown address space.</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    // unknown address space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    std::optional<unsigned> fallbackAddressSpace;</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    std::optional<unsigned> fallbackAddressSpace;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">    int          offset = 0;       // offset off of ptrVal</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">    int          offset = 0;       // offset off of ptrVal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">    uint64_t     size = 0;         // the size of the memory location</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">    uint64_t     size = 0;         // the size of the memory location</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">                                   // (taken from memVT if zero)</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">                                   // (taken from memVT if zero)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">    MaybeAlign align = Align(1);   // alignment</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">    MaybeAlign align = Align(1);   // alignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline"></td>
    <td class="lineNumber">1092</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">    MachineMemOperand::Flags flags = MachineMemOperand::MONone;</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">    MachineMemOperand::Flags flags = MachineMemOperand::MONone;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">    IntrinsicInfo() = default;</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">    IntrinsicInfo() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  /// Given an intrinsic, checks if on the target the intrinsic will need to map</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  /// Given an intrinsic, checks if on the target the intrinsic will need to map</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">  /// to a MemIntrinsicNode (touches memory). If this is the case, it returns</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">  /// to a MemIntrinsicNode (touches memory). If this is the case, it returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">  /// true and store the intrinsic information into the IntrinsicInfo that was</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">  /// true and store the intrinsic information into the IntrinsicInfo that was</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  /// passed to the function.</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  /// passed to the function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  virtual bool getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &,</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  virtual bool getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">                                  MachineFunction &,</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">                                  MachineFunction &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">                                  unsigned /*Intrinsic*/) const {</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">                                  unsigned /*Intrinsic*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline"></td>
    <td class="lineNumber">1106</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// Returns true if the target can instruction select the specified FP</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// Returns true if the target can instruction select the specified FP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// immediate natively. If false, the legalizer will materialize the FP</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// immediate natively. If false, the legalizer will materialize the FP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  /// immediate as a load from a constant pool.</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  /// immediate as a load from a constant pool.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  virtual bool isFPImmLegal(const APFloat & /*Imm*/, EVT /*VT*/,</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  virtual bool isFPImmLegal(const APFloat & /*Imm*/, EVT /*VT*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">                            bool ForCodeSize = false) const {</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">                            bool ForCodeSize = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline"></td>
    <td class="lineNumber">1114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// Targets can use this to indicate that they only support *some*</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// Targets can use this to indicate that they only support *some*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  /// VECTOR_SHUFFLE operations, those with specific masks.  By default, if a</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  /// VECTOR_SHUFFLE operations, those with specific masks.  By default, if a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  /// legal.</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  /// legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  virtual bool isShuffleMaskLegal(ArrayRef<int> /*Mask*/, EVT /*VT*/) const {</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  virtual bool isShuffleMaskLegal(ArrayRef<int> /*Mask*/, EVT /*VT*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline"></td>
    <td class="lineNumber">1122</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">  /// Returns true if the operation can trap for the value type.</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">  /// Returns true if the operation can trap for the value type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// VT must be a legal type. By default, we optimistically assume most</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// VT must be a legal type. By default, we optimistically assume most</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  /// operations don't trap except for integer divide and remainder.</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  /// operations don't trap except for integer divide and remainder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  virtual bool canOpTrap(unsigned Op, EVT VT) const;</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  virtual bool canOpTrap(unsigned Op, EVT VT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline"></td>
    <td class="lineNumber">1128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">  /// Similar to isShuffleMaskLegal. Targets can use this to indicate if there</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">  /// Similar to isShuffleMaskLegal. Targets can use this to indicate if there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">  /// is a suitable VECTOR_SHUFFLE that can be used to replace a VAND with a</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">  /// is a suitable VECTOR_SHUFFLE that can be used to replace a VAND with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">  /// constant pool entry.</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">  /// constant pool entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">  virtual bool isVectorClearMaskLegal(ArrayRef<int> /*Mask*/,</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">  virtual bool isVectorClearMaskLegal(ArrayRef<int> /*Mask*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">                                      EVT /*VT*/) const {</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">                                      EVT /*VT*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline"></td>
    <td class="lineNumber">1136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">  /// How to legalize this custom operation?</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">  /// How to legalize this custom operation?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">  virtual LegalizeAction getCustomOperationAction(SDNode &Op) const {</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">  virtual LegalizeAction getCustomOperationAction(SDNode &Op) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">    return Legal;</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">    return Legal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  /// Return how this operation should be treated: either it is legal, needs to</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  /// Return how this operation should be treated: either it is legal, needs to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">  /// be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">  /// be promoted to a larger size, needs to be expanded to some other code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  LegalizeAction getOperationAction(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  LegalizeAction getOperationAction(unsigned Op, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (VT.isExtended()) return Expand;</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (VT.isExtended()) return Expand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    // If a target-specific SDNode requires legalization, require the target</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    // If a target-specific SDNode requires legalization, require the target</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">    // to provide custom legalization for it.</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">    // to provide custom legalization for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    if (Op >= std::size(OpActions[0]))</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    if (Op >= std::size(OpActions[0]))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">      return Custom;</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">      return Custom;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">    return OpActions[(unsigned)VT.getSimpleVT().SimpleTy][Op];</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">    return OpActions[(unsigned)VT.getSimpleVT().SimpleTy][Op];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline"></td>
    <td class="lineNumber">1153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// Custom method defined by each target to indicate if an operation which</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// Custom method defined by each target to indicate if an operation which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// may require a scale is supported natively by the target.</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// may require a scale is supported natively by the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  /// If not, the operation is illegal.</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  /// If not, the operation is illegal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  virtual bool isSupportedFixedPointOperation(unsigned Op, EVT VT,</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  virtual bool isSupportedFixedPointOperation(unsigned Op, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">                                              unsigned Scale) const {</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">                                              unsigned Scale) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">  /// Some fixed point operations may be natively supported by the target but</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">  /// Some fixed point operations may be natively supported by the target but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// only for specific scales. This method allows for checking</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// only for specific scales. This method allows for checking</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  /// if the width is supported by the target for a given operation that may</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  /// if the width is supported by the target for a given operation that may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  /// depend on scale.</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  /// depend on scale.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  LegalizeAction getFixedPointOperationAction(unsigned Op, EVT VT,</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  LegalizeAction getFixedPointOperationAction(unsigned Op, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">                                              unsigned Scale) const {</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">                                              unsigned Scale) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">    auto Action = getOperationAction(Op, VT);</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">    auto Action = getOperationAction(Op, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">    if (Action != Legal)</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">    if (Action != Legal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">      return Action;</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">      return Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline"></td>
    <td class="lineNumber">1171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">    // This operation is supported in this type but may only work on specific</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">    // This operation is supported in this type but may only work on specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">    // scales.</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">    // scales.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">    bool Supported;</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">    bool Supported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">    switch (Op) {</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">    switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">      llvm_unreachable("Unexpected fixed point operation.");</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">      llvm_unreachable("Unexpected fixed point operation.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">    case ISD::SMULFIX:</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">    case ISD::SMULFIX:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">    case ISD::SMULFIXSAT:</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">    case ISD::SMULFIXSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">    case ISD::UMULFIX:</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">    case ISD::UMULFIX:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">    case ISD::UMULFIXSAT:</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">    case ISD::UMULFIXSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">    case ISD::SDIVFIX:</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">    case ISD::SDIVFIX:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    case ISD::SDIVFIXSAT:</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    case ISD::SDIVFIXSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">    case ISD::UDIVFIX:</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">    case ISD::UDIVFIX:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">    case ISD::UDIVFIXSAT:</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">    case ISD::UDIVFIXSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">      Supported = isSupportedFixedPointOperation(Op, VT, Scale);</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">      Supported = isSupportedFixedPointOperation(Op, VT, Scale);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">    return Supported ? Action : Expand;</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">    return Supported ? Action : Expand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  // If Op is a strict floating-point operation, return the result</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  // If Op is a strict floating-point operation, return the result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  // of getOperationAction for the equivalent non-strict operation.</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  // of getOperationAction for the equivalent non-strict operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">  LegalizeAction getStrictFPOperationAction(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">  LegalizeAction getStrictFPOperationAction(unsigned Op, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">    unsigned EqOpc;</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">    unsigned EqOpc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">    switch (Op) {</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">    switch (Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">      default: llvm_unreachable("Unexpected FP pseudo-opcode");</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">      default: llvm_unreachable("Unexpected FP pseudo-opcode");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">      case ISD::STRICT_##DAGN: EqOpc = ISD::DAGN; break;</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">      case ISD::STRICT_##DAGN: EqOpc = ISD::DAGN; break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">      case ISD::STRICT_##DAGN: EqOpc = ISD::SETCC; break;</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">      case ISD::STRICT_##DAGN: EqOpc = ISD::SETCC; break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">#include "llvm/IR/ConstrainedOps.def"</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">#include "llvm/IR/ConstrainedOps.def"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline"></td>
    <td class="lineNumber">1205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">    return getOperationAction(EqOpc, VT);</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">    return getOperationAction(EqOpc, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target or can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  /// made legal with custom lowering. This is used to help guide high-level</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  /// made legal with custom lowering. This is used to help guide high-level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  /// lowering decisions. LegalOnly is an optional convenience for code paths</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  /// lowering decisions. LegalOnly is an optional convenience for code paths</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  /// traversed pre and post legalisation.</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  /// traversed pre and post legalisation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  bool isOperationLegalOrCustom(unsigned Op, EVT VT,</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  bool isOperationLegalOrCustom(unsigned Op, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">                                bool LegalOnly = false) const {</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">                                bool LegalOnly = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">    if (LegalOnly)</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">    if (LegalOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">      return isOperationLegal(Op, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline"></td>
    <td class="lineNumber">1217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">      (getOperationAction(Op, VT) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">       getOperationAction(Op, VT) == Custom);</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">       getOperationAction(Op, VT) == Custom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target or can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  /// made legal using promotion. This is used to help guide high-level lowering</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  /// made legal using promotion. This is used to help guide high-level lowering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">  /// decisions. LegalOnly is an optional convenience for code paths traversed</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">  /// decisions. LegalOnly is an optional convenience for code paths traversed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// pre and post legalisation.</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// pre and post legalisation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  bool isOperationLegalOrPromote(unsigned Op, EVT VT,</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  bool isOperationLegalOrPromote(unsigned Op, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">                                 bool LegalOnly = false) const {</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">                                 bool LegalOnly = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">    if (LegalOnly)</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">    if (LegalOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">      return isOperationLegal(Op, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">      (getOperationAction(Op, VT) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">       getOperationAction(Op, VT) == Promote);</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">       getOperationAction(Op, VT) == Promote);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target or can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  /// made legal with custom lowering or using promotion. This is used to help</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  /// made legal with custom lowering or using promotion. This is used to help</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// guide high-level lowering decisions. LegalOnly is an optional convenience</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// guide high-level lowering decisions. LegalOnly is an optional convenience</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// for code paths traversed pre and post legalisation.</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// for code paths traversed pre and post legalisation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  bool isOperationLegalOrCustomOrPromote(unsigned Op, EVT VT,</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  bool isOperationLegalOrCustomOrPromote(unsigned Op, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">                                         bool LegalOnly = false) const {</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">                                         bool LegalOnly = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">    if (LegalOnly)</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">    if (LegalOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">      return isOperationLegal(Op, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline"></td>
    <td class="lineNumber">1245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">      (getOperationAction(Op, VT) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">       getOperationAction(Op, VT) == Custom ||</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">       getOperationAction(Op, VT) == Custom ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">       getOperationAction(Op, VT) == Promote);</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">       getOperationAction(Op, VT) == Promote);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline"></td>
    <td class="lineNumber">1251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// Return true if the operation uses custom lowering, regardless of whether</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// Return true if the operation uses custom lowering, regardless of whether</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  /// the type is legal or not.</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  /// the type is legal or not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  bool isOperationCustom(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  bool isOperationCustom(unsigned Op, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">    return getOperationAction(Op, VT) == Custom;</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">    return getOperationAction(Op, VT) == Custom;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline"></td>
    <td class="lineNumber">1257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// Return true if lowering to a jump table is allowed.</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// Return true if lowering to a jump table is allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  virtual bool areJTsAllowed(const Function *Fn) const {</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  virtual bool areJTsAllowed(const Function *Fn) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">    if (Fn->getFnAttribute("no-jump-tables").getValueAsBool())</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">    if (Fn->getFnAttribute("no-jump-tables").getValueAsBool())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">    return isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">    return isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">           isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">           isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// Check whether the range [Low,High] fits in a machine word.</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// Check whether the range [Low,High] fits in a machine word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  bool rangeFitsInWord(const APInt &Low, const APInt &High,</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  bool rangeFitsInWord(const APInt &Low, const APInt &High,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">                       const DataLayout &DL) const {</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">                       const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">    // FIXME: Using the pointer type doesn't seem ideal.</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">    // FIXME: Using the pointer type doesn't seem ideal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">    uint64_t BW = DL.getIndexSizeInBits(0u);</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">    uint64_t BW = DL.getIndexSizeInBits(0u);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">    uint64_t Range = (High - Low).getLimitedValue(UINT64_MAX - 1) + 1;</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">    uint64_t Range = (High - Low).getLimitedValue(UINT64_MAX - 1) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">    return Range <= BW;</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">    return Range <= BW;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline"></td>
    <td class="lineNumber">1275</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  /// Return true if lowering to a jump table is suitable for a set of case</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  /// Return true if lowering to a jump table is suitable for a set of case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// clusters which may contain \p NumCases cases, \p Range range of values.</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// clusters which may contain \p NumCases cases, \p Range range of values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  virtual bool isSuitableForJumpTable(const SwitchInst *SI, uint64_t NumCases,</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  virtual bool isSuitableForJumpTable(const SwitchInst *SI, uint64_t NumCases,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">                                      uint64_t Range, ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">                                      uint64_t Range, ProfileSummaryInfo *PSI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">                                      BlockFrequencyInfo *BFI) const;</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">                                      BlockFrequencyInfo *BFI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline"></td>
    <td class="lineNumber">1281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// Returns preferred type for switch condition.</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// Returns preferred type for switch condition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">  virtual MVT getPreferredSwitchConditionType(LLVMContext &Context,</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">  virtual MVT getPreferredSwitchConditionType(LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">                                              EVT ConditionVT) const;</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">                                              EVT ConditionVT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// Return true if lowering to a bit test is suitable for a set of case</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// Return true if lowering to a bit test is suitable for a set of case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// clusters which contains \p NumDests unique destinations, \p Low and</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// clusters which contains \p NumDests unique destinations, \p Low and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// \p High as its lowest and highest case values, and expects \p NumCmps</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// \p High as its lowest and highest case values, and expects \p NumCmps</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// case value comparisons. Check if the number of destinations, comparison</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// case value comparisons. Check if the number of destinations, comparison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// metric, and range are all suitable.</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// metric, and range are all suitable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">  bool isSuitableForBitTests(unsigned NumDests, unsigned NumCmps,</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">  bool isSuitableForBitTests(unsigned NumDests, unsigned NumCmps,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">                             const APInt &Low, const APInt &High,</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">                             const APInt &Low, const APInt &High,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">                             const DataLayout &DL) const {</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">                             const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">    // FIXME: I don't think NumCmps is the correct metric: a single case and a</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">    // FIXME: I don't think NumCmps is the correct metric: a single case and a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">    // range of cases both require only one branch to lower. Just looking at the</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">    // range of cases both require only one branch to lower. Just looking at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    // number of clusters and destinations should be enough to decide whether to</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    // number of clusters and destinations should be enough to decide whether to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">    // build bit tests.</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">    // build bit tests.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline"></td>
    <td class="lineNumber">1298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">    // To lower a range with bit tests, the range must fit the bitwidth of a</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">    // To lower a range with bit tests, the range must fit the bitwidth of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">    // machine word.</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">    // machine word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">    if (!rangeFitsInWord(Low, High, DL))</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">    if (!rangeFitsInWord(Low, High, DL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">    // Decide whether it's profitable to lower this range with bit tests. Each</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">    // Decide whether it's profitable to lower this range with bit tests. Each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">    // destination requires a bit test and branch, and there is an overall range</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">    // destination requires a bit test and branch, and there is an overall range</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">    // check branch. For a small number of clusters, separate comparisons might</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">    // check branch. For a small number of clusters, separate comparisons might</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">    // be cheaper, and for many destinations, splitting the range might be</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">    // be cheaper, and for many destinations, splitting the range might be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">    // better.</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">    // better.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">    return (NumDests == 1 && NumCmps >= 3) || (NumDests == 2 && NumCmps >= 5) ||</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">    return (NumDests == 1 && NumCmps >= 3) || (NumDests == 2 && NumCmps >= 5) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">           (NumDests == 3 && NumCmps >= 6);</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">           (NumDests == 3 && NumCmps >= 6);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  /// Return true if the specified operation is illegal on this target or</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  /// Return true if the specified operation is illegal on this target or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  /// unlikely to be made legal with custom lowering. This is used to help guide</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  /// unlikely to be made legal with custom lowering. This is used to help guide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  /// high-level lowering decisions.</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  /// high-level lowering decisions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  bool isOperationExpand(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  bool isOperationExpand(unsigned Op, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">    return (!isTypeLegal(VT) || getOperationAction(Op, VT) == Expand);</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">    return (!isTypeLegal(VT) || getOperationAction(Op, VT) == Expand);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target.</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// Return true if the specified operation is legal on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  bool isOperationLegal(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  bool isOperationLegal(unsigned Op, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">           getOperationAction(Op, VT) == Legal;</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">           getOperationAction(Op, VT) == Legal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">  /// Return how this load with extension should be treated: either it is legal,</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">  /// Return how this load with extension should be treated: either it is legal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  /// needs to be promoted to a larger size, needs to be expanded to some other</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  /// needs to be promoted to a larger size, needs to be expanded to some other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  /// code sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  /// code sequence, or the target has a custom expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  LegalizeAction getLoadExtAction(unsigned ExtType, EVT ValVT,</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  LegalizeAction getLoadExtAction(unsigned ExtType, EVT ValVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">                                  EVT MemVT) const {</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">                                  EVT MemVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::VALUETYPE_SIZE &&</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::VALUETYPE_SIZE &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">           MemI < MVT::VALUETYPE_SIZE && "Table isn't big enough!");</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">           MemI < MVT::VALUETYPE_SIZE && "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">    unsigned Shift = 4 * ExtType;</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">    unsigned Shift = 4 * ExtType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">    return (LegalizeAction)((LoadExtActions[ValI][MemI] >> Shift) & 0xf);</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">    return (LegalizeAction)((LoadExtActions[ValI][MemI] >> Shift) & 0xf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">  /// Return true if the specified load with extension is legal on this target.</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">  /// Return true if the specified load with extension is legal on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  bool isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  bool isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal;</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline"></td>
    <td class="lineNumber">1344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  /// Return true if the specified load with extension is legal or custom</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  /// Return true if the specified load with extension is legal or custom</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  /// on this target.</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  /// on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">  bool isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">  bool isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal ||</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">           getLoadExtAction(ExtType, ValVT, MemVT) == Custom;</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">           getLoadExtAction(ExtType, ValVT, MemVT) == Custom;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  /// Return how this store with truncation should be treated: either it is</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  /// Return how this store with truncation should be treated: either it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  /// legal, needs to be promoted to a larger size, needs to be expanded to some</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  /// legal, needs to be promoted to a larger size, needs to be expanded to some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">  /// other code sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">  /// other code sequence, or the target has a custom expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">  LegalizeAction getTruncStoreAction(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">  LegalizeAction getTruncStoreAction(EVT ValVT, EVT MemVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">    assert(ValI < MVT::VALUETYPE_SIZE && MemI < MVT::VALUETYPE_SIZE &&</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">    assert(ValI < MVT::VALUETYPE_SIZE && MemI < MVT::VALUETYPE_SIZE &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">           "Table isn't big enough!");</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">           "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">    return TruncStoreActions[ValI][MemI];</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">    return TruncStoreActions[ValI][MemI];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  /// Return true if the specified store with truncation is legal on this</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  /// Return true if the specified store with truncation is legal on this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// target.</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">  bool isTruncStoreLegal(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">  bool isTruncStoreLegal(EVT ValVT, EVT MemVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">    return isTypeLegal(ValVT) && getTruncStoreAction(ValVT, MemVT) == Legal;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">    return isTypeLegal(ValVT) && getTruncStoreAction(ValVT, MemVT) == Legal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  /// Return true if the specified store with truncation has solution on this</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  /// Return true if the specified store with truncation has solution on this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  /// target.</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  /// target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">  bool isTruncStoreLegalOrCustom(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">  bool isTruncStoreLegalOrCustom(EVT ValVT, EVT MemVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    return isTypeLegal(ValVT) &&</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    return isTypeLegal(ValVT) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">      (getTruncStoreAction(ValVT, MemVT) == Legal ||</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">      (getTruncStoreAction(ValVT, MemVT) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">       getTruncStoreAction(ValVT, MemVT) == Custom);</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">       getTruncStoreAction(ValVT, MemVT) == Custom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  virtual bool canCombineTruncStore(EVT ValVT, EVT MemVT,</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  virtual bool canCombineTruncStore(EVT ValVT, EVT MemVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">                                    bool LegalOnly) const {</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">                                    bool LegalOnly) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    if (LegalOnly)</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    if (LegalOnly)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">      return isTruncStoreLegal(ValVT, MemVT);</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">      return isTruncStoreLegal(ValVT, MemVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">    return isTruncStoreLegalOrCustom(ValVT, MemVT);</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">    return isTruncStoreLegalOrCustom(ValVT, MemVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline"></td>
    <td class="lineNumber">1385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">  /// Return how the indexed load should be treated: either it is legal, needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">  LegalizeAction getIndexedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">  LegalizeAction getIndexedLoadAction(unsigned IdxMode, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_Load);</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_Load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  bool isIndexedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  bool isIndexedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">    return VT.isSimple() &&</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">    return VT.isSimple() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">      (getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">      (getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">       getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">       getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  /// Return how the indexed store should be treated: either it is legal, needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  LegalizeAction getIndexedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  LegalizeAction getIndexedStoreAction(unsigned IdxMode, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_Store);</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_Store);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">  bool isIndexedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">  bool isIndexedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    return VT.isSimple() &&</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    return VT.isSimple() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">      (getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">      (getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">       getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">       getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">  /// Return how the indexed load should be treated: either it is legal, needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">  LegalizeAction getIndexedMaskedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">  LegalizeAction getIndexedMaskedLoadAction(unsigned IdxMode, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad);</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline"></td>
    <td class="lineNumber">1420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">  bool isIndexedMaskedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">  bool isIndexedMaskedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">    return VT.isSimple() &&</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">    return VT.isSimple() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">           (getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">           (getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">            getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">            getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline"></td>
    <td class="lineNumber">1427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  /// Return how the indexed store should be treated: either it is legal, needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">  /// sequence, or the target has a custom expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">  LegalizeAction getIndexedMaskedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">  LegalizeAction getIndexedMaskedStoreAction(unsigned IdxMode, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedStore);</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedStore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">  /// Return true if the specified indexed load is legal on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">  bool isIndexedMaskedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">  bool isIndexedMaskedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">    return VT.isSimple() &&</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">    return VT.isSimple() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">           (getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">           (getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">            getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">            getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline"></td>
    <td class="lineNumber">1441</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">  /// Returns true if the index type for a masked gather/scatter requires</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">  /// Returns true if the index type for a masked gather/scatter requires</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">  /// extending</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">  /// extending</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  virtual bool shouldExtendGSIndex(EVT VT, EVT &EltTy) const { return false; }</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  virtual bool shouldExtendGSIndex(EVT VT, EVT &EltTy) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  // Returns true if VT is a legal index type for masked gathers/scatters</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  // Returns true if VT is a legal index type for masked gathers/scatters</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">  // on this target</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">  // on this target</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">  virtual bool shouldRemoveExtendFromGSIndex(EVT IndexVT, EVT DataVT) const {</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">  virtual bool shouldRemoveExtendFromGSIndex(EVT IndexVT, EVT DataVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  // Return true if the target supports a scatter/gather instruction with</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  // Return true if the target supports a scatter/gather instruction with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">  // indices which are scaled by the particular value.  Note that all targets</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">  // indices which are scaled by the particular value.  Note that all targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">  // must by definition support scale of 1.</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">  // must by definition support scale of 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">  virtual bool isLegalScaleForGatherScatter(uint64_t Scale,</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">  virtual bool isLegalScaleForGatherScatter(uint64_t Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">                                            uint64_t ElemSize) const {</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">                                            uint64_t ElemSize) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">    // MGATHER/MSCATTER are only required to support scaling by one or by the</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">    // MGATHER/MSCATTER are only required to support scaling by one or by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    // element size.</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    // element size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">    if (Scale != ElemSize && Scale != 1)</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">    if (Scale != ElemSize && Scale != 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline"></td>
    <td class="lineNumber">1463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  /// Return how the condition code should be treated: either it is legal, needs</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  /// Return how the condition code should be treated: either it is legal, needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  /// to be expanded to some other code sequence, or the target has a custom</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  /// to be expanded to some other code sequence, or the target has a custom</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  /// expander for it.</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  /// expander for it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  LegalizeAction</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  LegalizeAction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  getCondCodeAction(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  getCondCodeAction(ISD::CondCode CC, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">    assert((unsigned)CC < std::size(CondCodeActions) &&</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">    assert((unsigned)CC < std::size(CondCodeActions) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">           ((unsigned)VT.SimpleTy >> 3) < std::size(CondCodeActions[0]) &&</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">           ((unsigned)VT.SimpleTy >> 3) < std::size(CondCodeActions[0]) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">           "Table isn't big enough!");</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">           "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">    // See setCondCodeAction for how this is encoded.</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">    // See setCondCodeAction for how this is encoded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">    uint32_t Value = CondCodeActions[CC][VT.SimpleTy >> 3];</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">    uint32_t Value = CondCodeActions[CC][VT.SimpleTy >> 3];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">    LegalizeAction Action = (LegalizeAction) ((Value >> Shift) & 0xF);</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">    LegalizeAction Action = (LegalizeAction) ((Value >> Shift) & 0xF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">    assert(Action != Promote && "Can't promote condition code!");</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">    assert(Action != Promote && "Can't promote condition code!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    return Action;</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    return Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline"></td>
    <td class="lineNumber">1479</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  /// Return true if the specified condition code is legal on this target.</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  /// Return true if the specified condition code is legal on this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">  bool isCondCodeLegal(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">  bool isCondCodeLegal(ISD::CondCode CC, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    return getCondCodeAction(CC, VT) == Legal;</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    return getCondCodeAction(CC, VT) == Legal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  /// Return true if the specified condition code is legal or custom on this</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  /// Return true if the specified condition code is legal or custom on this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  /// target.</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  /// target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  bool isCondCodeLegalOrCustom(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  bool isCondCodeLegalOrCustom(ISD::CondCode CC, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">    return getCondCodeAction(CC, VT) == Legal ||</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">    return getCondCodeAction(CC, VT) == Legal ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">           getCondCodeAction(CC, VT) == Custom;</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">           getCondCodeAction(CC, VT) == Custom;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline"></td>
    <td class="lineNumber">1491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  /// If the action for this operation is to promote, this method returns the</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  /// If the action for this operation is to promote, this method returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  /// ValueType to promote to.</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  /// ValueType to promote to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  MVT getTypeToPromoteTo(unsigned Op, MVT VT) const {</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  MVT getTypeToPromoteTo(unsigned Op, MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">    assert(getOperationAction(Op, VT) == Promote &&</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">    assert(getOperationAction(Op, VT) == Promote &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">           "This operation isn't promoted!");</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">           "This operation isn't promoted!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline"></td>
    <td class="lineNumber">1497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">    // See if this has an explicit type specified.</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">    // See if this has an explicit type specified.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">    std::map<std::pair<unsigned, MVT::SimpleValueType>,</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">    std::map<std::pair<unsigned, MVT::SimpleValueType>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">             MVT::SimpleValueType>::const_iterator PTTI =</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">             MVT::SimpleValueType>::const_iterator PTTI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">      PromoteToType.find(std::make_pair(Op, VT.SimpleTy));</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">      PromoteToType.find(std::make_pair(Op, VT.SimpleTy));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">    if (PTTI != PromoteToType.end()) return PTTI->second;</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">    if (PTTI != PromoteToType.end()) return PTTI->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline"></td>
    <td class="lineNumber">1503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">    assert((VT.isInteger() || VT.isFloatingPoint()) &&</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">    assert((VT.isInteger() || VT.isFloatingPoint()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">           "Cannot autopromote this type, add it with AddPromotedToType.");</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">           "Cannot autopromote this type, add it with AddPromotedToType.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline"></td>
    <td class="lineNumber">1506</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">    MVT NVT = VT;</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">    MVT NVT = VT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">      NVT = (MVT::SimpleValueType)(NVT.SimpleTy+1);</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">      NVT = (MVT::SimpleValueType)(NVT.SimpleTy+1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">      assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid &&</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">      assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">             "Didn't find type to promote to!");</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">             "Didn't find type to promote to!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    } while (!isTypeLegal(NVT) ||</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    } while (!isTypeLegal(NVT) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">              getOperationAction(Op, NVT) == Promote);</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">              getOperationAction(Op, NVT) == Promote);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    return NVT;</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    return NVT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline"></td>
    <td class="lineNumber">1516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">  virtual EVT getAsmOperandValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">  virtual EVT getAsmOperandValueType(const DataLayout &DL, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">                                     bool AllowUnknown = false) const {</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">                                     bool AllowUnknown = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">    return getValueType(DL, Ty, AllowUnknown);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">  /// Return the EVT corresponding to this LLVM type.  This is fixed by the LLVM</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">  /// Return the EVT corresponding to this LLVM type.  This is fixed by the LLVM</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">  /// operations except for the pointer size.  If AllowUnknown is true, this</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">  /// operations except for the pointer size.  If AllowUnknown is true, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  /// will return MVT::Other for types with no EVT counterpart (e.g. structs),</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  /// will return MVT::Other for types with no EVT counterpart (e.g. structs),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">  /// otherwise it will assert.</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">  /// otherwise it will assert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">  EVT getValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">  EVT getValueType(const DataLayout &DL, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">                   bool AllowUnknown = false) const {</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">                   bool AllowUnknown = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">    // Lower scalar pointers to native pointer types.</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">    // Lower scalar pointers to native pointer types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">      return getPointerTy(DL, PTy->getAddressSpace());</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">      return getPointerTy(DL, PTy->getAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">      Type *EltTy = VTy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">      // Lower vectors of pointers to native pointer types.</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">      // Lower vectors of pointers to native pointer types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">        EVT PointerTy(getPointerTy(DL, PTy->getAddressSpace()));</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">        EVT PointerTy(getPointerTy(DL, PTy->getAddressSpace()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">                              VTy->getElementCount());</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">                              VTy->getElementCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">    return EVT::getEVT(Ty, AllowUnknown);</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">    return EVT::getEVT(Ty, AllowUnknown);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  EVT getMemValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  EVT getMemValueType(const DataLayout &DL, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">                      bool AllowUnknown = false) const {</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">                      bool AllowUnknown = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">    // Lower scalar pointers to native pointer types.</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">    // Lower scalar pointers to native pointer types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">      return getPointerMemTy(DL, PTy->getAddressSpace());</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">      return getPointerMemTy(DL, PTy->getAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline"></td>
    <td class="lineNumber">1551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">      Type *EltTy = VTy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">        EVT PointerTy(getPointerMemTy(DL, PTy->getAddressSpace()));</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">        EVT PointerTy(getPointerMemTy(DL, PTy->getAddressSpace()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">                              VTy->getElementCount());</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">                              VTy->getElementCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline"></td>
    <td class="lineNumber">1561</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">    return getValueType(DL, Ty, AllowUnknown);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline"></td>
    <td class="lineNumber">1565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">  /// Return the MVT corresponding to this LLVM type. See getValueType.</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">  /// Return the MVT corresponding to this LLVM type. See getValueType.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">  MVT getSimpleValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">  MVT getSimpleValueType(const DataLayout &DL, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">                         bool AllowUnknown = false) const {</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">                         bool AllowUnknown = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">    return getValueType(DL, Ty, AllowUnknown).getSimpleVT();</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">    return getValueType(DL, Ty, AllowUnknown).getSimpleVT();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">  /// Return the desired alignment for ByVal or InAlloca aggregate function</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">  /// Return the desired alignment for ByVal or InAlloca aggregate function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">  /// arguments in the caller parameter area.  This is the actual alignment, not</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">  /// arguments in the caller parameter area.  This is the actual alignment, not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">  /// its logarithm.</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">  /// its logarithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">  virtual uint64_t getByValTypeAlignment(Type *Ty, const DataLayout &DL) const;</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">  virtual uint64_t getByValTypeAlignment(Type *Ty, const DataLayout &DL) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline"></td>
    <td class="lineNumber">1576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">  /// Return the type of registers that this ValueType will eventually require.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">  MVT getRegisterType(MVT VT) const {</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">  MVT getRegisterType(MVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">    assert((unsigned)VT.SimpleTy < std::size(RegisterTypeForVT));</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">    assert((unsigned)VT.SimpleTy < std::size(RegisterTypeForVT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    return RegisterTypeForVT[VT.SimpleTy];</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    return RegisterTypeForVT[VT.SimpleTy];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">  /// Return the type of registers that this ValueType will eventually require.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">  MVT getRegisterType(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">  MVT getRegisterType(LLVMContext &Context, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">    if (VT.isSimple())</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">    if (VT.isSimple())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">      return getRegisterType(VT.getSimpleVT());</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">      return getRegisterType(VT.getSimpleVT());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">    if (VT.isVector()) {</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">    if (VT.isVector()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">      EVT VT1;</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">      EVT VT1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">      MVT RegisterVT;</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">      MVT RegisterVT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">      unsigned NumIntermediates;</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">      unsigned NumIntermediates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">      (void)getVectorTypeBreakdown(Context, VT, VT1,</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">      (void)getVectorTypeBreakdown(Context, VT, VT1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">                                   NumIntermediates, RegisterVT);</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">                                   NumIntermediates, RegisterVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">      return RegisterVT;</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">      return RegisterVT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">    if (VT.isInteger()) {</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">    if (VT.isInteger()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">      return getRegisterType(Context, getTypeToTransformTo(Context, VT));</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">      return getRegisterType(Context, getTypeToTransformTo(Context, VT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">    llvm_unreachable("Unsupported extended type!");</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">    llvm_unreachable("Unsupported extended type!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">  /// Return the number of registers that this ValueType will eventually</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">  /// Return the number of registers that this ValueType will eventually</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// require.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// require.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">  /// This is one for any types promoted to live in larger registers, but may be</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">  /// This is one for any types promoted to live in larger registers, but may be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">  /// more than one for types (like i64) that are split into pieces.  For types</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">  /// more than one for types (like i64) that are split into pieces.  For types</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">  /// like i140, which are first promoted then expanded, it is the number of</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">  /// like i140, which are first promoted then expanded, it is the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">  /// registers needed to hold all the bits of the original type.  For an i140</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">  /// registers needed to hold all the bits of the original type.  For an i140</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">  /// on a 32 bit machine this means 5 registers.</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">  /// on a 32 bit machine this means 5 registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">  /// RegisterVT may be passed as a way to override the default settings, for</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">  /// RegisterVT may be passed as a way to override the default settings, for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">  /// instance with i128 inline assembly operands on SystemZ.</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">  /// instance with i128 inline assembly operands on SystemZ.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">  virtual unsigned</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">  virtual unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">  getNumRegisters(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">  getNumRegisters(LLVMContext &Context, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">                  std::optional<MVT> RegisterVT = std::nullopt) const {</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">                  std::optional<MVT> RegisterVT = std::nullopt) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">    if (VT.isSimple()) {</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">    if (VT.isSimple()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">      assert((unsigned)VT.getSimpleVT().SimpleTy <</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">      assert((unsigned)VT.getSimpleVT().SimpleTy <</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">             std::size(NumRegistersForVT));</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">             std::size(NumRegistersForVT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">      return NumRegistersForVT[VT.getSimpleVT().SimpleTy];</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">      return NumRegistersForVT[VT.getSimpleVT().SimpleTy];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">    if (VT.isVector()) {</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">    if (VT.isVector()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">      EVT VT1;</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">      EVT VT1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">      MVT VT2;</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">      MVT VT2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">      unsigned NumIntermediates;</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">      unsigned NumIntermediates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">      return getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2);</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">      return getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">    if (VT.isInteger()) {</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">    if (VT.isInteger()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">      unsigned BitWidth = VT.getSizeInBits();</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">      unsigned BitWidth = VT.getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">      unsigned RegWidth = getRegisterType(Context, VT).getSizeInBits();</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">      unsigned RegWidth = getRegisterType(Context, VT).getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">      return (BitWidth + RegWidth - 1) / RegWidth;</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">      return (BitWidth + RegWidth - 1) / RegWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">    llvm_unreachable("Unsupported extended type!");</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">    llvm_unreachable("Unsupported extended type!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline"></td>
    <td class="lineNumber">1633</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">  /// Certain combinations of ABIs, Targets and features require that types</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">  /// Certain combinations of ABIs, Targets and features require that types</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">  /// are legal for some operations and not for other operations.</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">  /// are legal for some operations and not for other operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">  /// For MIPS all vector types must be passed through the integer register set.</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">  /// For MIPS all vector types must be passed through the integer register set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">  virtual MVT getRegisterTypeForCallingConv(LLVMContext &Context,</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">  virtual MVT getRegisterTypeForCallingConv(LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">                                            CallingConv::ID CC, EVT VT) const {</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">                                            CallingConv::ID CC, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">    return getRegisterType(Context, VT);</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">    return getRegisterType(Context, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline"></td>
    <td class="lineNumber">1641</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">  /// Certain targets require unusual breakdowns of certain types. For MIPS,</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">  /// Certain targets require unusual breakdowns of certain types. For MIPS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">  /// this occurs when a vector type is used, as vector are passed through the</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">  /// this occurs when a vector type is used, as vector are passed through the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">  /// integer register set.</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">  /// integer register set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">  virtual unsigned getNumRegistersForCallingConv(LLVMContext &Context,</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">  virtual unsigned getNumRegistersForCallingConv(LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">                                                 CallingConv::ID CC,</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">                                                 CallingConv::ID CC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">                                                 EVT VT) const {</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">                                                 EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">    return getNumRegisters(Context, VT);</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">    return getNumRegisters(Context, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline"></td>
    <td class="lineNumber">1650</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">  /// Certain targets have context sensitive alignment requirements, where one</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">  /// Certain targets have context sensitive alignment requirements, where one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">  /// type has the alignment requirement of another type.</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">  /// type has the alignment requirement of another type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  virtual Align getABIAlignmentForCallingConv(Type *ArgTy,</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  virtual Align getABIAlignmentForCallingConv(Type *ArgTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">                                              const DataLayout &DL) const {</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">                                              const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">    return DL.getABITypeAlign(ArgTy);</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">    return DL.getABITypeAlign(ArgTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">  /// If true, then instruction selection should seek to shrink the FP constant</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">  /// If true, then instruction selection should seek to shrink the FP constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">  /// of the specified type to a smaller type in order to save space and / or</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">  /// of the specified type to a smaller type in order to save space and / or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">  /// reduce runtime.</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">  /// reduce runtime.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">  virtual bool ShouldShrinkFPConstant(EVT) const { return true; }</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">  virtual bool ShouldShrinkFPConstant(EVT) const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline"></td>
    <td class="lineNumber">1662</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  /// Return true if it is profitable to reduce a load to a smaller type.</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  /// Return true if it is profitable to reduce a load to a smaller type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">  /// Example: (i16 (trunc (i32 (load x))) -> i16 load x</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">  /// Example: (i16 (trunc (i32 (load x))) -> i16 load x</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  virtual bool shouldReduceLoadWidth(SDNode *Load, ISD::LoadExtType ExtTy,</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  virtual bool shouldReduceLoadWidth(SDNode *Load, ISD::LoadExtType ExtTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">                                     EVT NewVT) const {</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">                                     EVT NewVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">    // By default, assume that it is cheaper to extract a subvector from a wide</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">    // By default, assume that it is cheaper to extract a subvector from a wide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">    // vector load rather than creating multiple narrow vector loads.</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">    // vector load rather than creating multiple narrow vector loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">    if (NewVT.isVector() && !Load->hasOneUse())</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">    if (NewVT.isVector() && !Load->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline"></td>
    <td class="lineNumber">1674</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">  /// Return true (the default) if it is profitable to remove a sext_inreg(x)</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">  /// Return true (the default) if it is profitable to remove a sext_inreg(x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">  /// where the sext is redundant, and use x directly.</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">  /// where the sext is redundant, and use x directly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  virtual bool shouldRemoveRedundantExtend(SDValue Op) const { return true; }</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  virtual bool shouldRemoveRedundantExtend(SDValue Op) const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// When splitting a value of the specified type into parts, does the Lo</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// When splitting a value of the specified type into parts, does the Lo</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// or Hi part come first?  This usually follows the endianness, except</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// or Hi part come first?  This usually follows the endianness, except</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">  /// for ppcf128, where the Hi part always comes first.</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">  /// for ppcf128, where the Hi part always comes first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  bool hasBigEndianPartOrdering(EVT VT, const DataLayout &DL) const {</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  bool hasBigEndianPartOrdering(EVT VT, const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">    return DL.isBigEndian() || VT == MVT::ppcf128;</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">    return DL.isBigEndian() || VT == MVT::ppcf128;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline"></td>
    <td class="lineNumber">1685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">  /// If true, the target has custom DAG combine transformations that it can</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">  /// If true, the target has custom DAG combine transformations that it can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  /// perform for the specified node.</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  /// perform for the specified node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">  bool hasTargetDAGCombine(ISD::NodeType NT) const {</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">  bool hasTargetDAGCombine(ISD::NodeType NT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">    assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">    assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">    return TargetDAGCombineArray[NT >> 3] & (1 << (NT&7));</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">    return TargetDAGCombineArray[NT >> 3] & (1 << (NT&7));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline"></td>
    <td class="lineNumber">1692</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">  unsigned getGatherAllAliasesMaxDepth() const {</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">  unsigned getGatherAllAliasesMaxDepth() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">    return GatherAllAliasesMaxDepth;</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">    return GatherAllAliasesMaxDepth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  /// Returns the size of the platform's va_list object.</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  /// Returns the size of the platform's va_list object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">  virtual unsigned getVaListSizeInBits(const DataLayout &DL) const {</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">  virtual unsigned getVaListSizeInBits(const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">    return getPointerTy(DL).getSizeInBits();</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">    return getPointerTy(DL).getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">  /// Get maximum # of store operations permitted for llvm.memset</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">  /// Get maximum # of store operations permitted for llvm.memset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">  /// to replace a call to llvm.memset. The value is set by the target at the</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">  /// to replace a call to llvm.memset. The value is set by the target at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">  unsigned getMaxStoresPerMemset(bool OptSize) const {</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">  unsigned getMaxStoresPerMemset(bool OptSize) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">    return OptSize ? MaxStoresPerMemsetOptSize : MaxStoresPerMemset;</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">    return OptSize ? MaxStoresPerMemsetOptSize : MaxStoresPerMemset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  /// Get maximum # of store operations permitted for llvm.memcpy</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  /// Get maximum # of store operations permitted for llvm.memcpy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">  /// to replace a call to llvm.memcpy. The value is set by the target at the</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">  /// to replace a call to llvm.memcpy. The value is set by the target at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  unsigned getMaxStoresPerMemcpy(bool OptSize) const {</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  unsigned getMaxStoresPerMemcpy(bool OptSize) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">    return OptSize ? MaxStoresPerMemcpyOptSize : MaxStoresPerMemcpy;</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">    return OptSize ? MaxStoresPerMemcpyOptSize : MaxStoresPerMemcpy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  /// \brief Get maximum # of store operations to be glued together</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  /// \brief Get maximum # of store operations to be glued together</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">  /// to glue together during lowering of llvm.memcpy. The value is set by</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">  /// to glue together during lowering of llvm.memcpy. The value is set by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">  //  the target at the performance threshold for such a replacement.</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">  //  the target at the performance threshold for such a replacement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  virtual unsigned getMaxGluedStoresPerMemcpy() const {</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  virtual unsigned getMaxGluedStoresPerMemcpy() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">    return MaxGluedStoresPerMemcpy;</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">    return MaxGluedStoresPerMemcpy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline"></td>
    <td class="lineNumber">1730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">  /// Get maximum # of load operations permitted for memcmp</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">  /// Get maximum # of load operations permitted for memcmp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">  /// This function returns the maximum number of load operations permitted</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">  /// This function returns the maximum number of load operations permitted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">  /// to replace a call to memcmp. The value is set by the target at the</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">  /// to replace a call to memcmp. The value is set by the target at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">  unsigned getMaxExpandSizeMemcmp(bool OptSize) const {</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">  unsigned getMaxExpandSizeMemcmp(bool OptSize) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">    return OptSize ? MaxLoadsPerMemcmpOptSize : MaxLoadsPerMemcmp;</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">    return OptSize ? MaxLoadsPerMemcmpOptSize : MaxLoadsPerMemcmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">  /// Get maximum # of store operations permitted for llvm.memmove</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">  /// Get maximum # of store operations permitted for llvm.memmove</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">  /// This function returns the maximum number of store operations permitted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">  /// to replace a call to llvm.memmove. The value is set by the target at the</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">  /// to replace a call to llvm.memmove. The value is set by the target at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">  /// performance threshold for such a replacement. If OptSize is true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">  /// return the limit for functions that have OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">  unsigned getMaxStoresPerMemmove(bool OptSize) const {</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">  unsigned getMaxStoresPerMemmove(bool OptSize) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">    return OptSize ? MaxStoresPerMemmoveOptSize : MaxStoresPerMemmove;</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">    return OptSize ? MaxStoresPerMemmoveOptSize : MaxStoresPerMemmove;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline"></td>
    <td class="lineNumber">1750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">  /// Determine if the target supports unaligned memory accesses.</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">  /// Determine if the target supports unaligned memory accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">  /// This function returns true if the target allows unaligned memory accesses</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">  /// This function returns true if the target allows unaligned memory accesses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">  /// of the specified type in the given address space. If true, it also returns</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">  /// of the specified type in the given address space. If true, it also returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">  /// a relative speed of the unaligned memory access in the last argument by</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">  /// a relative speed of the unaligned memory access in the last argument by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">  /// reference. The higher the speed number the faster the operation comparing</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">  /// reference. The higher the speed number the faster the operation comparing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">  /// to a number returned by another such call. This is used, for example, in</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">  /// to a number returned by another such call. This is used, for example, in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">  /// situations where an array copy/move/set is converted to a sequence of</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">  /// situations where an array copy/move/set is converted to a sequence of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">  /// store operations. Its use helps to ensure that such replacements don't</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">  /// store operations. Its use helps to ensure that such replacements don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">  /// generate code that causes an alignment error (trap) on the target machine.</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">  /// generate code that causes an alignment error (trap) on the target machine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">  virtual bool allowsMisalignedMemoryAccesses(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">      EVT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">      EVT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">      unsigned * /*Fast*/ = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">  /// LLT handling variant.</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">  /// LLT handling variant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">  virtual bool allowsMisalignedMemoryAccesses(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">      LLT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">      LLT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">      unsigned * /*Fast*/ = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline"></td>
    <td class="lineNumber">1775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">  /// This function returns true if the memory access is aligned or if the</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">  /// This function returns true if the memory access is aligned or if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  /// target allows this specific unaligned memory access. If the access is</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  /// target allows this specific unaligned memory access. If the access is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">  /// allowed, the optional final parameter returns a relative speed of the</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">  /// allowed, the optional final parameter returns a relative speed of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  /// access (as defined by the target).</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  /// access (as defined by the target).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  bool allowsMemoryAccessForAlignment(</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  bool allowsMemoryAccessForAlignment(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">      LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">      LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">      unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">      unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">      unsigned *Fast = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline"></td>
    <td class="lineNumber">1785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  /// Return true if the memory access of this type is aligned or if the target</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  /// Return true if the memory access of this type is aligned or if the target</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">  /// allows this specific unaligned access for the given MachineMemOperand.</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">  /// allows this specific unaligned access for the given MachineMemOperand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  /// If the access is allowed, the optional final parameter returns a relative</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  /// If the access is allowed, the optional final parameter returns a relative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">  /// speed of the access (as defined by the target).</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">  /// speed of the access (as defined by the target).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  bool allowsMemoryAccessForAlignment(LLVMContext &Context,</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  bool allowsMemoryAccessForAlignment(LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">                                      const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">                                      const DataLayout &DL, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">                                      const MachineMemOperand &MMO,</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">                                      const MachineMemOperand &MMO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">                                      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">                                      unsigned *Fast = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline"></td>
    <td class="lineNumber">1794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  /// Return true if the target supports a memory access of this type for the</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  /// Return true if the target supports a memory access of this type for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  /// given address space and alignment. If the access is allowed, the optional</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  /// given address space and alignment. If the access is allowed, the optional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  /// final parameter returns the relative speed of the access (as defined by</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  /// final parameter returns the relative speed of the access (as defined by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  /// the target).</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  /// the target).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">                     unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">                     unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">                     MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">                     MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">                     unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">                     unsigned *Fast = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline"></td>
    <td class="lineNumber">1804</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  /// Return true if the target supports a memory access of this type for the</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  /// Return true if the target supports a memory access of this type for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">  /// given MachineMemOperand. If the access is allowed, the optional</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">  /// given MachineMemOperand. If the access is allowed, the optional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  /// final parameter returns the relative access speed (as defined by the</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  /// final parameter returns the relative access speed (as defined by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">  /// target).</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">  /// target).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">                          const MachineMemOperand &MMO,</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">                          const MachineMemOperand &MMO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">                          unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">                          unsigned *Fast = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline"></td>
    <td class="lineNumber">1812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  /// LLT handling variant.</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  /// LLT handling variant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, LLT Ty,</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, LLT Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">                          const MachineMemOperand &MMO,</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">                          const MachineMemOperand &MMO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">                          unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">                          unsigned *Fast = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline"></td>
    <td class="lineNumber">1817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">  /// Returns the target specific optimal type for load and store operations as</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">  /// Returns the target specific optimal type for load and store operations as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">  /// a result of memset, memcpy, and memmove lowering.</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">  /// a result of memset, memcpy, and memmove lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">  /// It returns EVT::Other if the type should be determined using generic</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">  /// It returns EVT::Other if the type should be determined using generic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">  /// target-independent logic.</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">  /// target-independent logic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">  virtual EVT</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">  virtual EVT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  getOptimalMemOpType(const MemOp &Op,</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  getOptimalMemOpType(const MemOp &Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">                      const AttributeList & /*FuncAttributes*/) const {</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">                      const AttributeList & /*FuncAttributes*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">    return MVT::Other;</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">    return MVT::Other;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline"></td>
    <td class="lineNumber">1827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">  /// LLT returning variant.</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">  /// LLT returning variant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">  virtual LLT</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">  virtual LLT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">  getOptimalMemOpLLT(const MemOp &Op,</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">  getOptimalMemOpLLT(const MemOp &Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">                     const AttributeList & /*FuncAttributes*/) const {</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">                     const AttributeList & /*FuncAttributes*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">    return LLT();</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">    return LLT();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">  /// Returns true if it's safe to use load / store of the specified type to</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">  /// Returns true if it's safe to use load / store of the specified type to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">  /// expand memcpy / memset inline.</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">  /// expand memcpy / memset inline.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  /// This is mostly true for all types except for some special cases. For</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  /// This is mostly true for all types except for some special cases. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">  /// example, on X86 targets without SSE2 f64 load / store are done with fldl /</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">  /// example, on X86 targets without SSE2 f64 load / store are done with fldl /</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  /// fstpl which also does type conversion. Note the specified type doesn't</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  /// fstpl which also does type conversion. Note the specified type doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">  /// have to be legal as the hook is used before type legalization.</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">  /// have to be legal as the hook is used before type legalization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">  virtual bool isSafeMemOpType(MVT /*VT*/) const { return true; }</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">  virtual bool isSafeMemOpType(MVT /*VT*/) const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline"></td>
    <td class="lineNumber">1843</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">  /// Return lower limit for number of blocks in a jump table.</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">  /// Return lower limit for number of blocks in a jump table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">  virtual unsigned getMinimumJumpTableEntries() const;</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">  virtual unsigned getMinimumJumpTableEntries() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline"></td>
    <td class="lineNumber">1846</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">  /// Return lower limit of the density in a jump table.</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">  /// Return lower limit of the density in a jump table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">  unsigned getMinimumJumpTableDensity(bool OptForSize) const;</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">  unsigned getMinimumJumpTableDensity(bool OptForSize) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline"></td>
    <td class="lineNumber">1849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  /// Return upper limit for number of entries in a jump table.</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  /// Return upper limit for number of entries in a jump table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">  /// Zero if no limit.</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">  /// Zero if no limit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  unsigned getMaximumJumpTableSize() const;</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  unsigned getMaximumJumpTableSize() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline"></td>
    <td class="lineNumber">1853</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">  virtual bool isJumpTableRelative() const;</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">  virtual bool isJumpTableRelative() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline"></td>
    <td class="lineNumber">1855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  /// If a physical register, this specifies the register that</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  /// If a physical register, this specifies the register that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine diffFirst">  Register getStackPointerRegisterToSaveRestore() const {</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  Register getStackPointerRegisterToSaveRestore() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine diffFirst">    return StackPointerRegisterToSaveRestore;</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">    return StackPointerRegisterToSaveRestore;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// If a physical register, this returns the register that receives the</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// If a physical register, this returns the register that receives the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  /// exception address on entry to an EH pad.</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  /// exception address on entry to an EH pad.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  virtual Register</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  virtual Register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">  getExceptionPointerRegister(const Constant *PersonalityFn) const {</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">  getExceptionPointerRegister(const Constant *PersonalityFn) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">    return Register();</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">    return Register();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline"></td>
    <td class="lineNumber">1868</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">  /// If a physical register, this returns the register that receives the</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">  /// If a physical register, this returns the register that receives the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">  /// exception typeid on entry to a landing pad.</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">  /// exception typeid on entry to a landing pad.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">  virtual Register</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">  virtual Register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  getExceptionSelectorRegister(const Constant *PersonalityFn) const {</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  getExceptionSelectorRegister(const Constant *PersonalityFn) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">    return Register();</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">    return Register();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">  virtual bool needsFixedCatchObjects() const {</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">  virtual bool needsFixedCatchObjects() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">    report_fatal_error("Funclet EH is not implemented for this target");</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">    report_fatal_error("Funclet EH is not implemented for this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline"></td>
    <td class="lineNumber">1879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">  /// Return the minimum stack alignment of an argument.</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">  /// Return the minimum stack alignment of an argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  Align getMinStackArgumentAlignment() const {</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  Align getMinStackArgumentAlignment() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">    return MinStackArgumentAlignment;</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">    return MinStackArgumentAlignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline"></td>
    <td class="lineNumber">1884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// Return the minimum function alignment.</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// Return the minimum function alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">  Align getMinFunctionAlignment() const { return MinFunctionAlignment; }</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">  Align getMinFunctionAlignment() const { return MinFunctionAlignment; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// Return the preferred function alignment.</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// Return the preferred function alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">  Align getPrefFunctionAlignment() const { return PrefFunctionAlignment; }</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">  Align getPrefFunctionAlignment() const { return PrefFunctionAlignment; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">  /// Return the preferred loop alignment.</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">  /// Return the preferred loop alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  virtual Align getPrefLoopAlignment(MachineLoop *ML = nullptr) const;</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  virtual Align getPrefLoopAlignment(MachineLoop *ML = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline"></td>
    <td class="lineNumber">1893</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">  /// Return the maximum amount of bytes allowed to be emitted when padding for</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">  /// Return the maximum amount of bytes allowed to be emitted when padding for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  /// alignment</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  /// alignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">  virtual unsigned</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">  virtual unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">  getMaxPermittedBytesForAlignment(MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">  getMaxPermittedBytesForAlignment(MachineBasicBlock *MBB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline"></td>
    <td class="lineNumber">1898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">  /// Should loops be aligned even when the function is marked OptSize (but not</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">  /// Should loops be aligned even when the function is marked OptSize (but not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">  /// MinSize).</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">  /// MinSize).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">  virtual bool alignLoopsWithOptSize() const { return false; }</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">  virtual bool alignLoopsWithOptSize() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline"></td>
    <td class="lineNumber">1902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">  /// If the target has a standard location for the stack protector guard,</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">  /// If the target has a standard location for the stack protector guard,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">  /// returns the address of that location. Otherwise, returns nullptr.</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">  /// returns the address of that location. Otherwise, returns nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">  /// DEPRECATED: please override useLoadStackGuardNode and customize</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">  /// DEPRECATED: please override useLoadStackGuardNode and customize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">  ///             LOAD_STACK_GUARD, or customize \@llvm.stackguard().</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">  ///             LOAD_STACK_GUARD, or customize \@llvm.stackguard().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">  virtual Value *getIRStackGuard(IRBuilderBase &IRB) const;</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">  virtual Value *getIRStackGuard(IRBuilderBase &IRB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline"></td>
    <td class="lineNumber">1908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  /// Inserts necessary declarations for SSP (stack protection) purpose.</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  /// Inserts necessary declarations for SSP (stack protection) purpose.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">  /// Should be used only when getIRStackGuard returns nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">  virtual void insertSSPDeclarations(Module &M) const;</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">  virtual void insertSSPDeclarations(Module &M) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  /// Return the variable that's previously inserted by insertSSPDeclarations,</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  /// Return the variable that's previously inserted by insertSSPDeclarations,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  /// if any, otherwise return nullptr. Should be used only when</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  /// if any, otherwise return nullptr. Should be used only when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  /// getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  /// getIRStackGuard returns nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">  virtual Value *getSDagStackGuard(const Module &M) const;</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">  virtual Value *getSDagStackGuard(const Module &M) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline"></td>
    <td class="lineNumber">1917</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">  /// If this function returns true, stack protection checks should XOR the</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">  /// If this function returns true, stack protection checks should XOR the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">  /// frame pointer (or whichever pointer is used to address locals) into the</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">  /// frame pointer (or whichever pointer is used to address locals) into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">  /// stack guard value before checking it. getIRStackGuard must return nullptr</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">  /// stack guard value before checking it. getIRStackGuard must return nullptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">  /// if this returns true.</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">  /// if this returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">  virtual bool useStackGuardXorFP() const { return false; }</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">  virtual bool useStackGuardXorFP() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  /// If the target has a standard stack protection check function that</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  /// If the target has a standard stack protection check function that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">  /// performs validation and error handling, returns the function. Otherwise,</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">  /// performs validation and error handling, returns the function. Otherwise,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">  /// returns nullptr. Must be previously inserted by insertSSPDeclarations.</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">  /// returns nullptr. Must be previously inserted by insertSSPDeclarations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">  /// Should be used only when getIRStackGuard returns nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">  virtual Function *getSSPStackGuardCheck(const Module &M) const;</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">  virtual Function *getSSPStackGuardCheck(const Module &M) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline"></td>
    <td class="lineNumber">1929</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  /// \returns true if a constant G_UBFX is legal on the target.</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  /// \returns true if a constant G_UBFX is legal on the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  virtual bool isConstantUnsignedBitfieldExtractLegal(unsigned Opc, LLT Ty1,</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  virtual bool isConstantUnsignedBitfieldExtractLegal(unsigned Opc, LLT Ty1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">                                                      LLT Ty2) const {</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">                                                      LLT Ty2) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline"></td>
    <td class="lineNumber">1935</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  Value *getDefaultSafeStackPointerLocation(IRBuilderBase &IRB,</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  Value *getDefaultSafeStackPointerLocation(IRBuilderBase &IRB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">                                            bool UseTLS) const;</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">                                            bool UseTLS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline"></td>
    <td class="lineNumber">1939</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">  /// Returns the target-specific address of the unsafe stack pointer.</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">  /// Returns the target-specific address of the unsafe stack pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  virtual Value *getSafeStackPointerLocation(IRBuilderBase &IRB) const;</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  virtual Value *getSafeStackPointerLocation(IRBuilderBase &IRB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline"></td>
    <td class="lineNumber">1943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">  /// Returns the name of the symbol used to emit stack probes or the empty</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">  /// Returns the name of the symbol used to emit stack probes or the empty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  /// string if not applicable.</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  /// string if not applicable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">  virtual bool hasStackProbeSymbol(const MachineFunction &MF) const { return false; }</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">  virtual bool hasStackProbeSymbol(const MachineFunction &MF) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  virtual bool hasInlineStackProbe(const MachineFunction &MF) const { return false; }</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  virtual bool hasInlineStackProbe(const MachineFunction &MF) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline"></td>
    <td class="lineNumber">1949</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">  virtual StringRef getStackProbeSymbolName(const MachineFunction &MF) const {</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">  virtual StringRef getStackProbeSymbolName(const MachineFunction &MF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">    return "";</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">    return "";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">  /// Returns true if a cast from SrcAS to DestAS is "cheap", such that e.g. we</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">  /// Returns true if a cast from SrcAS to DestAS is "cheap", such that e.g. we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">  /// are happy to sink it into basic blocks. A cast may be free, but not</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">  /// are happy to sink it into basic blocks. A cast may be free, but not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">  /// necessarily a no-op. e.g. a free truncate from a 64-bit to 32-bit pointer.</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">  /// necessarily a no-op. e.g. a free truncate from a 64-bit to 32-bit pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  virtual bool isFreeAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const;</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  virtual bool isFreeAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline"></td>
    <td class="lineNumber">1958</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  /// Return true if the pointer arguments to CI should be aligned by aligning</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  /// Return true if the pointer arguments to CI should be aligned by aligning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  /// the object whose address is being passed. If so then MinSize is set to the</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  /// the object whose address is being passed. If so then MinSize is set to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  /// minimum size the object must be to be aligned and PrefAlign is set to the</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  /// minimum size the object must be to be aligned and PrefAlign is set to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  /// preferred alignment.</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  /// preferred alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  virtual bool shouldAlignPointerArgs(CallInst * /*CI*/, unsigned & /*MinSize*/,</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  virtual bool shouldAlignPointerArgs(CallInst * /*CI*/, unsigned & /*MinSize*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">                                      Align & /*PrefAlign*/) const {</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">                                      Align & /*PrefAlign*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline"></td>
    <td class="lineNumber">1967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">  /// \name Helpers for TargetTransformInfo implementations</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">  /// \name Helpers for TargetTransformInfo implementations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline"></td>
    <td class="lineNumber">1971</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">  /// Get the ISD node that corresponds to the Instruction class opcode.</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">  /// Get the ISD node that corresponds to the Instruction class opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">  int InstructionOpcodeToISD(unsigned Opcode) const;</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">  int InstructionOpcodeToISD(unsigned Opcode) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline"></td>
    <td class="lineNumber">1974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline"></td>
    <td class="lineNumber">1976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  /// \name Helpers for atomic expansion.</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  /// \name Helpers for atomic expansion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline"></td>
    <td class="lineNumber">1980</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">  /// Returns the maximum atomic operation size (in bits) supported by</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">  /// Returns the maximum atomic operation size (in bits) supported by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">  /// the backend. Atomic operations greater than this size (as well</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">  /// the backend. Atomic operations greater than this size (as well</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">  /// as ones that are not naturally aligned), will be expanded by</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">  /// as ones that are not naturally aligned), will be expanded by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  /// AtomicExpandPass into an __atomic_* library call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  unsigned getMaxAtomicSizeInBitsSupported() const {</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  unsigned getMaxAtomicSizeInBitsSupported() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">    return MaxAtomicSizeInBitsSupported;</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">    return MaxAtomicSizeInBitsSupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline"></td>
    <td class="lineNumber">1988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">  /// Returns the size in bits of the maximum div/rem the backend supports.</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">  /// Returns the size in bits of the maximum div/rem the backend supports.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">  unsigned getMaxDivRemBitWidthSupported() const {</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">  unsigned getMaxDivRemBitWidthSupported() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">    return MaxDivRemBitWidthSupported;</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">    return MaxDivRemBitWidthSupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline"></td>
    <td class="lineNumber">1994</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">  /// Returns the size in bits of the maximum larget fp convert the backend</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">  /// Returns the size in bits of the maximum larget fp convert the backend</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">  unsigned getMaxLargeFPConvertBitWidthSupported() const {</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">  unsigned getMaxLargeFPConvertBitWidthSupported() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">    return MaxLargeFPConvertBitWidthSupported;</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">    return MaxLargeFPConvertBitWidthSupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline"></td>
    <td class="lineNumber">2000</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">  /// Returns the size of the smallest cmpxchg or ll/sc instruction</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">  /// Returns the size of the smallest cmpxchg or ll/sc instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">  /// the backend supports.  Any smaller operations are widened in</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">  /// the backend supports.  Any smaller operations are widened in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">  /// AtomicExpandPass.</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">  /// AtomicExpandPass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">  /// Note that *unlike* operations above the maximum size, atomic ops</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">  /// Note that *unlike* operations above the maximum size, atomic ops</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">  /// are still natively supported below the minimum; they just</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">  /// are still natively supported below the minimum; they just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">  /// require a more complex expansion.</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">  /// require a more complex expansion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">  unsigned getMinCmpXchgSizeInBits() const { return MinCmpXchgSizeInBits; }</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">  unsigned getMinCmpXchgSizeInBits() const { return MinCmpXchgSizeInBits; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">  /// Whether the target supports unaligned atomic operations.</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">  /// Whether the target supports unaligned atomic operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">  bool supportsUnalignedAtomics() const { return SupportsUnalignedAtomics; }</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">  bool supportsUnalignedAtomics() const { return SupportsUnalignedAtomics; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline"></td>
    <td class="lineNumber">2012</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">  /// Whether AtomicExpandPass should automatically insert fences and reduce</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">  /// Whether AtomicExpandPass should automatically insert fences and reduce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  /// ordering for this atomic. This should be true for most architectures with</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  /// ordering for this atomic. This should be true for most architectures with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  /// weak memory ordering. Defaults to false.</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  /// weak memory ordering. Defaults to false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">  virtual bool shouldInsertFencesForAtomic(const Instruction *I) const {</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">  virtual bool shouldInsertFencesForAtomic(const Instruction *I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline"></td>
    <td class="lineNumber">2019</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">  /// Whether AtomicExpandPass should automatically insert a trailing fence</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">  /// Whether AtomicExpandPass should automatically insert a trailing fence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">  /// without reducing the ordering for this atomic. Defaults to false.</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">  /// without reducing the ordering for this atomic. Defaults to false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  shouldInsertTrailingFenceForAtomicStore(const Instruction *I) const {</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  shouldInsertTrailingFenceForAtomicStore(const Instruction *I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">  /// Perform a load-linked operation on Addr, returning a "Value *" with the</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">  /// Perform a load-linked operation on Addr, returning a "Value *" with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  /// corresponding pointee type. This may entail some non-trivial operations to</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  /// corresponding pointee type. This may entail some non-trivial operations to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">  /// truncate or reconstruct types that will be illegal in the backend. See</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">  /// truncate or reconstruct types that will be illegal in the backend. See</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">  /// ARMISelLowering for an example implementation.</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">  /// ARMISelLowering for an example implementation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">  virtual Value *emitLoadLinked(IRBuilderBase &Builder, Type *ValueTy,</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">  virtual Value *emitLoadLinked(IRBuilderBase &Builder, Type *ValueTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">                                Value *Addr, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">                                Value *Addr, AtomicOrdering Ord) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">    llvm_unreachable("Load linked unimplemented on this target");</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">    llvm_unreachable("Load linked unimplemented on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  /// Perform a store-conditional operation to Addr. Return the status of the</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  /// Perform a store-conditional operation to Addr. Return the status of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  /// store. This should be 0 if the store succeeded, non-zero otherwise.</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  /// store. This should be 0 if the store succeeded, non-zero otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">  virtual Value *emitStoreConditional(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">  virtual Value *emitStoreConditional(IRBuilderBase &Builder, Value *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">                                      Value *Addr, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">                                      Value *Addr, AtomicOrdering Ord) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">    llvm_unreachable("Store conditional unimplemented on this target");</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">    llvm_unreachable("Store conditional unimplemented on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline"></td>
    <td class="lineNumber">2042</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">  /// Perform a masked atomicrmw using a target-specific intrinsic. This</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">  /// Perform a masked atomicrmw using a target-specific intrinsic. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  /// is not responsible for masking and shifting the result.</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  /// is not responsible for masking and shifting the result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">  virtual Value *emitMaskedAtomicRMWIntrinsic(IRBuilderBase &Builder,</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">  virtual Value *emitMaskedAtomicRMWIntrinsic(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">                                              AtomicRMWInst *AI,</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">                                              AtomicRMWInst *AI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">                                              Value *AlignedAddr, Value *Incr,</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">                                              Value *AlignedAddr, Value *Incr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">                                              Value *Mask, Value *ShiftAmt,</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">                                              Value *Mask, Value *ShiftAmt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">                                              AtomicOrdering Ord) const {</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">                                              AtomicOrdering Ord) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">    llvm_unreachable("Masked atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">    llvm_unreachable("Masked atomicrmw expansion unimplemented on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline"></td>
    <td class="lineNumber">2054</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  /// Perform a atomicrmw expansion using a target-specific way. This is</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  /// Perform a atomicrmw expansion using a target-specific way. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  /// expected to be called when masked atomicrmw and bit test atomicrmw don't</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  /// expected to be called when masked atomicrmw and bit test atomicrmw don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  /// work, and the target supports another way to lower atomicrmw.</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  /// work, and the target supports another way to lower atomicrmw.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  virtual void emitExpandAtomicRMW(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  virtual void emitExpandAtomicRMW(AtomicRMWInst *AI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">    llvm_unreachable(</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">    llvm_unreachable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">        "Generic atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">        "Generic atomicrmw expansion unimplemented on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline"></td>
    <td class="lineNumber">2062</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">  /// Perform a bit test atomicrmw using a target-specific intrinsic. This</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">  /// Perform a bit test atomicrmw using a target-specific intrinsic. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">  /// represents the combined bit test intrinsic which will be lowered at a late</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">  /// represents the combined bit test intrinsic which will be lowered at a late</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">  /// stage by the backend.</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">  /// stage by the backend.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">  virtual void emitBitTestAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">  virtual void emitBitTestAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">    llvm_unreachable(</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">    llvm_unreachable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">        "Bit test atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">        "Bit test atomicrmw expansion unimplemented on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline"></td>
    <td class="lineNumber">2070</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">  /// Perform a atomicrmw which the result is only used by comparison, using a</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">  /// Perform a atomicrmw which the result is only used by comparison, using a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">  /// target-specific intrinsic. This represents the combined atomic and compare</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">  /// target-specific intrinsic. This represents the combined atomic and compare</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">  /// intrinsic which will be lowered at a late stage by the backend.</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">  /// intrinsic which will be lowered at a late stage by the backend.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">  virtual void emitCmpArithAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">  virtual void emitCmpArithAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">    llvm_unreachable(</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">    llvm_unreachable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">        "Compare arith atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">        "Compare arith atomicrmw expansion unimplemented on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">  /// Perform a masked cmpxchg using a target-specific intrinsic. This</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">  /// Perform a masked cmpxchg using a target-specific intrinsic. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">  /// is not responsible for masking and shifting the result.</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">  /// is not responsible for masking and shifting the result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  virtual Value *emitMaskedAtomicCmpXchgIntrinsic(</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  virtual Value *emitMaskedAtomicCmpXchgIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">      IRBuilderBase &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">      IRBuilderBase &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">      Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">      Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">    llvm_unreachable("Masked cmpxchg expansion unimplemented on this target");</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">    llvm_unreachable("Masked cmpxchg expansion unimplemented on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">  /// \name KCFI check lowering.</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">  /// \name KCFI check lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline"></td>
    <td class="lineNumber">2092</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  virtual MachineInstr *EmitKCFICheck(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  virtual MachineInstr *EmitKCFICheck(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">                                      MachineBasicBlock::instr_iterator &MBBI,</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">                                      MachineBasicBlock::instr_iterator &MBBI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">                                      const TargetInstrInfo *TII) const {</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">                                      const TargetInstrInfo *TII) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">    llvm_unreachable("KCFI is not supported on this target");</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">    llvm_unreachable("KCFI is not supported on this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  /// Inserts in the IR a target-specific intrinsic specifying a fence.</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  /// Inserts in the IR a target-specific intrinsic specifying a fence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">  /// It is called by AtomicExpandPass before expanding an</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">  /// It is called by AtomicExpandPass before expanding an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  ///   AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  ///   AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  ///   if shouldInsertFencesForAtomic returns true.</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  ///   if shouldInsertFencesForAtomic returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  /// Inst is the original atomic instruction, prior to other expansions that</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  /// Inst is the original atomic instruction, prior to other expansions that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  /// may be performed.</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  /// may be performed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  /// This function should either return a nullptr, or a pointer to an IR-level</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  /// This function should either return a nullptr, or a pointer to an IR-level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">  ///   Instruction*. Even complex fence sequences can be represented by a</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">  ///   Instruction*. Even complex fence sequences can be represented by a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">  ///   single Instruction* through an intrinsic to be lowered later.</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">  ///   single Instruction* through an intrinsic to be lowered later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">  /// Backends should override this method to produce target-specific intrinsic</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">  /// Backends should override this method to produce target-specific intrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  ///   for their fences.</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  ///   for their fences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">  /// FIXME: Please note that the default implementation here in terms of</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">  /// FIXME: Please note that the default implementation here in terms of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  ///   IR-level fences exists for historical/compatibility reasons and is</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  ///   IR-level fences exists for historical/compatibility reasons and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">  ///   *unsound* ! Fences cannot, in general, be used to restore sequential</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">  ///   *unsound* ! Fences cannot, in general, be used to restore sequential</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">  ///   consistency. For example, consider the following example:</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">  ///   consistency. For example, consider the following example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">  /// atomic<int> x = y = 0;</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">  /// atomic<int> x = y = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  /// int r1, r2, r3, r4;</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  /// int r1, r2, r3, r4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">  /// Thread 0:</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">  /// Thread 0:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">  ///   x.store(1);</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">  ///   x.store(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  /// Thread 1:</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  /// Thread 1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">  ///   y.store(1);</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">  ///   y.store(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">  /// Thread 2:</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">  /// Thread 2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  ///   r1 = x.load();</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  ///   r1 = x.load();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">  ///   r2 = y.load();</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">  ///   r2 = y.load();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  /// Thread 3:</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  /// Thread 3:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">  ///   r3 = y.load();</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">  ///   r3 = y.load();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">  ///   r4 = x.load();</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">  ///   r4 = x.load();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">  ///  r1 = r3 = 1 and r2 = r4 = 0 is impossible as long as the accesses are all</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">  ///  r1 = r3 = 1 and r2 = r4 = 0 is impossible as long as the accesses are all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  ///  seq_cst. But if they are lowered to monotonic accesses, no amount of</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  ///  seq_cst. But if they are lowered to monotonic accesses, no amount of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  ///  IR-level fences can prevent it.</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  ///  IR-level fences can prevent it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">  virtual Instruction *emitLeadingFence(IRBuilderBase &Builder,</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">  virtual Instruction *emitLeadingFence(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">                                        Instruction *Inst,</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">                                        Instruction *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">                                        AtomicOrdering Ord) const;</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">                                        AtomicOrdering Ord) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline"></td>
    <td class="lineNumber">2137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  virtual Instruction *emitTrailingFence(IRBuilderBase &Builder,</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  virtual Instruction *emitTrailingFence(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">                                         Instruction *Inst,</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">                                         Instruction *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">                                         AtomicOrdering Ord) const;</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">                                         AtomicOrdering Ord) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline"></td>
    <td class="lineNumber">2142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  // Emits code that executes when the comparison result in the ll/sc</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  // Emits code that executes when the comparison result in the ll/sc</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  // expansion of a cmpxchg instruction is such that the store-conditional will</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  // expansion of a cmpxchg instruction is such that the store-conditional will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  // not execute.  This makes it possible to balance out the load-linked with</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  // not execute.  This makes it possible to balance out the load-linked with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">  // a dedicated instruction, if desired.</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">  // a dedicated instruction, if desired.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">  // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">  // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">  // be unnecessarily held, except if clrex, inserted by this hook, is executed.</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">  // be unnecessarily held, except if clrex, inserted by this hook, is executed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">  virtual void emitAtomicCmpXchgNoStoreLLBalance(IRBuilderBase &Builder) const {}</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">  virtual void emitAtomicCmpXchgNoStoreLLBalance(IRBuilderBase &Builder) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">  /// Returns true if arguments should be sign-extended in lib calls.</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">  /// Returns true if arguments should be sign-extended in lib calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">  virtual bool shouldSignExtendTypeInLibCall(EVT Type, bool IsSigned) const {</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">  virtual bool shouldSignExtendTypeInLibCall(EVT Type, bool IsSigned) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">    return IsSigned;</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">    return IsSigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline"></td>
    <td class="lineNumber">2155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  /// Returns true if arguments should be extended in lib calls.</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  /// Returns true if arguments should be extended in lib calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">  virtual bool shouldExtendTypeInLibCall(EVT Type) const {</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">  virtual bool shouldExtendTypeInLibCall(EVT Type) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline"></td>
    <td class="lineNumber">2160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  /// Returns how the given (atomic) load should be expanded by the</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  /// Returns how the given (atomic) load should be expanded by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">  /// IR-level AtomicExpand pass.</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">  /// IR-level AtomicExpand pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldExpandAtomicLoadInIR(LoadInst *LI) const {</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldExpandAtomicLoadInIR(LoadInst *LI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline"></td>
    <td class="lineNumber">2166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">  /// Returns how the given (atomic) load should be cast by the IR-level</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">  /// Returns how the given (atomic) load should be cast by the IR-level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  /// AtomicExpand pass.</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  /// AtomicExpand pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldCastAtomicLoadInIR(LoadInst *LI) const {</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldCastAtomicLoadInIR(LoadInst *LI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">    if (LI->getType()->isFloatingPointTy())</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">    if (LI->getType()->isFloatingPointTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">      return AtomicExpansionKind::CastToInteger;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline"></td>
    <td class="lineNumber">2174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">  /// Returns how the given (atomic) store should be expanded by the IR-level</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">  /// Returns how the given (atomic) store should be expanded by the IR-level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">  /// AtomicExpand pass into. For instance AtomicExpansionKind::Expand will try</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">  /// AtomicExpand pass into. For instance AtomicExpansionKind::Expand will try</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">  /// to use an atomicrmw xchg.</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">  /// to use an atomicrmw xchg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldExpandAtomicStoreInIR(StoreInst *SI) const {</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldExpandAtomicStoreInIR(StoreInst *SI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">  /// Returns how the given (atomic) store should be cast by the IR-level</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">  /// Returns how the given (atomic) store should be cast by the IR-level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">  /// AtomicExpand pass into. For instance AtomicExpansionKind::CastToInteger</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">  /// AtomicExpand pass into. For instance AtomicExpansionKind::CastToInteger</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">  /// will try to cast the operands to integer values.</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">  /// will try to cast the operands to integer values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldCastAtomicStoreInIR(StoreInst *SI) const {</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldCastAtomicStoreInIR(StoreInst *SI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">    if (SI->getValueOperand()->getType()->isFloatingPointTy())</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">    if (SI->getValueOperand()->getType()->isFloatingPointTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">      return AtomicExpansionKind::CastToInteger;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline"></td>
    <td class="lineNumber">2190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">  /// Returns how the given atomic cmpxchg should be expanded by the IR-level</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">  /// Returns how the given atomic cmpxchg should be expanded by the IR-level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">  /// AtomicExpand pass.</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">  /// AtomicExpand pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">  virtual AtomicExpansionKind</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">  virtual AtomicExpansionKind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *AI) const {</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *AI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline"></td>
    <td class="lineNumber">2197</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">  /// Returns how the IR-level AtomicExpand pass should expand the given</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">  /// Returns how the IR-level AtomicExpand pass should expand the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">  /// AtomicRMW, if at all. Default is to never expand.</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">  /// AtomicRMW, if at all. Default is to never expand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">  virtual AtomicExpansionKind shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">    return RMW->isFloatingPointOperation() ?</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">    return RMW->isFloatingPointOperation() ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">      AtomicExpansionKind::CmpXChg : AtomicExpansionKind::None;</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">      AtomicExpansionKind::CmpXChg : AtomicExpansionKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline"></td>
    <td class="lineNumber">2204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">  /// Returns how the given atomic atomicrmw should be cast by the IR-level</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">  /// Returns how the given atomic atomicrmw should be cast by the IR-level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">  /// AtomicExpand pass.</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">  /// AtomicExpand pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">  virtual AtomicExpansionKind</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">  virtual AtomicExpansionKind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">  shouldCastAtomicRMWIInIR(AtomicRMWInst *RMWI) const {</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">  shouldCastAtomicRMWIInIR(AtomicRMWInst *RMWI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">    if (RMWI->getOperation() == AtomicRMWInst::Xchg &&</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">    if (RMWI->getOperation() == AtomicRMWInst::Xchg &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">        (RMWI->getValOperand()->getType()->isFloatingPointTy() ||</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">        (RMWI->getValOperand()->getType()->isFloatingPointTy() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">         RMWI->getValOperand()->getType()->isPointerTy()))</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">         RMWI->getValOperand()->getType()->isPointerTy()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">      return AtomicExpansionKind::CastToInteger;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline"></td>
    <td class="lineNumber">2213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">    return AtomicExpansionKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">  /// On some platforms, an AtomicRMW that never actually modifies the value</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">  /// On some platforms, an AtomicRMW that never actually modifies the value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">  /// (such as fetch_add of 0) can be turned into a fence followed by an</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">  /// (such as fetch_add of 0) can be turned into a fence followed by an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">  /// atomic load. This may sound useless, but it makes it possible for the</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">  /// atomic load. This may sound useless, but it makes it possible for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">  /// processor to keep the cacheline shared, dramatically improving</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">  /// processor to keep the cacheline shared, dramatically improving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">  /// performance. And such idempotent RMWs are useful for implementing some</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">  /// performance. And such idempotent RMWs are useful for implementing some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">  /// kinds of locks, see for example (justification + benchmarks):</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">  /// kinds of locks, see for example (justification + benchmarks):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">  /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">  /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">  /// This method tries doing that transformation, returning the atomic load if</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">  /// This method tries doing that transformation, returning the atomic load if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">  /// it succeeds, and nullptr otherwise.</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">  /// it succeeds, and nullptr otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">  /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">  /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">  /// another round of expansion.</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">  /// another round of expansion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">  virtual LoadInst *</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">  virtual LoadInst *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">  lowerIdempotentRMWIntoFencedLoad(AtomicRMWInst *RMWI) const {</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">  lowerIdempotentRMWIntoFencedLoad(AtomicRMWInst *RMWI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline"></td>
    <td class="lineNumber">2232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">  /// Returns how the platform's atomic operations are extended (ZERO_EXTEND,</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">  /// Returns how the platform's atomic operations are extended (ZERO_EXTEND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  /// SIGN_EXTEND, or ANY_EXTEND).</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  /// SIGN_EXTEND, or ANY_EXTEND).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">  virtual ISD::NodeType getExtendForAtomicOps() const {</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">  virtual ISD::NodeType getExtendForAtomicOps() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">    return ISD::ZERO_EXTEND;</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">    return ISD::ZERO_EXTEND;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  /// Returns how the platform's atomic compare and swap expects its comparison</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  /// Returns how the platform's atomic compare and swap expects its comparison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  /// separate from getExtendForAtomicOps, which is concerned with the</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  /// separate from getExtendForAtomicOps, which is concerned with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">  /// sign-extension of the instruction's output, whereas here we are concerned</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">  /// sign-extension of the instruction's output, whereas here we are concerned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  /// with the sign-extension of the input. For targets with compare-and-swap</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  /// with the sign-extension of the input. For targets with compare-and-swap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">  /// instructions (or sub-word comparisons in their LL/SC loop expansions),</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">  /// instructions (or sub-word comparisons in their LL/SC loop expansions),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">  /// the input can be ANY_EXTEND, but the output will still have a specific</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">  /// the input can be ANY_EXTEND, but the output will still have a specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">  /// extension.</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">  /// extension.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  virtual ISD::NodeType getExtendForAtomicCmpSwapArg() const {</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  virtual ISD::NodeType getExtendForAtomicCmpSwapArg() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">    return ISD::ANY_EXTEND;</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">    return ISD::ANY_EXTEND;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline"></td>
    <td class="lineNumber">2250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline"></td>
    <td class="lineNumber">2252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">  /// Returns true if we should normalize</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">  /// Returns true if we should normalize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">  /// that it saves us from materializing N0 and N1 in an integer register.</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">  /// that it saves us from materializing N0 and N1 in an integer register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  /// Targets that are able to perform and/or on flags should return false here.</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  /// Targets that are able to perform and/or on flags should return false here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  virtual bool shouldNormalizeToSelectSequence(LLVMContext &Context,</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  virtual bool shouldNormalizeToSelectSequence(LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">                                               EVT VT) const {</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">                                               EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    // If a target has multiple condition registers, then it likely has logical</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    // If a target has multiple condition registers, then it likely has logical</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">    // operations on those registers.</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">    // operations on those registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">    if (hasMultipleConditionRegisters())</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">    if (hasMultipleConditionRegisters())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">    // Only do the transform if the value won't be split into multiple</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">    // Only do the transform if the value won't be split into multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">    // registers.</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">    // registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">    LegalizeTypeAction Action = getTypeAction(Context, VT);</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">    LegalizeTypeAction Action = getTypeAction(Context, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">    return Action != TypeExpandInteger && Action != TypeExpandFloat &&</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">    return Action != TypeExpandInteger && Action != TypeExpandFloat &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">      Action != TypeSplitVector;</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">      Action != TypeSplitVector;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline"></td>
    <td class="lineNumber">2270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">  virtual bool isProfitableToCombineMinNumMaxNum(EVT VT) const { return true; }</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">  virtual bool isProfitableToCombineMinNumMaxNum(EVT VT) const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline"></td>
    <td class="lineNumber">2272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">  /// Return true if a select of constants (select Cond, C1, C2) should be</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">  /// Return true if a select of constants (select Cond, C1, C2) should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">  /// transformed into simple math ops with the condition value. For example:</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">  /// transformed into simple math ops with the condition value. For example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">  /// select Cond, C1, C1-1 --> add (zext Cond), C1-1</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">  /// select Cond, C1, C1-1 --> add (zext Cond), C1-1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">  virtual bool convertSelectOfConstantsToMath(EVT VT) const {</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">  virtual bool convertSelectOfConstantsToMath(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">  /// Return true if it is profitable to transform an integer</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">  /// Return true if it is profitable to transform an integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">  /// multiplication-by-constant into simpler operations like shifts and adds.</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">  /// multiplication-by-constant into simpler operations like shifts and adds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">  /// This may be true if the target does not directly support the</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">  /// This may be true if the target does not directly support the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">  /// multiplication operation for the specified type or the sequence of simpler</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">  /// multiplication operation for the specified type or the sequence of simpler</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">  /// ops is faster than the multiply.</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">  /// ops is faster than the multiply.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">  virtual bool decomposeMulByConstant(LLVMContext &Context,</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">  virtual bool decomposeMulByConstant(LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">                                      EVT VT, SDValue C) const {</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">                                      EVT VT, SDValue C) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline"></td>
    <td class="lineNumber">2289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">  /// Return true if it may be profitable to transform</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">  /// Return true if it may be profitable to transform</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">  /// (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2).</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">  /// (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">  /// This may not be true if c1 and c2 can be represented as immediates but</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">  /// This may not be true if c1 and c2 can be represented as immediates but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">  /// c1*c2 cannot, for example.</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">  /// c1*c2 cannot, for example.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">  /// The target should check if c1, c2 and c1*c2 can be represented as</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">  /// The target should check if c1, c2 and c1*c2 can be represented as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">  /// immediates, or have to be materialized into registers. If it is not sure</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">  /// immediates, or have to be materialized into registers. If it is not sure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">  /// about some cases, a default true can be returned to let the DAGCombiner</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">  /// about some cases, a default true can be returned to let the DAGCombiner</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">  /// decide.</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">  /// decide.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">  /// AddNode is (add x, c1), and ConstNode is c2.</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">  /// AddNode is (add x, c1), and ConstNode is c2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">  virtual bool isMulAddWithConstProfitable(SDValue AddNode,</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">  virtual bool isMulAddWithConstProfitable(SDValue AddNode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">                                           SDValue ConstNode) const {</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">                                           SDValue ConstNode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline"></td>
    <td class="lineNumber">2303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">  /// Return true if it is more correct/profitable to use strict FP_TO_INT</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">  /// Return true if it is more correct/profitable to use strict FP_TO_INT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">  /// conversion operations - canonicalizing the FP source value instead of</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">  /// conversion operations - canonicalizing the FP source value instead of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">  /// converting all cases and then selecting based on value.</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">  /// converting all cases and then selecting based on value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">  /// This may be true if the target throws exceptions for out of bounds</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">  /// This may be true if the target throws exceptions for out of bounds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">  /// conversions or has fast FP CMOV.</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">  /// conversions or has fast FP CMOV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">  virtual bool shouldUseStrictFP_TO_INT(EVT FpVT, EVT IntVT,</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">  virtual bool shouldUseStrictFP_TO_INT(EVT FpVT, EVT IntVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">                                        bool IsSigned) const {</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">                                        bool IsSigned) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline"></td>
    <td class="lineNumber">2313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">  /// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">  /// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">  /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">  /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">  /// considered beneficial.</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">  /// considered beneficial.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">  /// If optimizing for size, expansion is only considered beneficial for upto</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">  /// If optimizing for size, expansion is only considered beneficial for upto</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">  /// 5 multiplies and a divide (if the exponent is negative).</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">  /// 5 multiplies and a divide (if the exponent is negative).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">  bool isBeneficialToExpandPowI(int64_t Exponent, bool OptForSize) const {</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">  bool isBeneficialToExpandPowI(int64_t Exponent, bool OptForSize) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">    if (Exponent < 0)</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">    if (Exponent < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">      Exponent = -Exponent;</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">      Exponent = -Exponent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">    uint64_t E = static_cast<uint64_t>(Exponent);</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">    uint64_t E = static_cast<uint64_t>(Exponent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">    return !OptForSize || (llvm::popcount(E) + Log2_64(E) < 7);</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">    return !OptForSize || (llvm::popcount(E) + Log2_64(E) < 7);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline"></td>
    <td class="lineNumber">2325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">  // TargetLowering Configuration Methods - These methods should be invoked by</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">  // TargetLowering Configuration Methods - These methods should be invoked by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">  // the derived class constructor to configure this object for the target.</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">  // the derived class constructor to configure this object for the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">  /// Specify how the target extends the result of integer and floating point</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">  /// Specify how the target extends the result of integer and floating point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">  void setBooleanContents(BooleanContent Ty) {</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">  void setBooleanContents(BooleanContent Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">    BooleanContents = Ty;</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">    BooleanContents = Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">    BooleanFloatContents = Ty;</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">    BooleanFloatContents = Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline"></td>
    <td class="lineNumber">2337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  /// Specify how the target extends the result of integer and floating point</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  /// Specify how the target extends the result of integer and floating point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">  void setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy) {</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">  void setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">    BooleanContents = IntTy;</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">    BooleanContents = IntTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">    BooleanFloatContents = FloatTy;</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">    BooleanFloatContents = FloatTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">  /// Specify how the target extends the result of a vector boolean value from a</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">  /// Specify how the target extends the result of a vector boolean value from a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">  /// vector of i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">  /// vector of i1 to a wider type.  See getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">  void setBooleanVectorContents(BooleanContent Ty) {</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">  void setBooleanVectorContents(BooleanContent Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">    BooleanVectorContents = Ty;</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">    BooleanVectorContents = Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline"></td>
    <td class="lineNumber">2350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">  /// Specify the target scheduling preference.</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">  /// Specify the target scheduling preference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">  void setSchedulingPreference(Sched::Preference Pref) {</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">  void setSchedulingPreference(Sched::Preference Pref) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">    SchedPreferenceInfo = Pref;</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">    SchedPreferenceInfo = Pref;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline"></td>
    <td class="lineNumber">2355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">  /// Indicate the minimum number of blocks to generate jump tables.</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">  /// Indicate the minimum number of blocks to generate jump tables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">  void setMinimumJumpTableEntries(unsigned Val);</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">  void setMinimumJumpTableEntries(unsigned Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline"></td>
    <td class="lineNumber">2358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  /// Indicate the maximum number of entries in jump tables.</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  /// Indicate the maximum number of entries in jump tables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">  /// Set to zero to generate unlimited jump tables.</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">  /// Set to zero to generate unlimited jump tables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  void setMaximumJumpTableSize(unsigned);</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  void setMaximumJumpTableSize(unsigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  /// If set to a physical register, this specifies the register that</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  /// If set to a physical register, this specifies the register that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  void setStackPointerRegisterToSaveRestore(Register R) {</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  void setStackPointerRegisterToSaveRestore(Register R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">    StackPointerRegisterToSaveRestore = R;</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">    StackPointerRegisterToSaveRestore = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline"></td>
    <td class="lineNumber">2368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  /// Tells the code generator that the target has multiple (allocatable)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  /// condition registers that can be used to store the results of comparisons</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  /// condition registers that can be used to store the results of comparisons</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  /// for use by selects and conditional branches. With multiple condition</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  /// for use by selects and conditional branches. With multiple condition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">  /// registers, the code generator will not aggressively sink comparisons into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">  /// the blocks of their users.</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">  /// the blocks of their users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  void setHasMultipleConditionRegisters(bool hasManyRegs = true) {</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  void setHasMultipleConditionRegisters(bool hasManyRegs = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    HasMultipleConditionRegisters = hasManyRegs;</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    HasMultipleConditionRegisters = hasManyRegs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline"></td>
    <td class="lineNumber">2377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">  /// Tells the code generator that the target has BitExtract instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">  /// their users if the users will generate "and" instructions which can be</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">  /// their users if the users will generate "and" instructions which can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">  /// combined with "shift" to BitExtract instructions.</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">  /// combined with "shift" to BitExtract instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">  void setHasExtractBitsInsn(bool hasExtractInsn = true) {</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">  void setHasExtractBitsInsn(bool hasExtractInsn = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">    HasExtractBitsInsn = hasExtractInsn;</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">    HasExtractBitsInsn = hasExtractInsn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">  /// Tells the code generator not to expand logic operations on comparison</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">  /// Tells the code generator not to expand logic operations on comparison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">  /// predicates into separate sequences that increase the amount of flow</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">  /// predicates into separate sequences that increase the amount of flow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">  /// control.</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">  /// control.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">  void setJumpIsExpensive(bool isExpensive = true);</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">  void setJumpIsExpensive(bool isExpensive = true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline"></td>
    <td class="lineNumber">2390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">  /// Tells the code generator which bitwidths to bypass.</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">  /// Tells the code generator which bitwidths to bypass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">  void addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth) {</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">  void addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">    BypassSlowDivWidths[SlowBitWidth] = FastBitWidth;</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">    BypassSlowDivWidths[SlowBitWidth] = FastBitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline"></td>
    <td class="lineNumber">2395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">  /// Add the specified register class as an available regclass for the</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">  /// Add the specified register class as an available regclass for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">  /// specified value type. This indicates the selector can handle values of</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">  /// specified value type. This indicates the selector can handle values of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">  /// that class natively.</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">  /// that class natively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">  void addRegisterClass(MVT VT, const TargetRegisterClass *RC) {</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">  void addRegisterClass(MVT VT, const TargetRegisterClass *RC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">    assert((unsigned)VT.SimpleTy < std::size(RegClassForVT));</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">    assert((unsigned)VT.SimpleTy < std::size(RegClassForVT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">    RegClassForVT[VT.SimpleTy] = RC;</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">    RegClassForVT[VT.SimpleTy] = RC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">  /// Return the largest legal super-reg register class of the register class</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">  /// Return the largest legal super-reg register class of the register class</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  /// for the specified type and its associated "cost".</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  /// for the specified type and its associated "cost".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">  virtual std::pair<const TargetRegisterClass *, uint8_t></td>
    <td class="lineNumber">2406</td>
    <td class="codeline">  virtual std::pair<const TargetRegisterClass *, uint8_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT) const;</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline"></td>
    <td class="lineNumber">2408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  /// Once all of the register classes are added, this allows us to compute</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  /// Once all of the register classes are added, this allows us to compute</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">  /// derived properties we expose.</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">  /// derived properties we expose.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">  void computeRegisterProperties(const TargetRegisterInfo *TRI);</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">  void computeRegisterProperties(const TargetRegisterInfo *TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline"></td>
    <td class="lineNumber">2412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">  /// Indicate that the specified operation does not work with the specified</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">  /// Indicate that the specified operation does not work with the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">  /// type and indicate what to do about it. Note that VT may refer to either</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">  /// type and indicate what to do about it. Note that VT may refer to either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">  /// the type of a result or that of an operand of Op.</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">  /// the type of a result or that of an operand of Op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">  void setOperationAction(unsigned Op, MVT VT, LegalizeAction Action) {</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">  void setOperationAction(unsigned Op, MVT VT, LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">    assert(Op < std::size(OpActions[0]) && "Table isn't big enough!");</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">    assert(Op < std::size(OpActions[0]) && "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">    OpActions[(unsigned)VT.SimpleTy][Op] = Action;</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">    OpActions[(unsigned)VT.SimpleTy][Op] = Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">  void setOperationAction(ArrayRef<unsigned> Ops, MVT VT,</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">  void setOperationAction(ArrayRef<unsigned> Ops, MVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">                          LegalizeAction Action) {</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">                          LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">    for (auto Op : Ops)</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">    for (auto Op : Ops)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">      setOperationAction(Op, VT, Action);</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">      setOperationAction(Op, VT, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">  void setOperationAction(ArrayRef<unsigned> Ops, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">  void setOperationAction(ArrayRef<unsigned> Ops, ArrayRef<MVT> VTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">                          LegalizeAction Action) {</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">                          LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">    for (auto VT : VTs)</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">    for (auto VT : VTs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">      setOperationAction(Ops, VT, Action);</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">      setOperationAction(Ops, VT, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline"></td>
    <td class="lineNumber">2430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">  /// Indicate that the specified load with extension does not work with the</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">  /// Indicate that the specified load with extension does not work with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">  /// specified type and indicate what to do about it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">  void setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT,</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">  void setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">                        LegalizeAction Action) {</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">                        LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() &&</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">           MemVT.isValid() && "Table isn't big enough!");</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">           MemVT.isValid() && "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">    assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">    assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">    unsigned Shift = 4 * ExtType;</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">    unsigned Shift = 4 * ExtType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] &= ~((uint16_t)0xF << Shift);</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] &= ~((uint16_t)0xF << Shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] |= (uint16_t)Action << Shift;</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] |= (uint16_t)Action << Shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT, MVT MemVT,</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT, MVT MemVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">                        LegalizeAction Action) {</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">                        LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">    for (auto ExtType : ExtTypes)</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">    for (auto ExtType : ExtTypes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">      setLoadExtAction(ExtType, ValVT, MemVT, Action);</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">      setLoadExtAction(ExtType, ValVT, MemVT, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT,</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">                        ArrayRef<MVT> MemVTs, LegalizeAction Action) {</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">                        ArrayRef<MVT> MemVTs, LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">    for (auto MemVT : MemVTs)</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">    for (auto MemVT : MemVTs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">      setLoadExtAction(ExtTypes, ValVT, MemVT, Action);</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">      setLoadExtAction(ExtTypes, ValVT, MemVT, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline"></td>
    <td class="lineNumber">2452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">  /// Indicate that the specified truncating store does not work with the</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">  /// Indicate that the specified truncating store does not work with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">  /// specified type and indicate what to do about it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">  void setTruncStoreAction(MVT ValVT, MVT MemVT, LegalizeAction Action) {</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">  void setTruncStoreAction(MVT ValVT, MVT MemVT, LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">    assert(ValVT.isValid() && MemVT.isValid() && "Table isn't big enough!");</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">    assert(ValVT.isValid() && MemVT.isValid() && "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">    TruncStoreActions[(unsigned)ValVT.SimpleTy][MemVT.SimpleTy] = Action;</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">    TruncStoreActions[(unsigned)ValVT.SimpleTy][MemVT.SimpleTy] = Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline"></td>
    <td class="lineNumber">2459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">  /// Indicate that the specified indexed load does or does not work with the</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">  /// Indicate that the specified indexed load does or does not work with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">  /// specified type and indicate what to do abort it.</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">  /// specified type and indicate what to do abort it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">  /// NOTE: All indexed mode loads are initialized to Expand in</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">  /// NOTE: All indexed mode loads are initialized to Expand in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">                            LegalizeAction Action) {</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">                            LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">    for (auto IdxMode : IdxModes)</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">    for (auto IdxMode : IdxModes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">      setIndexedModeAction(IdxMode, VT, IMAB_Load, Action);</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">      setIndexedModeAction(IdxMode, VT, IMAB_Load, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline"></td>
    <td class="lineNumber">2470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">                            LegalizeAction Action) {</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">                            LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">    for (auto VT : VTs)</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">    for (auto VT : VTs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">      setIndexedLoadAction(IdxModes, VT, Action);</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">      setIndexedLoadAction(IdxModes, VT, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline"></td>
    <td class="lineNumber">2476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">  /// Indicate that the specified indexed store does or does not work with the</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">  /// Indicate that the specified indexed store does or does not work with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">  /// specified type and indicate what to do about it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">  /// NOTE: All indexed mode stores are initialized to Expand in</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">  /// NOTE: All indexed mode stores are initialized to Expand in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">                             LegalizeAction Action) {</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">                             LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">    for (auto IdxMode : IdxModes)</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">    for (auto IdxMode : IdxModes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">      setIndexedModeAction(IdxMode, VT, IMAB_Store, Action);</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">      setIndexedModeAction(IdxMode, VT, IMAB_Store, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline"></td>
    <td class="lineNumber">2487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">                             LegalizeAction Action) {</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">                             LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">    for (auto VT : VTs)</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">    for (auto VT : VTs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">      setIndexedStoreAction(IdxModes, VT, Action);</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">      setIndexedStoreAction(IdxModes, VT, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline"></td>
    <td class="lineNumber">2493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">  /// Indicate that the specified indexed masked load does or does not work with</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">  /// Indicate that the specified indexed masked load does or does not work with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">  /// the specified type and indicate what to do about it.</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">  /// the specified type and indicate what to do about it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">  /// NOTE: All indexed mode masked loads are initialized to Expand in</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">  /// NOTE: All indexed mode masked loads are initialized to Expand in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">  void setIndexedMaskedLoadAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">  void setIndexedMaskedLoadAction(unsigned IdxMode, MVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">                                  LegalizeAction Action) {</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">                                  LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad, Action);</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline"></td>
    <td class="lineNumber">2503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">  /// Indicate that the specified indexed masked store does or does not work</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">  /// Indicate that the specified indexed masked store does or does not work</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">  /// with the specified type and indicate what to do about it.</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">  /// with the specified type and indicate what to do about it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">  /// NOTE: All indexed mode masked stores are initialized to Expand in</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">  /// NOTE: All indexed mode masked stores are initialized to Expand in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">  /// TargetLowering.cpp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">  void setIndexedMaskedStoreAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">  void setIndexedMaskedStoreAction(unsigned IdxMode, MVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">                                   LegalizeAction Action) {</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">                                   LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedStore, Action);</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedStore, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline"></td>
    <td class="lineNumber">2513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">  /// Indicate that the specified condition code is or isn't supported on the</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">  /// Indicate that the specified condition code is or isn't supported on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">  /// target and indicate what to do about it.</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">  /// target and indicate what to do about it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, MVT VT,</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, MVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">                         LegalizeAction Action) {</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">                         LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">    for (auto CC : CCs) {</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">    for (auto CC : CCs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">      assert(VT.isValid() && (unsigned)CC < std::size(CondCodeActions) &&</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">      assert(VT.isValid() && (unsigned)CC < std::size(CondCodeActions) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">             "Table isn't big enough!");</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">             "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">      assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">      assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">      /// The lower 3 bits of the SimpleTy index into Nth 4bit set from the</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">      /// The lower 3 bits of the SimpleTy index into Nth 4bit set from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">      /// 32-bit value and the upper 29 bits index into the second dimension of</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">      /// 32-bit value and the upper 29 bits index into the second dimension of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">      /// the array to select what 32-bit value to use.</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">      /// the array to select what 32-bit value to use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">      uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">      uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">      CondCodeActions[CC][VT.SimpleTy >> 3] &= ~((uint32_t)0xF << Shift);</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">      CondCodeActions[CC][VT.SimpleTy >> 3] &= ~((uint32_t)0xF << Shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">      CondCodeActions[CC][VT.SimpleTy >> 3] |= (uint32_t)Action << Shift;</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">      CondCodeActions[CC][VT.SimpleTy >> 3] |= (uint32_t)Action << Shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, ArrayRef<MVT> VTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">                         LegalizeAction Action) {</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">                         LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">    for (auto VT : VTs)</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">    for (auto VT : VTs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">      setCondCodeAction(CCs, VT, Action);</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">      setCondCodeAction(CCs, VT, Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline"></td>
    <td class="lineNumber">2535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">  /// If Opc/OrigVT is specified as being promoted, the promotion code defaults</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">  /// If Opc/OrigVT is specified as being promoted, the promotion code defaults</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">  /// to trying a larger integer/fp until it can find one that works. If that</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">  /// to trying a larger integer/fp until it can find one that works. If that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">  /// default is insufficient, this method can be used by the target to override</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">  /// default is insufficient, this method can be used by the target to override</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">  /// the default.</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">  /// the default.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">  void AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">  void AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">    PromoteToType[std::make_pair(Opc, OrigVT.SimpleTy)] = DestVT.SimpleTy;</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">    PromoteToType[std::make_pair(Opc, OrigVT.SimpleTy)] = DestVT.SimpleTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline"></td>
    <td class="lineNumber">2543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">  /// Convenience method to set an operation to Promote and specify the type</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">  /// Convenience method to set an operation to Promote and specify the type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">  /// in a single call.</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">  /// in a single call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">  void setOperationPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">  void setOperationPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">    setOperationAction(Opc, OrigVT, Promote);</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">    setOperationAction(Opc, OrigVT, Promote);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">    AddPromotedToType(Opc, OrigVT, DestVT);</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">    AddPromotedToType(Opc, OrigVT, DestVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline"></td>
    <td class="lineNumber">2550</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">  /// Targets should invoke this method for each target independent node that</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">  /// Targets should invoke this method for each target independent node that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">  /// they want to provide a custom DAG combiner for by implementing the</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">  /// they want to provide a custom DAG combiner for by implementing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">  /// PerformDAGCombine virtual method.</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">  /// PerformDAGCombine virtual method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">  void setTargetDAGCombine(ArrayRef<ISD::NodeType> NTs) {</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">  void setTargetDAGCombine(ArrayRef<ISD::NodeType> NTs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">    for (auto NT : NTs) {</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">    for (auto NT : NTs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">      assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">      assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">      TargetDAGCombineArray[NT >> 3] |= 1 << (NT & 7);</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">      TargetDAGCombineArray[NT >> 3] |= 1 << (NT & 7);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline"></td>
    <td class="lineNumber">2560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">  /// Set the target's minimum function alignment.</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">  /// Set the target's minimum function alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">  void setMinFunctionAlignment(Align Alignment) {</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">  void setMinFunctionAlignment(Align Alignment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">    MinFunctionAlignment = Alignment;</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">    MinFunctionAlignment = Alignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline"></td>
    <td class="lineNumber">2565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">  /// Set the target's preferred function alignment.  This should be set if</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">  /// Set the target's preferred function alignment.  This should be set if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">  /// there is a performance benefit to higher-than-minimum alignment</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">  /// there is a performance benefit to higher-than-minimum alignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">  void setPrefFunctionAlignment(Align Alignment) {</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">  void setPrefFunctionAlignment(Align Alignment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">    PrefFunctionAlignment = Alignment;</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">    PrefFunctionAlignment = Alignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline"></td>
    <td class="lineNumber">2571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">  /// Set the target's preferred loop alignment. Default alignment is one, it</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">  /// Set the target's preferred loop alignment. Default alignment is one, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">  /// means the target does not care about loop alignment. The target may also</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">  /// means the target does not care about loop alignment. The target may also</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">  /// override getPrefLoopAlignment to provide per-loop values.</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">  /// override getPrefLoopAlignment to provide per-loop values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">  void setPrefLoopAlignment(Align Alignment) { PrefLoopAlignment = Alignment; }</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">  void setPrefLoopAlignment(Align Alignment) { PrefLoopAlignment = Alignment; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">  void setMaxBytesForAlignment(unsigned MaxBytes) {</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">  void setMaxBytesForAlignment(unsigned MaxBytes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">    MaxBytesForAlignment = MaxBytes;</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">    MaxBytesForAlignment = MaxBytes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline"></td>
    <td class="lineNumber">2579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">  /// Set the minimum stack alignment of an argument.</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">  /// Set the minimum stack alignment of an argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">  void setMinStackArgumentAlignment(Align Alignment) {</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">  void setMinStackArgumentAlignment(Align Alignment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">    MinStackArgumentAlignment = Alignment;</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">    MinStackArgumentAlignment = Alignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline"></td>
    <td class="lineNumber">2584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">  /// Set the maximum atomic operation size supported by the</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">  /// Set the maximum atomic operation size supported by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">  /// backend. Atomic operations greater than this size (as well as</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">  /// backend. Atomic operations greater than this size (as well as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">  /// ones that are not naturally aligned), will be expanded by</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">  /// ones that are not naturally aligned), will be expanded by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">  /// AtomicExpandPass into an __atomic_* library call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">  void setMaxAtomicSizeInBitsSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">  void setMaxAtomicSizeInBitsSupported(unsigned SizeInBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">    MaxAtomicSizeInBitsSupported = SizeInBits;</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">    MaxAtomicSizeInBitsSupported = SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline"></td>
    <td class="lineNumber">2592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">  /// Set the size in bits of the maximum div/rem the backend supports.</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">  /// Set the size in bits of the maximum div/rem the backend supports.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">  void setMaxDivRemBitWidthSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">  void setMaxDivRemBitWidthSupported(unsigned SizeInBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">    MaxDivRemBitWidthSupported = SizeInBits;</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">    MaxDivRemBitWidthSupported = SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline"></td>
    <td class="lineNumber">2598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">  /// Set the size in bits of the maximum fp convert the backend supports.</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">  /// Set the size in bits of the maximum fp convert the backend supports.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeFPConvert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">  void setMaxLargeFPConvertBitWidthSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">  void setMaxLargeFPConvertBitWidthSupported(unsigned SizeInBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">    MaxLargeFPConvertBitWidthSupported = SizeInBits;</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">    MaxLargeFPConvertBitWidthSupported = SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline"></td>
    <td class="lineNumber">2604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">  /// Sets the minimum cmpxchg or ll/sc size supported by the backend.</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">  /// Sets the minimum cmpxchg or ll/sc size supported by the backend.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">  void setMinCmpXchgSizeInBits(unsigned SizeInBits) {</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">  void setMinCmpXchgSizeInBits(unsigned SizeInBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">    MinCmpXchgSizeInBits = SizeInBits;</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">    MinCmpXchgSizeInBits = SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline"></td>
    <td class="lineNumber">2609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">  /// Sets whether unaligned atomic operations are supported.</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">  /// Sets whether unaligned atomic operations are supported.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">  void setSupportsUnalignedAtomics(bool UnalignedSupported) {</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">  void setSupportsUnalignedAtomics(bool UnalignedSupported) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">    SupportsUnalignedAtomics = UnalignedSupported;</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">    SupportsUnalignedAtomics = UnalignedSupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline"></td>
    <td class="lineNumber">2614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">  // Addressing mode description hooks (used by LSR etc).</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">  // Addressing mode description hooks (used by LSR etc).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2618</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline"></td>
    <td class="lineNumber">2619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">  /// CodeGenPrepare sinks address calculations into the same BB as Load/Store</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">  /// CodeGenPrepare sinks address calculations into the same BB as Load/Store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">  /// instructions reading the address. This allows as much computation as</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">  /// instructions reading the address. This allows as much computation as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">  /// possible to be done in the address mode for that operand. This hook lets</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">  /// possible to be done in the address mode for that operand. This hook lets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">  /// targets also pass back when this should be done on intrinsics which</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">  /// targets also pass back when this should be done on intrinsics which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline">  /// load/store.</td>
    <td class="lineNumber">2624</td>
    <td class="codeline">  /// load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">  virtual bool getAddrModeArguments(IntrinsicInst * /*I*/,</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">  virtual bool getAddrModeArguments(IntrinsicInst * /*I*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">                                    SmallVectorImpl<Value*> &/*Ops*/,</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">                                    SmallVectorImpl<Value*> &/*Ops*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">                                    Type *&/*AccessTy*/) const {</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">                                    Type *&/*AccessTy*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline"></td>
    <td class="lineNumber">2630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">  /// This represents an addressing mode of:</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">  /// This represents an addressing mode of:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">  ///    BaseGV + BaseOffs + BaseReg + Scale*ScaleReg</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">  ///    BaseGV + BaseOffs + BaseReg + Scale*ScaleReg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">  /// If BaseGV is null,  there is no BaseGV.</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">  /// If BaseGV is null,  there is no BaseGV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">  /// If BaseOffs is zero, there is no base offset.</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">  /// If BaseOffs is zero, there is no base offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">  /// If HasBaseReg is false, there is no base register.</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">  /// If HasBaseReg is false, there is no base register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">  /// If Scale is zero, there is no ScaleReg.  Scale of 1 indicates a reg with</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">  /// If Scale is zero, there is no ScaleReg.  Scale of 1 indicates a reg with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">  /// no scale.</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">  /// no scale.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline">  struct AddrMode {</td>
    <td class="lineNumber">2638</td>
    <td class="codeline">  struct AddrMode {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">    GlobalValue *BaseGV = nullptr;</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">    GlobalValue *BaseGV = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">    int64_t      BaseOffs = 0;</td>
    <td class="lineNumber">2640</td>
    <td class="codeline">    int64_t      BaseOffs = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">    bool         HasBaseReg = false;</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">    bool         HasBaseReg = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">    int64_t      Scale = 0;</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">    int64_t      Scale = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">    AddrMode() = default;</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">    AddrMode() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2644</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline"></td>
    <td class="lineNumber">2645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">  /// Return true if the addressing mode represented by AM is legal for this</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">  /// Return true if the addressing mode represented by AM is legal for this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline">  /// target, for a load/store of the specified type.</td>
    <td class="lineNumber">2647</td>
    <td class="codeline">  /// target, for a load/store of the specified type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">  /// The type may be VoidTy, in which case only return true if the addressing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">  /// mode is legal for a load/store of any legal type.  TODO: Handle</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">  /// mode is legal for a load/store of any legal type.  TODO: Handle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline">  /// pre/postinc as well.</td>
    <td class="lineNumber">2651</td>
    <td class="codeline">  /// pre/postinc as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">  /// If the address space cannot be determined, it will be -1.</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">  /// If the address space cannot be determined, it will be -1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2654</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">  /// TODO: Remove default argument</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">  /// TODO: Remove default argument</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">  virtual bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM,</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">  virtual bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">                                     Type *Ty, unsigned AddrSpace,</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">                                     Type *Ty, unsigned AddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline">                                     Instruction *I = nullptr) const;</td>
    <td class="lineNumber">2658</td>
    <td class="codeline">                                     Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline"></td>
    <td class="lineNumber">2659</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline">  /// Return true if the specified immediate is legal icmp immediate, that is</td>
    <td class="lineNumber">2660</td>
    <td class="codeline">  /// Return true if the specified immediate is legal icmp immediate, that is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">  /// the target has icmp instructions which can compare a register against the</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">  /// the target has icmp instructions which can compare a register against the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">  /// immediate without having to materialize the immediate into a register.</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">  /// immediate without having to materialize the immediate into a register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">  virtual bool isLegalICmpImmediate(int64_t) const {</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">  virtual bool isLegalICmpImmediate(int64_t) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline"></td>
    <td class="lineNumber">2666</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">  /// Return true if the specified immediate is legal add immediate, that is the</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">  /// Return true if the specified immediate is legal add immediate, that is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline">  /// target has add instructions which can add a register with the immediate</td>
    <td class="lineNumber">2668</td>
    <td class="codeline">  /// target has add instructions which can add a register with the immediate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">  /// without having to materialize the immediate into a register.</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">  /// without having to materialize the immediate into a register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline">  virtual bool isLegalAddImmediate(int64_t) const {</td>
    <td class="lineNumber">2670</td>
    <td class="codeline">  virtual bool isLegalAddImmediate(int64_t) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2671</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2672</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline"></td>
    <td class="lineNumber">2673</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">  /// Return true if the specified immediate is legal for the value input of a</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">  /// Return true if the specified immediate is legal for the value input of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline">  /// store instruction.</td>
    <td class="lineNumber">2675</td>
    <td class="codeline">  /// store instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline">  virtual bool isLegalStoreImmediate(int64_t Value) const {</td>
    <td class="lineNumber">2676</td>
    <td class="codeline">  virtual bool isLegalStoreImmediate(int64_t Value) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline">    // Default implementation assumes that at least 0 works since it is likely</td>
    <td class="lineNumber">2677</td>
    <td class="codeline">    // Default implementation assumes that at least 0 works since it is likely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">    // that a zero register exists or a zero immediate is allowed.</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">    // that a zero register exists or a zero immediate is allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">    return Value == 0;</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">    return Value == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2680</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline"></td>
    <td class="lineNumber">2681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">  /// Return true if it's significantly cheaper to shift a vector by a uniform</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">  /// Return true if it's significantly cheaper to shift a vector by a uniform</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline">  /// scalar than by an amount which will vary across each lane. On x86 before</td>
    <td class="lineNumber">2683</td>
    <td class="codeline">  /// scalar than by an amount which will vary across each lane. On x86 before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline">  /// AVX2 for example, there is a "psllw" instruction for the former case, but</td>
    <td class="lineNumber">2684</td>
    <td class="codeline">  /// AVX2 for example, there is a "psllw" instruction for the former case, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline">  /// no simple instruction for a general "a << b" operation on vectors.</td>
    <td class="lineNumber">2685</td>
    <td class="codeline">  /// no simple instruction for a general "a << b" operation on vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline">  /// This should also apply to lowering for vector funnel shifts (rotates).</td>
    <td class="lineNumber">2686</td>
    <td class="codeline">  /// This should also apply to lowering for vector funnel shifts (rotates).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">  virtual bool isVectorShiftByScalarCheap(Type *Ty) const {</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">  virtual bool isVectorShiftByScalarCheap(Type *Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2688</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline"></td>
    <td class="lineNumber">2690</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline">  /// Given a shuffle vector SVI representing a vector splat, return a new</td>
    <td class="lineNumber">2691</td>
    <td class="codeline">  /// Given a shuffle vector SVI representing a vector splat, return a new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">  /// scalar type of size equal to SVI's scalar type if the new type is more</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">  /// scalar type of size equal to SVI's scalar type if the new type is more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">  /// profitable. Returns nullptr otherwise. For example under MVE float splats</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">  /// profitable. Returns nullptr otherwise. For example under MVE float splats</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline">  /// are converted to integer to prevent the need to move from SPR to GPR</td>
    <td class="lineNumber">2694</td>
    <td class="codeline">  /// are converted to integer to prevent the need to move from SPR to GPR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline">  /// registers.</td>
    <td class="lineNumber">2695</td>
    <td class="codeline">  /// registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline">  virtual Type* shouldConvertSplatType(ShuffleVectorInst* SVI) const {</td>
    <td class="lineNumber">2696</td>
    <td class="codeline">  virtual Type* shouldConvertSplatType(ShuffleVectorInst* SVI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2698</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline"></td>
    <td class="lineNumber">2699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline">  /// Given a set in interconnected phis of type 'From' that are loaded/stored</td>
    <td class="lineNumber">2700</td>
    <td class="codeline">  /// Given a set in interconnected phis of type 'From' that are loaded/stored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline">  /// or bitcast to type 'To', return true if the set should be converted to</td>
    <td class="lineNumber">2701</td>
    <td class="codeline">  /// or bitcast to type 'To', return true if the set should be converted to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline">  /// 'To'.</td>
    <td class="lineNumber">2702</td>
    <td class="codeline">  /// 'To'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline">  virtual bool shouldConvertPhiType(Type *From, Type *To) const {</td>
    <td class="lineNumber">2703</td>
    <td class="codeline">  virtual bool shouldConvertPhiType(Type *From, Type *To) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline">    return (From->isIntegerTy() || From->isFloatingPointTy()) &&</td>
    <td class="lineNumber">2704</td>
    <td class="codeline">    return (From->isIntegerTy() || From->isFloatingPointTy()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">           (To->isIntegerTy() || To->isFloatingPointTy());</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">           (To->isIntegerTy() || To->isFloatingPointTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2706</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline"></td>
    <td class="lineNumber">2707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">  /// Returns true if the opcode is a commutative binary operation.</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">  /// Returns true if the opcode is a commutative binary operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline">  virtual bool isCommutativeBinOp(unsigned Opcode) const {</td>
    <td class="lineNumber">2709</td>
    <td class="codeline">  virtual bool isCommutativeBinOp(unsigned Opcode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline">    // FIXME: This should get its info from the td file.</td>
    <td class="lineNumber">2710</td>
    <td class="codeline">    // FIXME: This should get its info from the td file.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline">    switch (Opcode) {</td>
    <td class="lineNumber">2711</td>
    <td class="codeline">    switch (Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline">    case ISD::ADD:</td>
    <td class="lineNumber">2712</td>
    <td class="codeline">    case ISD::ADD:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">    case ISD::SMIN:</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">    case ISD::SMIN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline">    case ISD::SMAX:</td>
    <td class="lineNumber">2714</td>
    <td class="codeline">    case ISD::SMAX:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline">    case ISD::UMIN:</td>
    <td class="lineNumber">2715</td>
    <td class="codeline">    case ISD::UMIN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">    case ISD::UMAX:</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">    case ISD::UMAX:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline">    case ISD::MUL:</td>
    <td class="lineNumber">2717</td>
    <td class="codeline">    case ISD::MUL:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline">    case ISD::MULHU:</td>
    <td class="lineNumber">2718</td>
    <td class="codeline">    case ISD::MULHU:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline">    case ISD::MULHS:</td>
    <td class="lineNumber">2719</td>
    <td class="codeline">    case ISD::MULHS:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline">    case ISD::SMUL_LOHI:</td>
    <td class="lineNumber">2720</td>
    <td class="codeline">    case ISD::SMUL_LOHI:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline">    case ISD::UMUL_LOHI:</td>
    <td class="lineNumber">2721</td>
    <td class="codeline">    case ISD::UMUL_LOHI:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline">    case ISD::FADD:</td>
    <td class="lineNumber">2722</td>
    <td class="codeline">    case ISD::FADD:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline">    case ISD::FMUL:</td>
    <td class="lineNumber">2723</td>
    <td class="codeline">    case ISD::FMUL:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline">    case ISD::AND:</td>
    <td class="lineNumber">2724</td>
    <td class="codeline">    case ISD::AND:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline">    case ISD::OR:</td>
    <td class="lineNumber">2725</td>
    <td class="codeline">    case ISD::OR:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline">    case ISD::XOR:</td>
    <td class="lineNumber">2726</td>
    <td class="codeline">    case ISD::XOR:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline">    case ISD::SADDO:</td>
    <td class="lineNumber">2727</td>
    <td class="codeline">    case ISD::SADDO:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeline">    case ISD::UADDO:</td>
    <td class="lineNumber">2728</td>
    <td class="codeline">    case ISD::UADDO:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeline">    case ISD::ADDC:</td>
    <td class="lineNumber">2729</td>
    <td class="codeline">    case ISD::ADDC:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeline">    case ISD::ADDE:</td>
    <td class="lineNumber">2730</td>
    <td class="codeline">    case ISD::ADDE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeline">    case ISD::SADDSAT:</td>
    <td class="lineNumber">2731</td>
    <td class="codeline">    case ISD::SADDSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeline">    case ISD::UADDSAT:</td>
    <td class="lineNumber">2732</td>
    <td class="codeline">    case ISD::UADDSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeline">    case ISD::FMINNUM:</td>
    <td class="lineNumber">2733</td>
    <td class="codeline">    case ISD::FMINNUM:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeline">    case ISD::FMAXNUM:</td>
    <td class="lineNumber">2734</td>
    <td class="codeline">    case ISD::FMAXNUM:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeline">    case ISD::FMINNUM_IEEE:</td>
    <td class="lineNumber">2735</td>
    <td class="codeline">    case ISD::FMINNUM_IEEE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeline">    case ISD::FMAXNUM_IEEE:</td>
    <td class="lineNumber">2736</td>
    <td class="codeline">    case ISD::FMAXNUM_IEEE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeline">    case ISD::FMINIMUM:</td>
    <td class="lineNumber">2737</td>
    <td class="codeline">    case ISD::FMINIMUM:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeline">    case ISD::FMAXIMUM:</td>
    <td class="lineNumber">2738</td>
    <td class="codeline">    case ISD::FMAXIMUM:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeline">    case ISD::AVGFLOORS:</td>
    <td class="lineNumber">2739</td>
    <td class="codeline">    case ISD::AVGFLOORS:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeline">    case ISD::AVGFLOORU:</td>
    <td class="lineNumber">2740</td>
    <td class="codeline">    case ISD::AVGFLOORU:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeline">    case ISD::AVGCEILS:</td>
    <td class="lineNumber">2741</td>
    <td class="codeline">    case ISD::AVGCEILS:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeline">    case ISD::AVGCEILU:</td>
    <td class="lineNumber">2742</td>
    <td class="codeline">    case ISD::AVGCEILU:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeline">    case ISD::ABDS:</td>
    <td class="lineNumber">2743</td>
    <td class="codeline">    case ISD::ABDS:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeline">    case ISD::ABDU:</td>
    <td class="lineNumber">2744</td>
    <td class="codeline">    case ISD::ABDU:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2745</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeline">    default: return false;</td>
    <td class="lineNumber">2746</td>
    <td class="codeline">    default: return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2747</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2748</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeline"></td>
    <td class="lineNumber">2749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeline">  /// Return true if the node is a math/logic binary operator.</td>
    <td class="lineNumber">2750</td>
    <td class="codeline">  /// Return true if the node is a math/logic binary operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeline">  virtual bool isBinOp(unsigned Opcode) const {</td>
    <td class="lineNumber">2751</td>
    <td class="codeline">  virtual bool isBinOp(unsigned Opcode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeline">    // A commutative binop must be a binop.</td>
    <td class="lineNumber">2752</td>
    <td class="codeline">    // A commutative binop must be a binop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeline">    if (isCommutativeBinOp(Opcode))</td>
    <td class="lineNumber">2753</td>
    <td class="codeline">    if (isCommutativeBinOp(Opcode))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2754</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeline">    // These are non-commutative binops.</td>
    <td class="lineNumber">2755</td>
    <td class="codeline">    // These are non-commutative binops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeline">    switch (Opcode) {</td>
    <td class="lineNumber">2756</td>
    <td class="codeline">    switch (Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeline">    case ISD::SUB:</td>
    <td class="lineNumber">2757</td>
    <td class="codeline">    case ISD::SUB:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeline">    case ISD::SHL:</td>
    <td class="lineNumber">2758</td>
    <td class="codeline">    case ISD::SHL:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeline">    case ISD::SRL:</td>
    <td class="lineNumber">2759</td>
    <td class="codeline">    case ISD::SRL:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeline">    case ISD::SRA:</td>
    <td class="lineNumber">2760</td>
    <td class="codeline">    case ISD::SRA:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeline">    case ISD::ROTL:</td>
    <td class="lineNumber">2761</td>
    <td class="codeline">    case ISD::ROTL:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeline">    case ISD::ROTR:</td>
    <td class="lineNumber">2762</td>
    <td class="codeline">    case ISD::ROTR:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeline">    case ISD::SDIV:</td>
    <td class="lineNumber">2763</td>
    <td class="codeline">    case ISD::SDIV:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeline">    case ISD::UDIV:</td>
    <td class="lineNumber">2764</td>
    <td class="codeline">    case ISD::UDIV:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeline">    case ISD::SREM:</td>
    <td class="lineNumber">2765</td>
    <td class="codeline">    case ISD::SREM:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeline">    case ISD::UREM:</td>
    <td class="lineNumber">2766</td>
    <td class="codeline">    case ISD::UREM:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeline">    case ISD::SSUBSAT:</td>
    <td class="lineNumber">2767</td>
    <td class="codeline">    case ISD::SSUBSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeline">    case ISD::USUBSAT:</td>
    <td class="lineNumber">2768</td>
    <td class="codeline">    case ISD::USUBSAT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeline">    case ISD::FSUB:</td>
    <td class="lineNumber">2769</td>
    <td class="codeline">    case ISD::FSUB:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeline">    case ISD::FDIV:</td>
    <td class="lineNumber">2770</td>
    <td class="codeline">    case ISD::FDIV:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeline">    case ISD::FREM:</td>
    <td class="lineNumber">2771</td>
    <td class="codeline">    case ISD::FREM:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2772</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">2773</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2774</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2775</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2776</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeline"></td>
    <td class="lineNumber">2777</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeline">  /// Return true if it's free to truncate a value of type FromTy to type</td>
    <td class="lineNumber">2778</td>
    <td class="codeline">  /// Return true if it's free to truncate a value of type FromTy to type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeline">  /// ToTy. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td class="lineNumber">2779</td>
    <td class="codeline">  /// ToTy. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeline">  /// by referencing its sub-register AX.</td>
    <td class="lineNumber">2780</td>
    <td class="codeline">  /// by referencing its sub-register AX.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeline">  /// Targets must return false when FromTy <= ToTy.</td>
    <td class="lineNumber">2781</td>
    <td class="codeline">  /// Targets must return false when FromTy <= ToTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeline">  virtual bool isTruncateFree(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">2782</td>
    <td class="codeline">  virtual bool isTruncateFree(Type *FromTy, Type *ToTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2783</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2784</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeline"></td>
    <td class="lineNumber">2785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeline">  /// Return true if a truncation from FromTy to ToTy is permitted when deciding</td>
    <td class="lineNumber">2786</td>
    <td class="codeline">  /// Return true if a truncation from FromTy to ToTy is permitted when deciding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeline">  /// whether a call is in tail position. Typically this means that both results</td>
    <td class="lineNumber">2787</td>
    <td class="codeline">  /// whether a call is in tail position. Typically this means that both results</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeline">  /// would be assigned to the same register or stack slot, but it could mean</td>
    <td class="lineNumber">2788</td>
    <td class="codeline">  /// would be assigned to the same register or stack slot, but it could mean</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeline">  /// the target performs adequate checks of its own before proceeding with the</td>
    <td class="lineNumber">2789</td>
    <td class="codeline">  /// the target performs adequate checks of its own before proceeding with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeline">  /// tail call.  Targets must return false when FromTy <= ToTy.</td>
    <td class="lineNumber">2790</td>
    <td class="codeline">  /// tail call.  Targets must return false when FromTy <= ToTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeline">  virtual bool allowTruncateForTailCall(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">2791</td>
    <td class="codeline">  virtual bool allowTruncateForTailCall(Type *FromTy, Type *ToTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2792</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2793</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeline"></td>
    <td class="lineNumber">2794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeline">  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const { return false; }</td>
    <td class="lineNumber">2795</td>
    <td class="codeline">  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeline">  virtual bool isTruncateFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td class="lineNumber">2796</td>
    <td class="codeline">  virtual bool isTruncateFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeline">                              LLVMContext &Ctx) const {</td>
    <td class="lineNumber">2797</td>
    <td class="codeline">                              LLVMContext &Ctx) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeline">    return isTruncateFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td class="lineNumber">2798</td>
    <td class="codeline">    return isTruncateFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeline">                          getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td class="lineNumber">2799</td>
    <td class="codeline">                          getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2800</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeline"></td>
    <td class="lineNumber">2801</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeline">  virtual bool isProfitableToHoist(Instruction *I) const { return true; }</td>
    <td class="lineNumber">2802</td>
    <td class="codeline">  virtual bool isProfitableToHoist(Instruction *I) const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeline"></td>
    <td class="lineNumber">2803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeline">  /// Return true if the extension represented by \p I is free.</td>
    <td class="lineNumber">2804</td>
    <td class="codeline">  /// Return true if the extension represented by \p I is free.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeline">  /// Unlikely the is[Z|FP]ExtFree family which is based on types,</td>
    <td class="lineNumber">2805</td>
    <td class="codeline">  /// Unlikely the is[Z|FP]ExtFree family which is based on types,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeline">  /// this method can use the context provided by \p I to decide</td>
    <td class="lineNumber">2806</td>
    <td class="codeline">  /// this method can use the context provided by \p I to decide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeline">  /// whether or not \p I is free.</td>
    <td class="lineNumber">2807</td>
    <td class="codeline">  /// whether or not \p I is free.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeline">  /// This method extends the behavior of the is[Z|FP]ExtFree family.</td>
    <td class="lineNumber">2808</td>
    <td class="codeline">  /// This method extends the behavior of the is[Z|FP]ExtFree family.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeline">  /// In other words, if is[Z|FP]Free returns true, then this method</td>
    <td class="lineNumber">2809</td>
    <td class="codeline">  /// In other words, if is[Z|FP]Free returns true, then this method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeline">  /// returns true as well. The converse is not true.</td>
    <td class="lineNumber">2810</td>
    <td class="codeline">  /// returns true as well. The converse is not true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeline">  /// The target can perform the adequate checks by overriding isExtFreeImpl.</td>
    <td class="lineNumber">2811</td>
    <td class="codeline">  /// The target can perform the adequate checks by overriding isExtFreeImpl.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeline">  /// \pre \p I must be a sign, zero, or fp extension.</td>
    <td class="lineNumber">2812</td>
    <td class="codeline">  /// \pre \p I must be a sign, zero, or fp extension.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeline">  bool isExtFree(const Instruction *I) const {</td>
    <td class="lineNumber">2813</td>
    <td class="codeline">  bool isExtFree(const Instruction *I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeline">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">2814</td>
    <td class="codeline">    switch (I->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeline">    case Instruction::FPExt:</td>
    <td class="lineNumber">2815</td>
    <td class="codeline">    case Instruction::FPExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeline">      if (isFPExtFree(EVT::getEVT(I->getType()),</td>
    <td class="lineNumber">2816</td>
    <td class="codeline">      if (isFPExtFree(EVT::getEVT(I->getType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeline">                      EVT::getEVT(I->getOperand(0)->getType())))</td>
    <td class="lineNumber">2817</td>
    <td class="codeline">                      EVT::getEVT(I->getOperand(0)->getType())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">2818</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2819</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeline">    case Instruction::ZExt:</td>
    <td class="lineNumber">2820</td>
    <td class="codeline">    case Instruction::ZExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeline">      if (isZExtFree(I->getOperand(0)->getType(), I->getType()))</td>
    <td class="lineNumber">2821</td>
    <td class="codeline">      if (isZExtFree(I->getOperand(0)->getType(), I->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">2822</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2823</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeline">    case Instruction::SExt:</td>
    <td class="lineNumber">2824</td>
    <td class="codeline">    case Instruction::SExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2825</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">2826</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeline">      llvm_unreachable("Instruction is not an extension");</td>
    <td class="lineNumber">2827</td>
    <td class="codeline">      llvm_unreachable("Instruction is not an extension");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2828</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeline">    return isExtFreeImpl(I);</td>
    <td class="lineNumber">2829</td>
    <td class="codeline">    return isExtFreeImpl(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2830</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeline"></td>
    <td class="lineNumber">2831</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeline">  /// Return true if \p Load and \p Ext can form an ExtLoad.</td>
    <td class="lineNumber">2832</td>
    <td class="codeline">  /// Return true if \p Load and \p Ext can form an ExtLoad.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeline">  /// For example, in AArch64</td>
    <td class="lineNumber">2833</td>
    <td class="codeline">  /// For example, in AArch64</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeline">  ///   %L = load i8, i8* %ptr</td>
    <td class="lineNumber">2834</td>
    <td class="codeline">  ///   %L = load i8, i8* %ptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeline">  ///   %E = zext i8 %L to i32</td>
    <td class="lineNumber">2835</td>
    <td class="codeline">  ///   %E = zext i8 %L to i32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeline">  /// can be lowered into one load instruction</td>
    <td class="lineNumber">2836</td>
    <td class="codeline">  /// can be lowered into one load instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeline">  ///   ldrb w0, [x0]</td>
    <td class="lineNumber">2837</td>
    <td class="codeline">  ///   ldrb w0, [x0]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeline">  bool isExtLoad(const LoadInst *Load, const Instruction *Ext,</td>
    <td class="lineNumber">2838</td>
    <td class="codeline">  bool isExtLoad(const LoadInst *Load, const Instruction *Ext,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeline">                 const DataLayout &DL) const {</td>
    <td class="lineNumber">2839</td>
    <td class="codeline">                 const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeline">    EVT VT = getValueType(DL, Ext->getType());</td>
    <td class="lineNumber">2840</td>
    <td class="codeline">    EVT VT = getValueType(DL, Ext->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeline">    EVT LoadVT = getValueType(DL, Load->getType());</td>
    <td class="lineNumber">2841</td>
    <td class="codeline">    EVT LoadVT = getValueType(DL, Load->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeline"></td>
    <td class="lineNumber">2842</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeline">    // If the load has other users and the truncate is not free, the ext</td>
    <td class="lineNumber">2843</td>
    <td class="codeline">    // If the load has other users and the truncate is not free, the ext</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeline">    // probably isn't free.</td>
    <td class="lineNumber">2844</td>
    <td class="codeline">    // probably isn't free.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeline">    if (!Load->hasOneUse() && (isTypeLegal(LoadVT) || !isTypeLegal(VT)) &&</td>
    <td class="lineNumber">2845</td>
    <td class="codeline">    if (!Load->hasOneUse() && (isTypeLegal(LoadVT) || !isTypeLegal(VT)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeline">        !isTruncateFree(Ext->getType(), Load->getType()))</td>
    <td class="lineNumber">2846</td>
    <td class="codeline">        !isTruncateFree(Ext->getType(), Load->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2847</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeline"></td>
    <td class="lineNumber">2848</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeline">    // Check whether the target supports casts folded into loads.</td>
    <td class="lineNumber">2849</td>
    <td class="codeline">    // Check whether the target supports casts folded into loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeline">    unsigned LType;</td>
    <td class="lineNumber">2850</td>
    <td class="codeline">    unsigned LType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeline">    if (isa<ZExtInst>(Ext))</td>
    <td class="lineNumber">2851</td>
    <td class="codeline">    if (isa<ZExtInst>(Ext))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeline">      LType = ISD::ZEXTLOAD;</td>
    <td class="lineNumber">2852</td>
    <td class="codeline">      LType = ISD::ZEXTLOAD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeline">    else {</td>
    <td class="lineNumber">2853</td>
    <td class="codeline">    else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeline">      assert(isa<SExtInst>(Ext) && "Unexpected ext type!");</td>
    <td class="lineNumber">2854</td>
    <td class="codeline">      assert(isa<SExtInst>(Ext) && "Unexpected ext type!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeline">      LType = ISD::SEXTLOAD;</td>
    <td class="lineNumber">2855</td>
    <td class="codeline">      LType = ISD::SEXTLOAD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2856</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeline"></td>
    <td class="lineNumber">2857</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeline">    return isLoadExtLegal(LType, VT, LoadVT);</td>
    <td class="lineNumber">2858</td>
    <td class="codeline">    return isLoadExtLegal(LType, VT, LoadVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2859</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeline"></td>
    <td class="lineNumber">2860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeline">  /// Return true if any actual instruction that defines a value of type FromTy</td>
    <td class="lineNumber">2861</td>
    <td class="codeline">  /// Return true if any actual instruction that defines a value of type FromTy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeline">  /// implicitly zero-extends the value to ToTy in the result register.</td>
    <td class="lineNumber">2862</td>
    <td class="codeline">  /// implicitly zero-extends the value to ToTy in the result register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2863</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeline">  /// The function should return true when it is likely that the truncate can</td>
    <td class="lineNumber">2864</td>
    <td class="codeline">  /// The function should return true when it is likely that the truncate can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeline">  /// be freely folded with an instruction defining a value of FromTy. If</td>
    <td class="lineNumber">2865</td>
    <td class="codeline">  /// be freely folded with an instruction defining a value of FromTy. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeline">  /// the defining instruction is unknown (because you're looking at a</td>
    <td class="lineNumber">2866</td>
    <td class="codeline">  /// the defining instruction is unknown (because you're looking at a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeline">  /// function argument, PHI, etc.) then the target may require an</td>
    <td class="lineNumber">2867</td>
    <td class="codeline">  /// function argument, PHI, etc.) then the target may require an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeline">  /// explicit truncate, which is not necessarily free, but this function</td>
    <td class="lineNumber">2868</td>
    <td class="codeline">  /// explicit truncate, which is not necessarily free, but this function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeline">  /// does not deal with those cases.</td>
    <td class="lineNumber">2869</td>
    <td class="codeline">  /// does not deal with those cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeline">  /// Targets must return false when FromTy >= ToTy.</td>
    <td class="lineNumber">2870</td>
    <td class="codeline">  /// Targets must return false when FromTy >= ToTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeline">  virtual bool isZExtFree(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">2871</td>
    <td class="codeline">  virtual bool isZExtFree(Type *FromTy, Type *ToTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2872</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2873</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeline"></td>
    <td class="lineNumber">2874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeline">  virtual bool isZExtFree(EVT FromTy, EVT ToTy) const { return false; }</td>
    <td class="lineNumber">2875</td>
    <td class="codeline">  virtual bool isZExtFree(EVT FromTy, EVT ToTy) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeline">  virtual bool isZExtFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td class="lineNumber">2876</td>
    <td class="codeline">  virtual bool isZExtFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeline">                          LLVMContext &Ctx) const {</td>
    <td class="lineNumber">2877</td>
    <td class="codeline">                          LLVMContext &Ctx) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeline">    return isZExtFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td class="lineNumber">2878</td>
    <td class="codeline">    return isZExtFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeline">                      getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td class="lineNumber">2879</td>
    <td class="codeline">                      getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2880</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeline"></td>
    <td class="lineNumber">2881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeline">  /// Return true if zero-extending the specific node Val to type VT2 is free</td>
    <td class="lineNumber">2882</td>
    <td class="codeline">  /// Return true if zero-extending the specific node Val to type VT2 is free</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeline">  /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or</td>
    <td class="lineNumber">2883</td>
    <td class="codeline">  /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeline">  /// because it's folded such as X86 zero-extending loads).</td>
    <td class="lineNumber">2884</td>
    <td class="codeline">  /// because it's folded such as X86 zero-extending loads).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeline">  virtual bool isZExtFree(SDValue Val, EVT VT2) const {</td>
    <td class="lineNumber">2885</td>
    <td class="codeline">  virtual bool isZExtFree(SDValue Val, EVT VT2) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeline">    return isZExtFree(Val.getValueType(), VT2);</td>
    <td class="lineNumber">2886</td>
    <td class="codeline">    return isZExtFree(Val.getValueType(), VT2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2887</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeline"></td>
    <td class="lineNumber">2888</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeline">  /// Return true if sign-extension from FromTy to ToTy is cheaper than</td>
    <td class="lineNumber">2889</td>
    <td class="codeline">  /// Return true if sign-extension from FromTy to ToTy is cheaper than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeline">  /// zero-extension.</td>
    <td class="lineNumber">2890</td>
    <td class="codeline">  /// zero-extension.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeline">  virtual bool isSExtCheaperThanZExt(EVT FromTy, EVT ToTy) const {</td>
    <td class="lineNumber">2891</td>
    <td class="codeline">  virtual bool isSExtCheaperThanZExt(EVT FromTy, EVT ToTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2892</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2893</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeline"></td>
    <td class="lineNumber">2894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeline">  /// Return true if this constant should be sign extended when promoting to</td>
    <td class="lineNumber">2895</td>
    <td class="codeline">  /// Return true if this constant should be sign extended when promoting to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeline">  /// a larger type.</td>
    <td class="lineNumber">2896</td>
    <td class="codeline">  /// a larger type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeline">  virtual bool signExtendConstant(const ConstantInt *C) const { return false; }</td>
    <td class="lineNumber">2897</td>
    <td class="codeline">  virtual bool signExtendConstant(const ConstantInt *C) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeline"></td>
    <td class="lineNumber">2898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeline">  /// Return true if sinking I's operands to the same basic block as I is</td>
    <td class="lineNumber">2899</td>
    <td class="codeline">  /// Return true if sinking I's operands to the same basic block as I is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeline">  /// profitable, e.g. because the operands can be folded into a target</td>
    <td class="lineNumber">2900</td>
    <td class="codeline">  /// profitable, e.g. because the operands can be folded into a target</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeline">  /// instruction during instruction selection. After calling the function</td>
    <td class="lineNumber">2901</td>
    <td class="codeline">  /// instruction during instruction selection. After calling the function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeline">  /// \p Ops contains the Uses to sink ordered by dominance (dominating users</td>
    <td class="lineNumber">2902</td>
    <td class="codeline">  /// \p Ops contains the Uses to sink ordered by dominance (dominating users</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeline">  /// come first).</td>
    <td class="lineNumber">2903</td>
    <td class="codeline">  /// come first).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeline">  virtual bool shouldSinkOperands(Instruction *I,</td>
    <td class="lineNumber">2904</td>
    <td class="codeline">  virtual bool shouldSinkOperands(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeline">                                  SmallVectorImpl<Use *> &Ops) const {</td>
    <td class="lineNumber">2905</td>
    <td class="codeline">                                  SmallVectorImpl<Use *> &Ops) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2906</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2907</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeline"></td>
    <td class="lineNumber">2908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeline">  /// Try to optimize extending or truncating conversion instructions (like</td>
    <td class="lineNumber">2909</td>
    <td class="codeline">  /// Try to optimize extending or truncating conversion instructions (like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeline">  /// zext, trunc, fptoui, uitofp) for the target.</td>
    <td class="lineNumber">2910</td>
    <td class="codeline">  /// zext, trunc, fptoui, uitofp) for the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">2911</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeline">  optimizeExtendOrTruncateConversion(Instruction *I, Loop *L,</td>
    <td class="lineNumber">2912</td>
    <td class="codeline">  optimizeExtendOrTruncateConversion(Instruction *I, Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeline">                                     const TargetTransformInfo &TTI) const {</td>
    <td class="lineNumber">2913</td>
    <td class="codeline">                                     const TargetTransformInfo &TTI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2914</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2915</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeline"></td>
    <td class="lineNumber">2916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeline">  /// Return true if the target supplies and combines to a paired load</td>
    <td class="lineNumber">2917</td>
    <td class="codeline">  /// Return true if the target supplies and combines to a paired load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeline">  /// two loaded values of type LoadedType next to each other in memory.</td>
    <td class="lineNumber">2918</td>
    <td class="codeline">  /// two loaded values of type LoadedType next to each other in memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeline">  /// RequiredAlignment gives the minimal alignment constraints that must be met</td>
    <td class="lineNumber">2919</td>
    <td class="codeline">  /// RequiredAlignment gives the minimal alignment constraints that must be met</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeline">  /// to be able to select this paired load.</td>
    <td class="lineNumber">2920</td>
    <td class="codeline">  /// to be able to select this paired load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2921</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeline">  /// This information is *not* used to generate actual paired loads, but it is</td>
    <td class="lineNumber">2922</td>
    <td class="codeline">  /// This information is *not* used to generate actual paired loads, but it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeline">  /// used to generate a sequence of loads that is easier to combine into a</td>
    <td class="lineNumber">2923</td>
    <td class="codeline">  /// used to generate a sequence of loads that is easier to combine into a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeline">  /// paired load.</td>
    <td class="lineNumber">2924</td>
    <td class="codeline">  /// paired load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeline">  /// For instance, something like this:</td>
    <td class="lineNumber">2925</td>
    <td class="codeline">  /// For instance, something like this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeline">  /// a = load i64* addr</td>
    <td class="lineNumber">2926</td>
    <td class="codeline">  /// a = load i64* addr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeline">  /// b = trunc i64 a to i32</td>
    <td class="lineNumber">2927</td>
    <td class="codeline">  /// b = trunc i64 a to i32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeline">  /// c = lshr i64 a, 32</td>
    <td class="lineNumber">2928</td>
    <td class="codeline">  /// c = lshr i64 a, 32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeline">  /// d = trunc i64 c to i32</td>
    <td class="lineNumber">2929</td>
    <td class="codeline">  /// d = trunc i64 c to i32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeline">  /// will be optimized into:</td>
    <td class="lineNumber">2930</td>
    <td class="codeline">  /// will be optimized into:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeline">  /// b = load i32* addr1</td>
    <td class="lineNumber">2931</td>
    <td class="codeline">  /// b = load i32* addr1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeline">  /// d = load i32* addr2</td>
    <td class="lineNumber">2932</td>
    <td class="codeline">  /// d = load i32* addr2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeline">  /// Where addr1 = addr2 +/- sizeof(i32).</td>
    <td class="lineNumber">2933</td>
    <td class="codeline">  /// Where addr1 = addr2 +/- sizeof(i32).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2934</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeline">  /// In other words, unless the target performs a post-isel load combining,</td>
    <td class="lineNumber">2935</td>
    <td class="codeline">  /// In other words, unless the target performs a post-isel load combining,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeline">  /// this information should not be provided because it will generate more</td>
    <td class="lineNumber">2936</td>
    <td class="codeline">  /// this information should not be provided because it will generate more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeline">  /// loads.</td>
    <td class="lineNumber">2937</td>
    <td class="codeline">  /// loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeline">  virtual bool hasPairedLoad(EVT /*LoadedType*/,</td>
    <td class="lineNumber">2938</td>
    <td class="codeline">  virtual bool hasPairedLoad(EVT /*LoadedType*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeline">                             Align & /*RequiredAlignment*/) const {</td>
    <td class="lineNumber">2939</td>
    <td class="codeline">                             Align & /*RequiredAlignment*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2940</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2941</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeline"></td>
    <td class="lineNumber">2942</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeline">  /// Return true if the target has a vector blend instruction.</td>
    <td class="lineNumber">2943</td>
    <td class="codeline">  /// Return true if the target has a vector blend instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeline">  virtual bool hasVectorBlend() const { return false; }</td>
    <td class="lineNumber">2944</td>
    <td class="codeline">  virtual bool hasVectorBlend() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeline"></td>
    <td class="lineNumber">2945</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeline">  /// Get the maximum supported factor for interleaved memory accesses.</td>
    <td class="lineNumber">2946</td>
    <td class="codeline">  /// Get the maximum supported factor for interleaved memory accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeline">  /// Default to be the minimum interleave factor: 2.</td>
    <td class="lineNumber">2947</td>
    <td class="codeline">  /// Default to be the minimum interleave factor: 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeline">  virtual unsigned getMaxSupportedInterleaveFactor() const { return 2; }</td>
    <td class="lineNumber">2948</td>
    <td class="codeline">  virtual unsigned getMaxSupportedInterleaveFactor() const { return 2; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeline"></td>
    <td class="lineNumber">2949</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeline">  /// Lower an interleaved load to target specific intrinsics. Return</td>
    <td class="lineNumber">2950</td>
    <td class="codeline">  /// Lower an interleaved load to target specific intrinsics. Return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeline">  /// true on success.</td>
    <td class="lineNumber">2951</td>
    <td class="codeline">  /// true on success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2952</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeline">  /// \p LI is the vector load instruction.</td>
    <td class="lineNumber">2953</td>
    <td class="codeline">  /// \p LI is the vector load instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeline">  /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.</td>
    <td class="lineNumber">2954</td>
    <td class="codeline">  /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeline">  /// \p Indices is the corresponding indices for each shufflevector.</td>
    <td class="lineNumber">2955</td>
    <td class="codeline">  /// \p Indices is the corresponding indices for each shufflevector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeline">  /// \p Factor is the interleave factor.</td>
    <td class="lineNumber">2956</td>
    <td class="codeline">  /// \p Factor is the interleave factor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeline">  virtual bool lowerInterleavedLoad(LoadInst *LI,</td>
    <td class="lineNumber">2957</td>
    <td class="codeline">  virtual bool lowerInterleavedLoad(LoadInst *LI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeline">                                    ArrayRef<ShuffleVectorInst *> Shuffles,</td>
    <td class="lineNumber">2958</td>
    <td class="codeline">                                    ArrayRef<ShuffleVectorInst *> Shuffles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeline">                                    ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">2959</td>
    <td class="codeline">                                    ArrayRef<unsigned> Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeline">                                    unsigned Factor) const {</td>
    <td class="lineNumber">2960</td>
    <td class="codeline">                                    unsigned Factor) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2961</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2962</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeline"></td>
    <td class="lineNumber">2963</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeline">  /// Lower an interleaved store to target specific intrinsics. Return</td>
    <td class="lineNumber">2964</td>
    <td class="codeline">  /// Lower an interleaved store to target specific intrinsics. Return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeline">  /// true on success.</td>
    <td class="lineNumber">2965</td>
    <td class="codeline">  /// true on success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2966</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeline">  /// \p SI is the vector store instruction.</td>
    <td class="lineNumber">2967</td>
    <td class="codeline">  /// \p SI is the vector store instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeline">  /// \p SVI is the shufflevector to RE-interleave the stored vector.</td>
    <td class="lineNumber">2968</td>
    <td class="codeline">  /// \p SVI is the shufflevector to RE-interleave the stored vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeline">  /// \p Factor is the interleave factor.</td>
    <td class="lineNumber">2969</td>
    <td class="codeline">  /// \p Factor is the interleave factor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeline">  virtual bool lowerInterleavedStore(StoreInst *SI, ShuffleVectorInst *SVI,</td>
    <td class="lineNumber">2970</td>
    <td class="codeline">  virtual bool lowerInterleavedStore(StoreInst *SI, ShuffleVectorInst *SVI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeline">                                     unsigned Factor) const {</td>
    <td class="lineNumber">2971</td>
    <td class="codeline">                                     unsigned Factor) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2972</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2973</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeline"></td>
    <td class="lineNumber">2974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeline">  /// Lower a deinterleave intrinsic to a target specific load intrinsic.</td>
    <td class="lineNumber">2975</td>
    <td class="codeline">  /// Lower a deinterleave intrinsic to a target specific load intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeline">  /// Return true on success. Currently only supports</td>
    <td class="lineNumber">2976</td>
    <td class="codeline">  /// Return true on success. Currently only supports</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeline">  /// llvm.experimental.vector.deinterleave2</td>
    <td class="lineNumber">2977</td>
    <td class="codeline">  /// llvm.experimental.vector.deinterleave2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2978</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeline">  /// \p DI is the deinterleave intrinsic.</td>
    <td class="lineNumber">2979</td>
    <td class="codeline">  /// \p DI is the deinterleave intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeline">  /// \p LI is the accompanying load instruction</td>
    <td class="lineNumber">2980</td>
    <td class="codeline">  /// \p LI is the accompanying load instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeline">  virtual bool lowerDeinterleaveIntrinsicToLoad(IntrinsicInst *DI,</td>
    <td class="lineNumber">2981</td>
    <td class="codeline">  virtual bool lowerDeinterleaveIntrinsicToLoad(IntrinsicInst *DI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeline">                                                LoadInst *LI) const {</td>
    <td class="lineNumber">2982</td>
    <td class="codeline">                                                LoadInst *LI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2983</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2984</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeline"></td>
    <td class="lineNumber">2985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeline">  /// Lower an interleave intrinsic to a target specific store intrinsic.</td>
    <td class="lineNumber">2986</td>
    <td class="codeline">  /// Lower an interleave intrinsic to a target specific store intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeline">  /// Return true on success. Currently only supports</td>
    <td class="lineNumber">2987</td>
    <td class="codeline">  /// Return true on success. Currently only supports</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeline">  /// llvm.experimental.vector.interleave2</td>
    <td class="lineNumber">2988</td>
    <td class="codeline">  /// llvm.experimental.vector.interleave2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2989</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeline">  /// \p II is the interleave intrinsic.</td>
    <td class="lineNumber">2990</td>
    <td class="codeline">  /// \p II is the interleave intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeline">  /// \p SI is the accompanying store instruction</td>
    <td class="lineNumber">2991</td>
    <td class="codeline">  /// \p SI is the accompanying store instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeline">  virtual bool lowerInterleaveIntrinsicToStore(IntrinsicInst *II,</td>
    <td class="lineNumber">2992</td>
    <td class="codeline">  virtual bool lowerInterleaveIntrinsicToStore(IntrinsicInst *II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeline">                                               StoreInst *SI) const {</td>
    <td class="lineNumber">2993</td>
    <td class="codeline">                                               StoreInst *SI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2994</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2995</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeline"></td>
    <td class="lineNumber">2996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeline">  /// Return true if an fpext operation is free (for instance, because</td>
    <td class="lineNumber">2997</td>
    <td class="codeline">  /// Return true if an fpext operation is free (for instance, because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeline">  /// single-precision floating-point numbers are implicitly extended to</td>
    <td class="lineNumber">2998</td>
    <td class="codeline">  /// single-precision floating-point numbers are implicitly extended to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeline">  /// double-precision).</td>
    <td class="lineNumber">2999</td>
    <td class="codeline">  /// double-precision).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeline">  virtual bool isFPExtFree(EVT DestVT, EVT SrcVT) const {</td>
    <td class="lineNumber">3000</td>
    <td class="codeline">  virtual bool isFPExtFree(EVT DestVT, EVT SrcVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeline">    assert(SrcVT.isFloatingPoint() && DestVT.isFloatingPoint() &&</td>
    <td class="lineNumber">3001</td>
    <td class="codeline">    assert(SrcVT.isFloatingPoint() && DestVT.isFloatingPoint() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeline">           "invalid fpext types");</td>
    <td class="lineNumber">3002</td>
    <td class="codeline">           "invalid fpext types");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3003</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3004</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeline"></td>
    <td class="lineNumber">3005</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeline">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td class="lineNumber">3006</td>
    <td class="codeline">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeline">  /// (for instance, because half-precision floating-point numbers are</td>
    <td class="lineNumber">3007</td>
    <td class="codeline">  /// (for instance, because half-precision floating-point numbers are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeline">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td class="lineNumber">3008</td>
    <td class="codeline">  /// implicitly extended to float-precision) for an FMA instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeline">  virtual bool isFPExtFoldable(const MachineInstr &MI, unsigned Opcode,</td>
    <td class="lineNumber">3009</td>
    <td class="codeline">  virtual bool isFPExtFoldable(const MachineInstr &MI, unsigned Opcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeline">                               LLT DestTy, LLT SrcTy) const {</td>
    <td class="lineNumber">3010</td>
    <td class="codeline">                               LLT DestTy, LLT SrcTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3011</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3012</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeline"></td>
    <td class="lineNumber">3013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeline">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td class="lineNumber">3014</td>
    <td class="codeline">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeline">  /// (for instance, because half-precision floating-point numbers are</td>
    <td class="lineNumber">3015</td>
    <td class="codeline">  /// (for instance, because half-precision floating-point numbers are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeline">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td class="lineNumber">3016</td>
    <td class="codeline">  /// implicitly extended to float-precision) for an FMA instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeline">  virtual bool isFPExtFoldable(const SelectionDAG &DAG, unsigned Opcode,</td>
    <td class="lineNumber">3017</td>
    <td class="codeline">  virtual bool isFPExtFoldable(const SelectionDAG &DAG, unsigned Opcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeline">                               EVT DestVT, EVT SrcVT) const {</td>
    <td class="lineNumber">3018</td>
    <td class="codeline">                               EVT DestVT, EVT SrcVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeline">    assert(DestVT.isFloatingPoint() && SrcVT.isFloatingPoint() &&</td>
    <td class="lineNumber">3019</td>
    <td class="codeline">    assert(DestVT.isFloatingPoint() && SrcVT.isFloatingPoint() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeline">           "invalid fpext types");</td>
    <td class="lineNumber">3020</td>
    <td class="codeline">           "invalid fpext types");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeline">    return isFPExtFree(DestVT, SrcVT);</td>
    <td class="lineNumber">3021</td>
    <td class="codeline">    return isFPExtFree(DestVT, SrcVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3022</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeline"></td>
    <td class="lineNumber">3023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeline">  /// Return true if folding a vector load into ExtVal (a sign, zero, or any</td>
    <td class="lineNumber">3024</td>
    <td class="codeline">  /// Return true if folding a vector load into ExtVal (a sign, zero, or any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeline">  /// extend node) is profitable.</td>
    <td class="lineNumber">3025</td>
    <td class="codeline">  /// extend node) is profitable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeline">  virtual bool isVectorLoadExtDesirable(SDValue ExtVal) const { return false; }</td>
    <td class="lineNumber">3026</td>
    <td class="codeline">  virtual bool isVectorLoadExtDesirable(SDValue ExtVal) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeline"></td>
    <td class="lineNumber">3027</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeline">  /// Return true if an fneg operation is free to the point where it is never</td>
    <td class="lineNumber">3028</td>
    <td class="codeline">  /// Return true if an fneg operation is free to the point where it is never</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeline">  /// worthwhile to replace it with a bitwise operation.</td>
    <td class="lineNumber">3029</td>
    <td class="codeline">  /// worthwhile to replace it with a bitwise operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeline">  virtual bool isFNegFree(EVT VT) const {</td>
    <td class="lineNumber">3030</td>
    <td class="codeline">  virtual bool isFNegFree(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeline">    assert(VT.isFloatingPoint());</td>
    <td class="lineNumber">3031</td>
    <td class="codeline">    assert(VT.isFloatingPoint());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3032</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3033</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeline"></td>
    <td class="lineNumber">3034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeline">  /// Return true if an fabs operation is free to the point where it is never</td>
    <td class="lineNumber">3035</td>
    <td class="codeline">  /// Return true if an fabs operation is free to the point where it is never</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeline">  /// worthwhile to replace it with a bitwise operation.</td>
    <td class="lineNumber">3036</td>
    <td class="codeline">  /// worthwhile to replace it with a bitwise operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeline">  virtual bool isFAbsFree(EVT VT) const {</td>
    <td class="lineNumber">3037</td>
    <td class="codeline">  virtual bool isFAbsFree(EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeline">    assert(VT.isFloatingPoint());</td>
    <td class="lineNumber">3038</td>
    <td class="codeline">    assert(VT.isFloatingPoint());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3039</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3040</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeline"></td>
    <td class="lineNumber">3041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeline">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td class="lineNumber">3042</td>
    <td class="codeline">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeline">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td class="lineNumber">3043</td>
    <td class="codeline">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeline">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td class="lineNumber">3044</td>
    <td class="codeline">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3045</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeline">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td class="lineNumber">3046</td>
    <td class="codeline">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeline">  /// not legal, but should return true if those types will eventually legalize</td>
    <td class="lineNumber">3047</td>
    <td class="codeline">  /// not legal, but should return true if those types will eventually legalize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeline">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td class="lineNumber">3048</td>
    <td class="codeline">  /// to types that support FMAs. After legalization, it will only be called on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeline">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td class="lineNumber">3049</td>
    <td class="codeline">  /// types that support FMAs (via Legal or Custom actions)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeline">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td class="lineNumber">3050</td>
    <td class="codeline">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeline">                                          EVT) const {</td>
    <td class="lineNumber">3051</td>
    <td class="codeline">                                          EVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3052</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3053</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeline"></td>
    <td class="lineNumber">3054</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeline">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td class="lineNumber">3055</td>
    <td class="codeline">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeline">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td class="lineNumber">3056</td>
    <td class="codeline">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeline">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td class="lineNumber">3057</td>
    <td class="codeline">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3058</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeline">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td class="lineNumber">3059</td>
    <td class="codeline">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeline">  /// not legal, but should return true if those types will eventually legalize</td>
    <td class="lineNumber">3060</td>
    <td class="codeline">  /// not legal, but should return true if those types will eventually legalize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeline">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td class="lineNumber">3061</td>
    <td class="codeline">  /// to types that support FMAs. After legalization, it will only be called on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeline">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td class="lineNumber">3062</td>
    <td class="codeline">  /// types that support FMAs (via Legal or Custom actions)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeline">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td class="lineNumber">3063</td>
    <td class="codeline">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeline">                                          LLT) const {</td>
    <td class="lineNumber">3064</td>
    <td class="codeline">                                          LLT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3065</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3066</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeline"></td>
    <td class="lineNumber">3067</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeline">  /// IR version</td>
    <td class="lineNumber">3068</td>
    <td class="codeline">  /// IR version</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeline">  virtual bool isFMAFasterThanFMulAndFAdd(const Function &F, Type *) const {</td>
    <td class="lineNumber">3069</td>
    <td class="codeline">  virtual bool isFMAFasterThanFMulAndFAdd(const Function &F, Type *) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3070</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3071</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeline"></td>
    <td class="lineNumber">3072</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeline">  /// Returns true if \p MI can be combined with another instruction to</td>
    <td class="lineNumber">3073</td>
    <td class="codeline">  /// Returns true if \p MI can be combined with another instruction to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeline">  /// form TargetOpcode::G_FMAD. \p N may be an TargetOpcode::G_FADD,</td>
    <td class="lineNumber">3074</td>
    <td class="codeline">  /// form TargetOpcode::G_FMAD. \p N may be an TargetOpcode::G_FADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeline">  /// TargetOpcode::G_FSUB, or an TargetOpcode::G_FMUL which will be</td>
    <td class="lineNumber">3075</td>
    <td class="codeline">  /// TargetOpcode::G_FSUB, or an TargetOpcode::G_FMUL which will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeline">  /// distributed into an fadd/fsub.</td>
    <td class="lineNumber">3076</td>
    <td class="codeline">  /// distributed into an fadd/fsub.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeline">  virtual bool isFMADLegal(const MachineInstr &MI, LLT Ty) const {</td>
    <td class="lineNumber">3077</td>
    <td class="codeline">  virtual bool isFMADLegal(const MachineInstr &MI, LLT Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeline">    assert((MI.getOpcode() == TargetOpcode::G_FADD ||</td>
    <td class="lineNumber">3078</td>
    <td class="codeline">    assert((MI.getOpcode() == TargetOpcode::G_FADD ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeline">            MI.getOpcode() == TargetOpcode::G_FSUB ||</td>
    <td class="lineNumber">3079</td>
    <td class="codeline">            MI.getOpcode() == TargetOpcode::G_FSUB ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeline">            MI.getOpcode() == TargetOpcode::G_FMUL) &&</td>
    <td class="lineNumber">3080</td>
    <td class="codeline">            MI.getOpcode() == TargetOpcode::G_FMUL) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeline">           "unexpected node in FMAD forming combine");</td>
    <td class="lineNumber">3081</td>
    <td class="codeline">           "unexpected node in FMAD forming combine");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeline">    switch (Ty.getScalarSizeInBits()) {</td>
    <td class="lineNumber">3082</td>
    <td class="codeline">    switch (Ty.getScalarSizeInBits()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeline">    case 16:</td>
    <td class="lineNumber">3083</td>
    <td class="codeline">    case 16:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeline">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f16);</td>
    <td class="lineNumber">3084</td>
    <td class="codeline">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeline">    case 32:</td>
    <td class="lineNumber">3085</td>
    <td class="codeline">    case 32:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeline">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f32);</td>
    <td class="lineNumber">3086</td>
    <td class="codeline">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeline">    case 64:</td>
    <td class="lineNumber">3087</td>
    <td class="codeline">    case 64:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeline">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f64);</td>
    <td class="lineNumber">3088</td>
    <td class="codeline">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">3089</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">3090</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3091</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeline"></td>
    <td class="lineNumber">3092</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3093</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3094</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeline"></td>
    <td class="lineNumber">3095</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeline">  /// Returns true if be combined with to form an ISD::FMAD. \p N may be an</td>
    <td class="lineNumber">3096</td>
    <td class="codeline">  /// Returns true if be combined with to form an ISD::FMAD. \p N may be an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeline">  /// ISD::FADD, ISD::FSUB, or an ISD::FMUL which will be distributed into an</td>
    <td class="lineNumber">3097</td>
    <td class="codeline">  /// ISD::FADD, ISD::FSUB, or an ISD::FMUL which will be distributed into an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeline">  /// fadd/fsub.</td>
    <td class="lineNumber">3098</td>
    <td class="codeline">  /// fadd/fsub.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeline">  virtual bool isFMADLegal(const SelectionDAG &DAG, const SDNode *N) const {</td>
    <td class="lineNumber">3099</td>
    <td class="codeline">  virtual bool isFMADLegal(const SelectionDAG &DAG, const SDNode *N) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeline">    assert((N->getOpcode() == ISD::FADD || N->getOpcode() == ISD::FSUB ||</td>
    <td class="lineNumber">3100</td>
    <td class="codeline">    assert((N->getOpcode() == ISD::FADD || N->getOpcode() == ISD::FSUB ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeline">            N->getOpcode() == ISD::FMUL) &&</td>
    <td class="lineNumber">3101</td>
    <td class="codeline">            N->getOpcode() == ISD::FMUL) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeline">           "unexpected node in FMAD forming combine");</td>
    <td class="lineNumber">3102</td>
    <td class="codeline">           "unexpected node in FMAD forming combine");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeline">    return isOperationLegal(ISD::FMAD, N->getValueType(0));</td>
    <td class="lineNumber">3103</td>
    <td class="codeline">    return isOperationLegal(ISD::FMAD, N->getValueType(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3104</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeline"></td>
    <td class="lineNumber">3105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeline">  // Return true when the decision to generate FMA's (or FMS, FMLA etc) rather</td>
    <td class="lineNumber">3106</td>
    <td class="codeline">  // Return true when the decision to generate FMA's (or FMS, FMLA etc) rather</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeline">  // than FMUL and ADD is delegated to the machine combiner.</td>
    <td class="lineNumber">3107</td>
    <td class="codeline">  // than FMUL and ADD is delegated to the machine combiner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeline">  virtual bool generateFMAsInMachineCombiner(EVT VT,</td>
    <td class="lineNumber">3108</td>
    <td class="codeline">  virtual bool generateFMAsInMachineCombiner(EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeline">                                             CodeGenOpt::Level OptLevel) const {</td>
    <td class="lineNumber">3109</td>
    <td class="codeline">                                             CodeGenOpt::Level OptLevel) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3110</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3111</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeline"></td>
    <td class="lineNumber">3112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeline">  /// Return true if it's profitable to narrow operations of type SrcVT to</td>
    <td class="lineNumber">3113</td>
    <td class="codeline">  /// Return true if it's profitable to narrow operations of type SrcVT to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeline">  /// DestVT. e.g. on x86, it's profitable to narrow from i32 to i8 but not from</td>
    <td class="lineNumber">3114</td>
    <td class="codeline">  /// DestVT. e.g. on x86, it's profitable to narrow from i32 to i8 but not from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeline">  /// i32 to i16.</td>
    <td class="lineNumber">3115</td>
    <td class="codeline">  /// i32 to i16.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeline">  virtual bool isNarrowingProfitable(EVT SrcVT, EVT DestVT) const {</td>
    <td class="lineNumber">3116</td>
    <td class="codeline">  virtual bool isNarrowingProfitable(EVT SrcVT, EVT DestVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3117</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3118</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeline"></td>
    <td class="lineNumber">3119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeline">  /// Return true if pulling a binary operation into a select with an identity</td>
    <td class="lineNumber">3120</td>
    <td class="codeline">  /// Return true if pulling a binary operation into a select with an identity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeline">  /// constant is profitable. This is the inverse of an IR transform.</td>
    <td class="lineNumber">3121</td>
    <td class="codeline">  /// constant is profitable. This is the inverse of an IR transform.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeline">  /// Example: X + (Cond ? Y : 0) --> Cond ? (X + Y) : X</td>
    <td class="lineNumber">3122</td>
    <td class="codeline">  /// Example: X + (Cond ? Y : 0) --> Cond ? (X + Y) : X</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeline">  virtual bool shouldFoldSelectWithIdentityConstant(unsigned BinOpcode,</td>
    <td class="lineNumber">3123</td>
    <td class="codeline">  virtual bool shouldFoldSelectWithIdentityConstant(unsigned BinOpcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeline">                                                    EVT VT) const {</td>
    <td class="lineNumber">3124</td>
    <td class="codeline">                                                    EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3125</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3126</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeline"></td>
    <td class="lineNumber">3127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeline">  /// Return true if it is beneficial to convert a load of a constant to</td>
    <td class="lineNumber">3128</td>
    <td class="codeline">  /// Return true if it is beneficial to convert a load of a constant to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeline">  /// just the constant itself.</td>
    <td class="lineNumber">3129</td>
    <td class="codeline">  /// just the constant itself.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeline">  /// On some targets it might be more efficient to use a combination of</td>
    <td class="lineNumber">3130</td>
    <td class="codeline">  /// On some targets it might be more efficient to use a combination of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeline">  /// arithmetic instructions to materialize the constant instead of loading it</td>
    <td class="lineNumber">3131</td>
    <td class="codeline">  /// arithmetic instructions to materialize the constant instead of loading it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeline">  /// from a constant pool.</td>
    <td class="lineNumber">3132</td>
    <td class="codeline">  /// from a constant pool.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeline">  virtual bool shouldConvertConstantLoadToIntImm(const APInt &Imm,</td>
    <td class="lineNumber">3133</td>
    <td class="codeline">  virtual bool shouldConvertConstantLoadToIntImm(const APInt &Imm,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeline">                                                 Type *Ty) const {</td>
    <td class="lineNumber">3134</td>
    <td class="codeline">                                                 Type *Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3135</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3136</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeline"></td>
    <td class="lineNumber">3137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeline">  /// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type</td>
    <td class="lineNumber">3138</td>
    <td class="codeline">  /// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeline">  /// from this source type with this index. This is needed because</td>
    <td class="lineNumber">3139</td>
    <td class="codeline">  /// from this source type with this index. This is needed because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeline">  /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of</td>
    <td class="lineNumber">3140</td>
    <td class="codeline">  /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeline">  /// the first element, and only the target knows which lowering is cheap.</td>
    <td class="lineNumber">3141</td>
    <td class="codeline">  /// the first element, and only the target knows which lowering is cheap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeline">  virtual bool isExtractSubvectorCheap(EVT ResVT, EVT SrcVT,</td>
    <td class="lineNumber">3142</td>
    <td class="codeline">  virtual bool isExtractSubvectorCheap(EVT ResVT, EVT SrcVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeline">                                       unsigned Index) const {</td>
    <td class="lineNumber">3143</td>
    <td class="codeline">                                       unsigned Index) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3144</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3145</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeline"></td>
    <td class="lineNumber">3146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeline">  /// Try to convert an extract element of a vector binary operation into an</td>
    <td class="lineNumber">3147</td>
    <td class="codeline">  /// Try to convert an extract element of a vector binary operation into an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeline">  /// extract element followed by a scalar operation.</td>
    <td class="lineNumber">3148</td>
    <td class="codeline">  /// extract element followed by a scalar operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeline">  virtual bool shouldScalarizeBinop(SDValue VecOp) const {</td>
    <td class="lineNumber">3149</td>
    <td class="codeline">  virtual bool shouldScalarizeBinop(SDValue VecOp) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3150</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3151</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeline"></td>
    <td class="lineNumber">3152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeline">  /// Return true if extraction of a scalar element from the given vector type</td>
    <td class="lineNumber">3153</td>
    <td class="codeline">  /// Return true if extraction of a scalar element from the given vector type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeline">  /// at the given index is cheap. For example, if scalar operations occur on</td>
    <td class="lineNumber">3154</td>
    <td class="codeline">  /// at the given index is cheap. For example, if scalar operations occur on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeline">  /// the same register file as vector operations, then an extract element may</td>
    <td class="lineNumber">3155</td>
    <td class="codeline">  /// the same register file as vector operations, then an extract element may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeline">  /// be a sub-register rename rather than an actual instruction.</td>
    <td class="lineNumber">3156</td>
    <td class="codeline">  /// be a sub-register rename rather than an actual instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeline">  virtual bool isExtractVecEltCheap(EVT VT, unsigned Index) const {</td>
    <td class="lineNumber">3157</td>
    <td class="codeline">  virtual bool isExtractVecEltCheap(EVT VT, unsigned Index) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3158</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3159</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeline"></td>
    <td class="lineNumber">3160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeline">  /// Try to convert math with an overflow comparison into the corresponding DAG</td>
    <td class="lineNumber">3161</td>
    <td class="codeline">  /// Try to convert math with an overflow comparison into the corresponding DAG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeline">  /// node operation. Targets may want to override this independently of whether</td>
    <td class="lineNumber">3162</td>
    <td class="codeline">  /// node operation. Targets may want to override this independently of whether</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeline">  /// the operation is legal/custom for the given type because it may obscure</td>
    <td class="lineNumber">3163</td>
    <td class="codeline">  /// the operation is legal/custom for the given type because it may obscure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeline">  /// matching of other patterns.</td>
    <td class="lineNumber">3164</td>
    <td class="codeline">  /// matching of other patterns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeline">  virtual bool shouldFormOverflowOp(unsigned Opcode, EVT VT,</td>
    <td class="lineNumber">3165</td>
    <td class="codeline">  virtual bool shouldFormOverflowOp(unsigned Opcode, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeline">                                    bool MathUsed) const {</td>
    <td class="lineNumber">3166</td>
    <td class="codeline">                                    bool MathUsed) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeline">    // TODO: The default logic is inherited from code in CodeGenPrepare.</td>
    <td class="lineNumber">3167</td>
    <td class="codeline">    // TODO: The default logic is inherited from code in CodeGenPrepare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeline">    // The opcode should not make a difference by default?</td>
    <td class="lineNumber">3168</td>
    <td class="codeline">    // The opcode should not make a difference by default?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeline">    if (Opcode != ISD::UADDO)</td>
    <td class="lineNumber">3169</td>
    <td class="codeline">    if (Opcode != ISD::UADDO)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3170</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeline"></td>
    <td class="lineNumber">3171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeline">    // Allow the transform as long as we have an integer type that is not</td>
    <td class="lineNumber">3172</td>
    <td class="codeline">    // Allow the transform as long as we have an integer type that is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeline">    // obviously illegal and unsupported and if the math result is used</td>
    <td class="lineNumber">3173</td>
    <td class="codeline">    // obviously illegal and unsupported and if the math result is used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeline">    // besides the overflow check. On some targets (e.g. SPARC), it is</td>
    <td class="lineNumber">3174</td>
    <td class="codeline">    // besides the overflow check. On some targets (e.g. SPARC), it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeline">    // not profitable to form on overflow op if the math result has no</td>
    <td class="lineNumber">3175</td>
    <td class="codeline">    // not profitable to form on overflow op if the math result has no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeline">    // concrete users.</td>
    <td class="lineNumber">3176</td>
    <td class="codeline">    // concrete users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeline">    if (VT.isVector())</td>
    <td class="lineNumber">3177</td>
    <td class="codeline">    if (VT.isVector())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3178</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeline">    return MathUsed && (VT.isSimple() || !isOperationExpand(Opcode, VT));</td>
    <td class="lineNumber">3179</td>
    <td class="codeline">    return MathUsed && (VT.isSimple() || !isOperationExpand(Opcode, VT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3180</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeline"></td>
    <td class="lineNumber">3181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeline">  // Return true if it is profitable to use a scalar input to a BUILD_VECTOR</td>
    <td class="lineNumber">3182</td>
    <td class="codeline">  // Return true if it is profitable to use a scalar input to a BUILD_VECTOR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeline">  // even if the vector itself has multiple uses.</td>
    <td class="lineNumber">3183</td>
    <td class="codeline">  // even if the vector itself has multiple uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeline">  virtual bool aggressivelyPreferBuildVectorSources(EVT VecVT) const {</td>
    <td class="lineNumber">3184</td>
    <td class="codeline">  virtual bool aggressivelyPreferBuildVectorSources(EVT VecVT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3185</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3186</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeline"></td>
    <td class="lineNumber">3187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeline">  // Return true if CodeGenPrepare should consider splitting large offset of a</td>
    <td class="lineNumber">3188</td>
    <td class="codeline">  // Return true if CodeGenPrepare should consider splitting large offset of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeline">  // GEP to make the GEP fit into the addressing mode and can be sunk into the</td>
    <td class="lineNumber">3189</td>
    <td class="codeline">  // GEP to make the GEP fit into the addressing mode and can be sunk into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeline">  // same blocks of its users.</td>
    <td class="lineNumber">3190</td>
    <td class="codeline">  // same blocks of its users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeline">  virtual bool shouldConsiderGEPOffsetSplit() const { return false; }</td>
    <td class="lineNumber">3191</td>
    <td class="codeline">  virtual bool shouldConsiderGEPOffsetSplit() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeline"></td>
    <td class="lineNumber">3192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeline">  /// Return true if creating a shift of the type by the given</td>
    <td class="lineNumber">3193</td>
    <td class="codeline">  /// Return true if creating a shift of the type by the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeline">  /// amount is not profitable.</td>
    <td class="lineNumber">3194</td>
    <td class="codeline">  /// amount is not profitable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeline">  virtual bool shouldAvoidTransformToShift(EVT VT, unsigned Amount) const {</td>
    <td class="lineNumber">3195</td>
    <td class="codeline">  virtual bool shouldAvoidTransformToShift(EVT VT, unsigned Amount) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3196</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3197</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeline"></td>
    <td class="lineNumber">3198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeline">  /// Does this target require the clearing of high-order bits in a register</td>
    <td class="lineNumber">3199</td>
    <td class="codeline">  /// Does this target require the clearing of high-order bits in a register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeline">  /// passed to the fp16 to fp conversion library function.</td>
    <td class="lineNumber">3200</td>
    <td class="codeline">  /// passed to the fp16 to fp conversion library function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeline">  virtual bool shouldKeepZExtForFP16Conv() const { return false; }</td>
    <td class="lineNumber">3201</td>
    <td class="codeline">  virtual bool shouldKeepZExtForFP16Conv() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeline"></td>
    <td class="lineNumber">3202</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeline">  /// Should we generate fp_to_si_sat and fp_to_ui_sat from type FPVT to type VT</td>
    <td class="lineNumber">3203</td>
    <td class="codeline">  /// Should we generate fp_to_si_sat and fp_to_ui_sat from type FPVT to type VT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeline">  /// from min(max(fptoi)) saturation patterns.</td>
    <td class="lineNumber">3204</td>
    <td class="codeline">  /// from min(max(fptoi)) saturation patterns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeline">  virtual bool shouldConvertFpToSat(unsigned Op, EVT FPVT, EVT VT) const {</td>
    <td class="lineNumber">3205</td>
    <td class="codeline">  virtual bool shouldConvertFpToSat(unsigned Op, EVT FPVT, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeline">    return isOperationLegalOrCustom(Op, VT);</td>
    <td class="lineNumber">3206</td>
    <td class="codeline">    return isOperationLegalOrCustom(Op, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3207</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeline"></td>
    <td class="lineNumber">3208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeline">  /// Does this target support complex deinterleaving</td>
    <td class="lineNumber">3209</td>
    <td class="codeline">  /// Does this target support complex deinterleaving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeline">  virtual bool isComplexDeinterleavingSupported() const { return false; }</td>
    <td class="lineNumber">3210</td>
    <td class="codeline">  virtual bool isComplexDeinterleavingSupported() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeline"></td>
    <td class="lineNumber">3211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeline">  /// Does this target support complex deinterleaving with the given operation</td>
    <td class="lineNumber">3212</td>
    <td class="codeline">  /// Does this target support complex deinterleaving with the given operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeline">  /// and type</td>
    <td class="lineNumber">3213</td>
    <td class="codeline">  /// and type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeline">  virtual bool isComplexDeinterleavingOperationSupported(</td>
    <td class="lineNumber">3214</td>
    <td class="codeline">  virtual bool isComplexDeinterleavingOperationSupported(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeline">      ComplexDeinterleavingOperation Operation, Type *Ty) const {</td>
    <td class="lineNumber">3215</td>
    <td class="codeline">      ComplexDeinterleavingOperation Operation, Type *Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3216</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3217</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeline"></td>
    <td class="lineNumber">3218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeline">  /// Create the IR node for the given complex deinterleaving operation.</td>
    <td class="lineNumber">3219</td>
    <td class="codeline">  /// Create the IR node for the given complex deinterleaving operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeline">  /// If one cannot be created using all the given inputs, nullptr should be</td>
    <td class="lineNumber">3220</td>
    <td class="codeline">  /// If one cannot be created using all the given inputs, nullptr should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeline">  /// returned.</td>
    <td class="lineNumber">3221</td>
    <td class="codeline">  /// returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeline">  virtual Value *createComplexDeinterleavingIR(</td>
    <td class="lineNumber">3222</td>
    <td class="codeline">  virtual Value *createComplexDeinterleavingIR(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeline">      IRBuilderBase &B, ComplexDeinterleavingOperation OperationType,</td>
    <td class="lineNumber">3223</td>
    <td class="codeline">      IRBuilderBase &B, ComplexDeinterleavingOperation OperationType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeline">      ComplexDeinterleavingRotation Rotation, Value *InputA, Value *InputB,</td>
    <td class="lineNumber">3224</td>
    <td class="codeline">      ComplexDeinterleavingRotation Rotation, Value *InputA, Value *InputB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeline">      Value *Accumulator = nullptr) const {</td>
    <td class="lineNumber">3225</td>
    <td class="codeline">      Value *Accumulator = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">3226</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3227</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeline"></td>
    <td class="lineNumber">3228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">3229</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeline">  // Runtime Library hooks</td>
    <td class="lineNumber">3230</td>
    <td class="codeline">  // Runtime Library hooks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">3231</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeline"></td>
    <td class="lineNumber">3232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeline">  /// Rename the default libcall routine name for the specified libcall.</td>
    <td class="lineNumber">3233</td>
    <td class="codeline">  /// Rename the default libcall routine name for the specified libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeline">  void setLibcallName(RTLIB::Libcall Call, const char *Name) {</td>
    <td class="lineNumber">3234</td>
    <td class="codeline">  void setLibcallName(RTLIB::Libcall Call, const char *Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeline">    LibcallRoutineNames[Call] = Name;</td>
    <td class="lineNumber">3235</td>
    <td class="codeline">    LibcallRoutineNames[Call] = Name;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3236</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeline">  void setLibcallName(ArrayRef<RTLIB::Libcall> Calls, const char *Name) {</td>
    <td class="lineNumber">3237</td>
    <td class="codeline">  void setLibcallName(ArrayRef<RTLIB::Libcall> Calls, const char *Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeline">    for (auto Call : Calls)</td>
    <td class="lineNumber">3238</td>
    <td class="codeline">    for (auto Call : Calls)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeline">      setLibcallName(Call, Name);</td>
    <td class="lineNumber">3239</td>
    <td class="codeline">      setLibcallName(Call, Name);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3240</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeline"></td>
    <td class="lineNumber">3241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeline">  /// Get the libcall routine name for the specified libcall.</td>
    <td class="lineNumber">3242</td>
    <td class="codeline">  /// Get the libcall routine name for the specified libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeline">  const char *getLibcallName(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">3243</td>
    <td class="codeline">  const char *getLibcallName(RTLIB::Libcall Call) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeline">    return LibcallRoutineNames[Call];</td>
    <td class="lineNumber">3244</td>
    <td class="codeline">    return LibcallRoutineNames[Call];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3245</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeline"></td>
    <td class="lineNumber">3246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeline">  /// Override the default CondCode to be used to test the result of the</td>
    <td class="lineNumber">3247</td>
    <td class="codeline">  /// Override the default CondCode to be used to test the result of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeline">  /// comparison libcall against zero.</td>
    <td class="lineNumber">3248</td>
    <td class="codeline">  /// comparison libcall against zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeline">  void setCmpLibcallCC(RTLIB::Libcall Call, ISD::CondCode CC) {</td>
    <td class="lineNumber">3249</td>
    <td class="codeline">  void setCmpLibcallCC(RTLIB::Libcall Call, ISD::CondCode CC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeline">    CmpLibcallCCs[Call] = CC;</td>
    <td class="lineNumber">3250</td>
    <td class="codeline">    CmpLibcallCCs[Call] = CC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3251</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeline"></td>
    <td class="lineNumber">3252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeline">  /// Get the CondCode that's to be used to test the result of the comparison</td>
    <td class="lineNumber">3253</td>
    <td class="codeline">  /// Get the CondCode that's to be used to test the result of the comparison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeline">  /// libcall against zero.</td>
    <td class="lineNumber">3254</td>
    <td class="codeline">  /// libcall against zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeline">  ISD::CondCode getCmpLibcallCC(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">3255</td>
    <td class="codeline">  ISD::CondCode getCmpLibcallCC(RTLIB::Libcall Call) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeline">    return CmpLibcallCCs[Call];</td>
    <td class="lineNumber">3256</td>
    <td class="codeline">    return CmpLibcallCCs[Call];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3257</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeline"></td>
    <td class="lineNumber">3258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeline">  /// Set the CallingConv that should be used for the specified libcall.</td>
    <td class="lineNumber">3259</td>
    <td class="codeline">  /// Set the CallingConv that should be used for the specified libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeline">  void setLibcallCallingConv(RTLIB::Libcall Call, CallingConv::ID CC) {</td>
    <td class="lineNumber">3260</td>
    <td class="codeline">  void setLibcallCallingConv(RTLIB::Libcall Call, CallingConv::ID CC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeline">    LibcallCallingConvs[Call] = CC;</td>
    <td class="lineNumber">3261</td>
    <td class="codeline">    LibcallCallingConvs[Call] = CC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3262</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeline"></td>
    <td class="lineNumber">3263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeline">  /// Get the CallingConv that should be used for the specified libcall.</td>
    <td class="lineNumber">3264</td>
    <td class="codeline">  /// Get the CallingConv that should be used for the specified libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeline">  CallingConv::ID getLibcallCallingConv(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">3265</td>
    <td class="codeline">  CallingConv::ID getLibcallCallingConv(RTLIB::Libcall Call) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeline">    return LibcallCallingConvs[Call];</td>
    <td class="lineNumber">3266</td>
    <td class="codeline">    return LibcallCallingConvs[Call];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3267</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeline"></td>
    <td class="lineNumber">3268</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeline">  /// Execute target specific actions to finalize target lowering.</td>
    <td class="lineNumber">3269</td>
    <td class="codeline">  /// Execute target specific actions to finalize target lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeline">  /// This is used to set extra flags in MachineFrameInformation and freezing</td>
    <td class="lineNumber">3270</td>
    <td class="codeline">  /// This is used to set extra flags in MachineFrameInformation and freezing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeline">  /// the set of reserved registers.</td>
    <td class="lineNumber">3271</td>
    <td class="codeline">  /// the set of reserved registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeline">  /// The default implementation just freezes the set of reserved registers.</td>
    <td class="lineNumber">3272</td>
    <td class="codeline">  /// The default implementation just freezes the set of reserved registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeline">  virtual void finalizeLowering(MachineFunction &MF) const;</td>
    <td class="lineNumber">3273</td>
    <td class="codeline">  virtual void finalizeLowering(MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeline"></td>
    <td class="lineNumber">3274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeline">  //===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">3275</td>
    <td class="codeline">  //===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeline">  //  GlobalISel Hooks</td>
    <td class="lineNumber">3276</td>
    <td class="codeline">  //  GlobalISel Hooks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeline">  //===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">3277</td>
    <td class="codeline">  //===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="codeline">  /// Check whether or not \p MI needs to be moved close to its uses.</td>
    <td class="lineNumber">3278</td>
    <td class="codeline">  /// Check whether or not \p MI needs to be moved close to its uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="codeline">  virtual bool shouldLocalize(const MachineInstr &MI, const TargetTransformInfo *TTI) const;</td>
    <td class="lineNumber">3279</td>
    <td class="codeline">  virtual bool shouldLocalize(const MachineInstr &MI, const TargetTransformInfo *TTI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="codeline"></td>
    <td class="lineNumber">3280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class="codeline"></td>
    <td class="lineNumber">3281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">3282</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="codeline">  const TargetMachine &TM;</td>
    <td class="lineNumber">3283</td>
    <td class="codeline">  const TargetMachine &TM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="codeline"></td>
    <td class="lineNumber">3284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="codeline">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td class="lineNumber">3285</td>
    <td class="codeline">  /// Tells the code generator that the target has multiple (allocatable)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="codeline">  /// condition registers that can be used to store the results of comparisons</td>
    <td class="lineNumber">3286</td>
    <td class="codeline">  /// condition registers that can be used to store the results of comparisons</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="codeline">  /// for use by selects and conditional branches. With multiple condition</td>
    <td class="lineNumber">3287</td>
    <td class="codeline">  /// for use by selects and conditional branches. With multiple condition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="codeline">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td class="lineNumber">3288</td>
    <td class="codeline">  /// registers, the code generator will not aggressively sink comparisons into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="codeline">  /// the blocks of their users.</td>
    <td class="lineNumber">3289</td>
    <td class="codeline">  /// the blocks of their users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="codeline">  bool HasMultipleConditionRegisters;</td>
    <td class="lineNumber">3290</td>
    <td class="codeline">  bool HasMultipleConditionRegisters;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="codeline"></td>
    <td class="lineNumber">3291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="codeline">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td class="lineNumber">3292</td>
    <td class="codeline">  /// Tells the code generator that the target has BitExtract instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="codeline">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td class="lineNumber">3293</td>
    <td class="codeline">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="codeline">  /// their users if the users will generate "and" instructions which can be</td>
    <td class="lineNumber">3294</td>
    <td class="codeline">  /// their users if the users will generate "and" instructions which can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="codeline">  /// combined with "shift" to BitExtract instructions.</td>
    <td class="lineNumber">3295</td>
    <td class="codeline">  /// combined with "shift" to BitExtract instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="codeline">  bool HasExtractBitsInsn;</td>
    <td class="lineNumber">3296</td>
    <td class="codeline">  bool HasExtractBitsInsn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="codeline"></td>
    <td class="lineNumber">3297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="codeline">  /// Tells the code generator to bypass slow divide or remainder</td>
    <td class="lineNumber">3298</td>
    <td class="codeline">  /// Tells the code generator to bypass slow divide or remainder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="codeline">  /// instructions. For example, BypassSlowDivWidths[32,8] tells the code</td>
    <td class="lineNumber">3299</td>
    <td class="codeline">  /// instructions. For example, BypassSlowDivWidths[32,8] tells the code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="codeline">  /// generator to bypass 32-bit integer div/rem with an 8-bit unsigned integer</td>
    <td class="lineNumber">3300</td>
    <td class="codeline">  /// generator to bypass 32-bit integer div/rem with an 8-bit unsigned integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="codeline">  /// div/rem when the operands are positive and less than 256.</td>
    <td class="lineNumber">3301</td>
    <td class="codeline">  /// div/rem when the operands are positive and less than 256.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class="codeline">  DenseMap <unsigned int, unsigned int> BypassSlowDivWidths;</td>
    <td class="lineNumber">3302</td>
    <td class="codeline">  DenseMap <unsigned int, unsigned int> BypassSlowDivWidths;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="codeline"></td>
    <td class="lineNumber">3303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="codeline">  /// Tells the code generator that it shouldn't generate extra flow control</td>
    <td class="lineNumber">3304</td>
    <td class="codeline">  /// Tells the code generator that it shouldn't generate extra flow control</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="codeline">  /// instructions and should attempt to combine flow control instructions via</td>
    <td class="lineNumber">3305</td>
    <td class="codeline">  /// instructions and should attempt to combine flow control instructions via</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="codeline">  /// predication.</td>
    <td class="lineNumber">3306</td>
    <td class="codeline">  /// predication.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="codeline">  bool JumpIsExpensive;</td>
    <td class="lineNumber">3307</td>
    <td class="codeline">  bool JumpIsExpensive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class="codeline"></td>
    <td class="lineNumber">3308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="codeline">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td class="lineNumber">3309</td>
    <td class="codeline">  /// Information about the contents of the high-bits in boolean values held in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="codeline">  /// a type wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">3310</td>
    <td class="codeline">  /// a type wider than i1. See getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="codeline">  BooleanContent BooleanContents;</td>
    <td class="lineNumber">3311</td>
    <td class="codeline">  BooleanContent BooleanContents;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="codeline"></td>
    <td class="lineNumber">3312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="codeline">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td class="lineNumber">3313</td>
    <td class="codeline">  /// Information about the contents of the high-bits in boolean values held in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="codeline">  /// a type wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">3314</td>
    <td class="codeline">  /// a type wider than i1. See getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="codeline">  BooleanContent BooleanFloatContents;</td>
    <td class="lineNumber">3315</td>
    <td class="codeline">  BooleanContent BooleanFloatContents;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="codeline"></td>
    <td class="lineNumber">3316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="codeline">  /// Information about the contents of the high-bits in boolean vector values</td>
    <td class="lineNumber">3317</td>
    <td class="codeline">  /// Information about the contents of the high-bits in boolean vector values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="codeline">  /// when the element type is wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">3318</td>
    <td class="codeline">  /// when the element type is wider than i1. See getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="codeline">  BooleanContent BooleanVectorContents;</td>
    <td class="lineNumber">3319</td>
    <td class="codeline">  BooleanContent BooleanVectorContents;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="codeline"></td>
    <td class="lineNumber">3320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="codeline">  /// The target scheduling preference: shortest possible total cycles or lowest</td>
    <td class="lineNumber">3321</td>
    <td class="codeline">  /// The target scheduling preference: shortest possible total cycles or lowest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="codeline">  /// register usage.</td>
    <td class="lineNumber">3322</td>
    <td class="codeline">  /// register usage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="codeline">  Sched::Preference SchedPreferenceInfo;</td>
    <td class="lineNumber">3323</td>
    <td class="codeline">  Sched::Preference SchedPreferenceInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="codeline"></td>
    <td class="lineNumber">3324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="codeline">  /// The minimum alignment that any argument on the stack needs to have.</td>
    <td class="lineNumber">3325</td>
    <td class="codeline">  /// The minimum alignment that any argument on the stack needs to have.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="codeline">  Align MinStackArgumentAlignment;</td>
    <td class="lineNumber">3326</td>
    <td class="codeline">  Align MinStackArgumentAlignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class="codeline"></td>
    <td class="lineNumber">3327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="codeline">  /// The minimum function alignment (used when optimizing for size, and to</td>
    <td class="lineNumber">3328</td>
    <td class="codeline">  /// The minimum function alignment (used when optimizing for size, and to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="codeline">  /// prevent explicitly provided alignment from leading to incorrect code).</td>
    <td class="lineNumber">3329</td>
    <td class="codeline">  /// prevent explicitly provided alignment from leading to incorrect code).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="codeline">  Align MinFunctionAlignment;</td>
    <td class="lineNumber">3330</td>
    <td class="codeline">  Align MinFunctionAlignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="codeline"></td>
    <td class="lineNumber">3331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="codeline">  /// The preferred function alignment (used when alignment unspecified and</td>
    <td class="lineNumber">3332</td>
    <td class="codeline">  /// The preferred function alignment (used when alignment unspecified and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="codeline">  /// optimizing for speed).</td>
    <td class="lineNumber">3333</td>
    <td class="codeline">  /// optimizing for speed).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class="codeline">  Align PrefFunctionAlignment;</td>
    <td class="lineNumber">3334</td>
    <td class="codeline">  Align PrefFunctionAlignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="codeline"></td>
    <td class="lineNumber">3335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="codeline">  /// The preferred loop alignment (in log2 bot in bytes).</td>
    <td class="lineNumber">3336</td>
    <td class="codeline">  /// The preferred loop alignment (in log2 bot in bytes).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="codeline">  Align PrefLoopAlignment;</td>
    <td class="lineNumber">3337</td>
    <td class="codeline">  Align PrefLoopAlignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="codeline">  /// The maximum amount of bytes permitted to be emitted for alignment.</td>
    <td class="lineNumber">3338</td>
    <td class="codeline">  /// The maximum amount of bytes permitted to be emitted for alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="codeline">  unsigned MaxBytesForAlignment;</td>
    <td class="lineNumber">3339</td>
    <td class="codeline">  unsigned MaxBytesForAlignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="codeline"></td>
    <td class="lineNumber">3340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="codeline">  /// Size in bits of the maximum atomics size the backend supports.</td>
    <td class="lineNumber">3341</td>
    <td class="codeline">  /// Size in bits of the maximum atomics size the backend supports.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="codeline">  /// Accesses larger than this will be expanded by AtomicExpandPass.</td>
    <td class="lineNumber">3342</td>
    <td class="codeline">  /// Accesses larger than this will be expanded by AtomicExpandPass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="codeline">  unsigned MaxAtomicSizeInBitsSupported;</td>
    <td class="lineNumber">3343</td>
    <td class="codeline">  unsigned MaxAtomicSizeInBitsSupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class="codeline"></td>
    <td class="lineNumber">3344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="codeline">  /// Size in bits of the maximum div/rem size the backend supports.</td>
    <td class="lineNumber">3345</td>
    <td class="codeline">  /// Size in bits of the maximum div/rem size the backend supports.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">3346</td>
    <td class="codeline">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="codeline">  unsigned MaxDivRemBitWidthSupported;</td>
    <td class="lineNumber">3347</td>
    <td class="codeline">  unsigned MaxDivRemBitWidthSupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="codeline"></td>
    <td class="lineNumber">3348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="codeline">  /// Size in bits of the maximum larget fp convert size the backend</td>
    <td class="lineNumber">3349</td>
    <td class="codeline">  /// Size in bits of the maximum larget fp convert size the backend</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="codeline">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">3350</td>
    <td class="codeline">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="codeline">  unsigned MaxLargeFPConvertBitWidthSupported;</td>
    <td class="lineNumber">3351</td>
    <td class="codeline">  unsigned MaxLargeFPConvertBitWidthSupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="codeline"></td>
    <td class="lineNumber">3352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class="codeline">  /// Size in bits of the minimum cmpxchg or ll/sc operation the</td>
    <td class="lineNumber">3353</td>
    <td class="codeline">  /// Size in bits of the minimum cmpxchg or ll/sc operation the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="codeline">  /// backend supports.</td>
    <td class="lineNumber">3354</td>
    <td class="codeline">  /// backend supports.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="codeline">  unsigned MinCmpXchgSizeInBits;</td>
    <td class="lineNumber">3355</td>
    <td class="codeline">  unsigned MinCmpXchgSizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class="codeline"></td>
    <td class="lineNumber">3356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="codeline">  /// This indicates if the target supports unaligned atomic operations.</td>
    <td class="lineNumber">3357</td>
    <td class="codeline">  /// This indicates if the target supports unaligned atomic operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="codeline">  bool SupportsUnalignedAtomics;</td>
    <td class="lineNumber">3358</td>
    <td class="codeline">  bool SupportsUnalignedAtomics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="codeline"></td>
    <td class="lineNumber">3359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="codeline">  /// If set to a physical register, this specifies the register that</td>
    <td class="lineNumber">3360</td>
    <td class="codeline">  /// If set to a physical register, this specifies the register that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="codeline">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">3361</td>
    <td class="codeline">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="codeline">  Register StackPointerRegisterToSaveRestore;</td>
    <td class="lineNumber">3362</td>
    <td class="codeline">  Register StackPointerRegisterToSaveRestore;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="codeline"></td>
    <td class="lineNumber">3363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="codeline">  /// This indicates the default register class to use for each ValueType the</td>
    <td class="lineNumber">3364</td>
    <td class="codeline">  /// This indicates the default register class to use for each ValueType the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class="codeline">  /// target supports natively.</td>
    <td class="lineNumber">3365</td>
    <td class="codeline">  /// target supports natively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="codeline">  const TargetRegisterClass *RegClassForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">3366</td>
    <td class="codeline">  const TargetRegisterClass *RegClassForVT[MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="codeline">  uint16_t NumRegistersForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">3367</td>
    <td class="codeline">  uint16_t NumRegistersForVT[MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="codeline">  MVT RegisterTypeForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">3368</td>
    <td class="codeline">  MVT RegisterTypeForVT[MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="codeline"></td>
    <td class="lineNumber">3369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="codeline">  /// This indicates the "representative" register class to use for each</td>
    <td class="lineNumber">3370</td>
    <td class="codeline">  /// This indicates the "representative" register class to use for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="codeline">  /// ValueType the target supports natively. This information is used by the</td>
    <td class="lineNumber">3371</td>
    <td class="codeline">  /// ValueType the target supports natively. This information is used by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="codeline">  /// scheduler to track register pressure. By default, the representative</td>
    <td class="lineNumber">3372</td>
    <td class="codeline">  /// scheduler to track register pressure. By default, the representative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="codeline">  /// register class is the largest legal super-reg register class of the</td>
    <td class="lineNumber">3373</td>
    <td class="codeline">  /// register class is the largest legal super-reg register class of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="codeline">  /// register class of the specified type. e.g. On x86, i8, i16, and i32's</td>
    <td class="lineNumber">3374</td>
    <td class="codeline">  /// register class of the specified type. e.g. On x86, i8, i16, and i32's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="codeline">  /// representative class would be GR32.</td>
    <td class="lineNumber">3375</td>
    <td class="codeline">  /// representative class would be GR32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="codeline">  const TargetRegisterClass *RepRegClassForVT[MVT::VALUETYPE_SIZE] = {0};</td>
    <td class="lineNumber">3376</td>
    <td class="codeline">  const TargetRegisterClass *RepRegClassForVT[MVT::VALUETYPE_SIZE] = {0};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class="codeline"></td>
    <td class="lineNumber">3377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="codeline">  /// This indicates the "cost" of the "representative" register class for each</td>
    <td class="lineNumber">3378</td>
    <td class="codeline">  /// This indicates the "cost" of the "representative" register class for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="codeline">  /// ValueType. The cost is used by the scheduler to approximate register</td>
    <td class="lineNumber">3379</td>
    <td class="codeline">  /// ValueType. The cost is used by the scheduler to approximate register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="codeline">  /// pressure.</td>
    <td class="lineNumber">3380</td>
    <td class="codeline">  /// pressure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="codeline">  uint8_t RepRegClassCostForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">3381</td>
    <td class="codeline">  uint8_t RepRegClassCostForVT[MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="codeline"></td>
    <td class="lineNumber">3382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="codeline">  /// For any value types we are promoting or expanding, this contains the value</td>
    <td class="lineNumber">3383</td>
    <td class="codeline">  /// For any value types we are promoting or expanding, this contains the value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="codeline">  /// type that we are changing to.  For Expanded types, this contains one step</td>
    <td class="lineNumber">3384</td>
    <td class="codeline">  /// type that we are changing to.  For Expanded types, this contains one step</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="codeline">  /// of the expand (e.g. i64 -> i32), even if there are multiple steps required</td>
    <td class="lineNumber">3385</td>
    <td class="codeline">  /// of the expand (e.g. i64 -> i32), even if there are multiple steps required</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="codeline">  /// (e.g. i64 -> i16).  For types natively supported by the system, this holds</td>
    <td class="lineNumber">3386</td>
    <td class="codeline">  /// (e.g. i64 -> i16).  For types natively supported by the system, this holds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="codeline">  /// the same type (e.g. i32 -> i32).</td>
    <td class="lineNumber">3387</td>
    <td class="codeline">  /// the same type (e.g. i32 -> i32).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="codeline">  MVT TransformToType[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">3388</td>
    <td class="codeline">  MVT TransformToType[MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class="codeline"></td>
    <td class="lineNumber">3389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="codeline">  /// For each operation and each value type, keep a LegalizeAction that</td>
    <td class="lineNumber">3390</td>
    <td class="codeline">  /// For each operation and each value type, keep a LegalizeAction that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="codeline">  /// indicates how instruction selection should deal with the operation.  Most</td>
    <td class="lineNumber">3391</td>
    <td class="codeline">  /// indicates how instruction selection should deal with the operation.  Most</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="codeline">  /// operations are Legal (aka, supported natively by the target), but</td>
    <td class="lineNumber">3392</td>
    <td class="codeline">  /// operations are Legal (aka, supported natively by the target), but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="codeline">  /// operations that are not should be described.  Note that operations on</td>
    <td class="lineNumber">3393</td>
    <td class="codeline">  /// operations that are not should be described.  Note that operations on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="codeline">  /// non-legal value types are not described here.</td>
    <td class="lineNumber">3394</td>
    <td class="codeline">  /// non-legal value types are not described here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="codeline">  LegalizeAction OpActions[MVT::VALUETYPE_SIZE][ISD::BUILTIN_OP_END];</td>
    <td class="lineNumber">3395</td>
    <td class="codeline">  LegalizeAction OpActions[MVT::VALUETYPE_SIZE][ISD::BUILTIN_OP_END];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="codeline"></td>
    <td class="lineNumber">3396</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="codeline">  /// For each load extension type and each value type, keep a LegalizeAction</td>
    <td class="lineNumber">3397</td>
    <td class="codeline">  /// For each load extension type and each value type, keep a LegalizeAction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="codeline">  /// that indicates how instruction selection should deal with a load of a</td>
    <td class="lineNumber">3398</td>
    <td class="codeline">  /// that indicates how instruction selection should deal with a load of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="codeline">  /// specific value type and extension type. Uses 4-bits to store the action</td>
    <td class="lineNumber">3399</td>
    <td class="codeline">  /// specific value type and extension type. Uses 4-bits to store the action</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="codeline">  /// for each of the 4 load ext types.</td>
    <td class="lineNumber">3400</td>
    <td class="codeline">  /// for each of the 4 load ext types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="codeline">  uint16_t LoadExtActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">3401</td>
    <td class="codeline">  uint16_t LoadExtActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="codeline"></td>
    <td class="lineNumber">3402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="codeline">  /// For each value type pair keep a LegalizeAction that indicates whether a</td>
    <td class="lineNumber">3403</td>
    <td class="codeline">  /// For each value type pair keep a LegalizeAction that indicates whether a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="codeline">  /// truncating store of a specific value type and truncating type is legal.</td>
    <td class="lineNumber">3404</td>
    <td class="codeline">  /// truncating store of a specific value type and truncating type is legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="codeline">  LegalizeAction TruncStoreActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">3405</td>
    <td class="codeline">  LegalizeAction TruncStoreActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="codeline"></td>
    <td class="lineNumber">3406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="codeline">  /// For each indexed mode and each value type, keep a quad of LegalizeAction</td>
    <td class="lineNumber">3407</td>
    <td class="codeline">  /// For each indexed mode and each value type, keep a quad of LegalizeAction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="codeline">  /// that indicates how instruction selection should deal with the load /</td>
    <td class="lineNumber">3408</td>
    <td class="codeline">  /// that indicates how instruction selection should deal with the load /</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="codeline">  /// store / maskedload / maskedstore.</td>
    <td class="lineNumber">3409</td>
    <td class="codeline">  /// store / maskedload / maskedstore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3410</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="codeline">  /// The first dimension is the value_type for the reference. The second</td>
    <td class="lineNumber">3411</td>
    <td class="codeline">  /// The first dimension is the value_type for the reference. The second</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="codeline">  /// dimension represents the various modes for load store.</td>
    <td class="lineNumber">3412</td>
    <td class="codeline">  /// dimension represents the various modes for load store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class="codeline">  uint16_t IndexedModeActions[MVT::VALUETYPE_SIZE][ISD::LAST_INDEXED_MODE];</td>
    <td class="lineNumber">3413</td>
    <td class="codeline">  uint16_t IndexedModeActions[MVT::VALUETYPE_SIZE][ISD::LAST_INDEXED_MODE];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="codeline"></td>
    <td class="lineNumber">3414</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="codeline">  /// For each condition code (ISD::CondCode) keep a LegalizeAction that</td>
    <td class="lineNumber">3415</td>
    <td class="codeline">  /// For each condition code (ISD::CondCode) keep a LegalizeAction that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="codeline">  /// indicates how instruction selection should deal with the condition code.</td>
    <td class="lineNumber">3416</td>
    <td class="codeline">  /// indicates how instruction selection should deal with the condition code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3417</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="codeline">  /// Because each CC action takes up 4 bits, we need to have the array size be</td>
    <td class="lineNumber">3418</td>
    <td class="codeline">  /// Because each CC action takes up 4 bits, we need to have the array size be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="codeline">  /// large enough to fit all of the value types. This can be done by rounding</td>
    <td class="lineNumber">3419</td>
    <td class="codeline">  /// large enough to fit all of the value types. This can be done by rounding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="codeline">  /// up the MVT::VALUETYPE_SIZE value to the next multiple of 8.</td>
    <td class="lineNumber">3420</td>
    <td class="codeline">  /// up the MVT::VALUETYPE_SIZE value to the next multiple of 8.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="codeline">  uint32_t CondCodeActions[ISD::SETCC_INVALID][(MVT::VALUETYPE_SIZE + 7) / 8];</td>
    <td class="lineNumber">3421</td>
    <td class="codeline">  uint32_t CondCodeActions[ISD::SETCC_INVALID][(MVT::VALUETYPE_SIZE + 7) / 8];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class="codeline"></td>
    <td class="lineNumber">3422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="codeline">  ValueTypeActionImpl ValueTypeActions;</td>
    <td class="lineNumber">3423</td>
    <td class="codeline">  ValueTypeActionImpl ValueTypeActions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="codeline"></td>
    <td class="lineNumber">3424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">3425</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="codeline">  /// Targets can specify ISD nodes that they would like PerformDAGCombine</td>
    <td class="lineNumber">3426</td>
    <td class="codeline">  /// Targets can specify ISD nodes that they would like PerformDAGCombine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="codeline">  /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this</td>
    <td class="lineNumber">3427</td>
    <td class="codeline">  /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="codeline">  /// array.</td>
    <td class="lineNumber">3428</td>
    <td class="codeline">  /// array.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="codeline">  unsigned char</td>
    <td class="lineNumber">3429</td>
    <td class="codeline">  unsigned char</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="codeline">  TargetDAGCombineArray[(ISD::BUILTIN_OP_END+CHAR_BIT-1)/CHAR_BIT];</td>
    <td class="lineNumber">3430</td>
    <td class="codeline">  TargetDAGCombineArray[(ISD::BUILTIN_OP_END+CHAR_BIT-1)/CHAR_BIT];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="codeline"></td>
    <td class="lineNumber">3431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="codeline">  /// For operations that must be promoted to a specific type, this holds the</td>
    <td class="lineNumber">3432</td>
    <td class="codeline">  /// For operations that must be promoted to a specific type, this holds the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="codeline">  /// destination type.  This map should be sparse, so don't hold it as an</td>
    <td class="lineNumber">3433</td>
    <td class="codeline">  /// destination type.  This map should be sparse, so don't hold it as an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="codeline">  /// array.</td>
    <td class="lineNumber">3434</td>
    <td class="codeline">  /// array.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3435</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="codeline">  /// Targets add entries to this map with AddPromotedToType(..), clients access</td>
    <td class="lineNumber">3436</td>
    <td class="codeline">  /// Targets add entries to this map with AddPromotedToType(..), clients access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="codeline">  /// this with getTypeToPromoteTo(..).</td>
    <td class="lineNumber">3437</td>
    <td class="codeline">  /// this with getTypeToPromoteTo(..).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="codeline">  std::map<std::pair<unsigned, MVT::SimpleValueType>, MVT::SimpleValueType></td>
    <td class="lineNumber">3438</td>
    <td class="codeline">  std::map<std::pair<unsigned, MVT::SimpleValueType>, MVT::SimpleValueType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class="codeline">    PromoteToType;</td>
    <td class="lineNumber">3439</td>
    <td class="codeline">    PromoteToType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="codeline"></td>
    <td class="lineNumber">3440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="codeline">  /// Stores the name each libcall.</td>
    <td class="lineNumber">3441</td>
    <td class="codeline">  /// Stores the name each libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="codeline">  const char *LibcallRoutineNames[RTLIB::UNKNOWN_LIBCALL + 1];</td>
    <td class="lineNumber">3442</td>
    <td class="codeline">  const char *LibcallRoutineNames[RTLIB::UNKNOWN_LIBCALL + 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="codeline"></td>
    <td class="lineNumber">3443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="codeline">  /// The ISD::CondCode that should be used to test the result of each of the</td>
    <td class="lineNumber">3444</td>
    <td class="codeline">  /// The ISD::CondCode that should be used to test the result of each of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="codeline">  /// comparison libcall against zero.</td>
    <td class="lineNumber">3445</td>
    <td class="codeline">  /// comparison libcall against zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class="codeline">  ISD::CondCode CmpLibcallCCs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td class="lineNumber">3446</td>
    <td class="codeline">  ISD::CondCode CmpLibcallCCs[RTLIB::UNKNOWN_LIBCALL];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="codeline"></td>
    <td class="lineNumber">3447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="codeline">  /// Stores the CallingConv that should be used for each libcall.</td>
    <td class="lineNumber">3448</td>
    <td class="codeline">  /// Stores the CallingConv that should be used for each libcall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="codeline">  CallingConv::ID LibcallCallingConvs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td class="lineNumber">3449</td>
    <td class="codeline">  CallingConv::ID LibcallCallingConvs[RTLIB::UNKNOWN_LIBCALL];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class="codeline"></td>
    <td class="lineNumber">3450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="codeline">  /// Set default libcall names and calling conventions.</td>
    <td class="lineNumber">3451</td>
    <td class="codeline">  /// Set default libcall names and calling conventions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="codeline">  void InitLibcalls(const Triple &TT);</td>
    <td class="lineNumber">3452</td>
    <td class="codeline">  void InitLibcalls(const Triple &TT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class="codeline"></td>
    <td class="lineNumber">3453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="codeline">  /// The bits of IndexedModeActions used to store the legalisation actions</td>
    <td class="lineNumber">3454</td>
    <td class="codeline">  /// The bits of IndexedModeActions used to store the legalisation actions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="codeline">  /// We store the data as   | ML | MS |  L |  S | each taking 4 bits.</td>
    <td class="lineNumber">3455</td>
    <td class="codeline">  /// We store the data as   | ML | MS |  L |  S | each taking 4 bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="codeline">  enum IndexedModeActionsBits {</td>
    <td class="lineNumber">3456</td>
    <td class="codeline">  enum IndexedModeActionsBits {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="codeline">    IMAB_Store = 0,</td>
    <td class="lineNumber">3457</td>
    <td class="codeline">    IMAB_Store = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="codeline">    IMAB_Load = 4,</td>
    <td class="lineNumber">3458</td>
    <td class="codeline">    IMAB_Load = 4,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="codeline">    IMAB_MaskedStore = 8,</td>
    <td class="lineNumber">3459</td>
    <td class="codeline">    IMAB_MaskedStore = 8,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="codeline">    IMAB_MaskedLoad = 12</td>
    <td class="lineNumber">3460</td>
    <td class="codeline">    IMAB_MaskedLoad = 12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">3461</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="codeline"></td>
    <td class="lineNumber">3462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="codeline">  void setIndexedModeAction(unsigned IdxMode, MVT VT, unsigned Shift,</td>
    <td class="lineNumber">3463</td>
    <td class="codeline">  void setIndexedModeAction(unsigned IdxMode, MVT VT, unsigned Shift,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="codeline">                            LegalizeAction Action) {</td>
    <td class="lineNumber">3464</td>
    <td class="codeline">                            LegalizeAction Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="codeline">    assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE &&</td>
    <td class="lineNumber">3465</td>
    <td class="codeline">    assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="codeline">           (unsigned)Action < 0xf && "Table isn't big enough!");</td>
    <td class="lineNumber">3466</td>
    <td class="codeline">           (unsigned)Action < 0xf && "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="codeline">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td class="lineNumber">3467</td>
    <td class="codeline">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="codeline">    IndexedModeActions[Ty][IdxMode] &= ~(0xf << Shift);</td>
    <td class="lineNumber">3468</td>
    <td class="codeline">    IndexedModeActions[Ty][IdxMode] &= ~(0xf << Shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="codeline">    IndexedModeActions[Ty][IdxMode] |= ((uint16_t)Action) << Shift;</td>
    <td class="lineNumber">3469</td>
    <td class="codeline">    IndexedModeActions[Ty][IdxMode] |= ((uint16_t)Action) << Shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3470</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="codeline"></td>
    <td class="lineNumber">3471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="codeline">  LegalizeAction getIndexedModeAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">3472</td>
    <td class="codeline">  LegalizeAction getIndexedModeAction(unsigned IdxMode, MVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="codeline">                                      unsigned Shift) const {</td>
    <td class="lineNumber">3473</td>
    <td class="codeline">                                      unsigned Shift) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="codeline">    assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() &&</td>
    <td class="lineNumber">3474</td>
    <td class="codeline">    assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="codeline">           "Table isn't big enough!");</td>
    <td class="lineNumber">3475</td>
    <td class="codeline">           "Table isn't big enough!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="codeline">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td class="lineNumber">3476</td>
    <td class="codeline">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="codeline">    return (LegalizeAction)((IndexedModeActions[Ty][IdxMode] >> Shift) & 0xf);</td>
    <td class="lineNumber">3477</td>
    <td class="codeline">    return (LegalizeAction)((IndexedModeActions[Ty][IdxMode] >> Shift) & 0xf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3478</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="codeline"></td>
    <td class="lineNumber">3479</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">3480</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="codeline">  /// Return true if the extension represented by \p I is free.</td>
    <td class="lineNumber">3481</td>
    <td class="codeline">  /// Return true if the extension represented by \p I is free.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="codeline">  /// \pre \p I is a sign, zero, or fp extension and</td>
    <td class="lineNumber">3482</td>
    <td class="codeline">  /// \pre \p I is a sign, zero, or fp extension and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="codeline">  ///      is[Z|FP]ExtFree of the related types is not true.</td>
    <td class="lineNumber">3483</td>
    <td class="codeline">  ///      is[Z|FP]ExtFree of the related types is not true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="codeline">  virtual bool isExtFreeImpl(const Instruction *I) const { return false; }</td>
    <td class="lineNumber">3484</td>
    <td class="codeline">  virtual bool isExtFreeImpl(const Instruction *I) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class="codeline"></td>
    <td class="lineNumber">3485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="codeline">  /// Depth that GatherAllAliases should should continue looking for chain</td>
    <td class="lineNumber">3486</td>
    <td class="codeline">  /// Depth that GatherAllAliases should should continue looking for chain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="codeline">  /// dependencies when trying to find a more preferable chain. As an</td>
    <td class="lineNumber">3487</td>
    <td class="codeline">  /// dependencies when trying to find a more preferable chain. As an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="codeline">  /// approximation, this should be more than the number of consecutive stores</td>
    <td class="lineNumber">3488</td>
    <td class="codeline">  /// approximation, this should be more than the number of consecutive stores</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="codeline">  /// expected to be merged.</td>
    <td class="lineNumber">3489</td>
    <td class="codeline">  /// expected to be merged.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="codeline">  unsigned GatherAllAliasesMaxDepth;</td>
    <td class="lineNumber">3490</td>
    <td class="codeline">  unsigned GatherAllAliasesMaxDepth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class="codeline"></td>
    <td class="lineNumber">3491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="codeline">  /// \brief Specify maximum number of store instructions per memset call.</td>
    <td class="lineNumber">3492</td>
    <td class="codeline">  /// \brief Specify maximum number of store instructions per memset call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3493</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="codeline">  /// When lowering \@llvm.memset this field specifies the maximum number of</td>
    <td class="lineNumber">3494</td>
    <td class="codeline">  /// When lowering \@llvm.memset this field specifies the maximum number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class="codeline">  /// store operations that may be substituted for the call to memset. Targets</td>
    <td class="lineNumber">3495</td>
    <td class="codeline">  /// store operations that may be substituted for the call to memset. Targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="codeline">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">3496</td>
    <td class="codeline">  /// must set this value based on the cost threshold for that target. Targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="codeline">  /// should assume that the memset will be done using as many of the largest</td>
    <td class="lineNumber">3497</td>
    <td class="codeline">  /// should assume that the memset will be done using as many of the largest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="codeline">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">3498</td>
    <td class="codeline">  /// store operations first, followed by smaller ones, if necessary, per</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="codeline">  /// alignment restrictions. For example, storing 9 bytes on a 32-bit machine</td>
    <td class="lineNumber">3499</td>
    <td class="codeline">  /// alignment restrictions. For example, storing 9 bytes on a 32-bit machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="codeline">  /// with 16-bit alignment would result in four 2-byte stores and one 1-byte</td>
    <td class="lineNumber">3500</td>
    <td class="codeline">  /// with 16-bit alignment would result in four 2-byte stores and one 1-byte</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="codeline">  /// store.  This only applies to setting a constant array of a constant size.</td>
    <td class="lineNumber">3501</td>
    <td class="codeline">  /// store.  This only applies to setting a constant array of a constant size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="codeline">  unsigned MaxStoresPerMemset;</td>
    <td class="lineNumber">3502</td>
    <td class="codeline">  unsigned MaxStoresPerMemset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">3503</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="codeline">  unsigned MaxStoresPerMemsetOptSize;</td>
    <td class="lineNumber">3504</td>
    <td class="codeline">  unsigned MaxStoresPerMemsetOptSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="codeline"></td>
    <td class="lineNumber">3505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="codeline">  /// \brief Specify maximum number of store instructions per memcpy call.</td>
    <td class="lineNumber">3506</td>
    <td class="codeline">  /// \brief Specify maximum number of store instructions per memcpy call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3507</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="codeline">  /// When lowering \@llvm.memcpy this field specifies the maximum number of</td>
    <td class="lineNumber">3508</td>
    <td class="codeline">  /// When lowering \@llvm.memcpy this field specifies the maximum number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="codeline">  /// store operations that may be substituted for a call to memcpy. Targets</td>
    <td class="lineNumber">3509</td>
    <td class="codeline">  /// store operations that may be substituted for a call to memcpy. Targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="codeline">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">3510</td>
    <td class="codeline">  /// must set this value based on the cost threshold for that target. Targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="codeline">  /// should assume that the memcpy will be done using as many of the largest</td>
    <td class="lineNumber">3511</td>
    <td class="codeline">  /// should assume that the memcpy will be done using as many of the largest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="codeline">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">3512</td>
    <td class="codeline">  /// store operations first, followed by smaller ones, if necessary, per</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="codeline">  /// alignment restrictions. For example, storing 7 bytes on a 32-bit machine</td>
    <td class="lineNumber">3513</td>
    <td class="codeline">  /// alignment restrictions. For example, storing 7 bytes on a 32-bit machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="codeline">  /// with 32-bit alignment would result in one 4-byte store, a one 2-byte store</td>
    <td class="lineNumber">3514</td>
    <td class="codeline">  /// with 32-bit alignment would result in one 4-byte store, a one 2-byte store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="codeline">  /// and one 1-byte store. This only applies to copying a constant array of</td>
    <td class="lineNumber">3515</td>
    <td class="codeline">  /// and one 1-byte store. This only applies to copying a constant array of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="codeline">  /// constant size.</td>
    <td class="lineNumber">3516</td>
    <td class="codeline">  /// constant size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="codeline">  unsigned MaxStoresPerMemcpy;</td>
    <td class="lineNumber">3517</td>
    <td class="codeline">  unsigned MaxStoresPerMemcpy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">3518</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="codeline">  unsigned MaxStoresPerMemcpyOptSize;</td>
    <td class="lineNumber">3519</td>
    <td class="codeline">  unsigned MaxStoresPerMemcpyOptSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="codeline">  /// \brief Specify max number of store instructions to glue in inlined memcpy.</td>
    <td class="lineNumber">3520</td>
    <td class="codeline">  /// \brief Specify max number of store instructions to glue in inlined memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3521</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="codeline">  /// When memcpy is inlined based on MaxStoresPerMemcpy, specify maximum number</td>
    <td class="lineNumber">3522</td>
    <td class="codeline">  /// When memcpy is inlined based on MaxStoresPerMemcpy, specify maximum number</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="codeline">  /// of store instructions to keep together. This helps in pairing and</td>
    <td class="lineNumber">3523</td>
    <td class="codeline">  /// of store instructions to keep together. This helps in pairing and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="codeline">  //  vectorization later on.</td>
    <td class="lineNumber">3524</td>
    <td class="codeline">  //  vectorization later on.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="codeline">  unsigned MaxGluedStoresPerMemcpy = 0;</td>
    <td class="lineNumber">3525</td>
    <td class="codeline">  unsigned MaxGluedStoresPerMemcpy = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class="codeline"></td>
    <td class="lineNumber">3526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="codeline">  /// \brief Specify maximum number of load instructions per memcmp call.</td>
    <td class="lineNumber">3527</td>
    <td class="codeline">  /// \brief Specify maximum number of load instructions per memcmp call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3528</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="codeline">  /// When lowering \@llvm.memcmp this field specifies the maximum number of</td>
    <td class="lineNumber">3529</td>
    <td class="codeline">  /// When lowering \@llvm.memcmp this field specifies the maximum number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="codeline">  /// pairs of load operations that may be substituted for a call to memcmp.</td>
    <td class="lineNumber">3530</td>
    <td class="codeline">  /// pairs of load operations that may be substituted for a call to memcmp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="codeline">  /// Targets must set this value based on the cost threshold for that target.</td>
    <td class="lineNumber">3531</td>
    <td class="codeline">  /// Targets must set this value based on the cost threshold for that target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="codeline">  /// Targets should assume that the memcmp will be done using as many of the</td>
    <td class="lineNumber">3532</td>
    <td class="codeline">  /// Targets should assume that the memcmp will be done using as many of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="codeline">  /// largest load operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">3533</td>
    <td class="codeline">  /// largest load operations first, followed by smaller ones, if necessary, per</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="codeline">  /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine</td>
    <td class="lineNumber">3534</td>
    <td class="codeline">  /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="codeline">  /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load</td>
    <td class="lineNumber">3535</td>
    <td class="codeline">  /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="codeline">  /// and one 1-byte load. This only applies to copying a constant array of</td>
    <td class="lineNumber">3536</td>
    <td class="codeline">  /// and one 1-byte load. This only applies to copying a constant array of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="codeline">  /// constant size.</td>
    <td class="lineNumber">3537</td>
    <td class="codeline">  /// constant size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="codeline">  unsigned MaxLoadsPerMemcmp;</td>
    <td class="lineNumber">3538</td>
    <td class="codeline">  unsigned MaxLoadsPerMemcmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">3539</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="codeline">  unsigned MaxLoadsPerMemcmpOptSize;</td>
    <td class="lineNumber">3540</td>
    <td class="codeline">  unsigned MaxLoadsPerMemcmpOptSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="codeline"></td>
    <td class="lineNumber">3541</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="codeline">  /// \brief Specify maximum number of store instructions per memmove call.</td>
    <td class="lineNumber">3542</td>
    <td class="codeline">  /// \brief Specify maximum number of store instructions per memmove call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3543</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="codeline">  /// When lowering \@llvm.memmove this field specifies the maximum number of</td>
    <td class="lineNumber">3544</td>
    <td class="codeline">  /// When lowering \@llvm.memmove this field specifies the maximum number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="codeline">  /// store instructions that may be substituted for a call to memmove. Targets</td>
    <td class="lineNumber">3545</td>
    <td class="codeline">  /// store instructions that may be substituted for a call to memmove. Targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="codeline">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">3546</td>
    <td class="codeline">  /// must set this value based on the cost threshold for that target. Targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="codeline">  /// should assume that the memmove will be done using as many of the largest</td>
    <td class="lineNumber">3547</td>
    <td class="codeline">  /// should assume that the memmove will be done using as many of the largest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="codeline">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">3548</td>
    <td class="codeline">  /// store operations first, followed by smaller ones, if necessary, per</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="codeline">  /// alignment restrictions. For example, moving 9 bytes on a 32-bit machine</td>
    <td class="lineNumber">3549</td>
    <td class="codeline">  /// alignment restrictions. For example, moving 9 bytes on a 32-bit machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="codeline">  /// with 8-bit alignment would result in nine 1-byte stores.  This only</td>
    <td class="lineNumber">3550</td>
    <td class="codeline">  /// with 8-bit alignment would result in nine 1-byte stores.  This only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="codeline">  /// applies to copying a constant array of constant size.</td>
    <td class="lineNumber">3551</td>
    <td class="codeline">  /// applies to copying a constant array of constant size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="codeline">  unsigned MaxStoresPerMemmove;</td>
    <td class="lineNumber">3552</td>
    <td class="codeline">  unsigned MaxStoresPerMemmove;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">3553</td>
    <td class="codeline">  /// Likewise for functions with the OptSize attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="codeline">  unsigned MaxStoresPerMemmoveOptSize;</td>
    <td class="lineNumber">3554</td>
    <td class="codeline">  unsigned MaxStoresPerMemmoveOptSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="codeline"></td>
    <td class="lineNumber">3555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="codeline">  /// Tells the code generator that select is more expensive than a branch if</td>
    <td class="lineNumber">3556</td>
    <td class="codeline">  /// Tells the code generator that select is more expensive than a branch if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class="codeline">  /// the branch is usually predicted right.</td>
    <td class="lineNumber">3557</td>
    <td class="codeline">  /// the branch is usually predicted right.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="codeline">  bool PredictableSelectIsExpensive;</td>
    <td class="lineNumber">3558</td>
    <td class="codeline">  bool PredictableSelectIsExpensive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="codeline"></td>
    <td class="lineNumber">3559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="codeline">  /// \see enableExtLdPromotion.</td>
    <td class="lineNumber">3560</td>
    <td class="codeline">  /// \see enableExtLdPromotion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="codeline">  bool EnableExtLdPromotion;</td>
    <td class="lineNumber">3561</td>
    <td class="codeline">  bool EnableExtLdPromotion;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class="codeline"></td>
    <td class="lineNumber">3562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="codeline">  /// Return true if the value types that can be represented by the specified</td>
    <td class="lineNumber">3563</td>
    <td class="codeline">  /// Return true if the value types that can be represented by the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="codeline">  /// register class are all legal.</td>
    <td class="lineNumber">3564</td>
    <td class="codeline">  /// register class are all legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="codeline">  bool isLegalRC(const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">3565</td>
    <td class="codeline">  bool isLegalRC(const TargetRegisterInfo &TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="codeline">                 const TargetRegisterClass &RC) const;</td>
    <td class="lineNumber">3566</td>
    <td class="codeline">                 const TargetRegisterClass &RC) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class="codeline"></td>
    <td class="lineNumber">3567</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="codeline">  /// Replace/modify any TargetFrameIndex operands with a targte-dependent</td>
    <td class="lineNumber">3568</td>
    <td class="codeline">  /// Replace/modify any TargetFrameIndex operands with a targte-dependent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="codeline">  /// sequence of memory operands that is recognized by PrologEpilogInserter.</td>
    <td class="lineNumber">3569</td>
    <td class="codeline">  /// sequence of memory operands that is recognized by PrologEpilogInserter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="codeline">  MachineBasicBlock *emitPatchPoint(MachineInstr &MI,</td>
    <td class="lineNumber">3570</td>
    <td class="codeline">  MachineBasicBlock *emitPatchPoint(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="codeline">                                    MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">3571</td>
    <td class="codeline">                                    MachineBasicBlock *MBB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class="codeline"></td>
    <td class="lineNumber">3572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="codeline">  bool IsStrictFPEnabled;</td>
    <td class="lineNumber">3573</td>
    <td class="codeline">  bool IsStrictFPEnabled;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="codeline">};</td>
    <td class="lineNumber">3574</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="codeline"></td>
    <td class="lineNumber">3575</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="codeline">/// This class defines information used to lower LLVM code to legal SelectionDAG</td>
    <td class="lineNumber">3576</td>
    <td class="codeline">/// This class defines information used to lower LLVM code to legal SelectionDAG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="codeline">/// operators that the target instruction selector can accept natively.</td>
    <td class="lineNumber">3577</td>
    <td class="codeline">/// operators that the target instruction selector can accept natively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="codeline">///</td>
    <td class="lineNumber">3578</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="codeline">/// This class also defines callbacks that targets must implement to lower</td>
    <td class="lineNumber">3579</td>
    <td class="codeline">/// This class also defines callbacks that targets must implement to lower</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="codeline">/// target-specific constructs to SelectionDAG operators.</td>
    <td class="lineNumber">3580</td>
    <td class="codeline">/// target-specific constructs to SelectionDAG operators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="codeline">class TargetLowering : public TargetLoweringBase {</td>
    <td class="lineNumber">3581</td>
    <td class="codeline">class TargetLowering : public TargetLoweringBase {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">3582</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="codeline">  struct DAGCombinerInfo;</td>
    <td class="lineNumber">3583</td>
    <td class="codeline">  struct DAGCombinerInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="codeline">  struct MakeLibCallOptions;</td>
    <td class="lineNumber">3584</td>
    <td class="codeline">  struct MakeLibCallOptions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="codeline"></td>
    <td class="lineNumber">3585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="codeline">  TargetLowering(const TargetLowering &) = delete;</td>
    <td class="lineNumber">3586</td>
    <td class="codeline">  TargetLowering(const TargetLowering &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class="codeline">  TargetLowering &operator=(const TargetLowering &) = delete;</td>
    <td class="lineNumber">3587</td>
    <td class="codeline">  TargetLowering &operator=(const TargetLowering &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="codeline"></td>
    <td class="lineNumber">3588</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="codeline">  explicit TargetLowering(const TargetMachine &TM);</td>
    <td class="lineNumber">3589</td>
    <td class="codeline">  explicit TargetLowering(const TargetMachine &TM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="codeline"></td>
    <td class="lineNumber">3590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="codeline">  bool isPositionIndependent() const;</td>
    <td class="lineNumber">3591</td>
    <td class="codeline">  bool isPositionIndependent() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class="codeline"></td>
    <td class="lineNumber">3592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="codeline">  virtual bool isSDNodeSourceOfDivergence(const SDNode *N,</td>
    <td class="lineNumber">3593</td>
    <td class="codeline">  virtual bool isSDNodeSourceOfDivergence(const SDNode *N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="codeline">                                          FunctionLoweringInfo *FLI,</td>
    <td class="lineNumber">3594</td>
    <td class="codeline">                                          FunctionLoweringInfo *FLI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="codeline">                                          UniformityInfo *UA) const {</td>
    <td class="lineNumber">3595</td>
    <td class="codeline">                                          UniformityInfo *UA) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3596</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3597</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="codeline"></td>
    <td class="lineNumber">3598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="codeline">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td class="lineNumber">3599</td>
    <td class="codeline">  // Lets target to control the following reassociation of operands: (op (op x,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="codeline">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td class="lineNumber">3600</td>
    <td class="codeline">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="codeline">  // default consider profitable any case where N0 has single use.  This</td>
    <td class="lineNumber">3601</td>
    <td class="codeline">  // default consider profitable any case where N0 has single use.  This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class="codeline">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td class="lineNumber">3602</td>
    <td class="codeline">  // behavior reflects the condition replaced by this target hook call in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="codeline">  // DAGCombiner.  Any particular target can implement its own heuristic to</td>
    <td class="lineNumber">3603</td>
    <td class="codeline">  // DAGCombiner.  Any particular target can implement its own heuristic to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="codeline">  // restrict common combiner.</td>
    <td class="lineNumber">3604</td>
    <td class="codeline">  // restrict common combiner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="codeline">  virtual bool isReassocProfitable(SelectionDAG &DAG, SDValue N0,</td>
    <td class="lineNumber">3605</td>
    <td class="codeline">  virtual bool isReassocProfitable(SelectionDAG &DAG, SDValue N0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="codeline">                                   SDValue N1) const {</td>
    <td class="lineNumber">3606</td>
    <td class="codeline">                                   SDValue N1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="codeline">    return N0.hasOneUse();</td>
    <td class="lineNumber">3607</td>
    <td class="codeline">    return N0.hasOneUse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3608</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="codeline"></td>
    <td class="lineNumber">3609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="codeline">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td class="lineNumber">3610</td>
    <td class="codeline">  // Lets target to control the following reassociation of operands: (op (op x,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="codeline">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td class="lineNumber">3611</td>
    <td class="codeline">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="codeline">  // default consider profitable any case where N0 has single use.  This</td>
    <td class="lineNumber">3612</td>
    <td class="codeline">  // default consider profitable any case where N0 has single use.  This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="codeline">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td class="lineNumber">3613</td>
    <td class="codeline">  // behavior reflects the condition replaced by this target hook call in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="codeline">  // combiner.  Any particular target can implement its own heuristic to</td>
    <td class="lineNumber">3614</td>
    <td class="codeline">  // combiner.  Any particular target can implement its own heuristic to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="codeline">  // restrict common combiner.</td>
    <td class="lineNumber">3615</td>
    <td class="codeline">  // restrict common combiner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="codeline">  virtual bool isReassocProfitable(MachineRegisterInfo &MRI, Register N0,</td>
    <td class="lineNumber">3616</td>
    <td class="codeline">  virtual bool isReassocProfitable(MachineRegisterInfo &MRI, Register N0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="codeline">                                   Register N1) const {</td>
    <td class="lineNumber">3617</td>
    <td class="codeline">                                   Register N1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="codeline">    return MRI.hasOneNonDBGUse(N0);</td>
    <td class="lineNumber">3618</td>
    <td class="codeline">    return MRI.hasOneNonDBGUse(N0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3619</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class="codeline"></td>
    <td class="lineNumber">3620</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="codeline">  virtual bool isSDNodeAlwaysUniform(const SDNode * N) const {</td>
    <td class="lineNumber">3621</td>
    <td class="codeline">  virtual bool isSDNodeAlwaysUniform(const SDNode * N) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3622</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3623</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class="codeline"></td>
    <td class="lineNumber">3624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="codeline">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td class="lineNumber">3625</td>
    <td class="codeline">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="codeline">  /// by reference if the node's address can be legally represented as</td>
    <td class="lineNumber">3626</td>
    <td class="codeline">  /// by reference if the node's address can be legally represented as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="codeline">  /// pre-indexed load / store address.</td>
    <td class="lineNumber">3627</td>
    <td class="codeline">  /// pre-indexed load / store address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="codeline">  virtual bool getPreIndexedAddressParts(SDNode * /*N*/, SDValue &/*Base*/,</td>
    <td class="lineNumber">3628</td>
    <td class="codeline">  virtual bool getPreIndexedAddressParts(SDNode * /*N*/, SDValue &/*Base*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="codeline">                                         SDValue &/*Offset*/,</td>
    <td class="lineNumber">3629</td>
    <td class="codeline">                                         SDValue &/*Offset*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="codeline">                                         ISD::MemIndexedMode &/*AM*/,</td>
    <td class="lineNumber">3630</td>
    <td class="codeline">                                         ISD::MemIndexedMode &/*AM*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="codeline">                                         SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">3631</td>
    <td class="codeline">                                         SelectionDAG &/*DAG*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3632</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3633</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="codeline"></td>
    <td class="lineNumber">3634</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="codeline">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td class="lineNumber">3635</td>
    <td class="codeline">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="codeline">  /// by reference if this node can be combined with a load / store to form a</td>
    <td class="lineNumber">3636</td>
    <td class="codeline">  /// by reference if this node can be combined with a load / store to form a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="codeline">  /// post-indexed load / store.</td>
    <td class="lineNumber">3637</td>
    <td class="codeline">  /// post-indexed load / store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="codeline">  virtual bool getPostIndexedAddressParts(SDNode * /*N*/, SDNode * /*Op*/,</td>
    <td class="lineNumber">3638</td>
    <td class="codeline">  virtual bool getPostIndexedAddressParts(SDNode * /*N*/, SDNode * /*Op*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="codeline">                                          SDValue &/*Base*/,</td>
    <td class="lineNumber">3639</td>
    <td class="codeline">                                          SDValue &/*Base*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="codeline">                                          SDValue &/*Offset*/,</td>
    <td class="lineNumber">3640</td>
    <td class="codeline">                                          SDValue &/*Offset*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class="codeline">                                          ISD::MemIndexedMode &/*AM*/,</td>
    <td class="lineNumber">3641</td>
    <td class="codeline">                                          ISD::MemIndexedMode &/*AM*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="codeline">                                          SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">3642</td>
    <td class="codeline">                                          SelectionDAG &/*DAG*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3643</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3644</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="codeline"></td>
    <td class="lineNumber">3645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="codeline">  /// Returns true if the specified base+offset is a legal indexed addressing</td>
    <td class="lineNumber">3646</td>
    <td class="codeline">  /// Returns true if the specified base+offset is a legal indexed addressing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class="codeline">  /// mode for this target. \p MI is the load or store instruction that is being</td>
    <td class="lineNumber">3647</td>
    <td class="codeline">  /// mode for this target. \p MI is the load or store instruction that is being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="codeline">  /// considered for transformation.</td>
    <td class="lineNumber">3648</td>
    <td class="codeline">  /// considered for transformation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="codeline">  virtual bool isIndexingLegal(MachineInstr &MI, Register Base, Register Offset,</td>
    <td class="lineNumber">3649</td>
    <td class="codeline">  virtual bool isIndexingLegal(MachineInstr &MI, Register Base, Register Offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="codeline">                               bool IsPre, MachineRegisterInfo &MRI) const {</td>
    <td class="lineNumber">3650</td>
    <td class="codeline">                               bool IsPre, MachineRegisterInfo &MRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3651</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3652</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class="codeline"></td>
    <td class="lineNumber">3653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="codeline">  /// Return the entry encoding for a jump table in the current function.  The</td>
    <td class="lineNumber">3654</td>
    <td class="codeline">  /// Return the entry encoding for a jump table in the current function.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="codeline">  /// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.</td>
    <td class="lineNumber">3655</td>
    <td class="codeline">  /// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="codeline">  virtual unsigned getJumpTableEncoding() const;</td>
    <td class="lineNumber">3656</td>
    <td class="codeline">  virtual unsigned getJumpTableEncoding() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class="codeline"></td>
    <td class="lineNumber">3657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="codeline">  virtual const MCExpr *</td>
    <td class="lineNumber">3658</td>
    <td class="codeline">  virtual const MCExpr *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="codeline">  LowerCustomJumpTableEntry(const MachineJumpTableInfo * /*MJTI*/,</td>
    <td class="lineNumber">3659</td>
    <td class="codeline">  LowerCustomJumpTableEntry(const MachineJumpTableInfo * /*MJTI*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="codeline">                            const MachineBasicBlock * /*MBB*/, unsigned /*uid*/,</td>
    <td class="lineNumber">3660</td>
    <td class="codeline">                            const MachineBasicBlock * /*MBB*/, unsigned /*uid*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="codeline">                            MCContext &/*Ctx*/) const {</td>
    <td class="lineNumber">3661</td>
    <td class="codeline">                            MCContext &/*Ctx*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="codeline">    llvm_unreachable("Need to implement this hook if target has custom JTIs");</td>
    <td class="lineNumber">3662</td>
    <td class="codeline">    llvm_unreachable("Need to implement this hook if target has custom JTIs");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3663</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="codeline"></td>
    <td class="lineNumber">3664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="codeline">  /// Returns relocation base for the given PIC jumptable.</td>
    <td class="lineNumber">3665</td>
    <td class="codeline">  /// Returns relocation base for the given PIC jumptable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="codeline">  virtual SDValue getPICJumpTableRelocBase(SDValue Table,</td>
    <td class="lineNumber">3666</td>
    <td class="codeline">  virtual SDValue getPICJumpTableRelocBase(SDValue Table,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="codeline">                                           SelectionDAG &DAG) const;</td>
    <td class="lineNumber">3667</td>
    <td class="codeline">                                           SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="codeline"></td>
    <td class="lineNumber">3668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="codeline">  /// This returns the relocation base for the given PIC jumptable, the same as</td>
    <td class="lineNumber">3669</td>
    <td class="codeline">  /// This returns the relocation base for the given PIC jumptable, the same as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="codeline">  /// getPICJumpTableRelocBase, but as an MCExpr.</td>
    <td class="lineNumber">3670</td>
    <td class="codeline">  /// getPICJumpTableRelocBase, but as an MCExpr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="codeline">  virtual const MCExpr *</td>
    <td class="lineNumber">3671</td>
    <td class="codeline">  virtual const MCExpr *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="codeline">  getPICJumpTableRelocBaseExpr(const MachineFunction *MF,</td>
    <td class="lineNumber">3672</td>
    <td class="codeline">  getPICJumpTableRelocBaseExpr(const MachineFunction *MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="codeline">                               unsigned JTI, MCContext &Ctx) const;</td>
    <td class="lineNumber">3673</td>
    <td class="codeline">                               unsigned JTI, MCContext &Ctx) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="codeline"></td>
    <td class="lineNumber">3674</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="codeline">  /// Return true if folding a constant offset with the given GlobalAddress is</td>
    <td class="lineNumber">3675</td>
    <td class="codeline">  /// Return true if folding a constant offset with the given GlobalAddress is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="codeline">  /// legal.  It is frequently not legal in PIC relocation models.</td>
    <td class="lineNumber">3676</td>
    <td class="codeline">  /// legal.  It is frequently not legal in PIC relocation models.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="codeline">  virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;</td>
    <td class="lineNumber">3677</td>
    <td class="codeline">  virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="codeline"></td>
    <td class="lineNumber">3678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="codeline">  /// On x86, return true if the operand with index OpNo is a CALL or JUMP</td>
    <td class="lineNumber">3679</td>
    <td class="codeline">  /// On x86, return true if the operand with index OpNo is a CALL or JUMP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="codeline">  /// instruction, which can use either a memory constraint or an address</td>
    <td class="lineNumber">3680</td>
    <td class="codeline">  /// instruction, which can use either a memory constraint or an address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="codeline">  /// constraint. -fasm-blocks "__asm call foo" lowers to</td>
    <td class="lineNumber">3681</td>
    <td class="codeline">  /// constraint. -fasm-blocks "__asm call foo" lowers to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="codeline">  /// call void asm sideeffect inteldialect "call ${0:P}", "*m..."</td>
    <td class="lineNumber">3682</td>
    <td class="codeline">  /// call void asm sideeffect inteldialect "call ${0:P}", "*m..."</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">3683</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="codeline">  /// This function is used by a hack to choose the address constraint,</td>
    <td class="lineNumber">3684</td>
    <td class="codeline">  /// This function is used by a hack to choose the address constraint,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="codeline">  /// lowering to a direct call.</td>
    <td class="lineNumber">3685</td>
    <td class="codeline">  /// lowering to a direct call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">3686</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="codeline">  isInlineAsmTargetBranch(const SmallVectorImpl<StringRef> &AsmStrs,</td>
    <td class="lineNumber">3687</td>
    <td class="codeline">  isInlineAsmTargetBranch(const SmallVectorImpl<StringRef> &AsmStrs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="codeline">                          unsigned OpNo) const {</td>
    <td class="lineNumber">3688</td>
    <td class="codeline">                          unsigned OpNo) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3689</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3690</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="codeline"></td>
    <td class="lineNumber">3691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="codeline">  bool isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,</td>
    <td class="lineNumber">3692</td>
    <td class="codeline">  bool isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="codeline">                            SDValue &Chain) const;</td>
    <td class="lineNumber">3693</td>
    <td class="codeline">                            SDValue &Chain) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="codeline"></td>
    <td class="lineNumber">3694</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="codeline">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td class="lineNumber">3695</td>
    <td class="codeline">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="codeline">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td class="lineNumber">3696</td>
    <td class="codeline">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="codeline">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td class="lineNumber">3697</td>
    <td class="codeline">                           const SDLoc &DL, const SDValue OldLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="codeline">                           const SDValue OldRHS) const;</td>
    <td class="lineNumber">3698</td>
    <td class="codeline">                           const SDValue OldRHS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class="codeline"></td>
    <td class="lineNumber">3699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="codeline">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td class="lineNumber">3700</td>
    <td class="codeline">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="codeline">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td class="lineNumber">3701</td>
    <td class="codeline">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="codeline">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td class="lineNumber">3702</td>
    <td class="codeline">                           const SDLoc &DL, const SDValue OldLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="codeline">                           const SDValue OldRHS, SDValue &Chain,</td>
    <td class="lineNumber">3703</td>
    <td class="codeline">                           const SDValue OldRHS, SDValue &Chain,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="codeline">                           bool IsSignaling = false) const;</td>
    <td class="lineNumber">3704</td>
    <td class="codeline">                           bool IsSignaling = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="codeline"></td>
    <td class="lineNumber">3705</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="codeline">  /// Returns a pair of (return value, chain).</td>
    <td class="lineNumber">3706</td>
    <td class="codeline">  /// Returns a pair of (return value, chain).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="codeline">  /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \p LC.</td>
    <td class="lineNumber">3707</td>
    <td class="codeline">  /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \p LC.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="codeline">  std::pair<SDValue, SDValue> makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC,</td>
    <td class="lineNumber">3708</td>
    <td class="codeline">  std::pair<SDValue, SDValue> makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="codeline">                                          EVT RetVT, ArrayRef<SDValue> Ops,</td>
    <td class="lineNumber">3709</td>
    <td class="codeline">                                          EVT RetVT, ArrayRef<SDValue> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="codeline">                                          MakeLibCallOptions CallOptions,</td>
    <td class="lineNumber">3710</td>
    <td class="codeline">                                          MakeLibCallOptions CallOptions,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="codeline">                                          const SDLoc &dl,</td>
    <td class="lineNumber">3711</td>
    <td class="codeline">                                          const SDLoc &dl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="codeline">                                          SDValue Chain = SDValue()) const;</td>
    <td class="lineNumber">3712</td>
    <td class="codeline">                                          SDValue Chain = SDValue()) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="codeline"></td>
    <td class="lineNumber">3713</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="codeline">  /// Check whether parameters to a call that are passed in callee saved</td>
    <td class="lineNumber">3714</td>
    <td class="codeline">  /// Check whether parameters to a call that are passed in callee saved</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="codeline">  /// registers are the same as from the calling function.  This needs to be</td>
    <td class="lineNumber">3715</td>
    <td class="codeline">  /// registers are the same as from the calling function.  This needs to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="codeline">  /// checked for tail call eligibility.</td>
    <td class="lineNumber">3716</td>
    <td class="codeline">  /// checked for tail call eligibility.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="codeline">  bool parametersInCSRMatch(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">3717</td>
    <td class="codeline">  bool parametersInCSRMatch(const MachineRegisterInfo &MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="codeline">      const uint32_t *CallerPreservedMask,</td>
    <td class="lineNumber">3718</td>
    <td class="codeline">      const uint32_t *CallerPreservedMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="codeline">      const SmallVectorImpl<CCValAssign> &ArgLocs,</td>
    <td class="lineNumber">3719</td>
    <td class="codeline">      const SmallVectorImpl<CCValAssign> &ArgLocs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="codeline">      const SmallVectorImpl<SDValue> &OutVals) const;</td>
    <td class="lineNumber">3720</td>
    <td class="codeline">      const SmallVectorImpl<SDValue> &OutVals) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="codeline"></td>
    <td class="lineNumber">3721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">3722</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="codeline">  // TargetLowering Optimization Methods</td>
    <td class="lineNumber">3723</td>
    <td class="codeline">  // TargetLowering Optimization Methods</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">3724</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="codeline"></td>
    <td class="lineNumber">3725</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="codeline">  /// A convenience struct that encapsulates a DAG, and two SDValues for</td>
    <td class="lineNumber">3726</td>
    <td class="codeline">  /// A convenience struct that encapsulates a DAG, and two SDValues for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="codeline">  /// returning information from TargetLowering to its clients that want to</td>
    <td class="lineNumber">3727</td>
    <td class="codeline">  /// returning information from TargetLowering to its clients that want to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="codeline">  /// combine.</td>
    <td class="lineNumber">3728</td>
    <td class="codeline">  /// combine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="codeline">  struct TargetLoweringOpt {</td>
    <td class="lineNumber">3729</td>
    <td class="codeline">  struct TargetLoweringOpt {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="codeline">    SelectionDAG &DAG;</td>
    <td class="lineNumber">3730</td>
    <td class="codeline">    SelectionDAG &DAG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="codeline">    bool LegalTys;</td>
    <td class="lineNumber">3731</td>
    <td class="codeline">    bool LegalTys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="codeline">    bool LegalOps;</td>
    <td class="lineNumber">3732</td>
    <td class="codeline">    bool LegalOps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="codeline">    SDValue Old;</td>
    <td class="lineNumber">3733</td>
    <td class="codeline">    SDValue Old;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="codeline">    SDValue New;</td>
    <td class="lineNumber">3734</td>
    <td class="codeline">    SDValue New;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="codeline"></td>
    <td class="lineNumber">3735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="codeline">    explicit TargetLoweringOpt(SelectionDAG &InDAG,</td>
    <td class="lineNumber">3736</td>
    <td class="codeline">    explicit TargetLoweringOpt(SelectionDAG &InDAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="codeline">                               bool LT, bool LO) :</td>
    <td class="lineNumber">3737</td>
    <td class="codeline">                               bool LT, bool LO) :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="codeline">      DAG(InDAG), LegalTys(LT), LegalOps(LO) {}</td>
    <td class="lineNumber">3738</td>
    <td class="codeline">      DAG(InDAG), LegalTys(LT), LegalOps(LO) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="codeline"></td>
    <td class="lineNumber">3739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="codeline">    bool LegalTypes() const { return LegalTys; }</td>
    <td class="lineNumber">3740</td>
    <td class="codeline">    bool LegalTypes() const { return LegalTys; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="codeline">    bool LegalOperations() const { return LegalOps; }</td>
    <td class="lineNumber">3741</td>
    <td class="codeline">    bool LegalOperations() const { return LegalOps; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="codeline"></td>
    <td class="lineNumber">3742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="codeline">    bool CombineTo(SDValue O, SDValue N) {</td>
    <td class="lineNumber">3743</td>
    <td class="codeline">    bool CombineTo(SDValue O, SDValue N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="codeline">      Old = O;</td>
    <td class="lineNumber">3744</td>
    <td class="codeline">      Old = O;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="codeline">      New = N;</td>
    <td class="lineNumber">3745</td>
    <td class="codeline">      New = N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3746</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3747</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">3748</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="codeline"></td>
    <td class="lineNumber">3749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="codeline">  /// Determines the optimal series of memory ops to replace the memset / memcpy.</td>
    <td class="lineNumber">3750</td>
    <td class="codeline">  /// Determines the optimal series of memory ops to replace the memset / memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="codeline">  /// Return true if the number of memory ops is below the threshold (Limit).</td>
    <td class="lineNumber">3751</td>
    <td class="codeline">  /// Return true if the number of memory ops is below the threshold (Limit).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="codeline">  /// Note that this is always the case when Limit is ~0.</td>
    <td class="lineNumber">3752</td>
    <td class="codeline">  /// Note that this is always the case when Limit is ~0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="codeline">  /// It returns the types of the sequence of memory ops to perform</td>
    <td class="lineNumber">3753</td>
    <td class="codeline">  /// It returns the types of the sequence of memory ops to perform</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="codeline">  /// memset / memcpy by reference.</td>
    <td class="lineNumber">3754</td>
    <td class="codeline">  /// memset / memcpy by reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">3755</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="codeline">  findOptimalMemOpLowering(std::vector<EVT> &MemOps, unsigned Limit,</td>
    <td class="lineNumber">3756</td>
    <td class="codeline">  findOptimalMemOpLowering(std::vector<EVT> &MemOps, unsigned Limit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="codeline">                           const MemOp &Op, unsigned DstAS, unsigned SrcAS,</td>
    <td class="lineNumber">3757</td>
    <td class="codeline">                           const MemOp &Op, unsigned DstAS, unsigned SrcAS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="codeline">                           const AttributeList &FuncAttributes) const;</td>
    <td class="lineNumber">3758</td>
    <td class="codeline">                           const AttributeList &FuncAttributes) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="codeline"></td>
    <td class="lineNumber">3759</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="codeline">  /// Check to see if the specified operand of the specified instruction is a</td>
    <td class="lineNumber">3760</td>
    <td class="codeline">  /// Check to see if the specified operand of the specified instruction is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="codeline">  /// constant integer.  If so, check to see if there are any bits set in the</td>
    <td class="lineNumber">3761</td>
    <td class="codeline">  /// constant integer.  If so, check to see if there are any bits set in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="codeline">  /// constant that are not demanded.  If so, shrink the constant and return</td>
    <td class="lineNumber">3762</td>
    <td class="codeline">  /// constant that are not demanded.  If so, shrink the constant and return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">3763</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="codeline">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3764</td>
    <td class="codeline">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class="codeline">                              const APInt &DemandedElts,</td>
    <td class="lineNumber">3765</td>
    <td class="codeline">                              const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="codeline">                              TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">3766</td>
    <td class="codeline">                              TargetLoweringOpt &TLO) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class="codeline"></td>
    <td class="lineNumber">3767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="codeline">  /// Helper wrapper around ShrinkDemandedConstant, demanding all elements.</td>
    <td class="lineNumber">3768</td>
    <td class="codeline">  /// Helper wrapper around ShrinkDemandedConstant, demanding all elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="codeline">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3769</td>
    <td class="codeline">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class="codeline">                              TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">3770</td>
    <td class="codeline">                              TargetLoweringOpt &TLO) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="codeline"></td>
    <td class="lineNumber">3771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class="codeline">  // Target hook to do target-specific const optimization, which is called by</td>
    <td class="lineNumber">3772</td>
    <td class="codeline">  // Target hook to do target-specific const optimization, which is called by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="codeline">  // ShrinkDemandedConstant. This function should return true if the target</td>
    <td class="lineNumber">3773</td>
    <td class="codeline">  // ShrinkDemandedConstant. This function should return true if the target</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="codeline">  // doesn't want ShrinkDemandedConstant to further optimize the constant.</td>
    <td class="lineNumber">3774</td>
    <td class="codeline">  // doesn't want ShrinkDemandedConstant to further optimize the constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="codeline">  virtual bool targetShrinkDemandedConstant(SDValue Op,</td>
    <td class="lineNumber">3775</td>
    <td class="codeline">  virtual bool targetShrinkDemandedConstant(SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="codeline">                                            const APInt &DemandedBits,</td>
    <td class="lineNumber">3776</td>
    <td class="codeline">                                            const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="codeline">                                            const APInt &DemandedElts,</td>
    <td class="lineNumber">3777</td>
    <td class="codeline">                                            const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="codeline">                                            TargetLoweringOpt &TLO) const {</td>
    <td class="lineNumber">3778</td>
    <td class="codeline">                                            TargetLoweringOpt &TLO) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3779</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3780</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class="codeline"></td>
    <td class="lineNumber">3781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="codeline">  /// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.  This</td>
    <td class="lineNumber">3782</td>
    <td class="codeline">  /// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.  This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="codeline">  /// uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be</td>
    <td class="lineNumber">3783</td>
    <td class="codeline">  /// uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="codeline">  /// generalized for targets with other types of implicit widening casts.</td>
    <td class="lineNumber">3784</td>
    <td class="codeline">  /// generalized for targets with other types of implicit widening casts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="codeline">  bool ShrinkDemandedOp(SDValue Op, unsigned BitWidth,</td>
    <td class="lineNumber">3785</td>
    <td class="codeline">  bool ShrinkDemandedOp(SDValue Op, unsigned BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="codeline">                        const APInt &DemandedBits,</td>
    <td class="lineNumber">3786</td>
    <td class="codeline">                        const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="codeline">                        TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">3787</td>
    <td class="codeline">                        TargetLoweringOpt &TLO) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class="codeline"></td>
    <td class="lineNumber">3788</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="codeline">  /// Look at Op.  At this point, we know that only the DemandedBits bits of the</td>
    <td class="lineNumber">3789</td>
    <td class="codeline">  /// Look at Op.  At this point, we know that only the DemandedBits bits of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="codeline">  /// result of Op are ever used downstream.  If we can use this information to</td>
    <td class="lineNumber">3790</td>
    <td class="codeline">  /// result of Op are ever used downstream.  If we can use this information to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="codeline">  /// simplify Op, create a new simplified DAG node and return true, returning</td>
    <td class="lineNumber">3791</td>
    <td class="codeline">  /// simplify Op, create a new simplified DAG node and return true, returning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="codeline">  /// the original and new nodes in Old and New.  Otherwise, analyze the</td>
    <td class="lineNumber">3792</td>
    <td class="codeline">  /// the original and new nodes in Old and New.  Otherwise, analyze the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="codeline">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td class="lineNumber">3793</td>
    <td class="codeline">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="codeline">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td class="lineNumber">3794</td>
    <td class="codeline">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="codeline">  /// be accurate for those bits in the Demanded masks.</td>
    <td class="lineNumber">3795</td>
    <td class="codeline">  /// be accurate for those bits in the Demanded masks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="codeline">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td class="lineNumber">3796</td>
    <td class="codeline">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="codeline">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td class="lineNumber">3797</td>
    <td class="codeline">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="codeline">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td class="lineNumber">3798</td>
    <td class="codeline">  ///    Callers are responsible for correctly updating the DAG based on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="codeline">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td class="lineNumber">3799</td>
    <td class="codeline">  ///    results of this function, because simply replacing replacing TLO.Old</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="codeline">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td class="lineNumber">3800</td>
    <td class="codeline">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="codeline">  ///    has multiple uses.</td>
    <td class="lineNumber">3801</td>
    <td class="codeline">  ///    has multiple uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3802</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="codeline">                            const APInt &DemandedElts, KnownBits &Known,</td>
    <td class="lineNumber">3803</td>
    <td class="codeline">                            const APInt &DemandedElts, KnownBits &Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="codeline">                            TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td class="lineNumber">3804</td>
    <td class="codeline">                            TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="codeline">                            bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">3805</td>
    <td class="codeline">                            bool AssumeSingleUse = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class="codeline"></td>
    <td class="lineNumber">3806</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedBits, demanding all elements.</td>
    <td class="lineNumber">3807</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedBits, demanding all elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">3808</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3809</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="codeline">                            KnownBits &Known, TargetLoweringOpt &TLO,</td>
    <td class="lineNumber">3810</td>
    <td class="codeline">                            KnownBits &Known, TargetLoweringOpt &TLO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="codeline">                            unsigned Depth = 0,</td>
    <td class="lineNumber">3811</td>
    <td class="codeline">                            unsigned Depth = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="codeline">                            bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">3812</td>
    <td class="codeline">                            bool AssumeSingleUse = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="codeline"></td>
    <td class="lineNumber">3813</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td class="lineNumber">3814</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedBits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">3815</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3816</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="codeline">                            DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">3817</td>
    <td class="codeline">                            DAGCombinerInfo &DCI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="codeline"></td>
    <td class="lineNumber">3818</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td class="lineNumber">3819</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedBits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">3820</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3821</td>
    <td class="codeline">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="codeline">                            const APInt &DemandedElts,</td>
    <td class="lineNumber">3822</td>
    <td class="codeline">                            const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="codeline">                            DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">3823</td>
    <td class="codeline">                            DAGCombinerInfo &DCI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class="codeline"></td>
    <td class="lineNumber">3824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="codeline">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td class="lineNumber">3825</td>
    <td class="codeline">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="codeline">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td class="lineNumber">3826</td>
    <td class="codeline">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="codeline">  /// bitwise ops etc.</td>
    <td class="lineNumber">3827</td>
    <td class="codeline">  /// bitwise ops etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="codeline">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3828</td>
    <td class="codeline">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="codeline">                                          const APInt &DemandedElts,</td>
    <td class="lineNumber">3829</td>
    <td class="codeline">                                          const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="codeline">                                          SelectionDAG &DAG,</td>
    <td class="lineNumber">3830</td>
    <td class="codeline">                                          SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="codeline">                                          unsigned Depth = 0) const;</td>
    <td class="lineNumber">3831</td>
    <td class="codeline">                                          unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class="codeline"></td>
    <td class="lineNumber">3832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="codeline">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td class="lineNumber">3833</td>
    <td class="codeline">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="codeline">  /// elements.</td>
    <td class="lineNumber">3834</td>
    <td class="codeline">  /// elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="codeline">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">3835</td>
    <td class="codeline">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="codeline">                                          SelectionDAG &DAG,</td>
    <td class="lineNumber">3836</td>
    <td class="codeline">                                          SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="codeline">                                          unsigned Depth = 0) const;</td>
    <td class="lineNumber">3837</td>
    <td class="codeline">                                          unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="codeline"></td>
    <td class="lineNumber">3838</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="codeline">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td class="lineNumber">3839</td>
    <td class="codeline">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="codeline">  /// bits from only some vector elements.</td>
    <td class="lineNumber">3840</td>
    <td class="codeline">  /// bits from only some vector elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="codeline">  SDValue SimplifyMultipleUseDemandedVectorElts(SDValue Op,</td>
    <td class="lineNumber">3841</td>
    <td class="codeline">  SDValue SimplifyMultipleUseDemandedVectorElts(SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="codeline">                                                const APInt &DemandedElts,</td>
    <td class="lineNumber">3842</td>
    <td class="codeline">                                                const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="codeline">                                                SelectionDAG &DAG,</td>
    <td class="lineNumber">3843</td>
    <td class="codeline">                                                SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="codeline">                                                unsigned Depth = 0) const;</td>
    <td class="lineNumber">3844</td>
    <td class="codeline">                                                unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="codeline"></td>
    <td class="lineNumber">3845</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="codeline">  /// Look at Vector Op. At this point, we know that only the DemandedElts</td>
    <td class="lineNumber">3846</td>
    <td class="codeline">  /// Look at Vector Op. At this point, we know that only the DemandedElts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="codeline">  /// elements of the result of Op are ever used downstream.  If we can use</td>
    <td class="lineNumber">3847</td>
    <td class="codeline">  /// elements of the result of Op are ever used downstream.  If we can use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="codeline">  /// this information to simplify Op, create a new simplified DAG node and</td>
    <td class="lineNumber">3848</td>
    <td class="codeline">  /// this information to simplify Op, create a new simplified DAG node and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="codeline">  /// return true, storing the original and new nodes in TLO.</td>
    <td class="lineNumber">3849</td>
    <td class="codeline">  /// return true, storing the original and new nodes in TLO.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="codeline">  /// Otherwise, analyze the expression and return a mask of KnownUndef and</td>
    <td class="lineNumber">3850</td>
    <td class="codeline">  /// Otherwise, analyze the expression and return a mask of KnownUndef and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="codeline">  /// KnownZero elements for the expression (used to simplify the caller).</td>
    <td class="lineNumber">3851</td>
    <td class="codeline">  /// KnownZero elements for the expression (used to simplify the caller).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="codeline">  /// The KnownUndef/Zero elements may only be accurate for those bits</td>
    <td class="lineNumber">3852</td>
    <td class="codeline">  /// The KnownUndef/Zero elements may only be accurate for those bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="codeline">  /// in the DemandedMask.</td>
    <td class="lineNumber">3853</td>
    <td class="codeline">  /// in the DemandedMask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="codeline">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td class="lineNumber">3854</td>
    <td class="codeline">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="codeline">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td class="lineNumber">3855</td>
    <td class="codeline">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="codeline">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td class="lineNumber">3856</td>
    <td class="codeline">  ///    Callers are responsible for correctly updating the DAG based on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="codeline">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td class="lineNumber">3857</td>
    <td class="codeline">  ///    results of this function, because simply replacing replacing TLO.Old</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="codeline">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td class="lineNumber">3858</td>
    <td class="codeline">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="codeline">  ///    has multiple uses.</td>
    <td class="lineNumber">3859</td>
    <td class="codeline">  ///    has multiple uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="codeline">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedEltMask,</td>
    <td class="lineNumber">3860</td>
    <td class="codeline">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedEltMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="codeline">                                  APInt &KnownUndef, APInt &KnownZero,</td>
    <td class="lineNumber">3861</td>
    <td class="codeline">                                  APInt &KnownUndef, APInt &KnownZero,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="codeline">                                  TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td class="lineNumber">3862</td>
    <td class="codeline">                                  TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="codeline">                                  bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">3863</td>
    <td class="codeline">                                  bool AssumeSingleUse = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class="codeline"></td>
    <td class="lineNumber">3864</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedVectorElts.</td>
    <td class="lineNumber">3865</td>
    <td class="codeline">  /// Helper wrapper around SimplifyDemandedVectorElts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">3866</td>
    <td class="codeline">  /// Adds Op back to the worklist upon success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="codeline">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">3867</td>
    <td class="codeline">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="codeline">                                  DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">3868</td>
    <td class="codeline">                                  DAGCombinerInfo &DCI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="codeline"></td>
    <td class="lineNumber">3869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="codeline">  /// Return true if the target supports simplifying demanded vector elements by</td>
    <td class="lineNumber">3870</td>
    <td class="codeline">  /// Return true if the target supports simplifying demanded vector elements by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="codeline">  /// converting them to undefs.</td>
    <td class="lineNumber">3871</td>
    <td class="codeline">  /// converting them to undefs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">3872</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="codeline">  shouldSimplifyDemandedVectorElts(SDValue Op,</td>
    <td class="lineNumber">3873</td>
    <td class="codeline">  shouldSimplifyDemandedVectorElts(SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="codeline">                                   const TargetLoweringOpt &TLO) const {</td>
    <td class="lineNumber">3874</td>
    <td class="codeline">                                   const TargetLoweringOpt &TLO) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3875</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3876</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="codeline"></td>
    <td class="lineNumber">3877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="codeline">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td class="lineNumber">3878</td>
    <td class="codeline">  /// Determine which of the bits specified in Mask are known to be either zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="codeline">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td class="lineNumber">3879</td>
    <td class="codeline">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="codeline">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td class="lineNumber">3880</td>
    <td class="codeline">  /// argument allows us to only collect the known bits that are shared by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="codeline">  /// requested vector elements.</td>
    <td class="lineNumber">3881</td>
    <td class="codeline">  /// requested vector elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="codeline">  virtual void computeKnownBitsForTargetNode(const SDValue Op,</td>
    <td class="lineNumber">3882</td>
    <td class="codeline">  virtual void computeKnownBitsForTargetNode(const SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="codeline">                                             KnownBits &Known,</td>
    <td class="lineNumber">3883</td>
    <td class="codeline">                                             KnownBits &Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="codeline">                                             const APInt &DemandedElts,</td>
    <td class="lineNumber">3884</td>
    <td class="codeline">                                             const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="codeline">                                             const SelectionDAG &DAG,</td>
    <td class="lineNumber">3885</td>
    <td class="codeline">                                             const SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="codeline">                                             unsigned Depth = 0) const;</td>
    <td class="lineNumber">3886</td>
    <td class="codeline">                                             unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="codeline"></td>
    <td class="lineNumber">3887</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="codeline">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td class="lineNumber">3888</td>
    <td class="codeline">  /// Determine which of the bits specified in Mask are known to be either zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="codeline">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td class="lineNumber">3889</td>
    <td class="codeline">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="codeline">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td class="lineNumber">3890</td>
    <td class="codeline">  /// argument allows us to only collect the known bits that are shared by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="codeline">  /// requested vector elements. This is for GISel.</td>
    <td class="lineNumber">3891</td>
    <td class="codeline">  /// requested vector elements. This is for GISel.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="codeline">  virtual void computeKnownBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">3892</td>
    <td class="codeline">  virtual void computeKnownBitsForTargetInstr(GISelKnownBits &Analysis,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="codeline">                                              Register R, KnownBits &Known,</td>
    <td class="lineNumber">3893</td>
    <td class="codeline">                                              Register R, KnownBits &Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="codeline">                                              const APInt &DemandedElts,</td>
    <td class="lineNumber">3894</td>
    <td class="codeline">                                              const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="codeline">                                              const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">3895</td>
    <td class="codeline">                                              const MachineRegisterInfo &MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="codeline">                                              unsigned Depth = 0) const;</td>
    <td class="lineNumber">3896</td>
    <td class="codeline">                                              unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="codeline"></td>
    <td class="lineNumber">3897</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="codeline">  /// Determine the known alignment for the pointer value \p R. This is can</td>
    <td class="lineNumber">3898</td>
    <td class="codeline">  /// Determine the known alignment for the pointer value \p R. This is can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="codeline">  /// typically be inferred from the number of low known 0 bits. However, for a</td>
    <td class="lineNumber">3899</td>
    <td class="codeline">  /// typically be inferred from the number of low known 0 bits. However, for a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="codeline">  /// pointer with a non-integral address space, the alignment value may be</td>
    <td class="lineNumber">3900</td>
    <td class="codeline">  /// pointer with a non-integral address space, the alignment value may be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="codeline">  /// independent from the known low bits.</td>
    <td class="lineNumber">3901</td>
    <td class="codeline">  /// independent from the known low bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="codeline">  virtual Align computeKnownAlignForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">3902</td>
    <td class="codeline">  virtual Align computeKnownAlignForTargetInstr(GISelKnownBits &Analysis,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="codeline">                                                Register R,</td>
    <td class="lineNumber">3903</td>
    <td class="codeline">                                                Register R,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="codeline">                                                const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">3904</td>
    <td class="codeline">                                                const MachineRegisterInfo &MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="codeline">                                                unsigned Depth = 0) const;</td>
    <td class="lineNumber">3905</td>
    <td class="codeline">                                                unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="codeline"></td>
    <td class="lineNumber">3906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="codeline">  /// Determine which of the bits of FrameIndex \p FIOp are known to be 0.</td>
    <td class="lineNumber">3907</td>
    <td class="codeline">  /// Determine which of the bits of FrameIndex \p FIOp are known to be 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="codeline">  /// Default implementation computes low bits based on alignment</td>
    <td class="lineNumber">3908</td>
    <td class="codeline">  /// Default implementation computes low bits based on alignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="codeline">  /// information. This should preserve known bits passed into it.</td>
    <td class="lineNumber">3909</td>
    <td class="codeline">  /// information. This should preserve known bits passed into it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="codeline">  virtual void computeKnownBitsForFrameIndex(int FIOp,</td>
    <td class="lineNumber">3910</td>
    <td class="codeline">  virtual void computeKnownBitsForFrameIndex(int FIOp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="codeline">                                             KnownBits &Known,</td>
    <td class="lineNumber">3911</td>
    <td class="codeline">                                             KnownBits &Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="codeline">                                             const MachineFunction &MF) const;</td>
    <td class="lineNumber">3912</td>
    <td class="codeline">                                             const MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="codeline"></td>
    <td class="lineNumber">3913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="codeline">  /// This method can be implemented by targets that want to expose additional</td>
    <td class="lineNumber">3914</td>
    <td class="codeline">  /// This method can be implemented by targets that want to expose additional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="codeline">  /// information about sign bits to the DAG Combiner. The DemandedElts</td>
    <td class="lineNumber">3915</td>
    <td class="codeline">  /// information about sign bits to the DAG Combiner. The DemandedElts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="codeline">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td class="lineNumber">3916</td>
    <td class="codeline">  /// argument allows us to only collect the minimum sign bits that are shared</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="codeline">  /// by the requested vector elements.</td>
    <td class="lineNumber">3917</td>
    <td class="codeline">  /// by the requested vector elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="codeline">  virtual unsigned ComputeNumSignBitsForTargetNode(SDValue Op,</td>
    <td class="lineNumber">3918</td>
    <td class="codeline">  virtual unsigned ComputeNumSignBitsForTargetNode(SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="codeline">                                                   const APInt &DemandedElts,</td>
    <td class="lineNumber">3919</td>
    <td class="codeline">                                                   const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="codeline">                                                   const SelectionDAG &DAG,</td>
    <td class="lineNumber">3920</td>
    <td class="codeline">                                                   const SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="codeline">                                                   unsigned Depth = 0) const;</td>
    <td class="lineNumber">3921</td>
    <td class="codeline">                                                   unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class="codeline"></td>
    <td class="lineNumber">3922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="codeline">  /// This method can be implemented by targets that want to expose additional</td>
    <td class="lineNumber">3923</td>
    <td class="codeline">  /// This method can be implemented by targets that want to expose additional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="codeline">  /// information about sign bits to GlobalISel combiners. The DemandedElts</td>
    <td class="lineNumber">3924</td>
    <td class="codeline">  /// information about sign bits to GlobalISel combiners. The DemandedElts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="codeline">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td class="lineNumber">3925</td>
    <td class="codeline">  /// argument allows us to only collect the minimum sign bits that are shared</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="codeline">  /// by the requested vector elements.</td>
    <td class="lineNumber">3926</td>
    <td class="codeline">  /// by the requested vector elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="codeline">  virtual unsigned computeNumSignBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">3927</td>
    <td class="codeline">  virtual unsigned computeNumSignBitsForTargetInstr(GISelKnownBits &Analysis,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="codeline">                                                    Register R,</td>
    <td class="lineNumber">3928</td>
    <td class="codeline">                                                    Register R,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="codeline">                                                    const APInt &DemandedElts,</td>
    <td class="lineNumber">3929</td>
    <td class="codeline">                                                    const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="codeline">                                                    const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">3930</td>
    <td class="codeline">                                                    const MachineRegisterInfo &MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="codeline">                                                    unsigned Depth = 0) const;</td>
    <td class="lineNumber">3931</td>
    <td class="codeline">                                                    unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="codeline"></td>
    <td class="lineNumber">3932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="codeline">  /// Attempt to simplify any target nodes based on the demanded vector</td>
    <td class="lineNumber">3933</td>
    <td class="codeline">  /// Attempt to simplify any target nodes based on the demanded vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="codeline">  /// elements, returning true on success. Otherwise, analyze the expression and</td>
    <td class="lineNumber">3934</td>
    <td class="codeline">  /// elements, returning true on success. Otherwise, analyze the expression and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="codeline">  /// return a mask of KnownUndef and KnownZero elements for the expression</td>
    <td class="lineNumber">3935</td>
    <td class="codeline">  /// return a mask of KnownUndef and KnownZero elements for the expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="codeline">  /// (used to simplify the caller). The KnownUndef/Zero elements may only be</td>
    <td class="lineNumber">3936</td>
    <td class="codeline">  /// (used to simplify the caller). The KnownUndef/Zero elements may only be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="codeline">  /// accurate for those bits in the DemandedMask.</td>
    <td class="lineNumber">3937</td>
    <td class="codeline">  /// accurate for those bits in the DemandedMask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="codeline">  virtual bool SimplifyDemandedVectorEltsForTargetNode(</td>
    <td class="lineNumber">3938</td>
    <td class="codeline">  virtual bool SimplifyDemandedVectorEltsForTargetNode(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="codeline">      SDValue Op, const APInt &DemandedElts, APInt &KnownUndef,</td>
    <td class="lineNumber">3939</td>
    <td class="codeline">      SDValue Op, const APInt &DemandedElts, APInt &KnownUndef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="codeline">      APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth = 0) const;</td>
    <td class="lineNumber">3940</td>
    <td class="codeline">      APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class="codeline"></td>
    <td class="lineNumber">3941</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="codeline">  /// Attempt to simplify any target nodes based on the demanded bits/elts,</td>
    <td class="lineNumber">3942</td>
    <td class="codeline">  /// Attempt to simplify any target nodes based on the demanded bits/elts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="codeline">  /// returning true on success. Otherwise, analyze the</td>
    <td class="lineNumber">3943</td>
    <td class="codeline">  /// returning true on success. Otherwise, analyze the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="codeline">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td class="lineNumber">3944</td>
    <td class="codeline">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="codeline">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td class="lineNumber">3945</td>
    <td class="codeline">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="codeline">  /// be accurate for those bits in the Demanded masks.</td>
    <td class="lineNumber">3946</td>
    <td class="codeline">  /// be accurate for those bits in the Demanded masks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="codeline">  virtual bool SimplifyDemandedBitsForTargetNode(SDValue Op,</td>
    <td class="lineNumber">3947</td>
    <td class="codeline">  virtual bool SimplifyDemandedBitsForTargetNode(SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="codeline">                                                 const APInt &DemandedBits,</td>
    <td class="lineNumber">3948</td>
    <td class="codeline">                                                 const APInt &DemandedBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="codeline">                                                 const APInt &DemandedElts,</td>
    <td class="lineNumber">3949</td>
    <td class="codeline">                                                 const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="codeline">                                                 KnownBits &Known,</td>
    <td class="lineNumber">3950</td>
    <td class="codeline">                                                 KnownBits &Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="codeline">                                                 TargetLoweringOpt &TLO,</td>
    <td class="lineNumber">3951</td>
    <td class="codeline">                                                 TargetLoweringOpt &TLO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class="codeline">                                                 unsigned Depth = 0) const;</td>
    <td class="lineNumber">3952</td>
    <td class="codeline">                                                 unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="codeline"></td>
    <td class="lineNumber">3953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="codeline">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td class="lineNumber">3954</td>
    <td class="codeline">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="codeline">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td class="lineNumber">3955</td>
    <td class="codeline">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="codeline">  /// bitwise ops etc.</td>
    <td class="lineNumber">3956</td>
    <td class="codeline">  /// bitwise ops etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="codeline">  virtual SDValue SimplifyMultipleUseDemandedBitsForTargetNode(</td>
    <td class="lineNumber">3957</td>
    <td class="codeline">  virtual SDValue SimplifyMultipleUseDemandedBitsForTargetNode(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="codeline">      SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,</td>
    <td class="lineNumber">3958</td>
    <td class="codeline">      SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="codeline">      SelectionDAG &DAG, unsigned Depth) const;</td>
    <td class="lineNumber">3959</td>
    <td class="codeline">      SelectionDAG &DAG, unsigned Depth) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class="codeline"></td>
    <td class="lineNumber">3960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="codeline">  /// Return true if this function can prove that \p Op is never poison</td>
    <td class="lineNumber">3961</td>
    <td class="codeline">  /// Return true if this function can prove that \p Op is never poison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="codeline">  /// and, if \p PoisonOnly is false, does not have undef bits. The DemandedElts</td>
    <td class="lineNumber">3962</td>
    <td class="codeline">  /// and, if \p PoisonOnly is false, does not have undef bits. The DemandedElts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="codeline">  /// argument limits the check to the requested vector elements.</td>
    <td class="lineNumber">3963</td>
    <td class="codeline">  /// argument limits the check to the requested vector elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="codeline">  virtual bool isGuaranteedNotToBeUndefOrPoisonForTargetNode(</td>
    <td class="lineNumber">3964</td>
    <td class="codeline">  virtual bool isGuaranteedNotToBeUndefOrPoisonForTargetNode(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class="codeline">      SDValue Op, const APInt &DemandedElts, const SelectionDAG &DAG,</td>
    <td class="lineNumber">3965</td>
    <td class="codeline">      SDValue Op, const APInt &DemandedElts, const SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="codeline">      bool PoisonOnly, unsigned Depth) const;</td>
    <td class="lineNumber">3966</td>
    <td class="codeline">      bool PoisonOnly, unsigned Depth) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class="codeline"></td>
    <td class="lineNumber">3967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="codeline">  /// Return true if Op can create undef or poison from non-undef & non-poison</td>
    <td class="lineNumber">3968</td>
    <td class="codeline">  /// Return true if Op can create undef or poison from non-undef & non-poison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="codeline">  /// operands. The DemandedElts argument limits the check to the requested</td>
    <td class="lineNumber">3969</td>
    <td class="codeline">  /// operands. The DemandedElts argument limits the check to the requested</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="codeline">  /// vector elements.</td>
    <td class="lineNumber">3970</td>
    <td class="codeline">  /// vector elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">3971</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="codeline">  canCreateUndefOrPoisonForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">3972</td>
    <td class="codeline">  canCreateUndefOrPoisonForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="codeline">                                      const SelectionDAG &DAG, bool PoisonOnly,</td>
    <td class="lineNumber">3973</td>
    <td class="codeline">                                      const SelectionDAG &DAG, bool PoisonOnly,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="codeline">                                      bool ConsiderFlags, unsigned Depth) const;</td>
    <td class="lineNumber">3974</td>
    <td class="codeline">                                      bool ConsiderFlags, unsigned Depth) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="codeline"></td>
    <td class="lineNumber">3975</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class="codeline">  /// Tries to build a legal vector shuffle using the provided parameters</td>
    <td class="lineNumber">3976</td>
    <td class="codeline">  /// Tries to build a legal vector shuffle using the provided parameters</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="codeline">  /// or equivalent variations. The Mask argument maybe be modified as the</td>
    <td class="lineNumber">3977</td>
    <td class="codeline">  /// or equivalent variations. The Mask argument maybe be modified as the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="codeline">  /// function tries different variations.</td>
    <td class="lineNumber">3978</td>
    <td class="codeline">  /// function tries different variations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class="codeline">  /// Returns an empty SDValue if the operation fails.</td>
    <td class="lineNumber">3979</td>
    <td class="codeline">  /// Returns an empty SDValue if the operation fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="codeline">  SDValue buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,</td>
    <td class="lineNumber">3980</td>
    <td class="codeline">  SDValue buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="codeline">                                  SDValue N1, MutableArrayRef<int> Mask,</td>
    <td class="lineNumber">3981</td>
    <td class="codeline">                                  SDValue N1, MutableArrayRef<int> Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="codeline">                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">3982</td>
    <td class="codeline">                                  SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="codeline"></td>
    <td class="lineNumber">3983</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="codeline">  /// This method returns the constant pool value that will be loaded by LD.</td>
    <td class="lineNumber">3984</td>
    <td class="codeline">  /// This method returns the constant pool value that will be loaded by LD.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="codeline">  /// NOTE: You must check for implicit extensions of the constant by LD.</td>
    <td class="lineNumber">3985</td>
    <td class="codeline">  /// NOTE: You must check for implicit extensions of the constant by LD.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="codeline">  virtual const Constant *getTargetConstantFromLoad(LoadSDNode *LD) const;</td>
    <td class="lineNumber">3986</td>
    <td class="codeline">  virtual const Constant *getTargetConstantFromLoad(LoadSDNode *LD) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="codeline"></td>
    <td class="lineNumber">3987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="codeline">  /// If \p SNaN is false, \returns true if \p Op is known to never be any</td>
    <td class="lineNumber">3988</td>
    <td class="codeline">  /// If \p SNaN is false, \returns true if \p Op is known to never be any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="codeline">  /// NaN. If \p sNaN is true, returns if \p Op is known to never be a signaling</td>
    <td class="lineNumber">3989</td>
    <td class="codeline">  /// NaN. If \p sNaN is true, returns if \p Op is known to never be a signaling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="codeline">  /// NaN.</td>
    <td class="lineNumber">3990</td>
    <td class="codeline">  /// NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="codeline">  virtual bool isKnownNeverNaNForTargetNode(SDValue Op,</td>
    <td class="lineNumber">3991</td>
    <td class="codeline">  virtual bool isKnownNeverNaNForTargetNode(SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="codeline">                                            const SelectionDAG &DAG,</td>
    <td class="lineNumber">3992</td>
    <td class="codeline">                                            const SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="codeline">                                            bool SNaN = false,</td>
    <td class="lineNumber">3993</td>
    <td class="codeline">                                            bool SNaN = false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="codeline">                                            unsigned Depth = 0) const;</td>
    <td class="lineNumber">3994</td>
    <td class="codeline">                                            unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class="codeline"></td>
    <td class="lineNumber">3995</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="codeline">  /// Return true if vector \p Op has the same value across all \p DemandedElts,</td>
    <td class="lineNumber">3996</td>
    <td class="codeline">  /// Return true if vector \p Op has the same value across all \p DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="codeline">  /// indicating any elements which may be undef in the output \p UndefElts.</td>
    <td class="lineNumber">3997</td>
    <td class="codeline">  /// indicating any elements which may be undef in the output \p UndefElts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="codeline">  virtual bool isSplatValueForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">3998</td>
    <td class="codeline">  virtual bool isSplatValueForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="codeline">                                         APInt &UndefElts,</td>
    <td class="lineNumber">3999</td>
    <td class="codeline">                                         APInt &UndefElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="codeline">                                         const SelectionDAG &DAG,</td>
    <td class="lineNumber">4000</td>
    <td class="codeline">                                         const SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="codeline">                                         unsigned Depth = 0) const;</td>
    <td class="lineNumber">4001</td>
    <td class="codeline">                                         unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class="codeline"></td>
    <td class="lineNumber">4002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="codeline">  /// Returns true if the given Opc is considered a canonical constant for the</td>
    <td class="lineNumber">4003</td>
    <td class="codeline">  /// Returns true if the given Opc is considered a canonical constant for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="codeline">  /// target, which should not be transformed back into a BUILD_VECTOR.</td>
    <td class="lineNumber">4004</td>
    <td class="codeline">  /// target, which should not be transformed back into a BUILD_VECTOR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="codeline">  virtual bool isTargetCanonicalConstantNode(SDValue Op) const {</td>
    <td class="lineNumber">4005</td>
    <td class="codeline">  virtual bool isTargetCanonicalConstantNode(SDValue Op) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="codeline">    return Op.getOpcode() == ISD::SPLAT_VECTOR;</td>
    <td class="lineNumber">4006</td>
    <td class="codeline">    return Op.getOpcode() == ISD::SPLAT_VECTOR;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4007</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="codeline"></td>
    <td class="lineNumber">4008</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class="codeline">  struct DAGCombinerInfo {</td>
    <td class="lineNumber">4009</td>
    <td class="codeline">  struct DAGCombinerInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="codeline">    void *DC;  // The DAG Combiner object.</td>
    <td class="lineNumber">4010</td>
    <td class="codeline">    void *DC;  // The DAG Combiner object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="codeline">    CombineLevel Level;</td>
    <td class="lineNumber">4011</td>
    <td class="codeline">    CombineLevel Level;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="codeline">    bool CalledByLegalizer;</td>
    <td class="lineNumber">4012</td>
    <td class="codeline">    bool CalledByLegalizer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class="codeline"></td>
    <td class="lineNumber">4013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">4014</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="codeline">    SelectionDAG &DAG;</td>
    <td class="lineNumber">4015</td>
    <td class="codeline">    SelectionDAG &DAG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="codeline"></td>
    <td class="lineNumber">4016</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="codeline">    DAGCombinerInfo(SelectionDAG &dag, CombineLevel level,  bool cl, void *dc)</td>
    <td class="lineNumber">4017</td>
    <td class="codeline">    DAGCombinerInfo(SelectionDAG &dag, CombineLevel level,  bool cl, void *dc)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="codeline">      : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag) {}</td>
    <td class="lineNumber">4018</td>
    <td class="codeline">      : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="codeline"></td>
    <td class="lineNumber">4019</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class="codeline">    bool isBeforeLegalize() const { return Level == BeforeLegalizeTypes; }</td>
    <td class="lineNumber">4020</td>
    <td class="codeline">    bool isBeforeLegalize() const { return Level == BeforeLegalizeTypes; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="codeline">    bool isBeforeLegalizeOps() const { return Level < AfterLegalizeVectorOps; }</td>
    <td class="lineNumber">4021</td>
    <td class="codeline">    bool isBeforeLegalizeOps() const { return Level < AfterLegalizeVectorOps; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="codeline">    bool isAfterLegalizeDAG() const { return Level >= AfterLegalizeDAG; }</td>
    <td class="lineNumber">4022</td>
    <td class="codeline">    bool isAfterLegalizeDAG() const { return Level >= AfterLegalizeDAG; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="codeline">    CombineLevel getDAGCombineLevel() { return Level; }</td>
    <td class="lineNumber">4023</td>
    <td class="codeline">    CombineLevel getDAGCombineLevel() { return Level; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="codeline">    bool isCalledByLegalizer() const { return CalledByLegalizer; }</td>
    <td class="lineNumber">4024</td>
    <td class="codeline">    bool isCalledByLegalizer() const { return CalledByLegalizer; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="codeline"></td>
    <td class="lineNumber">4025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="codeline">    void AddToWorklist(SDNode *N);</td>
    <td class="lineNumber">4026</td>
    <td class="codeline">    void AddToWorklist(SDNode *N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="codeline">    SDValue CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true);</td>
    <td class="lineNumber">4027</td>
    <td class="codeline">    SDValue CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="codeline">    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true);</td>
    <td class="lineNumber">4028</td>
    <td class="codeline">    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="codeline">    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true);</td>
    <td class="lineNumber">4029</td>
    <td class="codeline">    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="codeline"></td>
    <td class="lineNumber">4030</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="codeline">    bool recursivelyDeleteUnusedNodes(SDNode *N);</td>
    <td class="lineNumber">4031</td>
    <td class="codeline">    bool recursivelyDeleteUnusedNodes(SDNode *N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="codeline"></td>
    <td class="lineNumber">4032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="codeline">    void CommitTargetLoweringOpt(const TargetLoweringOpt &TLO);</td>
    <td class="lineNumber">4033</td>
    <td class="codeline">    void CommitTargetLoweringOpt(const TargetLoweringOpt &TLO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4034</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="codeline"></td>
    <td class="lineNumber">4035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="codeline">  /// Return if the N is a constant or constant vector equal to the true value</td>
    <td class="lineNumber">4036</td>
    <td class="codeline">  /// Return if the N is a constant or constant vector equal to the true value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="codeline">  /// from getBooleanContents().</td>
    <td class="lineNumber">4037</td>
    <td class="codeline">  /// from getBooleanContents().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="codeline">  bool isConstTrueVal(SDValue N) const;</td>
    <td class="lineNumber">4038</td>
    <td class="codeline">  bool isConstTrueVal(SDValue N) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class="codeline"></td>
    <td class="lineNumber">4039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="codeline">  /// Return if the N is a constant or constant vector equal to the false value</td>
    <td class="lineNumber">4040</td>
    <td class="codeline">  /// Return if the N is a constant or constant vector equal to the false value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="codeline">  /// from getBooleanContents().</td>
    <td class="lineNumber">4041</td>
    <td class="codeline">  /// from getBooleanContents().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="codeline">  bool isConstFalseVal(SDValue N) const;</td>
    <td class="lineNumber">4042</td>
    <td class="codeline">  bool isConstFalseVal(SDValue N) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="codeline"></td>
    <td class="lineNumber">4043</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="codeline">  /// Return if \p N is a True value when extended to \p VT.</td>
    <td class="lineNumber">4044</td>
    <td class="codeline">  /// Return if \p N is a True value when extended to \p VT.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="codeline">  bool isExtendedTrueVal(const ConstantSDNode *N, EVT VT, bool SExt) const;</td>
    <td class="lineNumber">4045</td>
    <td class="codeline">  bool isExtendedTrueVal(const ConstantSDNode *N, EVT VT, bool SExt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="codeline"></td>
    <td class="lineNumber">4046</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="codeline">  /// Try to simplify a setcc built with the specified operands and cc. If it is</td>
    <td class="lineNumber">4047</td>
    <td class="codeline">  /// Try to simplify a setcc built with the specified operands and cc. If it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="codeline">  /// unable to simplify it, return a null SDValue.</td>
    <td class="lineNumber">4048</td>
    <td class="codeline">  /// unable to simplify it, return a null SDValue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="codeline">  SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">4049</td>
    <td class="codeline">  SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="codeline">                        bool foldBooleans, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">4050</td>
    <td class="codeline">                        bool foldBooleans, DAGCombinerInfo &DCI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="codeline">                        const SDLoc &dl) const;</td>
    <td class="lineNumber">4051</td>
    <td class="codeline">                        const SDLoc &dl) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="codeline"></td>
    <td class="lineNumber">4052</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="codeline">  // For targets which wrap address, unwrap for analysis.</td>
    <td class="lineNumber">4053</td>
    <td class="codeline">  // For targets which wrap address, unwrap for analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="codeline">  virtual SDValue unwrapAddress(SDValue N) const { return N; }</td>
    <td class="lineNumber">4054</td>
    <td class="codeline">  virtual SDValue unwrapAddress(SDValue N) const { return N; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class="codeline"></td>
    <td class="lineNumber">4055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="codeline">  /// Returns true (and the GlobalValue and the offset) if the node is a</td>
    <td class="lineNumber">4056</td>
    <td class="codeline">  /// Returns true (and the GlobalValue and the offset) if the node is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="codeline">  /// GlobalAddress + offset.</td>
    <td class="lineNumber">4057</td>
    <td class="codeline">  /// GlobalAddress + offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">4058</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="codeline">  isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset) const;</td>
    <td class="lineNumber">4059</td>
    <td class="codeline">  isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="codeline"></td>
    <td class="lineNumber">4060</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="codeline">  /// This method will be invoked for all target nodes and for any</td>
    <td class="lineNumber">4061</td>
    <td class="codeline">  /// This method will be invoked for all target nodes and for any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="codeline">  /// target-independent nodes that the target has registered with invoke it</td>
    <td class="lineNumber">4062</td>
    <td class="codeline">  /// target-independent nodes that the target has registered with invoke it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="codeline">  /// for.</td>
    <td class="lineNumber">4063</td>
    <td class="codeline">  /// for.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4064</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="codeline">  /// The semantics are as follows:</td>
    <td class="lineNumber">4065</td>
    <td class="codeline">  /// The semantics are as follows:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="codeline">  /// Return Value:</td>
    <td class="lineNumber">4066</td>
    <td class="codeline">  /// Return Value:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="codeline">  ///   SDValue.Val == 0   - No change was made</td>
    <td class="lineNumber">4067</td>
    <td class="codeline">  ///   SDValue.Val == 0   - No change was made</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="codeline">  ///   SDValue.Val == N   - N was replaced, is dead, and is already handled.</td>
    <td class="lineNumber">4068</td>
    <td class="codeline">  ///   SDValue.Val == N   - N was replaced, is dead, and is already handled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="codeline">  ///   otherwise          - N should be replaced by the returned Operand.</td>
    <td class="lineNumber">4069</td>
    <td class="codeline">  ///   otherwise          - N should be replaced by the returned Operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4070</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="codeline">  /// In addition, methods provided by DAGCombinerInfo may be used to perform</td>
    <td class="lineNumber">4071</td>
    <td class="codeline">  /// In addition, methods provided by DAGCombinerInfo may be used to perform</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="codeline">  /// more complex transformations.</td>
    <td class="lineNumber">4072</td>
    <td class="codeline">  /// more complex transformations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4073</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="codeline">  virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">4074</td>
    <td class="codeline">  virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="codeline"></td>
    <td class="lineNumber">4075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="codeline">  /// Return true if it is profitable to move this shift by a constant amount</td>
    <td class="lineNumber">4076</td>
    <td class="codeline">  /// Return true if it is profitable to move this shift by a constant amount</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="codeline">  /// through its operand, adjusting any immediate operands as necessary to</td>
    <td class="lineNumber">4077</td>
    <td class="codeline">  /// through its operand, adjusting any immediate operands as necessary to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="codeline">  /// preserve semantics. This transformation may not be desirable if it</td>
    <td class="lineNumber">4078</td>
    <td class="codeline">  /// preserve semantics. This transformation may not be desirable if it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="codeline">  /// disrupts a particularly auspicious target-specific tree (e.g. bitfield</td>
    <td class="lineNumber">4079</td>
    <td class="codeline">  /// disrupts a particularly auspicious target-specific tree (e.g. bitfield</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="codeline">  /// extraction in AArch64). By default, it returns true.</td>
    <td class="lineNumber">4080</td>
    <td class="codeline">  /// extraction in AArch64). By default, it returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4081</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="codeline">  /// @param N the shift node</td>
    <td class="lineNumber">4082</td>
    <td class="codeline">  /// @param N the shift node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="codeline">  /// @param Level the current DAGCombine legalization level.</td>
    <td class="lineNumber">4083</td>
    <td class="codeline">  /// @param Level the current DAGCombine legalization level.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="codeline">  virtual bool isDesirableToCommuteWithShift(const SDNode *N,</td>
    <td class="lineNumber">4084</td>
    <td class="codeline">  virtual bool isDesirableToCommuteWithShift(const SDNode *N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="codeline">                                             CombineLevel Level) const {</td>
    <td class="lineNumber">4085</td>
    <td class="codeline">                                             CombineLevel Level) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">4086</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4087</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="codeline"></td>
    <td class="lineNumber">4088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="codeline">  /// GlobalISel - return true if it is profitable to move this shift by a</td>
    <td class="lineNumber">4089</td>
    <td class="codeline">  /// GlobalISel - return true if it is profitable to move this shift by a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="codeline">  /// constant amount through its operand, adjusting any immediate operands as</td>
    <td class="lineNumber">4090</td>
    <td class="codeline">  /// constant amount through its operand, adjusting any immediate operands as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="codeline">  /// necessary to preserve semantics. This transformation may not be desirable</td>
    <td class="lineNumber">4091</td>
    <td class="codeline">  /// necessary to preserve semantics. This transformation may not be desirable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="codeline">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td class="lineNumber">4092</td>
    <td class="codeline">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="codeline">  /// bitfield extraction in AArch64). By default, it returns true.</td>
    <td class="lineNumber">4093</td>
    <td class="codeline">  /// bitfield extraction in AArch64). By default, it returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4094</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="codeline">  /// @param MI the shift instruction</td>
    <td class="lineNumber">4095</td>
    <td class="codeline">  /// @param MI the shift instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="codeline">  /// @param IsAfterLegal true if running after legalization.</td>
    <td class="lineNumber">4096</td>
    <td class="codeline">  /// @param IsAfterLegal true if running after legalization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="codeline">  virtual bool isDesirableToCommuteWithShift(const MachineInstr &MI,</td>
    <td class="lineNumber">4097</td>
    <td class="codeline">  virtual bool isDesirableToCommuteWithShift(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="codeline">                                             bool IsAfterLegal) const {</td>
    <td class="lineNumber">4098</td>
    <td class="codeline">                                             bool IsAfterLegal) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">4099</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4100</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="codeline"></td>
    <td class="lineNumber">4101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="codeline">  // Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and</td>
    <td class="lineNumber">4102</td>
    <td class="codeline">  // Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class="codeline">  // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of</td>
    <td class="lineNumber">4103</td>
    <td class="codeline">  // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="codeline">  // writing this) is:</td>
    <td class="lineNumber">4104</td>
    <td class="codeline">  // writing this) is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="codeline">  //    With C as a power of 2 and C != 0 and C != INT_MIN:</td>
    <td class="lineNumber">4105</td>
    <td class="codeline">  //    With C as a power of 2 and C != 0 and C != INT_MIN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="codeline">  //    AddAnd:</td>
    <td class="lineNumber">4106</td>
    <td class="codeline">  //    AddAnd:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="codeline">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td class="lineNumber">4107</td>
    <td class="codeline">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="codeline">  //            -> (icmp eq and(add(A, C), ~(C + C)), 0)</td>
    <td class="lineNumber">4108</td>
    <td class="codeline">  //            -> (icmp eq and(add(A, C), ~(C + C)), 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="codeline">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td class="lineNumber">4109</td>
    <td class="codeline">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="codeline">  //            -> (icmp ne and(add(A, C), ~(C + C)), 0)</td>
    <td class="lineNumber">4110</td>
    <td class="codeline">  //            -> (icmp ne and(add(A, C), ~(C + C)), 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="codeline">  //    ABS:</td>
    <td class="lineNumber">4111</td>
    <td class="codeline">  //    ABS:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="codeline">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td class="lineNumber">4112</td>
    <td class="codeline">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="codeline">  //            -> (icmp eq Abs(A), C)</td>
    <td class="lineNumber">4113</td>
    <td class="codeline">  //            -> (icmp eq Abs(A), C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="codeline">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td class="lineNumber">4114</td>
    <td class="codeline">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="codeline">  //            -> (icmp ne Abs(A), C)</td>
    <td class="lineNumber">4115</td>
    <td class="codeline">  //            -> (icmp ne Abs(A), C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">4116</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="codeline">  // @param LogicOp the logic op</td>
    <td class="lineNumber">4117</td>
    <td class="codeline">  // @param LogicOp the logic op</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="codeline">  // @param SETCC0 the first of the SETCC nodes</td>
    <td class="lineNumber">4118</td>
    <td class="codeline">  // @param SETCC0 the first of the SETCC nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="codeline">  // @param SETCC0 the second of the SETCC nodes</td>
    <td class="lineNumber">4119</td>
    <td class="codeline">  // @param SETCC0 the second of the SETCC nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="codeline">  virtual AndOrSETCCFoldKind isDesirableToCombineLogicOpOfSETCC(</td>
    <td class="lineNumber">4120</td>
    <td class="codeline">  virtual AndOrSETCCFoldKind isDesirableToCombineLogicOpOfSETCC(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="codeline">      const SDNode *LogicOp, const SDNode *SETCC0, const SDNode *SETCC1) const {</td>
    <td class="lineNumber">4121</td>
    <td class="codeline">      const SDNode *LogicOp, const SDNode *SETCC0, const SDNode *SETCC1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="codeline">    return AndOrSETCCFoldKind::None;</td>
    <td class="lineNumber">4122</td>
    <td class="codeline">    return AndOrSETCCFoldKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4123</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="codeline"></td>
    <td class="lineNumber">4124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="codeline">  /// Return true if it is profitable to combine an XOR of a logical shift</td>
    <td class="lineNumber">4125</td>
    <td class="codeline">  /// Return true if it is profitable to combine an XOR of a logical shift</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="codeline">  /// to create a logical shift of NOT. This transformation may not be desirable</td>
    <td class="lineNumber">4126</td>
    <td class="codeline">  /// to create a logical shift of NOT. This transformation may not be desirable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="codeline">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td class="lineNumber">4127</td>
    <td class="codeline">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="codeline">  /// BIC on ARM/AArch64). By default, it returns true.</td>
    <td class="lineNumber">4128</td>
    <td class="codeline">  /// BIC on ARM/AArch64). By default, it returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="codeline">  virtual bool isDesirableToCommuteXorWithShift(const SDNode *N) const {</td>
    <td class="lineNumber">4129</td>
    <td class="codeline">  virtual bool isDesirableToCommuteXorWithShift(const SDNode *N) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">4130</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4131</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class="codeline"></td>
    <td class="lineNumber">4132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="codeline">  /// Return true if the target has native support for the specified value type</td>
    <td class="lineNumber">4133</td>
    <td class="codeline">  /// Return true if the target has native support for the specified value type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="codeline">  /// and it is 'desirable' to use the type for the given node type. e.g. On x86</td>
    <td class="lineNumber">4134</td>
    <td class="codeline">  /// and it is 'desirable' to use the type for the given node type. e.g. On x86</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="codeline">  /// i16 is legal, but undesirable since i16 instruction encodings are longer</td>
    <td class="lineNumber">4135</td>
    <td class="codeline">  /// i16 is legal, but undesirable since i16 instruction encodings are longer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="codeline">  /// and some i16 instructions are slow.</td>
    <td class="lineNumber">4136</td>
    <td class="codeline">  /// and some i16 instructions are slow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="codeline">  virtual bool isTypeDesirableForOp(unsigned /*Opc*/, EVT VT) const {</td>
    <td class="lineNumber">4137</td>
    <td class="codeline">  virtual bool isTypeDesirableForOp(unsigned /*Opc*/, EVT VT) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="codeline">    // By default, assume all legal types are desirable.</td>
    <td class="lineNumber">4138</td>
    <td class="codeline">    // By default, assume all legal types are desirable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="codeline">    return isTypeLegal(VT);</td>
    <td class="lineNumber">4139</td>
    <td class="codeline">    return isTypeLegal(VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4140</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="codeline"></td>
    <td class="lineNumber">4141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="codeline">  /// Return true if it is profitable for dag combiner to transform a floating</td>
    <td class="lineNumber">4142</td>
    <td class="codeline">  /// Return true if it is profitable for dag combiner to transform a floating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="codeline">  /// point op of specified opcode to a equivalent op of an integer</td>
    <td class="lineNumber">4143</td>
    <td class="codeline">  /// point op of specified opcode to a equivalent op of an integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="codeline">  /// type. e.g. f32 load -> i32 load can be profitable on ARM.</td>
    <td class="lineNumber">4144</td>
    <td class="codeline">  /// type. e.g. f32 load -> i32 load can be profitable on ARM.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="codeline">  virtual bool isDesirableToTransformToIntegerOp(unsigned /*Opc*/,</td>
    <td class="lineNumber">4145</td>
    <td class="codeline">  virtual bool isDesirableToTransformToIntegerOp(unsigned /*Opc*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="codeline">                                                 EVT /*VT*/) const {</td>
    <td class="lineNumber">4146</td>
    <td class="codeline">                                                 EVT /*VT*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4147</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4148</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="codeline"></td>
    <td class="lineNumber">4149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="codeline">  /// This method query the target whether it is beneficial for dag combiner to</td>
    <td class="lineNumber">4150</td>
    <td class="codeline">  /// This method query the target whether it is beneficial for dag combiner to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="codeline">  /// promote the specified node. If true, it should return the desired</td>
    <td class="lineNumber">4151</td>
    <td class="codeline">  /// promote the specified node. If true, it should return the desired</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="codeline">  /// promotion type by reference.</td>
    <td class="lineNumber">4152</td>
    <td class="codeline">  /// promotion type by reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="codeline">  virtual bool IsDesirableToPromoteOp(SDValue /*Op*/, EVT &/*PVT*/) const {</td>
    <td class="lineNumber">4153</td>
    <td class="codeline">  virtual bool IsDesirableToPromoteOp(SDValue /*Op*/, EVT &/*PVT*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4154</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4155</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="codeline"></td>
    <td class="lineNumber">4156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="codeline">  /// Return true if the target supports swifterror attribute. It optimizes</td>
    <td class="lineNumber">4157</td>
    <td class="codeline">  /// Return true if the target supports swifterror attribute. It optimizes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="codeline">  /// loads and stores to reading and writing a specific register.</td>
    <td class="lineNumber">4158</td>
    <td class="codeline">  /// loads and stores to reading and writing a specific register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="codeline">  virtual bool supportSwiftError() const {</td>
    <td class="lineNumber">4159</td>
    <td class="codeline">  virtual bool supportSwiftError() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4160</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4161</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="codeline"></td>
    <td class="lineNumber">4162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="codeline">  /// Return true if the target supports that a subset of CSRs for the given</td>
    <td class="lineNumber">4163</td>
    <td class="codeline">  /// Return true if the target supports that a subset of CSRs for the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="codeline">  /// machine function is handled explicitly via copies.</td>
    <td class="lineNumber">4164</td>
    <td class="codeline">  /// machine function is handled explicitly via copies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="codeline">  virtual bool supportSplitCSR(MachineFunction *MF) const {</td>
    <td class="lineNumber">4165</td>
    <td class="codeline">  virtual bool supportSplitCSR(MachineFunction *MF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4166</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4167</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class="codeline"></td>
    <td class="lineNumber">4168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="codeline">  /// Return true if the target supports kcfi operand bundles.</td>
    <td class="lineNumber">4169</td>
    <td class="codeline">  /// Return true if the target supports kcfi operand bundles.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="codeline">  virtual bool supportKCFIBundles() const { return false; }</td>
    <td class="lineNumber">4170</td>
    <td class="codeline">  virtual bool supportKCFIBundles() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="codeline"></td>
    <td class="lineNumber">4171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="codeline">  /// Perform necessary initialization to handle a subset of CSRs explicitly</td>
    <td class="lineNumber">4172</td>
    <td class="codeline">  /// Perform necessary initialization to handle a subset of CSRs explicitly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="codeline">  /// via copies. This function is called at the beginning of instruction</td>
    <td class="lineNumber">4173</td>
    <td class="codeline">  /// via copies. This function is called at the beginning of instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="codeline">  /// selection.</td>
    <td class="lineNumber">4174</td>
    <td class="codeline">  /// selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="codeline">  virtual void initializeSplitCSR(MachineBasicBlock *Entry) const {</td>
    <td class="lineNumber">4175</td>
    <td class="codeline">  virtual void initializeSplitCSR(MachineBasicBlock *Entry) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">4176</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4177</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="codeline"></td>
    <td class="lineNumber">4178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="codeline">  /// Insert explicit copies in entry and exit blocks. We copy a subset of</td>
    <td class="lineNumber">4179</td>
    <td class="codeline">  /// Insert explicit copies in entry and exit blocks. We copy a subset of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="codeline">  /// CSRs to virtual registers in the entry block, and copy them back to</td>
    <td class="lineNumber">4180</td>
    <td class="codeline">  /// CSRs to virtual registers in the entry block, and copy them back to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="codeline">  /// physical registers in the exit blocks. This function is called at the end</td>
    <td class="lineNumber">4181</td>
    <td class="codeline">  /// physical registers in the exit blocks. This function is called at the end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="codeline">  /// of instruction selection.</td>
    <td class="lineNumber">4182</td>
    <td class="codeline">  /// of instruction selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="codeline">  virtual void insertCopiesSplitCSR(</td>
    <td class="lineNumber">4183</td>
    <td class="codeline">  virtual void insertCopiesSplitCSR(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="codeline">      MachineBasicBlock *Entry,</td>
    <td class="lineNumber">4184</td>
    <td class="codeline">      MachineBasicBlock *Entry,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="codeline">      const SmallVectorImpl<MachineBasicBlock *> &Exits) const {</td>
    <td class="lineNumber">4185</td>
    <td class="codeline">      const SmallVectorImpl<MachineBasicBlock *> &Exits) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">4186</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4187</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class="codeline"></td>
    <td class="lineNumber">4188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="codeline">  /// Return the newly negated expression if the cost is not expensive and</td>
    <td class="lineNumber">4189</td>
    <td class="codeline">  /// Return the newly negated expression if the cost is not expensive and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="codeline">  /// set the cost in \p Cost to indicate that if it is cheaper or neutral to</td>
    <td class="lineNumber">4190</td>
    <td class="codeline">  /// set the cost in \p Cost to indicate that if it is cheaper or neutral to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="codeline">  /// do the negation.</td>
    <td class="lineNumber">4191</td>
    <td class="codeline">  /// do the negation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="codeline">  virtual SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td class="lineNumber">4192</td>
    <td class="codeline">  virtual SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="codeline">                                       bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">4193</td>
    <td class="codeline">                                       bool LegalOps, bool OptForSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="codeline">                                       NegatibleCost &Cost,</td>
    <td class="lineNumber">4194</td>
    <td class="codeline">                                       NegatibleCost &Cost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="codeline">                                       unsigned Depth = 0) const;</td>
    <td class="lineNumber">4195</td>
    <td class="codeline">                                       unsigned Depth = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="codeline"></td>
    <td class="lineNumber">4196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="codeline">  SDValue getCheaperOrNeutralNegatedExpression(</td>
    <td class="lineNumber">4197</td>
    <td class="codeline">  SDValue getCheaperOrNeutralNegatedExpression(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="codeline">      SDValue Op, SelectionDAG &DAG, bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">4198</td>
    <td class="codeline">      SDValue Op, SelectionDAG &DAG, bool LegalOps, bool OptForSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="codeline">      const NegatibleCost CostThreshold = NegatibleCost::Neutral,</td>
    <td class="lineNumber">4199</td>
    <td class="codeline">      const NegatibleCost CostThreshold = NegatibleCost::Neutral,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="codeline">      unsigned Depth = 0) const {</td>
    <td class="lineNumber">4200</td>
    <td class="codeline">      unsigned Depth = 0) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="codeline">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td class="lineNumber">4201</td>
    <td class="codeline">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="codeline">    SDValue Neg =</td>
    <td class="lineNumber">4202</td>
    <td class="codeline">    SDValue Neg =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="codeline">        getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td class="lineNumber">4203</td>
    <td class="codeline">        getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="codeline">    if (!Neg)</td>
    <td class="lineNumber">4204</td>
    <td class="codeline">    if (!Neg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="codeline">      return SDValue();</td>
    <td class="lineNumber">4205</td>
    <td class="codeline">      return SDValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="codeline"></td>
    <td class="lineNumber">4206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="codeline">    if (Cost <= CostThreshold)</td>
    <td class="lineNumber">4207</td>
    <td class="codeline">    if (Cost <= CostThreshold)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="codeline">      return Neg;</td>
    <td class="lineNumber">4208</td>
    <td class="codeline">      return Neg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="codeline"></td>
    <td class="lineNumber">4209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="codeline">    // Remove the new created node to avoid the side effect to the DAG.</td>
    <td class="lineNumber">4210</td>
    <td class="codeline">    // Remove the new created node to avoid the side effect to the DAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="codeline">    if (Neg->use_empty())</td>
    <td class="lineNumber">4211</td>
    <td class="codeline">    if (Neg->use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="codeline">      DAG.RemoveDeadNode(Neg.getNode());</td>
    <td class="lineNumber">4212</td>
    <td class="codeline">      DAG.RemoveDeadNode(Neg.getNode());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="codeline">    return SDValue();</td>
    <td class="lineNumber">4213</td>
    <td class="codeline">    return SDValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4214</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="codeline"></td>
    <td class="lineNumber">4215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="codeline">  /// This is the helper function to return the newly negated expression only</td>
    <td class="lineNumber">4216</td>
    <td class="codeline">  /// This is the helper function to return the newly negated expression only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="codeline">  /// when the cost is cheaper.</td>
    <td class="lineNumber">4217</td>
    <td class="codeline">  /// when the cost is cheaper.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="codeline">  SDValue getCheaperNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td class="lineNumber">4218</td>
    <td class="codeline">  SDValue getCheaperNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="codeline">                                      bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">4219</td>
    <td class="codeline">                                      bool LegalOps, bool OptForSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="codeline">                                      unsigned Depth = 0) const {</td>
    <td class="lineNumber">4220</td>
    <td class="codeline">                                      unsigned Depth = 0) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="codeline">    return getCheaperOrNeutralNegatedExpression(Op, DAG, LegalOps, OptForSize,</td>
    <td class="lineNumber">4221</td>
    <td class="codeline">    return getCheaperOrNeutralNegatedExpression(Op, DAG, LegalOps, OptForSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="codeline">                                                NegatibleCost::Cheaper, Depth);</td>
    <td class="lineNumber">4222</td>
    <td class="codeline">                                                NegatibleCost::Cheaper, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4223</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class="codeline"></td>
    <td class="lineNumber">4224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="codeline">  /// This is the helper function to return the newly negated expression if</td>
    <td class="lineNumber">4225</td>
    <td class="codeline">  /// This is the helper function to return the newly negated expression if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="codeline">  /// the cost is not expensive.</td>
    <td class="lineNumber">4226</td>
    <td class="codeline">  /// the cost is not expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="codeline">  SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG, bool LegalOps,</td>
    <td class="lineNumber">4227</td>
    <td class="codeline">  SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG, bool LegalOps,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="codeline">                               bool OptForSize, unsigned Depth = 0) const {</td>
    <td class="lineNumber">4228</td>
    <td class="codeline">                               bool OptForSize, unsigned Depth = 0) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="codeline">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td class="lineNumber">4229</td>
    <td class="codeline">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="codeline">    return getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td class="lineNumber">4230</td>
    <td class="codeline">    return getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4231</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="codeline"></td>
    <td class="lineNumber">4232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">4233</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="codeline">  // Lowering methods - These methods must be implemented by targets so that</td>
    <td class="lineNumber">4234</td>
    <td class="codeline">  // Lowering methods - These methods must be implemented by targets so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="codeline">  // the SelectionDAGBuilder code knows how to lower these.</td>
    <td class="lineNumber">4235</td>
    <td class="codeline">  // the SelectionDAGBuilder code knows how to lower these.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">4236</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="codeline"></td>
    <td class="lineNumber">4237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="codeline">  /// Target-specific splitting of values into parts that fit a register</td>
    <td class="lineNumber">4238</td>
    <td class="codeline">  /// Target-specific splitting of values into parts that fit a register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="codeline">  /// storing a legal type</td>
    <td class="lineNumber">4239</td>
    <td class="codeline">  /// storing a legal type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="codeline">  virtual bool splitValueIntoRegisterParts(</td>
    <td class="lineNumber">4240</td>
    <td class="codeline">  virtual bool splitValueIntoRegisterParts(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="codeline">      SelectionDAG & DAG, const SDLoc &DL, SDValue Val, SDValue *Parts,</td>
    <td class="lineNumber">4241</td>
    <td class="codeline">      SelectionDAG & DAG, const SDLoc &DL, SDValue Val, SDValue *Parts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="codeline">      unsigned NumParts, MVT PartVT, std::optional<CallingConv::ID> CC) const {</td>
    <td class="lineNumber">4242</td>
    <td class="codeline">      unsigned NumParts, MVT PartVT, std::optional<CallingConv::ID> CC) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4243</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4244</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="codeline"></td>
    <td class="lineNumber">4245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="codeline">  /// Allows the target to handle physreg-carried dependency</td>
    <td class="lineNumber">4246</td>
    <td class="codeline">  /// Allows the target to handle physreg-carried dependency</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="codeline">  /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether</td>
    <td class="lineNumber">4247</td>
    <td class="codeline">  /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="codeline">  /// to add the edge to the dependency graph.</td>
    <td class="lineNumber">4248</td>
    <td class="codeline">  /// to add the edge to the dependency graph.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="codeline">  /// Def - input: Selection DAG node defininfg physical register</td>
    <td class="lineNumber">4249</td>
    <td class="codeline">  /// Def - input: Selection DAG node defininfg physical register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="codeline">  /// User - input: Selection DAG node using physical register</td>
    <td class="lineNumber">4250</td>
    <td class="codeline">  /// User - input: Selection DAG node using physical register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="codeline">  /// Op - input: Number of User operand</td>
    <td class="lineNumber">4251</td>
    <td class="codeline">  /// Op - input: Number of User operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="codeline">  /// PhysReg - inout: set to the physical register if the edge is</td>
    <td class="lineNumber">4252</td>
    <td class="codeline">  /// PhysReg - inout: set to the physical register if the edge is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="codeline">  /// necessary, unchanged otherwise</td>
    <td class="lineNumber">4253</td>
    <td class="codeline">  /// necessary, unchanged otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="codeline">  /// Cost - inout: physical register copy cost.</td>
    <td class="lineNumber">4254</td>
    <td class="codeline">  /// Cost - inout: physical register copy cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="codeline">  /// Returns 'true' is the edge is necessary, 'false' otherwise</td>
    <td class="lineNumber">4255</td>
    <td class="codeline">  /// Returns 'true' is the edge is necessary, 'false' otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="codeline">  virtual bool checkForPhysRegDependency(SDNode *Def, SDNode *User, unsigned Op,</td>
    <td class="lineNumber">4256</td>
    <td class="codeline">  virtual bool checkForPhysRegDependency(SDNode *Def, SDNode *User, unsigned Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="codeline">                                         const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">4257</td>
    <td class="codeline">                                         const TargetRegisterInfo *TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="codeline">                                         const TargetInstrInfo *TII,</td>
    <td class="lineNumber">4258</td>
    <td class="codeline">                                         const TargetInstrInfo *TII,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="codeline">                                         unsigned &PhysReg, int &Cost) const {</td>
    <td class="lineNumber">4259</td>
    <td class="codeline">                                         unsigned &PhysReg, int &Cost) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4260</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4261</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="codeline"></td>
    <td class="lineNumber">4262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="codeline">  /// Target-specific combining of register parts into its original value</td>
    <td class="lineNumber">4263</td>
    <td class="codeline">  /// Target-specific combining of register parts into its original value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="codeline">  virtual SDValue</td>
    <td class="lineNumber">4264</td>
    <td class="codeline">  virtual SDValue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class="codeline">  joinRegisterPartsIntoValue(SelectionDAG &DAG, const SDLoc &DL,</td>
    <td class="lineNumber">4265</td>
    <td class="codeline">  joinRegisterPartsIntoValue(SelectionDAG &DAG, const SDLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="codeline">                             const SDValue *Parts, unsigned NumParts,</td>
    <td class="lineNumber">4266</td>
    <td class="codeline">                             const SDValue *Parts, unsigned NumParts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="codeline">                             MVT PartVT, EVT ValueVT,</td>
    <td class="lineNumber">4267</td>
    <td class="codeline">                             MVT PartVT, EVT ValueVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="codeline">                             std::optional<CallingConv::ID> CC) const {</td>
    <td class="lineNumber">4268</td>
    <td class="codeline">                             std::optional<CallingConv::ID> CC) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="codeline">    return SDValue();</td>
    <td class="lineNumber">4269</td>
    <td class="codeline">    return SDValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4270</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="codeline"></td>
    <td class="lineNumber">4271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="codeline">  /// This hook must be implemented to lower the incoming (formal) arguments,</td>
    <td class="lineNumber">4272</td>
    <td class="codeline">  /// This hook must be implemented to lower the incoming (formal) arguments,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="codeline">  /// described by the Ins array, into the specified DAG. The implementation</td>
    <td class="lineNumber">4273</td>
    <td class="codeline">  /// described by the Ins array, into the specified DAG. The implementation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="codeline">  /// should fill in the InVals array with legal-type argument values, and</td>
    <td class="lineNumber">4274</td>
    <td class="codeline">  /// should fill in the InVals array with legal-type argument values, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="codeline">  /// return the resulting token chain value.</td>
    <td class="lineNumber">4275</td>
    <td class="codeline">  /// return the resulting token chain value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="codeline">  virtual SDValue LowerFormalArguments(</td>
    <td class="lineNumber">4276</td>
    <td class="codeline">  virtual SDValue LowerFormalArguments(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="codeline">      SDValue /*Chain*/, CallingConv::ID /*CallConv*/, bool /*isVarArg*/,</td>
    <td class="lineNumber">4277</td>
    <td class="codeline">      SDValue /*Chain*/, CallingConv::ID /*CallConv*/, bool /*isVarArg*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="codeline">      const SmallVectorImpl<ISD::InputArg> & /*Ins*/, const SDLoc & /*dl*/,</td>
    <td class="lineNumber">4278</td>
    <td class="codeline">      const SmallVectorImpl<ISD::InputArg> & /*Ins*/, const SDLoc & /*dl*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="codeline">      SelectionDAG & /*DAG*/, SmallVectorImpl<SDValue> & /*InVals*/) const {</td>
    <td class="lineNumber">4279</td>
    <td class="codeline">      SelectionDAG & /*DAG*/, SmallVectorImpl<SDValue> & /*InVals*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">4280</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4281</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="codeline"></td>
    <td class="lineNumber">4282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="codeline">  /// This structure contains all information that is necessary for lowering</td>
    <td class="lineNumber">4283</td>
    <td class="codeline">  /// This structure contains all information that is necessary for lowering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="codeline">  /// calls. It is passed to TLI::LowerCallTo when the SelectionDAG builder</td>
    <td class="lineNumber">4284</td>
    <td class="codeline">  /// calls. It is passed to TLI::LowerCallTo when the SelectionDAG builder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class="codeline">  /// needs to lower a call, and targets will see this struct in their LowerCall</td>
    <td class="lineNumber">4285</td>
    <td class="codeline">  /// needs to lower a call, and targets will see this struct in their LowerCall</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="codeline">  /// implementation.</td>
    <td class="lineNumber">4286</td>
    <td class="codeline">  /// implementation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="codeline">  struct CallLoweringInfo {</td>
    <td class="lineNumber">4287</td>
    <td class="codeline">  struct CallLoweringInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="codeline">    SDValue Chain;</td>
    <td class="lineNumber">4288</td>
    <td class="codeline">    SDValue Chain;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="codeline">    Type *RetTy = nullptr;</td>
    <td class="lineNumber">4289</td>
    <td class="codeline">    Type *RetTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="codeline">    bool RetSExt           : 1;</td>
    <td class="lineNumber">4290</td>
    <td class="codeline">    bool RetSExt           : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="codeline">    bool RetZExt           : 1;</td>
    <td class="lineNumber">4291</td>
    <td class="codeline">    bool RetZExt           : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="codeline">    bool IsVarArg          : 1;</td>
    <td class="lineNumber">4292</td>
    <td class="codeline">    bool IsVarArg          : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="codeline">    bool IsInReg           : 1;</td>
    <td class="lineNumber">4293</td>
    <td class="codeline">    bool IsInReg           : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class="codeline">    bool DoesNotReturn     : 1;</td>
    <td class="lineNumber">4294</td>
    <td class="codeline">    bool DoesNotReturn     : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="codeline">    bool IsReturnValueUsed : 1;</td>
    <td class="lineNumber">4295</td>
    <td class="codeline">    bool IsReturnValueUsed : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="codeline">    bool IsConvergent      : 1;</td>
    <td class="lineNumber">4296</td>
    <td class="codeline">    bool IsConvergent      : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="codeline">    bool IsPatchPoint      : 1;</td>
    <td class="lineNumber">4297</td>
    <td class="codeline">    bool IsPatchPoint      : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="codeline">    bool IsPreallocated : 1;</td>
    <td class="lineNumber">4298</td>
    <td class="codeline">    bool IsPreallocated : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="codeline">    bool NoMerge           : 1;</td>
    <td class="lineNumber">4299</td>
    <td class="codeline">    bool NoMerge           : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class="codeline"></td>
    <td class="lineNumber">4300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="codeline">    // IsTailCall should be modified by implementations of</td>
    <td class="lineNumber">4301</td>
    <td class="codeline">    // IsTailCall should be modified by implementations of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="codeline">    // TargetLowering::LowerCall that perform tail call conversions.</td>
    <td class="lineNumber">4302</td>
    <td class="codeline">    // TargetLowering::LowerCall that perform tail call conversions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="codeline">    bool IsTailCall = false;</td>
    <td class="lineNumber">4303</td>
    <td class="codeline">    bool IsTailCall = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class="codeline"></td>
    <td class="lineNumber">4304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="codeline">    // Is Call lowering done post SelectionDAG type legalization.</td>
    <td class="lineNumber">4305</td>
    <td class="codeline">    // Is Call lowering done post SelectionDAG type legalization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="codeline">    bool IsPostTypeLegalization = false;</td>
    <td class="lineNumber">4306</td>
    <td class="codeline">    bool IsPostTypeLegalization = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="codeline"></td>
    <td class="lineNumber">4307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="codeline">    unsigned NumFixedArgs = -1;</td>
    <td class="lineNumber">4308</td>
    <td class="codeline">    unsigned NumFixedArgs = -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="codeline">    CallingConv::ID CallConv = CallingConv::C;</td>
    <td class="lineNumber">4309</td>
    <td class="codeline">    CallingConv::ID CallConv = CallingConv::C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="codeline">    SDValue Callee;</td>
    <td class="lineNumber">4310</td>
    <td class="codeline">    SDValue Callee;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="codeline">    ArgListTy Args;</td>
    <td class="lineNumber">4311</td>
    <td class="codeline">    ArgListTy Args;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="codeline">    SelectionDAG &DAG;</td>
    <td class="lineNumber">4312</td>
    <td class="codeline">    SelectionDAG &DAG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="codeline">    SDLoc DL;</td>
    <td class="lineNumber">4313</td>
    <td class="codeline">    SDLoc DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="codeline">    const CallBase *CB = nullptr;</td>
    <td class="lineNumber">4314</td>
    <td class="codeline">    const CallBase *CB = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="codeline">    SmallVector<ISD::OutputArg, 32> Outs;</td>
    <td class="lineNumber">4315</td>
    <td class="codeline">    SmallVector<ISD::OutputArg, 32> Outs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="codeline">    SmallVector<SDValue, 32> OutVals;</td>
    <td class="lineNumber">4316</td>
    <td class="codeline">    SmallVector<SDValue, 32> OutVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class="codeline">    SmallVector<ISD::InputArg, 32> Ins;</td>
    <td class="lineNumber">4317</td>
    <td class="codeline">    SmallVector<ISD::InputArg, 32> Ins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="codeline">    SmallVector<SDValue, 4> InVals;</td>
    <td class="lineNumber">4318</td>
    <td class="codeline">    SmallVector<SDValue, 4> InVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="codeline">    const ConstantInt *CFIType = nullptr;</td>
    <td class="lineNumber">4319</td>
    <td class="codeline">    const ConstantInt *CFIType = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class="codeline"></td>
    <td class="lineNumber">4320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="codeline">    CallLoweringInfo(SelectionDAG &DAG)</td>
    <td class="lineNumber">4321</td>
    <td class="codeline">    CallLoweringInfo(SelectionDAG &DAG)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="codeline">        : RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false),</td>
    <td class="lineNumber">4322</td>
    <td class="codeline">        : RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="codeline">          DoesNotReturn(false), IsReturnValueUsed(true), IsConvergent(false),</td>
    <td class="lineNumber">4323</td>
    <td class="codeline">          DoesNotReturn(false), IsReturnValueUsed(true), IsConvergent(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="codeline">          IsPatchPoint(false), IsPreallocated(false), NoMerge(false),</td>
    <td class="lineNumber">4324</td>
    <td class="codeline">          IsPatchPoint(false), IsPreallocated(false), NoMerge(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="codeline">          DAG(DAG) {}</td>
    <td class="lineNumber">4325</td>
    <td class="codeline">          DAG(DAG) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="codeline"></td>
    <td class="lineNumber">4326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="codeline">    CallLoweringInfo &setDebugLoc(const SDLoc &dl) {</td>
    <td class="lineNumber">4327</td>
    <td class="codeline">    CallLoweringInfo &setDebugLoc(const SDLoc &dl) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="codeline">      DL = dl;</td>
    <td class="lineNumber">4328</td>
    <td class="codeline">      DL = dl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4329</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4330</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="codeline"></td>
    <td class="lineNumber">4331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="codeline">    CallLoweringInfo &setChain(SDValue InChain) {</td>
    <td class="lineNumber">4332</td>
    <td class="codeline">    CallLoweringInfo &setChain(SDValue InChain) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="codeline">      Chain = InChain;</td>
    <td class="lineNumber">4333</td>
    <td class="codeline">      Chain = InChain;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4334</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4335</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="codeline"></td>
    <td class="lineNumber">4336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="codeline">    // setCallee with target/module-specific attributes</td>
    <td class="lineNumber">4337</td>
    <td class="codeline">    // setCallee with target/module-specific attributes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="codeline">    CallLoweringInfo &setLibCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td class="lineNumber">4338</td>
    <td class="codeline">    CallLoweringInfo &setLibCallee(CallingConv::ID CC, Type *ResultType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="codeline">                                   SDValue Target, ArgListTy &&ArgsList) {</td>
    <td class="lineNumber">4339</td>
    <td class="codeline">                                   SDValue Target, ArgListTy &&ArgsList) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="codeline">      RetTy = ResultType;</td>
    <td class="lineNumber">4340</td>
    <td class="codeline">      RetTy = ResultType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="codeline">      Callee = Target;</td>
    <td class="lineNumber">4341</td>
    <td class="codeline">      Callee = Target;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="codeline">      CallConv = CC;</td>
    <td class="lineNumber">4342</td>
    <td class="codeline">      CallConv = CC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="codeline">      NumFixedArgs = ArgsList.size();</td>
    <td class="lineNumber">4343</td>
    <td class="codeline">      NumFixedArgs = ArgsList.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="codeline">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">4344</td>
    <td class="codeline">      Args = std::move(ArgsList);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="codeline"></td>
    <td class="lineNumber">4345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="codeline">      DAG.getTargetLoweringInfo().markLibCallAttributes(</td>
    <td class="lineNumber">4346</td>
    <td class="codeline">      DAG.getTargetLoweringInfo().markLibCallAttributes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="codeline">          &(DAG.getMachineFunction()), CC, Args);</td>
    <td class="lineNumber">4347</td>
    <td class="codeline">          &(DAG.getMachineFunction()), CC, Args);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4348</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4349</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="codeline"></td>
    <td class="lineNumber">4350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="codeline">    CallLoweringInfo &setCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td class="lineNumber">4351</td>
    <td class="codeline">    CallLoweringInfo &setCallee(CallingConv::ID CC, Type *ResultType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="codeline">                                SDValue Target, ArgListTy &&ArgsList) {</td>
    <td class="lineNumber">4352</td>
    <td class="codeline">                                SDValue Target, ArgListTy &&ArgsList) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="codeline">      RetTy = ResultType;</td>
    <td class="lineNumber">4353</td>
    <td class="codeline">      RetTy = ResultType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="codeline">      Callee = Target;</td>
    <td class="lineNumber">4354</td>
    <td class="codeline">      Callee = Target;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="codeline">      CallConv = CC;</td>
    <td class="lineNumber">4355</td>
    <td class="codeline">      CallConv = CC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="codeline">      NumFixedArgs = ArgsList.size();</td>
    <td class="lineNumber">4356</td>
    <td class="codeline">      NumFixedArgs = ArgsList.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="codeline">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">4357</td>
    <td class="codeline">      Args = std::move(ArgsList);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4358</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4359</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="codeline"></td>
    <td class="lineNumber">4360</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="codeline">    CallLoweringInfo &setCallee(Type *ResultType, FunctionType *FTy,</td>
    <td class="lineNumber">4361</td>
    <td class="codeline">    CallLoweringInfo &setCallee(Type *ResultType, FunctionType *FTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="codeline">                                SDValue Target, ArgListTy &&ArgsList,</td>
    <td class="lineNumber">4362</td>
    <td class="codeline">                                SDValue Target, ArgListTy &&ArgsList,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="codeline">                                const CallBase &Call) {</td>
    <td class="lineNumber">4363</td>
    <td class="codeline">                                const CallBase &Call) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="codeline">      RetTy = ResultType;</td>
    <td class="lineNumber">4364</td>
    <td class="codeline">      RetTy = ResultType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class="codeline"></td>
    <td class="lineNumber">4365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="codeline">      IsInReg = Call.hasRetAttr(Attribute::InReg);</td>
    <td class="lineNumber">4366</td>
    <td class="codeline">      IsInReg = Call.hasRetAttr(Attribute::InReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="codeline">      DoesNotReturn =</td>
    <td class="lineNumber">4367</td>
    <td class="codeline">      DoesNotReturn =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="codeline">          Call.doesNotReturn() ||</td>
    <td class="lineNumber">4368</td>
    <td class="codeline">          Call.doesNotReturn() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="codeline">          (!isa<InvokeInst>(Call) && isa<UnreachableInst>(Call.getNextNode()));</td>
    <td class="lineNumber">4369</td>
    <td class="codeline">          (!isa<InvokeInst>(Call) && isa<UnreachableInst>(Call.getNextNode()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="codeline">      IsVarArg = FTy->isVarArg();</td>
    <td class="lineNumber">4370</td>
    <td class="codeline">      IsVarArg = FTy->isVarArg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="codeline">      IsReturnValueUsed = !Call.use_empty();</td>
    <td class="lineNumber">4371</td>
    <td class="codeline">      IsReturnValueUsed = !Call.use_empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="codeline">      RetSExt = Call.hasRetAttr(Attribute::SExt);</td>
    <td class="lineNumber">4372</td>
    <td class="codeline">      RetSExt = Call.hasRetAttr(Attribute::SExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="codeline">      RetZExt = Call.hasRetAttr(Attribute::ZExt);</td>
    <td class="lineNumber">4373</td>
    <td class="codeline">      RetZExt = Call.hasRetAttr(Attribute::ZExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="codeline">      NoMerge = Call.hasFnAttr(Attribute::NoMerge);</td>
    <td class="lineNumber">4374</td>
    <td class="codeline">      NoMerge = Call.hasFnAttr(Attribute::NoMerge);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="codeline"></td>
    <td class="lineNumber">4375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="codeline">      Callee = Target;</td>
    <td class="lineNumber">4376</td>
    <td class="codeline">      Callee = Target;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class="codeline"></td>
    <td class="lineNumber">4377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="codeline">      CallConv = Call.getCallingConv();</td>
    <td class="lineNumber">4378</td>
    <td class="codeline">      CallConv = Call.getCallingConv();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="codeline">      NumFixedArgs = FTy->getNumParams();</td>
    <td class="lineNumber">4379</td>
    <td class="codeline">      NumFixedArgs = FTy->getNumParams();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="codeline">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">4380</td>
    <td class="codeline">      Args = std::move(ArgsList);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="codeline"></td>
    <td class="lineNumber">4381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="codeline">      CB = &Call;</td>
    <td class="lineNumber">4382</td>
    <td class="codeline">      CB = &Call;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="codeline"></td>
    <td class="lineNumber">4383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4384</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4385</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class="codeline"></td>
    <td class="lineNumber">4386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="codeline">    CallLoweringInfo &setInRegister(bool Value = true) {</td>
    <td class="lineNumber">4387</td>
    <td class="codeline">    CallLoweringInfo &setInRegister(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="codeline">      IsInReg = Value;</td>
    <td class="lineNumber">4388</td>
    <td class="codeline">      IsInReg = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4389</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4390</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class="codeline"></td>
    <td class="lineNumber">4391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="codeline">    CallLoweringInfo &setNoReturn(bool Value = true) {</td>
    <td class="lineNumber">4392</td>
    <td class="codeline">    CallLoweringInfo &setNoReturn(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="codeline">      DoesNotReturn = Value;</td>
    <td class="lineNumber">4393</td>
    <td class="codeline">      DoesNotReturn = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4394</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4395</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="codeline"></td>
    <td class="lineNumber">4396</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="codeline">    CallLoweringInfo &setVarArg(bool Value = true) {</td>
    <td class="lineNumber">4397</td>
    <td class="codeline">    CallLoweringInfo &setVarArg(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="codeline">      IsVarArg = Value;</td>
    <td class="lineNumber">4398</td>
    <td class="codeline">      IsVarArg = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4399</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4400</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="codeline"></td>
    <td class="lineNumber">4401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="codeline">    CallLoweringInfo &setTailCall(bool Value = true) {</td>
    <td class="lineNumber">4402</td>
    <td class="codeline">    CallLoweringInfo &setTailCall(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="codeline">      IsTailCall = Value;</td>
    <td class="lineNumber">4403</td>
    <td class="codeline">      IsTailCall = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4404</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4405</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="codeline"></td>
    <td class="lineNumber">4406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="codeline">    CallLoweringInfo &setDiscardResult(bool Value = true) {</td>
    <td class="lineNumber">4407</td>
    <td class="codeline">    CallLoweringInfo &setDiscardResult(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="codeline">      IsReturnValueUsed = !Value;</td>
    <td class="lineNumber">4408</td>
    <td class="codeline">      IsReturnValueUsed = !Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4409</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4410</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class="codeline"></td>
    <td class="lineNumber">4411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="codeline">    CallLoweringInfo &setConvergent(bool Value = true) {</td>
    <td class="lineNumber">4412</td>
    <td class="codeline">    CallLoweringInfo &setConvergent(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="codeline">      IsConvergent = Value;</td>
    <td class="lineNumber">4413</td>
    <td class="codeline">      IsConvergent = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4414</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4415</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="codeline"></td>
    <td class="lineNumber">4416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="codeline">    CallLoweringInfo &setSExtResult(bool Value = true) {</td>
    <td class="lineNumber">4417</td>
    <td class="codeline">    CallLoweringInfo &setSExtResult(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="codeline">      RetSExt = Value;</td>
    <td class="lineNumber">4418</td>
    <td class="codeline">      RetSExt = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4419</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4420</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="codeline"></td>
    <td class="lineNumber">4421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="codeline">    CallLoweringInfo &setZExtResult(bool Value = true) {</td>
    <td class="lineNumber">4422</td>
    <td class="codeline">    CallLoweringInfo &setZExtResult(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="codeline">      RetZExt = Value;</td>
    <td class="lineNumber">4423</td>
    <td class="codeline">      RetZExt = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4424</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4425</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class="codeline"></td>
    <td class="lineNumber">4426</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="codeline">    CallLoweringInfo &setIsPatchPoint(bool Value = true) {</td>
    <td class="lineNumber">4427</td>
    <td class="codeline">    CallLoweringInfo &setIsPatchPoint(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="codeline">      IsPatchPoint = Value;</td>
    <td class="lineNumber">4428</td>
    <td class="codeline">      IsPatchPoint = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4429</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4430</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="codeline"></td>
    <td class="lineNumber">4431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="codeline">    CallLoweringInfo &setIsPreallocated(bool Value = true) {</td>
    <td class="lineNumber">4432</td>
    <td class="codeline">    CallLoweringInfo &setIsPreallocated(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="codeline">      IsPreallocated = Value;</td>
    <td class="lineNumber">4433</td>
    <td class="codeline">      IsPreallocated = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4434</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4435</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="codeline"></td>
    <td class="lineNumber">4436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="codeline">    CallLoweringInfo &setIsPostTypeLegalization(bool Value=true) {</td>
    <td class="lineNumber">4437</td>
    <td class="codeline">    CallLoweringInfo &setIsPostTypeLegalization(bool Value=true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="codeline">      IsPostTypeLegalization = Value;</td>
    <td class="lineNumber">4438</td>
    <td class="codeline">      IsPostTypeLegalization = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4439</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4440</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class="codeline"></td>
    <td class="lineNumber">4441</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="codeline">    CallLoweringInfo &setCFIType(const ConstantInt *Type) {</td>
    <td class="lineNumber">4442</td>
    <td class="codeline">    CallLoweringInfo &setCFIType(const ConstantInt *Type) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="codeline">      CFIType = Type;</td>
    <td class="lineNumber">4443</td>
    <td class="codeline">      CFIType = Type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4444</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4445</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="codeline"></td>
    <td class="lineNumber">4446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="codeline">    ArgListTy &getArgs() {</td>
    <td class="lineNumber">4447</td>
    <td class="codeline">    ArgListTy &getArgs() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="codeline">      return Args;</td>
    <td class="lineNumber">4448</td>
    <td class="codeline">      return Args;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4449</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4450</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="codeline"></td>
    <td class="lineNumber">4451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="codeline">  /// This structure is used to pass arguments to makeLibCall function.</td>
    <td class="lineNumber">4452</td>
    <td class="codeline">  /// This structure is used to pass arguments to makeLibCall function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="codeline">  struct MakeLibCallOptions {</td>
    <td class="lineNumber">4453</td>
    <td class="codeline">  struct MakeLibCallOptions {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="codeline">    // By passing type list before soften to makeLibCall, the target hook</td>
    <td class="lineNumber">4454</td>
    <td class="codeline">    // By passing type list before soften to makeLibCall, the target hook</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="codeline">    // shouldExtendTypeInLibCall can get the original type before soften.</td>
    <td class="lineNumber">4455</td>
    <td class="codeline">    // shouldExtendTypeInLibCall can get the original type before soften.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="codeline">    ArrayRef<EVT> OpsVTBeforeSoften;</td>
    <td class="lineNumber">4456</td>
    <td class="codeline">    ArrayRef<EVT> OpsVTBeforeSoften;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="codeline">    EVT RetVTBeforeSoften;</td>
    <td class="lineNumber">4457</td>
    <td class="codeline">    EVT RetVTBeforeSoften;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="codeline">    bool IsSExt : 1;</td>
    <td class="lineNumber">4458</td>
    <td class="codeline">    bool IsSExt : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="codeline">    bool DoesNotReturn : 1;</td>
    <td class="lineNumber">4459</td>
    <td class="codeline">    bool DoesNotReturn : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="codeline">    bool IsReturnValueUsed : 1;</td>
    <td class="lineNumber">4460</td>
    <td class="codeline">    bool IsReturnValueUsed : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="codeline">    bool IsPostTypeLegalization : 1;</td>
    <td class="lineNumber">4461</td>
    <td class="codeline">    bool IsPostTypeLegalization : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="codeline">    bool IsSoften : 1;</td>
    <td class="lineNumber">4462</td>
    <td class="codeline">    bool IsSoften : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="codeline"></td>
    <td class="lineNumber">4463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="codeline">    MakeLibCallOptions()</td>
    <td class="lineNumber">4464</td>
    <td class="codeline">    MakeLibCallOptions()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="codeline">        : IsSExt(false), DoesNotReturn(false), IsReturnValueUsed(true),</td>
    <td class="lineNumber">4465</td>
    <td class="codeline">        : IsSExt(false), DoesNotReturn(false), IsReturnValueUsed(true),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="codeline">          IsPostTypeLegalization(false), IsSoften(false) {}</td>
    <td class="lineNumber">4466</td>
    <td class="codeline">          IsPostTypeLegalization(false), IsSoften(false) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="codeline"></td>
    <td class="lineNumber">4467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="codeline">    MakeLibCallOptions &setSExt(bool Value = true) {</td>
    <td class="lineNumber">4468</td>
    <td class="codeline">    MakeLibCallOptions &setSExt(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="codeline">      IsSExt = Value;</td>
    <td class="lineNumber">4469</td>
    <td class="codeline">      IsSExt = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4470</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4471</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="codeline"></td>
    <td class="lineNumber">4472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="codeline">    MakeLibCallOptions &setNoReturn(bool Value = true) {</td>
    <td class="lineNumber">4473</td>
    <td class="codeline">    MakeLibCallOptions &setNoReturn(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="codeline">      DoesNotReturn = Value;</td>
    <td class="lineNumber">4474</td>
    <td class="codeline">      DoesNotReturn = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4475</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4476</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="codeline"></td>
    <td class="lineNumber">4477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="codeline">    MakeLibCallOptions &setDiscardResult(bool Value = true) {</td>
    <td class="lineNumber">4478</td>
    <td class="codeline">    MakeLibCallOptions &setDiscardResult(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="codeline">      IsReturnValueUsed = !Value;</td>
    <td class="lineNumber">4479</td>
    <td class="codeline">      IsReturnValueUsed = !Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4480</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4481</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="codeline"></td>
    <td class="lineNumber">4482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="codeline">    MakeLibCallOptions &setIsPostTypeLegalization(bool Value = true) {</td>
    <td class="lineNumber">4483</td>
    <td class="codeline">    MakeLibCallOptions &setIsPostTypeLegalization(bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="codeline">      IsPostTypeLegalization = Value;</td>
    <td class="lineNumber">4484</td>
    <td class="codeline">      IsPostTypeLegalization = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4485</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4486</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class="codeline"></td>
    <td class="lineNumber">4487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="codeline">    MakeLibCallOptions &setTypeListBeforeSoften(ArrayRef<EVT> OpsVT, EVT RetVT,</td>
    <td class="lineNumber">4488</td>
    <td class="codeline">    MakeLibCallOptions &setTypeListBeforeSoften(ArrayRef<EVT> OpsVT, EVT RetVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="codeline">                                                bool Value = true) {</td>
    <td class="lineNumber">4489</td>
    <td class="codeline">                                                bool Value = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="codeline">      OpsVTBeforeSoften = OpsVT;</td>
    <td class="lineNumber">4490</td>
    <td class="codeline">      OpsVTBeforeSoften = OpsVT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="codeline">      RetVTBeforeSoften = RetVT;</td>
    <td class="lineNumber">4491</td>
    <td class="codeline">      RetVTBeforeSoften = RetVT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="codeline">      IsSoften = Value;</td>
    <td class="lineNumber">4492</td>
    <td class="codeline">      IsSoften = Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">4493</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4494</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4495</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class="codeline"></td>
    <td class="lineNumber">4496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="codeline">  /// This function lowers an abstract call to a function into an actual call.</td>
    <td class="lineNumber">4497</td>
    <td class="codeline">  /// This function lowers an abstract call to a function into an actual call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="codeline">  /// This returns a pair of operands.  The first element is the return value</td>
    <td class="lineNumber">4498</td>
    <td class="codeline">  /// This returns a pair of operands.  The first element is the return value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="codeline">  /// for the function (if RetTy is not VoidTy).  The second element is the</td>
    <td class="lineNumber">4499</td>
    <td class="codeline">  /// for the function (if RetTy is not VoidTy).  The second element is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="codeline">  /// outgoing token chain. It calls LowerCall to do the actual lowering.</td>
    <td class="lineNumber">4500</td>
    <td class="codeline">  /// outgoing token chain. It calls LowerCall to do the actual lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="codeline">  std::pair<SDValue, SDValue> LowerCallTo(CallLoweringInfo &CLI) const;</td>
    <td class="lineNumber">4501</td>
    <td class="codeline">  std::pair<SDValue, SDValue> LowerCallTo(CallLoweringInfo &CLI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class="codeline"></td>
    <td class="lineNumber">4502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="codeline">  /// This hook must be implemented to lower calls into the specified</td>
    <td class="lineNumber">4503</td>
    <td class="codeline">  /// This hook must be implemented to lower calls into the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="codeline">  /// DAG. The outgoing arguments to the call are described by the Outs array,</td>
    <td class="lineNumber">4504</td>
    <td class="codeline">  /// DAG. The outgoing arguments to the call are described by the Outs array,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="codeline">  /// and the values to be returned by the call are described by the Ins</td>
    <td class="lineNumber">4505</td>
    <td class="codeline">  /// and the values to be returned by the call are described by the Ins</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="codeline">  /// array. The implementation should fill in the InVals array with legal-type</td>
    <td class="lineNumber">4506</td>
    <td class="codeline">  /// array. The implementation should fill in the InVals array with legal-type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="codeline">  /// return values from the call, and return the resulting token chain value.</td>
    <td class="lineNumber">4507</td>
    <td class="codeline">  /// return values from the call, and return the resulting token chain value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="codeline">  virtual SDValue</td>
    <td class="lineNumber">4508</td>
    <td class="codeline">  virtual SDValue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="codeline">    LowerCall(CallLoweringInfo &/*CLI*/,</td>
    <td class="lineNumber">4509</td>
    <td class="codeline">    LowerCall(CallLoweringInfo &/*CLI*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="codeline">              SmallVectorImpl<SDValue> &/*InVals*/) const {</td>
    <td class="lineNumber">4510</td>
    <td class="codeline">              SmallVectorImpl<SDValue> &/*InVals*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">4511</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4512</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class="codeline"></td>
    <td class="lineNumber">4513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="codeline">  /// Target-specific cleanup for formal ByVal parameters.</td>
    <td class="lineNumber">4514</td>
    <td class="codeline">  /// Target-specific cleanup for formal ByVal parameters.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="codeline">  virtual void HandleByVal(CCState *, unsigned &, Align) const {}</td>
    <td class="lineNumber">4515</td>
    <td class="codeline">  virtual void HandleByVal(CCState *, unsigned &, Align) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class="codeline"></td>
    <td class="lineNumber">4516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="codeline">  /// This hook should be implemented to check whether the return values</td>
    <td class="lineNumber">4517</td>
    <td class="codeline">  /// This hook should be implemented to check whether the return values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="codeline">  /// described by the Outs array can fit into the return registers.  If false</td>
    <td class="lineNumber">4518</td>
    <td class="codeline">  /// described by the Outs array can fit into the return registers.  If false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="codeline">  /// is returned, an sret-demotion is performed.</td>
    <td class="lineNumber">4519</td>
    <td class="codeline">  /// is returned, an sret-demotion is performed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="codeline">  virtual bool CanLowerReturn(CallingConv::ID /*CallConv*/,</td>
    <td class="lineNumber">4520</td>
    <td class="codeline">  virtual bool CanLowerReturn(CallingConv::ID /*CallConv*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="codeline">                              MachineFunction &/*MF*/, bool /*isVarArg*/,</td>
    <td class="lineNumber">4521</td>
    <td class="codeline">                              MachineFunction &/*MF*/, bool /*isVarArg*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="codeline">               const SmallVectorImpl<ISD::OutputArg> &/*Outs*/,</td>
    <td class="lineNumber">4522</td>
    <td class="codeline">               const SmallVectorImpl<ISD::OutputArg> &/*Outs*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="codeline">               LLVMContext &/*Context*/) const</td>
    <td class="lineNumber">4523</td>
    <td class="codeline">               LLVMContext &/*Context*/) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="codeline">  {</td>
    <td class="lineNumber">4524</td>
    <td class="codeline">  {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="codeline">    // Return true by default to get preexisting behavior.</td>
    <td class="lineNumber">4525</td>
    <td class="codeline">    // Return true by default to get preexisting behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">4526</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4527</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="codeline"></td>
    <td class="lineNumber">4528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="codeline">  /// This hook must be implemented to lower outgoing return values, described</td>
    <td class="lineNumber">4529</td>
    <td class="codeline">  /// This hook must be implemented to lower outgoing return values, described</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="codeline">  /// by the Outs array, into the specified DAG. The implementation should</td>
    <td class="lineNumber">4530</td>
    <td class="codeline">  /// by the Outs array, into the specified DAG. The implementation should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="codeline">  /// return the resulting token chain value.</td>
    <td class="lineNumber">4531</td>
    <td class="codeline">  /// return the resulting token chain value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="codeline">  virtual SDValue LowerReturn(SDValue /*Chain*/, CallingConv::ID /*CallConv*/,</td>
    <td class="lineNumber">4532</td>
    <td class="codeline">  virtual SDValue LowerReturn(SDValue /*Chain*/, CallingConv::ID /*CallConv*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="codeline">                              bool /*isVarArg*/,</td>
    <td class="lineNumber">4533</td>
    <td class="codeline">                              bool /*isVarArg*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="codeline">                              const SmallVectorImpl<ISD::OutputArg> & /*Outs*/,</td>
    <td class="lineNumber">4534</td>
    <td class="codeline">                              const SmallVectorImpl<ISD::OutputArg> & /*Outs*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="codeline">                              const SmallVectorImpl<SDValue> & /*OutVals*/,</td>
    <td class="lineNumber">4535</td>
    <td class="codeline">                              const SmallVectorImpl<SDValue> & /*OutVals*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="codeline">                              const SDLoc & /*dl*/,</td>
    <td class="lineNumber">4536</td>
    <td class="codeline">                              const SDLoc & /*dl*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="codeline">                              SelectionDAG & /*DAG*/) const {</td>
    <td class="lineNumber">4537</td>
    <td class="codeline">                              SelectionDAG & /*DAG*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">4538</td>
    <td class="codeline">    llvm_unreachable("Not Implemented");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4539</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="codeline"></td>
    <td class="lineNumber">4540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="codeline">  /// Return true if result of the specified node is used by a return node</td>
    <td class="lineNumber">4541</td>
    <td class="codeline">  /// Return true if result of the specified node is used by a return node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="codeline">  /// only. It also compute and return the input chain for the tail call.</td>
    <td class="lineNumber">4542</td>
    <td class="codeline">  /// only. It also compute and return the input chain for the tail call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4543</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="codeline">  /// This is used to determine whether it is possible to codegen a libcall as</td>
    <td class="lineNumber">4544</td>
    <td class="codeline">  /// This is used to determine whether it is possible to codegen a libcall as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="codeline">  /// tail call at legalization time.</td>
    <td class="lineNumber">4545</td>
    <td class="codeline">  /// tail call at legalization time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="codeline">  virtual bool isUsedByReturnOnly(SDNode *, SDValue &/*Chain*/) const {</td>
    <td class="lineNumber">4546</td>
    <td class="codeline">  virtual bool isUsedByReturnOnly(SDNode *, SDValue &/*Chain*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4547</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4548</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="codeline"></td>
    <td class="lineNumber">4549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="codeline">  /// Return true if the target may be able emit the call instruction as a tail</td>
    <td class="lineNumber">4550</td>
    <td class="codeline">  /// Return true if the target may be able emit the call instruction as a tail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="codeline">  /// call. This is used by optimization passes to determine if it's profitable</td>
    <td class="lineNumber">4551</td>
    <td class="codeline">  /// call. This is used by optimization passes to determine if it's profitable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="codeline">  /// to duplicate return instructions to enable tailcall optimization.</td>
    <td class="lineNumber">4552</td>
    <td class="codeline">  /// to duplicate return instructions to enable tailcall optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="codeline">  virtual bool mayBeEmittedAsTailCall(const CallInst *) const {</td>
    <td class="lineNumber">4553</td>
    <td class="codeline">  virtual bool mayBeEmittedAsTailCall(const CallInst *) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4554</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4555</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="codeline"></td>
    <td class="lineNumber">4556</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="codeline">  /// Return the builtin name for the __builtin___clear_cache intrinsic</td>
    <td class="lineNumber">4557</td>
    <td class="codeline">  /// Return the builtin name for the __builtin___clear_cache intrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="codeline">  /// Default is to invoke the clear cache library call</td>
    <td class="lineNumber">4558</td>
    <td class="codeline">  /// Default is to invoke the clear cache library call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="codeline">  virtual const char * getClearCacheBuiltinName() const {</td>
    <td class="lineNumber">4559</td>
    <td class="codeline">  virtual const char * getClearCacheBuiltinName() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="codeline">    return "__clear_cache";</td>
    <td class="lineNumber">4560</td>
    <td class="codeline">    return "__clear_cache";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4561</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class="codeline"></td>
    <td class="lineNumber">4562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="codeline">  /// Return the register ID of the name passed in. Used by named register</td>
    <td class="lineNumber">4563</td>
    <td class="codeline">  /// Return the register ID of the name passed in. Used by named register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="codeline">  /// global variables extension. There is no target-independent behaviour</td>
    <td class="lineNumber">4564</td>
    <td class="codeline">  /// global variables extension. There is no target-independent behaviour</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="codeline">  /// so the default action is to bail.</td>
    <td class="lineNumber">4565</td>
    <td class="codeline">  /// so the default action is to bail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="codeline">  virtual Register getRegisterByName(const char* RegName, LLT Ty,</td>
    <td class="lineNumber">4566</td>
    <td class="codeline">  virtual Register getRegisterByName(const char* RegName, LLT Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="codeline">                                     const MachineFunction &MF) const {</td>
    <td class="lineNumber">4567</td>
    <td class="codeline">                                     const MachineFunction &MF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="codeline">    report_fatal_error("Named registers not implemented for this target");</td>
    <td class="lineNumber">4568</td>
    <td class="codeline">    report_fatal_error("Named registers not implemented for this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4569</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="codeline"></td>
    <td class="lineNumber">4570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="codeline">  /// Return the type that should be used to zero or sign extend a</td>
    <td class="lineNumber">4571</td>
    <td class="codeline">  /// Return the type that should be used to zero or sign extend a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="codeline">  /// zeroext/signext integer return value.  FIXME: Some C calling conventions</td>
    <td class="lineNumber">4572</td>
    <td class="codeline">  /// zeroext/signext integer return value.  FIXME: Some C calling conventions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="codeline">  /// require the return type to be promoted, but this is not true all the time,</td>
    <td class="lineNumber">4573</td>
    <td class="codeline">  /// require the return type to be promoted, but this is not true all the time,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="codeline">  /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling</td>
    <td class="lineNumber">4574</td>
    <td class="codeline">  /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="codeline">  /// conventions. The frontend should handle this and include all of the</td>
    <td class="lineNumber">4575</td>
    <td class="codeline">  /// conventions. The frontend should handle this and include all of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="codeline">  /// necessary information.</td>
    <td class="lineNumber">4576</td>
    <td class="codeline">  /// necessary information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="codeline">  virtual EVT getTypeForExtReturn(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">4577</td>
    <td class="codeline">  virtual EVT getTypeForExtReturn(LLVMContext &Context, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="codeline">                                       ISD::NodeType /*ExtendKind*/) const {</td>
    <td class="lineNumber">4578</td>
    <td class="codeline">                                       ISD::NodeType /*ExtendKind*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="codeline">    EVT MinVT = getRegisterType(MVT::i32);</td>
    <td class="lineNumber">4579</td>
    <td class="codeline">    EVT MinVT = getRegisterType(MVT::i32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="codeline">    return VT.bitsLT(MinVT) ? MinVT : VT;</td>
    <td class="lineNumber">4580</td>
    <td class="codeline">    return VT.bitsLT(MinVT) ? MinVT : VT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4581</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class="codeline"></td>
    <td class="lineNumber">4582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="codeline">  /// For some targets, an LLVM struct type must be broken down into multiple</td>
    <td class="lineNumber">4583</td>
    <td class="codeline">  /// For some targets, an LLVM struct type must be broken down into multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="codeline">  /// simple types, but the calling convention specifies that the entire struct</td>
    <td class="lineNumber">4584</td>
    <td class="codeline">  /// simple types, but the calling convention specifies that the entire struct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="codeline">  /// must be passed in a block of consecutive registers.</td>
    <td class="lineNumber">4585</td>
    <td class="codeline">  /// must be passed in a block of consecutive registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">4586</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="codeline">  functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv,</td>
    <td class="lineNumber">4587</td>
    <td class="codeline">  functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="codeline">                                            bool isVarArg,</td>
    <td class="lineNumber">4588</td>
    <td class="codeline">                                            bool isVarArg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="codeline">                                            const DataLayout &DL) const {</td>
    <td class="lineNumber">4589</td>
    <td class="codeline">                                            const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4590</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4591</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="codeline"></td>
    <td class="lineNumber">4592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="codeline">  /// For most targets, an LLVM type must be broken down into multiple</td>
    <td class="lineNumber">4593</td>
    <td class="codeline">  /// For most targets, an LLVM type must be broken down into multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="codeline">  /// smaller types. Usually the halves are ordered according to the endianness</td>
    <td class="lineNumber">4594</td>
    <td class="codeline">  /// smaller types. Usually the halves are ordered according to the endianness</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="codeline">  /// but for some platform that would break. So this method will default to</td>
    <td class="lineNumber">4595</td>
    <td class="codeline">  /// but for some platform that would break. So this method will default to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="codeline">  /// matching the endianness but can be overridden.</td>
    <td class="lineNumber">4596</td>
    <td class="codeline">  /// matching the endianness but can be overridden.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">4597</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="codeline">  shouldSplitFunctionArgumentsAsLittleEndian(const DataLayout &DL) const {</td>
    <td class="lineNumber">4598</td>
    <td class="codeline">  shouldSplitFunctionArgumentsAsLittleEndian(const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="codeline">    return DL.isLittleEndian();</td>
    <td class="lineNumber">4599</td>
    <td class="codeline">    return DL.isLittleEndian();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4600</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="codeline"></td>
    <td class="lineNumber">4601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="codeline">  /// Returns a 0 terminated array of registers that can be safely used as</td>
    <td class="lineNumber">4602</td>
    <td class="codeline">  /// Returns a 0 terminated array of registers that can be safely used as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="codeline">  /// scratch registers.</td>
    <td class="lineNumber">4603</td>
    <td class="codeline">  /// scratch registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="codeline">  virtual const MCPhysReg *getScratchRegisters(CallingConv::ID CC) const {</td>
    <td class="lineNumber">4604</td>
    <td class="codeline">  virtual const MCPhysReg *getScratchRegisters(CallingConv::ID CC) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">4605</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4606</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="codeline"></td>
    <td class="lineNumber">4607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="codeline">  /// Returns a 0 terminated array of rounding control registers that can be</td>
    <td class="lineNumber">4608</td>
    <td class="codeline">  /// Returns a 0 terminated array of rounding control registers that can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="codeline">  /// attached into strict FP call.</td>
    <td class="lineNumber">4609</td>
    <td class="codeline">  /// attached into strict FP call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="codeline">  virtual ArrayRef<MCPhysReg> getRoundingControlRegisters() const {</td>
    <td class="lineNumber">4610</td>
    <td class="codeline">  virtual ArrayRef<MCPhysReg> getRoundingControlRegisters() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="codeline">    return ArrayRef<MCPhysReg>();</td>
    <td class="lineNumber">4611</td>
    <td class="codeline">    return ArrayRef<MCPhysReg>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4612</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="codeline"></td>
    <td class="lineNumber">4613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="codeline">  /// This callback is used to prepare for a volatile or atomic load.</td>
    <td class="lineNumber">4614</td>
    <td class="codeline">  /// This callback is used to prepare for a volatile or atomic load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="codeline">  /// It takes a chain node as input and returns the chain for the load itself.</td>
    <td class="lineNumber">4615</td>
    <td class="codeline">  /// It takes a chain node as input and returns the chain for the load itself.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4616</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="codeline">  /// Having a callback like this is necessary for targets like SystemZ,</td>
    <td class="lineNumber">4617</td>
    <td class="codeline">  /// Having a callback like this is necessary for targets like SystemZ,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="codeline">  /// which allows a CPU to reuse the result of a previous load indefinitely,</td>
    <td class="lineNumber">4618</td>
    <td class="codeline">  /// which allows a CPU to reuse the result of a previous load indefinitely,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="codeline">  /// even if a cache-coherent store is performed by another CPU.  The default</td>
    <td class="lineNumber">4619</td>
    <td class="codeline">  /// even if a cache-coherent store is performed by another CPU.  The default</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="codeline">  /// implementation does nothing.</td>
    <td class="lineNumber">4620</td>
    <td class="codeline">  /// implementation does nothing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="codeline">  virtual SDValue prepareVolatileOrAtomicLoad(SDValue Chain, const SDLoc &DL,</td>
    <td class="lineNumber">4621</td>
    <td class="codeline">  virtual SDValue prepareVolatileOrAtomicLoad(SDValue Chain, const SDLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="codeline">                                              SelectionDAG &DAG) const {</td>
    <td class="lineNumber">4622</td>
    <td class="codeline">                                              SelectionDAG &DAG) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="codeline">    return Chain;</td>
    <td class="lineNumber">4623</td>
    <td class="codeline">    return Chain;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4624</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="codeline"></td>
    <td class="lineNumber">4625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="codeline">  /// Should SelectionDAG lower an atomic store of the given kind as a normal</td>
    <td class="lineNumber">4626</td>
    <td class="codeline">  /// Should SelectionDAG lower an atomic store of the given kind as a normal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="codeline">  /// StoreSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td class="lineNumber">4627</td>
    <td class="codeline">  /// StoreSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="codeline">  /// eventually migrate all targets to the using StoreSDNodes, but porting is</td>
    <td class="lineNumber">4628</td>
    <td class="codeline">  /// eventually migrate all targets to the using StoreSDNodes, but porting is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="codeline">  /// being done target at a time.</td>
    <td class="lineNumber">4629</td>
    <td class="codeline">  /// being done target at a time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="codeline">  virtual bool lowerAtomicStoreAsStoreSDNode(const StoreInst &SI) const {</td>
    <td class="lineNumber">4630</td>
    <td class="codeline">  virtual bool lowerAtomicStoreAsStoreSDNode(const StoreInst &SI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="codeline">    assert(SI.isAtomic() && "violated precondition");</td>
    <td class="lineNumber">4631</td>
    <td class="codeline">    assert(SI.isAtomic() && "violated precondition");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4632</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4633</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="codeline"></td>
    <td class="lineNumber">4634</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="codeline">  /// Should SelectionDAG lower an atomic load of the given kind as a normal</td>
    <td class="lineNumber">4635</td>
    <td class="codeline">  /// Should SelectionDAG lower an atomic load of the given kind as a normal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="codeline">  /// LoadSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td class="lineNumber">4636</td>
    <td class="codeline">  /// LoadSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="codeline">  /// eventually migrate all targets to the using LoadSDNodes, but porting is</td>
    <td class="lineNumber">4637</td>
    <td class="codeline">  /// eventually migrate all targets to the using LoadSDNodes, but porting is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="codeline">  /// being done target at a time.</td>
    <td class="lineNumber">4638</td>
    <td class="codeline">  /// being done target at a time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="codeline">  virtual bool lowerAtomicLoadAsLoadSDNode(const LoadInst &LI) const {</td>
    <td class="lineNumber">4639</td>
    <td class="codeline">  virtual bool lowerAtomicLoadAsLoadSDNode(const LoadInst &LI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="codeline">    assert(LI.isAtomic() && "violated precondition");</td>
    <td class="lineNumber">4640</td>
    <td class="codeline">    assert(LI.isAtomic() && "violated precondition");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4641</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4642</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="codeline"></td>
    <td class="lineNumber">4643</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="codeline"></td>
    <td class="lineNumber">4644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="codeline">  /// This callback is invoked by the type legalizer to legalize nodes with an</td>
    <td class="lineNumber">4645</td>
    <td class="codeline">  /// This callback is invoked by the type legalizer to legalize nodes with an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="codeline">  /// illegal operand type but legal result types.  It replaces the</td>
    <td class="lineNumber">4646</td>
    <td class="codeline">  /// illegal operand type but legal result types.  It replaces the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="codeline">  /// LowerOperation callback in the type Legalizer.  The reason we can not do</td>
    <td class="lineNumber">4647</td>
    <td class="codeline">  /// LowerOperation callback in the type Legalizer.  The reason we can not do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="codeline">  /// away with LowerOperation entirely is that LegalizeDAG isn't yet ready to</td>
    <td class="lineNumber">4648</td>
    <td class="codeline">  /// away with LowerOperation entirely is that LegalizeDAG isn't yet ready to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="codeline">  /// use this callback.</td>
    <td class="lineNumber">4649</td>
    <td class="codeline">  /// use this callback.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4650</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="codeline">  /// TODO: Consider merging with ReplaceNodeResults.</td>
    <td class="lineNumber">4651</td>
    <td class="codeline">  /// TODO: Consider merging with ReplaceNodeResults.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4652</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="codeline">  /// The target places new result values for the node in Results (their number</td>
    <td class="lineNumber">4653</td>
    <td class="codeline">  /// The target places new result values for the node in Results (their number</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="codeline">  /// and types must exactly match those of the original return values of</td>
    <td class="lineNumber">4654</td>
    <td class="codeline">  /// and types must exactly match those of the original return values of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="codeline">  /// the node), or leaves Results empty, which indicates that the node is not</td>
    <td class="lineNumber">4655</td>
    <td class="codeline">  /// the node), or leaves Results empty, which indicates that the node is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="codeline">  /// to be custom lowered after all.</td>
    <td class="lineNumber">4656</td>
    <td class="codeline">  /// to be custom lowered after all.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="codeline">  /// The default implementation calls LowerOperation.</td>
    <td class="lineNumber">4657</td>
    <td class="codeline">  /// The default implementation calls LowerOperation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="codeline">  virtual void LowerOperationWrapper(SDNode *N,</td>
    <td class="lineNumber">4658</td>
    <td class="codeline">  virtual void LowerOperationWrapper(SDNode *N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="codeline">                                     SmallVectorImpl<SDValue> &Results,</td>
    <td class="lineNumber">4659</td>
    <td class="codeline">                                     SmallVectorImpl<SDValue> &Results,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="codeline">                                     SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4660</td>
    <td class="codeline">                                     SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="codeline"></td>
    <td class="lineNumber">4661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="codeline">  /// This callback is invoked for operations that are unsupported by the</td>
    <td class="lineNumber">4662</td>
    <td class="codeline">  /// This callback is invoked for operations that are unsupported by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="codeline">  /// target, which are registered to use 'custom' lowering, and whose defined</td>
    <td class="lineNumber">4663</td>
    <td class="codeline">  /// target, which are registered to use 'custom' lowering, and whose defined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="codeline">  /// values are all legal.  If the target has no operations that require custom</td>
    <td class="lineNumber">4664</td>
    <td class="codeline">  /// values are all legal.  If the target has no operations that require custom</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="codeline">  /// lowering, it need not implement this.  The default implementation of this</td>
    <td class="lineNumber">4665</td>
    <td class="codeline">  /// lowering, it need not implement this.  The default implementation of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="codeline">  /// aborts.</td>
    <td class="lineNumber">4666</td>
    <td class="codeline">  /// aborts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="codeline">  virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4667</td>
    <td class="codeline">  virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="codeline"></td>
    <td class="lineNumber">4668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="codeline">  /// This callback is invoked when a node result type is illegal for the</td>
    <td class="lineNumber">4669</td>
    <td class="codeline">  /// This callback is invoked when a node result type is illegal for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="codeline">  /// target, and the operation was registered to use 'custom' lowering for that</td>
    <td class="lineNumber">4670</td>
    <td class="codeline">  /// target, and the operation was registered to use 'custom' lowering for that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="codeline">  /// result type.  The target places new result values for the node in Results</td>
    <td class="lineNumber">4671</td>
    <td class="codeline">  /// result type.  The target places new result values for the node in Results</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="codeline">  /// (their number and types must exactly match those of the original return</td>
    <td class="lineNumber">4672</td>
    <td class="codeline">  /// (their number and types must exactly match those of the original return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="codeline">  /// values of the node), or leaves Results empty, which indicates that the</td>
    <td class="lineNumber">4673</td>
    <td class="codeline">  /// values of the node), or leaves Results empty, which indicates that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="codeline">  /// node is not to be custom lowered after all.</td>
    <td class="lineNumber">4674</td>
    <td class="codeline">  /// node is not to be custom lowered after all.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4675</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="codeline">  /// If the target has no operations that require custom lowering, it need not</td>
    <td class="lineNumber">4676</td>
    <td class="codeline">  /// If the target has no operations that require custom lowering, it need not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="codeline">  /// implement this.  The default implementation aborts.</td>
    <td class="lineNumber">4677</td>
    <td class="codeline">  /// implement this.  The default implementation aborts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="codeline">  virtual void ReplaceNodeResults(SDNode * /*N*/,</td>
    <td class="lineNumber">4678</td>
    <td class="codeline">  virtual void ReplaceNodeResults(SDNode * /*N*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="codeline">                                  SmallVectorImpl<SDValue> &/*Results*/,</td>
    <td class="lineNumber">4679</td>
    <td class="codeline">                                  SmallVectorImpl<SDValue> &/*Results*/,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="codeline">                                  SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">4680</td>
    <td class="codeline">                                  SelectionDAG &/*DAG*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="codeline">    llvm_unreachable("ReplaceNodeResults not implemented for this target!");</td>
    <td class="lineNumber">4681</td>
    <td class="codeline">    llvm_unreachable("ReplaceNodeResults not implemented for this target!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4682</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="codeline"></td>
    <td class="lineNumber">4683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="codeline">  /// This method returns the name of a target specific DAG node.</td>
    <td class="lineNumber">4684</td>
    <td class="codeline">  /// This method returns the name of a target specific DAG node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="codeline">  virtual const char *getTargetNodeName(unsigned Opcode) const;</td>
    <td class="lineNumber">4685</td>
    <td class="codeline">  virtual const char *getTargetNodeName(unsigned Opcode) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="codeline"></td>
    <td class="lineNumber">4686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="codeline">  /// This method returns a target specific FastISel object, or null if the</td>
    <td class="lineNumber">4687</td>
    <td class="codeline">  /// This method returns a target specific FastISel object, or null if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="codeline">  /// target does not support "fast" ISel.</td>
    <td class="lineNumber">4688</td>
    <td class="codeline">  /// target does not support "fast" ISel.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="codeline">  virtual FastISel *createFastISel(FunctionLoweringInfo &,</td>
    <td class="lineNumber">4689</td>
    <td class="codeline">  virtual FastISel *createFastISel(FunctionLoweringInfo &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="codeline">                                   const TargetLibraryInfo *) const {</td>
    <td class="lineNumber">4690</td>
    <td class="codeline">                                   const TargetLibraryInfo *) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">4691</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4692</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="codeline"></td>
    <td class="lineNumber">4693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="codeline">  bool verifyReturnAddressArgumentIsConstant(SDValue Op,</td>
    <td class="lineNumber">4694</td>
    <td class="codeline">  bool verifyReturnAddressArgumentIsConstant(SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="codeline">                                             SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4695</td>
    <td class="codeline">                                             SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="codeline"></td>
    <td class="lineNumber">4696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">4697</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="codeline">  // Inline Asm Support hooks</td>
    <td class="lineNumber">4698</td>
    <td class="codeline">  // Inline Asm Support hooks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">4699</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class="codeline"></td>
    <td class="lineNumber">4700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="codeline">  /// This hook allows the target to expand an inline asm call to be explicit</td>
    <td class="lineNumber">4701</td>
    <td class="codeline">  /// This hook allows the target to expand an inline asm call to be explicit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="codeline">  /// llvm code if it wants to.  This is useful for turning simple inline asms</td>
    <td class="lineNumber">4702</td>
    <td class="codeline">  /// llvm code if it wants to.  This is useful for turning simple inline asms</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="codeline">  /// into LLVM intrinsics, which gives the compiler more information about the</td>
    <td class="lineNumber">4703</td>
    <td class="codeline">  /// into LLVM intrinsics, which gives the compiler more information about the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="codeline">  /// behavior of the code.</td>
    <td class="lineNumber">4704</td>
    <td class="codeline">  /// behavior of the code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="codeline">  virtual bool ExpandInlineAsm(CallInst *) const {</td>
    <td class="lineNumber">4705</td>
    <td class="codeline">  virtual bool ExpandInlineAsm(CallInst *) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4706</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4707</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="codeline"></td>
    <td class="lineNumber">4708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="codeline">  enum ConstraintType {</td>
    <td class="lineNumber">4709</td>
    <td class="codeline">  enum ConstraintType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="codeline">    C_Register,            // Constraint represents specific register(s).</td>
    <td class="lineNumber">4710</td>
    <td class="codeline">    C_Register,            // Constraint represents specific register(s).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="codeline">    C_RegisterClass,       // Constraint represents any of register(s) in class.</td>
    <td class="lineNumber">4711</td>
    <td class="codeline">    C_RegisterClass,       // Constraint represents any of register(s) in class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="codeline">    C_Memory,              // Memory constraint.</td>
    <td class="lineNumber">4712</td>
    <td class="codeline">    C_Memory,              // Memory constraint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="codeline">    C_Address,             // Address constraint.</td>
    <td class="lineNumber">4713</td>
    <td class="codeline">    C_Address,             // Address constraint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="codeline">    C_Immediate,           // Requires an immediate.</td>
    <td class="lineNumber">4714</td>
    <td class="codeline">    C_Immediate,           // Requires an immediate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="codeline">    C_Other,               // Something else.</td>
    <td class="lineNumber">4715</td>
    <td class="codeline">    C_Other,               // Something else.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="codeline">    C_Unknown              // Unsupported constraint.</td>
    <td class="lineNumber">4716</td>
    <td class="codeline">    C_Unknown              // Unsupported constraint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4717</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="codeline"></td>
    <td class="lineNumber">4718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="codeline">  enum ConstraintWeight {</td>
    <td class="lineNumber">4719</td>
    <td class="codeline">  enum ConstraintWeight {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="codeline">    // Generic weights.</td>
    <td class="lineNumber">4720</td>
    <td class="codeline">    // Generic weights.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="codeline">    CW_Invalid  = -1,     // No match.</td>
    <td class="lineNumber">4721</td>
    <td class="codeline">    CW_Invalid  = -1,     // No match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="codeline">    CW_Okay     = 0,      // Acceptable.</td>
    <td class="lineNumber">4722</td>
    <td class="codeline">    CW_Okay     = 0,      // Acceptable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="codeline">    CW_Good     = 1,      // Good weight.</td>
    <td class="lineNumber">4723</td>
    <td class="codeline">    CW_Good     = 1,      // Good weight.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="codeline">    CW_Better   = 2,      // Better weight.</td>
    <td class="lineNumber">4724</td>
    <td class="codeline">    CW_Better   = 2,      // Better weight.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="codeline">    CW_Best     = 3,      // Best weight.</td>
    <td class="lineNumber">4725</td>
    <td class="codeline">    CW_Best     = 3,      // Best weight.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class="codeline"></td>
    <td class="lineNumber">4726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="codeline">    // Well-known weights.</td>
    <td class="lineNumber">4727</td>
    <td class="codeline">    // Well-known weights.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="codeline">    CW_SpecificReg  = CW_Okay,    // Specific register operands.</td>
    <td class="lineNumber">4728</td>
    <td class="codeline">    CW_SpecificReg  = CW_Okay,    // Specific register operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="codeline">    CW_Register     = CW_Good,    // Register operands.</td>
    <td class="lineNumber">4729</td>
    <td class="codeline">    CW_Register     = CW_Good,    // Register operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="codeline">    CW_Memory       = CW_Better,  // Memory operands.</td>
    <td class="lineNumber">4730</td>
    <td class="codeline">    CW_Memory       = CW_Better,  // Memory operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="codeline">    CW_Constant     = CW_Best,    // Constant operand.</td>
    <td class="lineNumber">4731</td>
    <td class="codeline">    CW_Constant     = CW_Best,    // Constant operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="codeline">    CW_Default      = CW_Okay     // Default or don't know type.</td>
    <td class="lineNumber">4732</td>
    <td class="codeline">    CW_Default      = CW_Okay     // Default or don't know type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4733</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class="codeline"></td>
    <td class="lineNumber">4734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="codeline">  /// This contains information for each constraint that we are lowering.</td>
    <td class="lineNumber">4735</td>
    <td class="codeline">  /// This contains information for each constraint that we are lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="codeline">  struct AsmOperandInfo : public InlineAsm::ConstraintInfo {</td>
    <td class="lineNumber">4736</td>
    <td class="codeline">  struct AsmOperandInfo : public InlineAsm::ConstraintInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="codeline">    /// This contains the actual string for the code, like "m".  TargetLowering</td>
    <td class="lineNumber">4737</td>
    <td class="codeline">    /// This contains the actual string for the code, like "m".  TargetLowering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="codeline">    /// picks the 'best' code from ConstraintInfo::Codes that most closely</td>
    <td class="lineNumber">4738</td>
    <td class="codeline">    /// picks the 'best' code from ConstraintInfo::Codes that most closely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="codeline">    /// matches the operand.</td>
    <td class="lineNumber">4739</td>
    <td class="codeline">    /// matches the operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="codeline">    std::string ConstraintCode;</td>
    <td class="lineNumber">4740</td>
    <td class="codeline">    std::string ConstraintCode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="codeline"></td>
    <td class="lineNumber">4741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class="codeline">    /// Information about the constraint code, e.g. Register, RegisterClass,</td>
    <td class="lineNumber">4742</td>
    <td class="codeline">    /// Information about the constraint code, e.g. Register, RegisterClass,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="codeline">    /// Memory, Other, Unknown.</td>
    <td class="lineNumber">4743</td>
    <td class="codeline">    /// Memory, Other, Unknown.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="codeline">    TargetLowering::ConstraintType ConstraintType = TargetLowering::C_Unknown;</td>
    <td class="lineNumber">4744</td>
    <td class="codeline">    TargetLowering::ConstraintType ConstraintType = TargetLowering::C_Unknown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="codeline"></td>
    <td class="lineNumber">4745</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="codeline">    /// If this is the result output operand or a clobber, this is null,</td>
    <td class="lineNumber">4746</td>
    <td class="codeline">    /// If this is the result output operand or a clobber, this is null,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="codeline">    /// otherwise it is the incoming operand to the CallInst.  This gets</td>
    <td class="lineNumber">4747</td>
    <td class="codeline">    /// otherwise it is the incoming operand to the CallInst.  This gets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="codeline">    /// modified as the asm is processed.</td>
    <td class="lineNumber">4748</td>
    <td class="codeline">    /// modified as the asm is processed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="codeline">    Value *CallOperandVal = nullptr;</td>
    <td class="lineNumber">4749</td>
    <td class="codeline">    Value *CallOperandVal = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class="codeline"></td>
    <td class="lineNumber">4750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="codeline">    /// The ValueType for the operand value.</td>
    <td class="lineNumber">4751</td>
    <td class="codeline">    /// The ValueType for the operand value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="codeline">    MVT ConstraintVT = MVT::Other;</td>
    <td class="lineNumber">4752</td>
    <td class="codeline">    MVT ConstraintVT = MVT::Other;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="codeline"></td>
    <td class="lineNumber">4753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="codeline">    /// Copy constructor for copying from a ConstraintInfo.</td>
    <td class="lineNumber">4754</td>
    <td class="codeline">    /// Copy constructor for copying from a ConstraintInfo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="codeline">    AsmOperandInfo(InlineAsm::ConstraintInfo Info)</td>
    <td class="lineNumber">4755</td>
    <td class="codeline">    AsmOperandInfo(InlineAsm::ConstraintInfo Info)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="codeline">        : InlineAsm::ConstraintInfo(std::move(Info)) {}</td>
    <td class="lineNumber">4756</td>
    <td class="codeline">        : InlineAsm::ConstraintInfo(std::move(Info)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="codeline"></td>
    <td class="lineNumber">4757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="codeline">    /// Return true of this is an input operand that is a matching constraint</td>
    <td class="lineNumber">4758</td>
    <td class="codeline">    /// Return true of this is an input operand that is a matching constraint</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="codeline">    /// like "4".</td>
    <td class="lineNumber">4759</td>
    <td class="codeline">    /// like "4".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="codeline">    bool isMatchingInputConstraint() const;</td>
    <td class="lineNumber">4760</td>
    <td class="codeline">    bool isMatchingInputConstraint() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="codeline"></td>
    <td class="lineNumber">4761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="codeline">    /// If this is an input matching constraint, this method returns the output</td>
    <td class="lineNumber">4762</td>
    <td class="codeline">    /// If this is an input matching constraint, this method returns the output</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="codeline">    /// operand it matches.</td>
    <td class="lineNumber">4763</td>
    <td class="codeline">    /// operand it matches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="codeline">    unsigned getMatchedOperand() const;</td>
    <td class="lineNumber">4764</td>
    <td class="codeline">    unsigned getMatchedOperand() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4765</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="codeline"></td>
    <td class="lineNumber">4766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="codeline">  using AsmOperandInfoVector = std::vector<AsmOperandInfo>;</td>
    <td class="lineNumber">4767</td>
    <td class="codeline">  using AsmOperandInfoVector = std::vector<AsmOperandInfo>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="codeline"></td>
    <td class="lineNumber">4768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="codeline">  /// Split up the constraint string from the inline assembly value into the</td>
    <td class="lineNumber">4769</td>
    <td class="codeline">  /// Split up the constraint string from the inline assembly value into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="codeline">  /// specific constraints and their prefixes, and also tie in the associated</td>
    <td class="lineNumber">4770</td>
    <td class="codeline">  /// specific constraints and their prefixes, and also tie in the associated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="codeline">  /// operand values.  If this returns an empty vector, and if the constraint</td>
    <td class="lineNumber">4771</td>
    <td class="codeline">  /// operand values.  If this returns an empty vector, and if the constraint</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="codeline">  /// string itself isn't empty, there was an error parsing.</td>
    <td class="lineNumber">4772</td>
    <td class="codeline">  /// string itself isn't empty, there was an error parsing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="codeline">  virtual AsmOperandInfoVector ParseConstraints(const DataLayout &DL,</td>
    <td class="lineNumber">4773</td>
    <td class="codeline">  virtual AsmOperandInfoVector ParseConstraints(const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="codeline">                                                const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">4774</td>
    <td class="codeline">                                                const TargetRegisterInfo *TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="codeline">                                                const CallBase &Call) const;</td>
    <td class="lineNumber">4775</td>
    <td class="codeline">                                                const CallBase &Call) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="codeline"></td>
    <td class="lineNumber">4776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="codeline">  /// Examine constraint type and operand type and determine a weight value.</td>
    <td class="lineNumber">4777</td>
    <td class="codeline">  /// Examine constraint type and operand type and determine a weight value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="codeline">  /// The operand object must already have been set up with the operand type.</td>
    <td class="lineNumber">4778</td>
    <td class="codeline">  /// The operand object must already have been set up with the operand type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="codeline">  virtual ConstraintWeight getMultipleConstraintMatchWeight(</td>
    <td class="lineNumber">4779</td>
    <td class="codeline">  virtual ConstraintWeight getMultipleConstraintMatchWeight(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="codeline">      AsmOperandInfo &info, int maIndex) const;</td>
    <td class="lineNumber">4780</td>
    <td class="codeline">      AsmOperandInfo &info, int maIndex) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="codeline"></td>
    <td class="lineNumber">4781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="codeline">  /// Examine constraint string and operand type and determine a weight value.</td>
    <td class="lineNumber">4782</td>
    <td class="codeline">  /// Examine constraint string and operand type and determine a weight value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="codeline">  /// The operand object must already have been set up with the operand type.</td>
    <td class="lineNumber">4783</td>
    <td class="codeline">  /// The operand object must already have been set up with the operand type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="codeline">  virtual ConstraintWeight getSingleConstraintMatchWeight(</td>
    <td class="lineNumber">4784</td>
    <td class="codeline">  virtual ConstraintWeight getSingleConstraintMatchWeight(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="codeline">      AsmOperandInfo &info, const char *constraint) const;</td>
    <td class="lineNumber">4785</td>
    <td class="codeline">      AsmOperandInfo &info, const char *constraint) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="codeline"></td>
    <td class="lineNumber">4786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="codeline">  /// Determines the constraint code and constraint type to use for the specific</td>
    <td class="lineNumber">4787</td>
    <td class="codeline">  /// Determines the constraint code and constraint type to use for the specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="codeline">  /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.</td>
    <td class="lineNumber">4788</td>
    <td class="codeline">  /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="codeline">  /// If the actual operand being passed in is available, it can be passed in as</td>
    <td class="lineNumber">4789</td>
    <td class="codeline">  /// If the actual operand being passed in is available, it can be passed in as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="codeline">  /// Op, otherwise an empty SDValue can be passed.</td>
    <td class="lineNumber">4790</td>
    <td class="codeline">  /// Op, otherwise an empty SDValue can be passed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="codeline">  virtual void ComputeConstraintToUse(AsmOperandInfo &OpInfo,</td>
    <td class="lineNumber">4791</td>
    <td class="codeline">  virtual void ComputeConstraintToUse(AsmOperandInfo &OpInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="codeline">                                      SDValue Op,</td>
    <td class="lineNumber">4792</td>
    <td class="codeline">                                      SDValue Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="codeline">                                      SelectionDAG *DAG = nullptr) const;</td>
    <td class="lineNumber">4793</td>
    <td class="codeline">                                      SelectionDAG *DAG = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="codeline"></td>
    <td class="lineNumber">4794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="codeline">  /// Given a constraint, return the type of constraint it is for this target.</td>
    <td class="lineNumber">4795</td>
    <td class="codeline">  /// Given a constraint, return the type of constraint it is for this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="codeline">  virtual ConstraintType getConstraintType(StringRef Constraint) const;</td>
    <td class="lineNumber">4796</td>
    <td class="codeline">  virtual ConstraintType getConstraintType(StringRef Constraint) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="codeline"></td>
    <td class="lineNumber">4797</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="codeline">  /// Given a physical register constraint (e.g.  {edx}), return the register</td>
    <td class="lineNumber">4798</td>
    <td class="codeline">  /// Given a physical register constraint (e.g.  {edx}), return the register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="codeline">  /// number and the register class for the register.</td>
    <td class="lineNumber">4799</td>
    <td class="codeline">  /// number and the register class for the register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4800</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="codeline">  /// Given a register class constraint, like 'r', if this corresponds directly</td>
    <td class="lineNumber">4801</td>
    <td class="codeline">  /// Given a register class constraint, like 'r', if this corresponds directly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="codeline">  /// to an LLVM register class, return a register of 0 and the register class</td>
    <td class="lineNumber">4802</td>
    <td class="codeline">  /// to an LLVM register class, return a register of 0 and the register class</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="codeline">  /// pointer.</td>
    <td class="lineNumber">4803</td>
    <td class="codeline">  /// pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">4804</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="codeline">  /// This should only be used for C_Register constraints.  On error, this</td>
    <td class="lineNumber">4805</td>
    <td class="codeline">  /// This should only be used for C_Register constraints.  On error, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="codeline">  /// returns a register number of 0 and a null register class pointer.</td>
    <td class="lineNumber">4806</td>
    <td class="codeline">  /// returns a register number of 0 and a null register class pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="codeline">  virtual std::pair<unsigned, const TargetRegisterClass *></td>
    <td class="lineNumber">4807</td>
    <td class="codeline">  virtual std::pair<unsigned, const TargetRegisterClass *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class="codeline">  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">4808</td>
    <td class="codeline">  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="codeline">                               StringRef Constraint, MVT VT) const;</td>
    <td class="lineNumber">4809</td>
    <td class="codeline">                               StringRef Constraint, MVT VT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="codeline"></td>
    <td class="lineNumber">4810</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="codeline">  virtual unsigned getInlineAsmMemConstraint(StringRef ConstraintCode) const {</td>
    <td class="lineNumber">4811</td>
    <td class="codeline">  virtual unsigned getInlineAsmMemConstraint(StringRef ConstraintCode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="codeline">    if (ConstraintCode == "m")</td>
    <td class="lineNumber">4812</td>
    <td class="codeline">    if (ConstraintCode == "m")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="codeline">      return InlineAsm::Constraint_m;</td>
    <td class="lineNumber">4813</td>
    <td class="codeline">      return InlineAsm::Constraint_m;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="codeline">    if (ConstraintCode == "o")</td>
    <td class="lineNumber">4814</td>
    <td class="codeline">    if (ConstraintCode == "o")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="codeline">      return InlineAsm::Constraint_o;</td>
    <td class="lineNumber">4815</td>
    <td class="codeline">      return InlineAsm::Constraint_o;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="codeline">    if (ConstraintCode == "X")</td>
    <td class="lineNumber">4816</td>
    <td class="codeline">    if (ConstraintCode == "X")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="codeline">      return InlineAsm::Constraint_X;</td>
    <td class="lineNumber">4817</td>
    <td class="codeline">      return InlineAsm::Constraint_X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="codeline">    if (ConstraintCode == "p")</td>
    <td class="lineNumber">4818</td>
    <td class="codeline">    if (ConstraintCode == "p")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="codeline">      return InlineAsm::Constraint_p;</td>
    <td class="lineNumber">4819</td>
    <td class="codeline">      return InlineAsm::Constraint_p;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="codeline">    return InlineAsm::Constraint_Unknown;</td>
    <td class="lineNumber">4820</td>
    <td class="codeline">    return InlineAsm::Constraint_Unknown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4821</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="codeline"></td>
    <td class="lineNumber">4822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="codeline">  /// Try to replace an X constraint, which matches anything, with another that</td>
    <td class="lineNumber">4823</td>
    <td class="codeline">  /// Try to replace an X constraint, which matches anything, with another that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="codeline">  /// has more specific requirements based on the type of the corresponding</td>
    <td class="lineNumber">4824</td>
    <td class="codeline">  /// has more specific requirements based on the type of the corresponding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="codeline">  /// operand.  This returns null if there is no replacement to make.</td>
    <td class="lineNumber">4825</td>
    <td class="codeline">  /// operand.  This returns null if there is no replacement to make.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="codeline">  virtual const char *LowerXConstraint(EVT ConstraintVT) const;</td>
    <td class="lineNumber">4826</td>
    <td class="codeline">  virtual const char *LowerXConstraint(EVT ConstraintVT) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="codeline"></td>
    <td class="lineNumber">4827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="codeline">  /// Lower the specified operand into the Ops vector.  If it is invalid, don't</td>
    <td class="lineNumber">4828</td>
    <td class="codeline">  /// Lower the specified operand into the Ops vector.  If it is invalid, don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="codeline">  /// add anything to Ops.</td>
    <td class="lineNumber">4829</td>
    <td class="codeline">  /// add anything to Ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="codeline">  virtual void LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint,</td>
    <td class="lineNumber">4830</td>
    <td class="codeline">  virtual void LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="codeline">                                            std::vector<SDValue> &Ops,</td>
    <td class="lineNumber">4831</td>
    <td class="codeline">                                            std::vector<SDValue> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="codeline">                                            SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4832</td>
    <td class="codeline">                                            SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="codeline"></td>
    <td class="lineNumber">4833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="codeline">  // Lower custom output constraints. If invalid, return SDValue().</td>
    <td class="lineNumber">4834</td>
    <td class="codeline">  // Lower custom output constraints. If invalid, return SDValue().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="codeline">  virtual SDValue LowerAsmOutputForConstraint(SDValue &Chain, SDValue &Glue,</td>
    <td class="lineNumber">4835</td>
    <td class="codeline">  virtual SDValue LowerAsmOutputForConstraint(SDValue &Chain, SDValue &Glue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="codeline">                                              const SDLoc &DL,</td>
    <td class="lineNumber">4836</td>
    <td class="codeline">                                              const SDLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="codeline">                                              const AsmOperandInfo &OpInfo,</td>
    <td class="lineNumber">4837</td>
    <td class="codeline">                                              const AsmOperandInfo &OpInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="codeline">                                              SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4838</td>
    <td class="codeline">                                              SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class="codeline"></td>
    <td class="lineNumber">4839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="codeline">  // Targets may override this function to collect operands from the CallInst</td>
    <td class="lineNumber">4840</td>
    <td class="codeline">  // Targets may override this function to collect operands from the CallInst</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="codeline">  // and for example, lower them into the SelectionDAG operands.</td>
    <td class="lineNumber">4841</td>
    <td class="codeline">  // and for example, lower them into the SelectionDAG operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="codeline">  virtual void CollectTargetIntrinsicOperands(const CallInst &I,</td>
    <td class="lineNumber">4842</td>
    <td class="codeline">  virtual void CollectTargetIntrinsicOperands(const CallInst &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="codeline">                                              SmallVectorImpl<SDValue> &Ops,</td>
    <td class="lineNumber">4843</td>
    <td class="codeline">                                              SmallVectorImpl<SDValue> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="codeline">                                              SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4844</td>
    <td class="codeline">                                              SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="codeline"></td>
    <td class="lineNumber">4845</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">4846</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class="codeline">  // Div utility functions</td>
    <td class="lineNumber">4847</td>
    <td class="codeline">  // Div utility functions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">4848</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="codeline"></td>
    <td class="lineNumber">4849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="codeline">  SDValue BuildSDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td class="lineNumber">4850</td>
    <td class="codeline">  SDValue BuildSDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="codeline">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">4851</td>
    <td class="codeline">                    SmallVectorImpl<SDNode *> &Created) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="codeline">  SDValue BuildUDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td class="lineNumber">4852</td>
    <td class="codeline">  SDValue BuildUDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="codeline">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">4853</td>
    <td class="codeline">                    SmallVectorImpl<SDNode *> &Created) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="codeline"></td>
    <td class="lineNumber">4854</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="codeline">  /// Targets may override this function to provide custom SDIV lowering for</td>
    <td class="lineNumber">4855</td>
    <td class="codeline">  /// Targets may override this function to provide custom SDIV lowering for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="codeline">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td class="lineNumber">4856</td>
    <td class="codeline">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="codeline">  /// assumes SDIV is expensive and replaces it with a series of other integer</td>
    <td class="lineNumber">4857</td>
    <td class="codeline">  /// assumes SDIV is expensive and replaces it with a series of other integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="codeline">  /// operations.</td>
    <td class="lineNumber">4858</td>
    <td class="codeline">  /// operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="codeline">  virtual SDValue BuildSDIVPow2(SDNode *N, const APInt &Divisor,</td>
    <td class="lineNumber">4859</td>
    <td class="codeline">  virtual SDValue BuildSDIVPow2(SDNode *N, const APInt &Divisor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="codeline">                                SelectionDAG &DAG,</td>
    <td class="lineNumber">4860</td>
    <td class="codeline">                                SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="codeline">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">4861</td>
    <td class="codeline">                                SmallVectorImpl<SDNode *> &Created) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="codeline"></td>
    <td class="lineNumber">4862</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="codeline">  /// Targets may override this function to provide custom SREM lowering for</td>
    <td class="lineNumber">4863</td>
    <td class="codeline">  /// Targets may override this function to provide custom SREM lowering for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="codeline">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td class="lineNumber">4864</td>
    <td class="codeline">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="codeline">  /// assumes SREM is expensive and replaces it with a series of other integer</td>
    <td class="lineNumber">4865</td>
    <td class="codeline">  /// assumes SREM is expensive and replaces it with a series of other integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="codeline">  /// operations.</td>
    <td class="lineNumber">4866</td>
    <td class="codeline">  /// operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="codeline">  virtual SDValue BuildSREMPow2(SDNode *N, const APInt &Divisor,</td>
    <td class="lineNumber">4867</td>
    <td class="codeline">  virtual SDValue BuildSREMPow2(SDNode *N, const APInt &Divisor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="codeline">                                SelectionDAG &DAG,</td>
    <td class="lineNumber">4868</td>
    <td class="codeline">                                SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="codeline">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">4869</td>
    <td class="codeline">                                SmallVectorImpl<SDNode *> &Created) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="codeline"></td>
    <td class="lineNumber">4870</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="codeline">  /// Indicate whether this target prefers to combine FDIVs with the same</td>
    <td class="lineNumber">4871</td>
    <td class="codeline">  /// Indicate whether this target prefers to combine FDIVs with the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="codeline">  /// divisor. If the transform should never be done, return zero. If the</td>
    <td class="lineNumber">4872</td>
    <td class="codeline">  /// divisor. If the transform should never be done, return zero. If the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="codeline">  /// transform should be done, return the minimum number of divisor uses</td>
    <td class="lineNumber">4873</td>
    <td class="codeline">  /// transform should be done, return the minimum number of divisor uses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="codeline">  /// that must exist.</td>
    <td class="lineNumber">4874</td>
    <td class="codeline">  /// that must exist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="codeline">  virtual unsigned combineRepeatedFPDivisors() const {</td>
    <td class="lineNumber">4875</td>
    <td class="codeline">  virtual unsigned combineRepeatedFPDivisors() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">4876</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4877</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="codeline"></td>
    <td class="lineNumber">4878</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="codeline">  /// Hooks for building estimates in place of slower divisions and square</td>
    <td class="lineNumber">4879</td>
    <td class="codeline">  /// Hooks for building estimates in place of slower divisions and square</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="codeline">  /// roots.</td>
    <td class="lineNumber">4880</td>
    <td class="codeline">  /// roots.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="codeline"></td>
    <td class="lineNumber">4881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="codeline">  /// Return either a square root or its reciprocal estimate value for the input</td>
    <td class="lineNumber">4882</td>
    <td class="codeline">  /// Return either a square root or its reciprocal estimate value for the input</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="codeline">  /// operand.</td>
    <td class="lineNumber">4883</td>
    <td class="codeline">  /// operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="codeline">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td class="lineNumber">4884</td>
    <td class="codeline">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="codeline">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td class="lineNumber">4885</td>
    <td class="codeline">  /// 'Enabled' as set by a potential default override attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="codeline">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td class="lineNumber">4886</td>
    <td class="codeline">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="codeline">  /// refinement iterations required to generate a sufficient (though not</td>
    <td class="lineNumber">4887</td>
    <td class="codeline">  /// refinement iterations required to generate a sufficient (though not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="codeline">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td class="lineNumber">4888</td>
    <td class="codeline">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="codeline">  /// The boolean UseOneConstNR output is used to select a Newton-Raphson</td>
    <td class="lineNumber">4889</td>
    <td class="codeline">  /// The boolean UseOneConstNR output is used to select a Newton-Raphson</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="codeline">  /// algorithm implementation that uses either one or two constants.</td>
    <td class="lineNumber">4890</td>
    <td class="codeline">  /// algorithm implementation that uses either one or two constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="codeline">  /// The boolean Reciprocal is used to select whether the estimate is for the</td>
    <td class="lineNumber">4891</td>
    <td class="codeline">  /// The boolean Reciprocal is used to select whether the estimate is for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="codeline">  /// square root of the input operand or the reciprocal of its square root.</td>
    <td class="lineNumber">4892</td>
    <td class="codeline">  /// square root of the input operand or the reciprocal of its square root.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="codeline">  /// A target may choose to implement its own refinement within this function.</td>
    <td class="lineNumber">4893</td>
    <td class="codeline">  /// A target may choose to implement its own refinement within this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="codeline">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td class="lineNumber">4894</td>
    <td class="codeline">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="codeline">  /// any further refinement of the estimate.</td>
    <td class="lineNumber">4895</td>
    <td class="codeline">  /// any further refinement of the estimate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="codeline">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td class="lineNumber">4896</td>
    <td class="codeline">  /// An empty SDValue return means no estimate sequence can be created.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="codeline">  virtual SDValue getSqrtEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">4897</td>
    <td class="codeline">  virtual SDValue getSqrtEstimate(SDValue Operand, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="codeline">                                  int Enabled, int &RefinementSteps,</td>
    <td class="lineNumber">4898</td>
    <td class="codeline">                                  int Enabled, int &RefinementSteps,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="codeline">                                  bool &UseOneConstNR, bool Reciprocal) const {</td>
    <td class="lineNumber">4899</td>
    <td class="codeline">                                  bool &UseOneConstNR, bool Reciprocal) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="codeline">    return SDValue();</td>
    <td class="lineNumber">4900</td>
    <td class="codeline">    return SDValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4901</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="codeline"></td>
    <td class="lineNumber">4902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="codeline">  /// Try to convert the fminnum/fmaxnum to a compare/select sequence. This is</td>
    <td class="lineNumber">4903</td>
    <td class="codeline">  /// Try to convert the fminnum/fmaxnum to a compare/select sequence. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="codeline">  /// required for correctness since InstCombine might have canonicalized a</td>
    <td class="lineNumber">4904</td>
    <td class="codeline">  /// required for correctness since InstCombine might have canonicalized a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="codeline">  /// fcmp+select sequence to a FMINNUM/FMAXNUM intrinsic.  If we were to fall</td>
    <td class="lineNumber">4905</td>
    <td class="codeline">  /// fcmp+select sequence to a FMINNUM/FMAXNUM intrinsic.  If we were to fall</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="codeline">  /// through to the default expansion/soften to libcall, we might introduce a</td>
    <td class="lineNumber">4906</td>
    <td class="codeline">  /// through to the default expansion/soften to libcall, we might introduce a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="codeline">  /// link-time dependency on libm into a file that originally did not have one.</td>
    <td class="lineNumber">4907</td>
    <td class="codeline">  /// link-time dependency on libm into a file that originally did not have one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="codeline">  SDValue createSelectForFMINNUM_FMAXNUM(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4908</td>
    <td class="codeline">  SDValue createSelectForFMINNUM_FMAXNUM(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="codeline"></td>
    <td class="lineNumber">4909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="codeline">  /// Return a reciprocal estimate value for the input operand.</td>
    <td class="lineNumber">4910</td>
    <td class="codeline">  /// Return a reciprocal estimate value for the input operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="codeline">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td class="lineNumber">4911</td>
    <td class="codeline">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="codeline">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td class="lineNumber">4912</td>
    <td class="codeline">  /// 'Enabled' as set by a potential default override attribute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="codeline">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td class="lineNumber">4913</td>
    <td class="codeline">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="codeline">  /// refinement iterations required to generate a sufficient (though not</td>
    <td class="lineNumber">4914</td>
    <td class="codeline">  /// refinement iterations required to generate a sufficient (though not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="codeline">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td class="lineNumber">4915</td>
    <td class="codeline">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="codeline">  /// A target may choose to implement its own refinement within this function.</td>
    <td class="lineNumber">4916</td>
    <td class="codeline">  /// A target may choose to implement its own refinement within this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="codeline">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td class="lineNumber">4917</td>
    <td class="codeline">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="codeline">  /// any further refinement of the estimate.</td>
    <td class="lineNumber">4918</td>
    <td class="codeline">  /// any further refinement of the estimate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="codeline">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td class="lineNumber">4919</td>
    <td class="codeline">  /// An empty SDValue return means no estimate sequence can be created.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="codeline">  virtual SDValue getRecipEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">4920</td>
    <td class="codeline">  virtual SDValue getRecipEstimate(SDValue Operand, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="codeline">                                   int Enabled, int &RefinementSteps) const {</td>
    <td class="lineNumber">4921</td>
    <td class="codeline">                                   int Enabled, int &RefinementSteps) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="codeline">    return SDValue();</td>
    <td class="lineNumber">4922</td>
    <td class="codeline">    return SDValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4923</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class="codeline"></td>
    <td class="lineNumber">4924</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="codeline">  /// Return a target-dependent comparison result if the input operand is</td>
    <td class="lineNumber">4925</td>
    <td class="codeline">  /// Return a target-dependent comparison result if the input operand is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="codeline">  /// suitable for use with a square root estimate calculation. For example, the</td>
    <td class="lineNumber">4926</td>
    <td class="codeline">  /// suitable for use with a square root estimate calculation. For example, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="codeline">  /// comparison may check if the operand is NAN, INF, zero, normal, etc. The</td>
    <td class="lineNumber">4927</td>
    <td class="codeline">  /// comparison may check if the operand is NAN, INF, zero, normal, etc. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="codeline">  /// result should be used as the condition operand for a select or branch.</td>
    <td class="lineNumber">4928</td>
    <td class="codeline">  /// result should be used as the condition operand for a select or branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="codeline">  virtual SDValue getSqrtInputTest(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">4929</td>
    <td class="codeline">  virtual SDValue getSqrtInputTest(SDValue Operand, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="codeline">                                   const DenormalMode &Mode) const;</td>
    <td class="lineNumber">4930</td>
    <td class="codeline">                                   const DenormalMode &Mode) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="codeline"></td>
    <td class="lineNumber">4931</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="codeline">  /// Return a target-dependent result if the input operand is not suitable for</td>
    <td class="lineNumber">4932</td>
    <td class="codeline">  /// Return a target-dependent result if the input operand is not suitable for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="codeline">  /// use with a square root estimate calculation.</td>
    <td class="lineNumber">4933</td>
    <td class="codeline">  /// use with a square root estimate calculation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="codeline">  virtual SDValue getSqrtResultForDenormInput(SDValue Operand,</td>
    <td class="lineNumber">4934</td>
    <td class="codeline">  virtual SDValue getSqrtResultForDenormInput(SDValue Operand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="codeline">                                              SelectionDAG &DAG) const {</td>
    <td class="lineNumber">4935</td>
    <td class="codeline">                                              SelectionDAG &DAG) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="codeline">    return DAG.getConstantFP(0.0, SDLoc(Operand), Operand.getValueType());</td>
    <td class="lineNumber">4936</td>
    <td class="codeline">    return DAG.getConstantFP(0.0, SDLoc(Operand), Operand.getValueType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4937</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="codeline"></td>
    <td class="lineNumber">4938</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">4939</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="codeline">  // Legalization utility functions</td>
    <td class="lineNumber">4940</td>
    <td class="codeline">  // Legalization utility functions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">4941</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="codeline"></td>
    <td class="lineNumber">4942</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="codeline">  /// Expand a MUL or [US]MUL_LOHI of n-bit values into two or four nodes,</td>
    <td class="lineNumber">4943</td>
    <td class="codeline">  /// Expand a MUL or [US]MUL_LOHI of n-bit values into two or four nodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="codeline">  /// respectively, each computing an n/2-bit part of the result.</td>
    <td class="lineNumber">4944</td>
    <td class="codeline">  /// respectively, each computing an n/2-bit part of the result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="codeline">  /// \param Result A vector that will be filled with the parts of the result</td>
    <td class="lineNumber">4945</td>
    <td class="codeline">  /// \param Result A vector that will be filled with the parts of the result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="codeline">  ///        in little-endian order.</td>
    <td class="lineNumber">4946</td>
    <td class="codeline">  ///        in little-endian order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="codeline">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td class="lineNumber">4947</td>
    <td class="codeline">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="codeline">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td class="lineNumber">4948</td>
    <td class="codeline">  ///        if you want to control how low bits are extracted from the LHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="codeline">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">4949</td>
    <td class="codeline">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class="codeline">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td class="lineNumber">4950</td>
    <td class="codeline">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="codeline">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">4951</td>
    <td class="codeline">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="codeline">  /// \returns true if the node has been expanded, false if it has not</td>
    <td class="lineNumber">4952</td>
    <td class="codeline">  /// \returns true if the node has been expanded, false if it has not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="codeline">  bool expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl, SDValue LHS,</td>
    <td class="lineNumber">4953</td>
    <td class="codeline">  bool expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl, SDValue LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="codeline">                      SDValue RHS, SmallVectorImpl<SDValue> &Result, EVT HiLoVT,</td>
    <td class="lineNumber">4954</td>
    <td class="codeline">                      SDValue RHS, SmallVectorImpl<SDValue> &Result, EVT HiLoVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="codeline">                      SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td class="lineNumber">4955</td>
    <td class="codeline">                      SelectionDAG &DAG, MulExpansionKind Kind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class="codeline">                      SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td class="lineNumber">4956</td>
    <td class="codeline">                      SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="codeline">                      SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td class="lineNumber">4957</td>
    <td class="codeline">                      SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="codeline"></td>
    <td class="lineNumber">4958</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="codeline">  /// Expand a MUL into two nodes.  One that computes the high bits of</td>
    <td class="lineNumber">4959</td>
    <td class="codeline">  /// Expand a MUL into two nodes.  One that computes the high bits of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="codeline">  /// the result and one that computes the low bits.</td>
    <td class="lineNumber">4960</td>
    <td class="codeline">  /// the result and one that computes the low bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="codeline">  /// \param HiLoVT The value type to use for the Lo and Hi nodes.</td>
    <td class="lineNumber">4961</td>
    <td class="codeline">  /// \param HiLoVT The value type to use for the Lo and Hi nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="codeline">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td class="lineNumber">4962</td>
    <td class="codeline">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="codeline">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td class="lineNumber">4963</td>
    <td class="codeline">  ///        if you want to control how low bits are extracted from the LHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="codeline">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">4964</td>
    <td class="codeline">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class="codeline">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td class="lineNumber">4965</td>
    <td class="codeline">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="codeline">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">4966</td>
    <td class="codeline">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="codeline">  /// \returns true if the node has been expanded. false if it has not</td>
    <td class="lineNumber">4967</td>
    <td class="codeline">  /// \returns true if the node has been expanded. false if it has not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="codeline">  bool expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,</td>
    <td class="lineNumber">4968</td>
    <td class="codeline">  bool expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="codeline">                 SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td class="lineNumber">4969</td>
    <td class="codeline">                 SelectionDAG &DAG, MulExpansionKind Kind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="codeline">                 SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td class="lineNumber">4970</td>
    <td class="codeline">                 SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="codeline">                 SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td class="lineNumber">4971</td>
    <td class="codeline">                 SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="codeline"></td>
    <td class="lineNumber">4972</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="codeline">  /// Attempt to expand an n-bit div/rem/divrem by constant using a n/2-bit</td>
    <td class="lineNumber">4973</td>
    <td class="codeline">  /// Attempt to expand an n-bit div/rem/divrem by constant using a n/2-bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class="codeline">  /// urem by constant and other arithmetic ops. The n/2-bit urem by constant</td>
    <td class="lineNumber">4974</td>
    <td class="codeline">  /// urem by constant and other arithmetic ops. The n/2-bit urem by constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="codeline">  /// will be expanded by DAGCombiner. This is not possible for all constant</td>
    <td class="lineNumber">4975</td>
    <td class="codeline">  /// will be expanded by DAGCombiner. This is not possible for all constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="codeline">  /// divisors.</td>
    <td class="lineNumber">4976</td>
    <td class="codeline">  /// divisors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">4977</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="codeline">  /// \param Result A vector that will be filled with the lo and high parts of</td>
    <td class="lineNumber">4978</td>
    <td class="codeline">  /// \param Result A vector that will be filled with the lo and high parts of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="codeline">  ///        the results. For *DIVREM, this will be the quotient parts followed</td>
    <td class="lineNumber">4979</td>
    <td class="codeline">  ///        the results. For *DIVREM, this will be the quotient parts followed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="codeline">  ///        by the remainder parts.</td>
    <td class="lineNumber">4980</td>
    <td class="codeline">  ///        by the remainder parts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="codeline">  /// \param HiLoVT The value type to use for the Lo and Hi parts. Should be</td>
    <td class="lineNumber">4981</td>
    <td class="codeline">  /// \param HiLoVT The value type to use for the Lo and Hi parts. Should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="codeline">  ///        half of VT.</td>
    <td class="lineNumber">4982</td>
    <td class="codeline">  ///        half of VT.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="codeline">  /// \param LL Low bits of the LHS of the operation. You can use this</td>
    <td class="lineNumber">4983</td>
    <td class="codeline">  /// \param LL Low bits of the LHS of the operation. You can use this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="codeline">  ///        parameter if you want to control how low bits are extracted from</td>
    <td class="lineNumber">4984</td>
    <td class="codeline">  ///        parameter if you want to control how low bits are extracted from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="codeline">  ///        the LHS.</td>
    <td class="lineNumber">4985</td>
    <td class="codeline">  ///        the LHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="codeline">  /// \param LH High bits of the LHS of the operation. See LL for meaning.</td>
    <td class="lineNumber">4986</td>
    <td class="codeline">  /// \param LH High bits of the LHS of the operation. See LL for meaning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="codeline">  /// \returns true if the node has been expanded, false if it has not.</td>
    <td class="lineNumber">4987</td>
    <td class="codeline">  /// \returns true if the node has been expanded, false if it has not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="codeline">  bool expandDIVREMByConstant(SDNode *N, SmallVectorImpl<SDValue> &Result,</td>
    <td class="lineNumber">4988</td>
    <td class="codeline">  bool expandDIVREMByConstant(SDNode *N, SmallVectorImpl<SDValue> &Result,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="codeline">                              EVT HiLoVT, SelectionDAG &DAG,</td>
    <td class="lineNumber">4989</td>
    <td class="codeline">                              EVT HiLoVT, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="codeline">                              SDValue LL = SDValue(),</td>
    <td class="lineNumber">4990</td>
    <td class="codeline">                              SDValue LL = SDValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="codeline">                              SDValue LH = SDValue()) const;</td>
    <td class="lineNumber">4991</td>
    <td class="codeline">                              SDValue LH = SDValue()) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class="codeline"></td>
    <td class="lineNumber">4992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="codeline">  /// Expand funnel shift.</td>
    <td class="lineNumber">4993</td>
    <td class="codeline">  /// Expand funnel shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">4994</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="codeline">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td class="lineNumber">4995</td>
    <td class="codeline">  /// \returns The expansion if successful, SDValue() otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="codeline">  SDValue expandFunnelShift(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">4996</td>
    <td class="codeline">  SDValue expandFunnelShift(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="codeline"></td>
    <td class="lineNumber">4997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="codeline">  /// Expand rotations.</td>
    <td class="lineNumber">4998</td>
    <td class="codeline">  /// Expand rotations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">4999</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="codeline">  /// \param AllowVectorOps expand vector rotate, this should only be performed</td>
    <td class="lineNumber">5000</td>
    <td class="codeline">  /// \param AllowVectorOps expand vector rotate, this should only be performed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="codeline">  ///        if the legalization is happening outside of LegalizeVectorOps</td>
    <td class="lineNumber">5001</td>
    <td class="codeline">  ///        if the legalization is happening outside of LegalizeVectorOps</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="codeline">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td class="lineNumber">5002</td>
    <td class="codeline">  /// \returns The expansion if successful, SDValue() otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="codeline">  SDValue expandROT(SDNode *N, bool AllowVectorOps, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5003</td>
    <td class="codeline">  SDValue expandROT(SDNode *N, bool AllowVectorOps, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="codeline"></td>
    <td class="lineNumber">5004</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="codeline">  /// Expand shift-by-parts.</td>
    <td class="lineNumber">5005</td>
    <td class="codeline">  /// Expand shift-by-parts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5006</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="codeline">  /// \param Lo lower-output-part after conversion</td>
    <td class="lineNumber">5007</td>
    <td class="codeline">  /// \param Lo lower-output-part after conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="codeline">  /// \param Hi upper-output-part after conversion</td>
    <td class="lineNumber">5008</td>
    <td class="codeline">  /// \param Hi upper-output-part after conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="codeline">  void expandShiftParts(SDNode *N, SDValue &Lo, SDValue &Hi,</td>
    <td class="lineNumber">5009</td>
    <td class="codeline">  void expandShiftParts(SDNode *N, SDValue &Lo, SDValue &Hi,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="codeline">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5010</td>
    <td class="codeline">                        SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="codeline"></td>
    <td class="lineNumber">5011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="codeline">  /// Expand float(f32) to SINT(i64) conversion</td>
    <td class="lineNumber">5012</td>
    <td class="codeline">  /// Expand float(f32) to SINT(i64) conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5013</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="codeline">  /// \param Result output after conversion</td>
    <td class="lineNumber">5014</td>
    <td class="codeline">  /// \param Result output after conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="codeline">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">5015</td>
    <td class="codeline">  /// \returns True, if the expansion was successful, false otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="codeline">  bool expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5016</td>
    <td class="codeline">  bool expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="codeline"></td>
    <td class="lineNumber">5017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="codeline">  /// Expand float to UINT conversion</td>
    <td class="lineNumber">5018</td>
    <td class="codeline">  /// Expand float to UINT conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5019</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="codeline">  /// \param Result output after conversion</td>
    <td class="lineNumber">5020</td>
    <td class="codeline">  /// \param Result output after conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="codeline">  /// \param Chain output chain after conversion</td>
    <td class="lineNumber">5021</td>
    <td class="codeline">  /// \param Chain output chain after conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="codeline">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">5022</td>
    <td class="codeline">  /// \returns True, if the expansion was successful, false otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="codeline">  bool expandFP_TO_UINT(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td class="lineNumber">5023</td>
    <td class="codeline">  bool expandFP_TO_UINT(SDNode *N, SDValue &Result, SDValue &Chain,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="codeline">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5024</td>
    <td class="codeline">                        SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class="codeline"></td>
    <td class="lineNumber">5025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="codeline">  /// Expand UINT(i64) to double(f64) conversion</td>
    <td class="lineNumber">5026</td>
    <td class="codeline">  /// Expand UINT(i64) to double(f64) conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5027</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="codeline">  /// \param Result output after conversion</td>
    <td class="lineNumber">5028</td>
    <td class="codeline">  /// \param Result output after conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="codeline">  /// \param Chain output chain after conversion</td>
    <td class="lineNumber">5029</td>
    <td class="codeline">  /// \param Chain output chain after conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="codeline">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">5030</td>
    <td class="codeline">  /// \returns True, if the expansion was successful, false otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="codeline">  bool expandUINT_TO_FP(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td class="lineNumber">5031</td>
    <td class="codeline">  bool expandUINT_TO_FP(SDNode *N, SDValue &Result, SDValue &Chain,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="codeline">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5032</td>
    <td class="codeline">                        SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class="codeline"></td>
    <td class="lineNumber">5033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="codeline">  /// Expand fminnum/fmaxnum into fminnum_ieee/fmaxnum_ieee with quieted inputs.</td>
    <td class="lineNumber">5034</td>
    <td class="codeline">  /// Expand fminnum/fmaxnum into fminnum_ieee/fmaxnum_ieee with quieted inputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="codeline">  SDValue expandFMINNUM_FMAXNUM(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5035</td>
    <td class="codeline">  SDValue expandFMINNUM_FMAXNUM(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="codeline"></td>
    <td class="lineNumber">5036</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="codeline">  /// Expand FP_TO_[US]INT_SAT into FP_TO_[US]INT and selects or min/max.</td>
    <td class="lineNumber">5037</td>
    <td class="codeline">  /// Expand FP_TO_[US]INT_SAT into FP_TO_[US]INT and selects or min/max.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5038</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="codeline">  /// \returns The expansion result</td>
    <td class="lineNumber">5039</td>
    <td class="codeline">  /// \returns The expansion result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="codeline">  SDValue expandFP_TO_INT_SAT(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5040</td>
    <td class="codeline">  SDValue expandFP_TO_INT_SAT(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="codeline"></td>
    <td class="lineNumber">5041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="codeline">  /// Expand check for floating point class.</td>
    <td class="lineNumber">5042</td>
    <td class="codeline">  /// Expand check for floating point class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="codeline">  /// \param ResultVT The type of intrinsic call result.</td>
    <td class="lineNumber">5043</td>
    <td class="codeline">  /// \param ResultVT The type of intrinsic call result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="codeline">  /// \param Op The tested value.</td>
    <td class="lineNumber">5044</td>
    <td class="codeline">  /// \param Op The tested value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="codeline">  /// \param Test The test to perform.</td>
    <td class="lineNumber">5045</td>
    <td class="codeline">  /// \param Test The test to perform.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="codeline">  /// \param Flags The optimization flags.</td>
    <td class="lineNumber">5046</td>
    <td class="codeline">  /// \param Flags The optimization flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5047</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="codeline">  SDValue expandIS_FPCLASS(EVT ResultVT, SDValue Op, FPClassTest Test,</td>
    <td class="lineNumber">5048</td>
    <td class="codeline">  SDValue expandIS_FPCLASS(EVT ResultVT, SDValue Op, FPClassTest Test,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="codeline">                           SDNodeFlags Flags, const SDLoc &DL,</td>
    <td class="lineNumber">5049</td>
    <td class="codeline">                           SDNodeFlags Flags, const SDLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="codeline">                           SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5050</td>
    <td class="codeline">                           SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class="codeline"></td>
    <td class="lineNumber">5051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="codeline">  /// Expand CTPOP nodes. Expands vector/scalar CTPOP nodes,</td>
    <td class="lineNumber">5052</td>
    <td class="codeline">  /// Expand CTPOP nodes. Expands vector/scalar CTPOP nodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">5053</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5054</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5055</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="codeline">  SDValue expandCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5056</td>
    <td class="codeline">  SDValue expandCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="codeline"></td>
    <td class="lineNumber">5057</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="codeline">  /// Expand VP_CTPOP nodes.</td>
    <td class="lineNumber">5058</td>
    <td class="codeline">  /// Expand VP_CTPOP nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5059</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="codeline">  SDValue expandVPCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5060</td>
    <td class="codeline">  SDValue expandVPCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="codeline"></td>
    <td class="lineNumber">5061</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="codeline">  /// Expand CTLZ/CTLZ_ZERO_UNDEF nodes. Expands vector/scalar CTLZ nodes,</td>
    <td class="lineNumber">5062</td>
    <td class="codeline">  /// Expand CTLZ/CTLZ_ZERO_UNDEF nodes. Expands vector/scalar CTLZ nodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">5063</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5064</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5065</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="codeline">  SDValue expandCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5066</td>
    <td class="codeline">  SDValue expandCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="codeline"></td>
    <td class="lineNumber">5067</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="codeline">  /// Expand VP_CTLZ/VP_CTLZ_ZERO_UNDEF nodes.</td>
    <td class="lineNumber">5068</td>
    <td class="codeline">  /// Expand VP_CTLZ/VP_CTLZ_ZERO_UNDEF nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5069</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5070</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="codeline">  SDValue expandVPCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5071</td>
    <td class="codeline">  SDValue expandVPCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="codeline"></td>
    <td class="lineNumber">5072</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="codeline">  /// Expand CTTZ via Table Lookup.</td>
    <td class="lineNumber">5073</td>
    <td class="codeline">  /// Expand CTTZ via Table Lookup.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5074</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5075</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="codeline">  SDValue CTTZTableLookup(SDNode *N, SelectionDAG &DAG, const SDLoc &DL, EVT VT,</td>
    <td class="lineNumber">5076</td>
    <td class="codeline">  SDValue CTTZTableLookup(SDNode *N, SelectionDAG &DAG, const SDLoc &DL, EVT VT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="codeline">                          SDValue Op, unsigned NumBitsPerElt) const;</td>
    <td class="lineNumber">5077</td>
    <td class="codeline">                          SDValue Op, unsigned NumBitsPerElt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class="codeline"></td>
    <td class="lineNumber">5078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="codeline">  /// Expand CTTZ/CTTZ_ZERO_UNDEF nodes. Expands vector/scalar CTTZ nodes,</td>
    <td class="lineNumber">5079</td>
    <td class="codeline">  /// Expand CTTZ/CTTZ_ZERO_UNDEF nodes. Expands vector/scalar CTTZ nodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">5080</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5081</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5082</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="codeline">  SDValue expandCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5083</td>
    <td class="codeline">  SDValue expandCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="codeline"></td>
    <td class="lineNumber">5084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="codeline">  /// Expand VP_CTTZ/VP_CTTZ_ZERO_UNDEF nodes.</td>
    <td class="lineNumber">5085</td>
    <td class="codeline">  /// Expand VP_CTTZ/VP_CTTZ_ZERO_UNDEF nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5086</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5087</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="codeline">  SDValue expandVPCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5088</td>
    <td class="codeline">  SDValue expandVPCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class="codeline"></td>
    <td class="lineNumber">5089</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="codeline">  /// Expand ABS nodes. Expands vector/scalar ABS nodes,</td>
    <td class="lineNumber">5090</td>
    <td class="codeline">  /// Expand ABS nodes. Expands vector/scalar ABS nodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">5091</td>
    <td class="codeline">  /// vector nodes can only succeed if all operations are legal/custom.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="codeline">  /// (ABS x) -> (XOR (ADD x, (SRA x, type_size)), (SRA x, type_size))</td>
    <td class="lineNumber">5092</td>
    <td class="codeline">  /// (ABS x) -> (XOR (ADD x, (SRA x, type_size)), (SRA x, type_size))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5093</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="codeline">  /// \param IsNegative indicate negated abs</td>
    <td class="lineNumber">5094</td>
    <td class="codeline">  /// \param IsNegative indicate negated abs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5095</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="codeline">  SDValue expandABS(SDNode *N, SelectionDAG &DAG,</td>
    <td class="lineNumber">5096</td>
    <td class="codeline">  SDValue expandABS(SDNode *N, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="codeline">                    bool IsNegative = false) const;</td>
    <td class="lineNumber">5097</td>
    <td class="codeline">                    bool IsNegative = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="codeline"></td>
    <td class="lineNumber">5098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="codeline">  /// Expand ABDS/ABDU nodes. Expands vector/scalar ABDS/ABDU nodes.</td>
    <td class="lineNumber">5099</td>
    <td class="codeline">  /// Expand ABDS/ABDU nodes. Expands vector/scalar ABDS/ABDU nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5100</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5101</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="codeline">  SDValue expandABD(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5102</td>
    <td class="codeline">  SDValue expandABD(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="codeline"></td>
    <td class="lineNumber">5103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="codeline">  /// Expand BSWAP nodes. Expands scalar/vector BSWAP nodes with i16/i32/i64</td>
    <td class="lineNumber">5104</td>
    <td class="codeline">  /// Expand BSWAP nodes. Expands scalar/vector BSWAP nodes with i16/i32/i64</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="codeline">  /// scalar types. Returns SDValue() if expand fails.</td>
    <td class="lineNumber">5105</td>
    <td class="codeline">  /// scalar types. Returns SDValue() if expand fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5106</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5107</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class="codeline">  SDValue expandBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5108</td>
    <td class="codeline">  SDValue expandBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="codeline"></td>
    <td class="lineNumber">5109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="codeline">  /// Expand VP_BSWAP nodes. Expands VP_BSWAP nodes with</td>
    <td class="lineNumber">5110</td>
    <td class="codeline">  /// Expand VP_BSWAP nodes. Expands VP_BSWAP nodes with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="codeline">  /// i16/i32/i64 scalar types. Returns SDValue() if expand fails. \param N Node</td>
    <td class="lineNumber">5111</td>
    <td class="codeline">  /// i16/i32/i64 scalar types. Returns SDValue() if expand fails. \param N Node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="codeline">  /// to expand \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5112</td>
    <td class="codeline">  /// to expand \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="codeline">  SDValue expandVPBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5113</td>
    <td class="codeline">  SDValue expandVPBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class="codeline"></td>
    <td class="lineNumber">5114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="codeline">  /// Expand BITREVERSE nodes. Expands scalar/vector BITREVERSE nodes.</td>
    <td class="lineNumber">5115</td>
    <td class="codeline">  /// Expand BITREVERSE nodes. Expands scalar/vector BITREVERSE nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="codeline">  /// Returns SDValue() if expand fails.</td>
    <td class="lineNumber">5116</td>
    <td class="codeline">  /// Returns SDValue() if expand fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="codeline">  /// \param N Node to expand</td>
    <td class="lineNumber">5117</td>
    <td class="codeline">  /// \param N Node to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5118</td>
    <td class="codeline">  /// \returns The expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="codeline">  SDValue expandBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5119</td>
    <td class="codeline">  SDValue expandBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="codeline"></td>
    <td class="lineNumber">5120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="codeline">  /// Expand VP_BITREVERSE nodes. Expands VP_BITREVERSE nodes with</td>
    <td class="lineNumber">5121</td>
    <td class="codeline">  /// Expand VP_BITREVERSE nodes. Expands VP_BITREVERSE nodes with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="codeline">  /// i8/i16/i32/i64 scalar types. \param N Node to expand \returns The</td>
    <td class="lineNumber">5122</td>
    <td class="codeline">  /// i8/i16/i32/i64 scalar types. \param N Node to expand \returns The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="codeline">  /// expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">5123</td>
    <td class="codeline">  /// expansion result or SDValue() if it fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="codeline">  SDValue expandVPBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5124</td>
    <td class="codeline">  SDValue expandVPBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="codeline"></td>
    <td class="lineNumber">5125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="codeline">  /// Turn load of vector type into a load of the individual elements.</td>
    <td class="lineNumber">5126</td>
    <td class="codeline">  /// Turn load of vector type into a load of the individual elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="codeline">  /// \param LD load to expand</td>
    <td class="lineNumber">5127</td>
    <td class="codeline">  /// \param LD load to expand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="codeline">  /// \returns BUILD_VECTOR and TokenFactor nodes.</td>
    <td class="lineNumber">5128</td>
    <td class="codeline">  /// \returns BUILD_VECTOR and TokenFactor nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="codeline">  std::pair<SDValue, SDValue> scalarizeVectorLoad(LoadSDNode *LD,</td>
    <td class="lineNumber">5129</td>
    <td class="codeline">  std::pair<SDValue, SDValue> scalarizeVectorLoad(LoadSDNode *LD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="codeline">                                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5130</td>
    <td class="codeline">                                                  SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="codeline"></td>
    <td class="lineNumber">5131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="codeline">  // Turn a store of a vector type into stores of the individual elements.</td>
    <td class="lineNumber">5132</td>
    <td class="codeline">  // Turn a store of a vector type into stores of the individual elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="codeline">  /// \param ST Store with a vector value type</td>
    <td class="lineNumber">5133</td>
    <td class="codeline">  /// \param ST Store with a vector value type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="codeline">  /// \returns TokenFactor of the individual store chains.</td>
    <td class="lineNumber">5134</td>
    <td class="codeline">  /// \returns TokenFactor of the individual store chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="codeline">  SDValue scalarizeVectorStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5135</td>
    <td class="codeline">  SDValue scalarizeVectorStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class="codeline"></td>
    <td class="lineNumber">5136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="codeline">  /// Expands an unaligned load to 2 half-size loads for an integer, and</td>
    <td class="lineNumber">5137</td>
    <td class="codeline">  /// Expands an unaligned load to 2 half-size loads for an integer, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="codeline">  /// possibly more for vectors.</td>
    <td class="lineNumber">5138</td>
    <td class="codeline">  /// possibly more for vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="codeline">  std::pair<SDValue, SDValue> expandUnalignedLoad(LoadSDNode *LD,</td>
    <td class="lineNumber">5139</td>
    <td class="codeline">  std::pair<SDValue, SDValue> expandUnalignedLoad(LoadSDNode *LD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="codeline">                                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5140</td>
    <td class="codeline">                                                  SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="codeline"></td>
    <td class="lineNumber">5141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="codeline">  /// Expands an unaligned store to 2 half-size stores for integer values, and</td>
    <td class="lineNumber">5142</td>
    <td class="codeline">  /// Expands an unaligned store to 2 half-size stores for integer values, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="codeline">  /// possibly more for vectors.</td>
    <td class="lineNumber">5143</td>
    <td class="codeline">  /// possibly more for vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="codeline">  SDValue expandUnalignedStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5144</td>
    <td class="codeline">  SDValue expandUnalignedStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class="codeline"></td>
    <td class="lineNumber">5145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="codeline">  /// Increments memory address \p Addr according to the type of the value</td>
    <td class="lineNumber">5146</td>
    <td class="codeline">  /// Increments memory address \p Addr according to the type of the value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="codeline">  /// \p DataVT that should be stored. If the data is stored in compressed</td>
    <td class="lineNumber">5147</td>
    <td class="codeline">  /// \p DataVT that should be stored. If the data is stored in compressed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="codeline">  /// form, the memory address should be incremented according to the number of</td>
    <td class="lineNumber">5148</td>
    <td class="codeline">  /// form, the memory address should be incremented according to the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="codeline">  /// the stored elements. This number is equal to the number of '1's bits</td>
    <td class="lineNumber">5149</td>
    <td class="codeline">  /// the stored elements. This number is equal to the number of '1's bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="codeline">  /// in the \p Mask.</td>
    <td class="lineNumber">5150</td>
    <td class="codeline">  /// in the \p Mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="codeline">  /// \p DataVT is a vector type. \p Mask is a vector value.</td>
    <td class="lineNumber">5151</td>
    <td class="codeline">  /// \p DataVT is a vector type. \p Mask is a vector value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="codeline">  /// \p DataVT and \p Mask have the same number of vector elements.</td>
    <td class="lineNumber">5152</td>
    <td class="codeline">  /// \p DataVT and \p Mask have the same number of vector elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="codeline">  SDValue IncrementMemoryAddress(SDValue Addr, SDValue Mask, const SDLoc &DL,</td>
    <td class="lineNumber">5153</td>
    <td class="codeline">  SDValue IncrementMemoryAddress(SDValue Addr, SDValue Mask, const SDLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="codeline">                                 EVT DataVT, SelectionDAG &DAG,</td>
    <td class="lineNumber">5154</td>
    <td class="codeline">                                 EVT DataVT, SelectionDAG &DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="codeline">                                 bool IsCompressedMemory) const;</td>
    <td class="lineNumber">5155</td>
    <td class="codeline">                                 bool IsCompressedMemory) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class="codeline"></td>
    <td class="lineNumber">5156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="codeline">  /// Get a pointer to vector element \p Idx located in memory for a vector of</td>
    <td class="lineNumber">5157</td>
    <td class="codeline">  /// Get a pointer to vector element \p Idx located in memory for a vector of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="codeline">  /// type \p VecVT starting at a base address of \p VecPtr. If \p Idx is out of</td>
    <td class="lineNumber">5158</td>
    <td class="codeline">  /// type \p VecVT starting at a base address of \p VecPtr. If \p Idx is out of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="codeline">  /// bounds the returned pointer is unspecified, but will be within the vector</td>
    <td class="lineNumber">5159</td>
    <td class="codeline">  /// bounds the returned pointer is unspecified, but will be within the vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="codeline">  /// bounds.</td>
    <td class="lineNumber">5160</td>
    <td class="codeline">  /// bounds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="codeline">  SDValue getVectorElementPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td class="lineNumber">5161</td>
    <td class="codeline">  SDValue getVectorElementPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="codeline">                                  SDValue Index) const;</td>
    <td class="lineNumber">5162</td>
    <td class="codeline">                                  SDValue Index) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class="codeline"></td>
    <td class="lineNumber">5163</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="codeline">  /// Get a pointer to a sub-vector of type \p SubVecVT at index \p Idx located</td>
    <td class="lineNumber">5164</td>
    <td class="codeline">  /// Get a pointer to a sub-vector of type \p SubVecVT at index \p Idx located</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="codeline">  /// in memory for a vector of type \p VecVT starting at a base address of</td>
    <td class="lineNumber">5165</td>
    <td class="codeline">  /// in memory for a vector of type \p VecVT starting at a base address of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="codeline">  /// \p VecPtr. If \p Idx plus the size of \p SubVecVT is out of bounds the</td>
    <td class="lineNumber">5166</td>
    <td class="codeline">  /// \p VecPtr. If \p Idx plus the size of \p SubVecVT is out of bounds the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="codeline">  /// returned pointer is unspecified, but the value returned will be such that</td>
    <td class="lineNumber">5167</td>
    <td class="codeline">  /// returned pointer is unspecified, but the value returned will be such that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="codeline">  /// the entire subvector would be within the vector bounds.</td>
    <td class="lineNumber">5168</td>
    <td class="codeline">  /// the entire subvector would be within the vector bounds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="codeline">  SDValue getVectorSubVecPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td class="lineNumber">5169</td>
    <td class="codeline">  SDValue getVectorSubVecPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="codeline">                                 EVT SubVecVT, SDValue Index) const;</td>
    <td class="lineNumber">5170</td>
    <td class="codeline">                                 EVT SubVecVT, SDValue Index) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class="codeline"></td>
    <td class="lineNumber">5171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US][MIN|MAX]. This</td>
    <td class="lineNumber">5172</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US][MIN|MAX]. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">5173</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="codeline">  SDValue expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5174</td>
    <td class="codeline">  SDValue expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class="codeline"></td>
    <td class="lineNumber">5175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US][ADD|SUB]SAT. This</td>
    <td class="lineNumber">5176</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US][ADD|SUB]SAT. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">5177</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="codeline">  SDValue expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5178</td>
    <td class="codeline">  SDValue expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="codeline"></td>
    <td class="lineNumber">5179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US]SHLSAT. This</td>
    <td class="lineNumber">5180</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US]SHLSAT. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">5181</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="codeline">  SDValue expandShlSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5182</td>
    <td class="codeline">  SDValue expandShlSat(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="codeline"></td>
    <td class="lineNumber">5183</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[U|S]MULFIX[SAT]. This</td>
    <td class="lineNumber">5184</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[U|S]MULFIX[SAT]. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">5185</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="codeline">  SDValue expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5186</td>
    <td class="codeline">  SDValue expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="codeline"></td>
    <td class="lineNumber">5187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This</td>
    <td class="lineNumber">5188</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">5189</td>
    <td class="codeline">  /// method accepts integers as its arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="codeline">  /// Note: This method may fail if the division could not be performed</td>
    <td class="lineNumber">5190</td>
    <td class="codeline">  /// Note: This method may fail if the division could not be performed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class="codeline">  /// within the type. Clients must retry with a wider type if this happens.</td>
    <td class="lineNumber">5191</td>
    <td class="codeline">  /// within the type. Clients must retry with a wider type if this happens.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="codeline">  SDValue expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,</td>
    <td class="lineNumber">5192</td>
    <td class="codeline">  SDValue expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="codeline">                              SDValue LHS, SDValue RHS,</td>
    <td class="lineNumber">5193</td>
    <td class="codeline">                              SDValue LHS, SDValue RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="codeline">                              unsigned Scale, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5194</td>
    <td class="codeline">                              unsigned Scale, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class="codeline"></td>
    <td class="lineNumber">5195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::U(ADD|SUB)O. Expansion</td>
    <td class="lineNumber">5196</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::U(ADD|SUB)O. Expansion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="codeline">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">5197</td>
    <td class="codeline">  /// always suceeds and populates the Result and Overflow arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="codeline">  void expandUADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">5198</td>
    <td class="codeline">  void expandUADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="codeline">                      SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5199</td>
    <td class="codeline">                      SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="codeline"></td>
    <td class="lineNumber">5200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::S(ADD|SUB)O. Expansion</td>
    <td class="lineNumber">5201</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::S(ADD|SUB)O. Expansion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="codeline">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">5202</td>
    <td class="codeline">  /// always suceeds and populates the Result and Overflow arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="codeline">  void expandSADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">5203</td>
    <td class="codeline">  void expandSADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="codeline">                      SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5204</td>
    <td class="codeline">                      SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class="codeline"></td>
    <td class="lineNumber">5205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5206</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US]MULO. Returns whether</td>
    <td class="lineNumber">5206</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::[US]MULO. Returns whether</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5207</td>
    <td class="codeline">  /// expansion was successful and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">5207</td>
    <td class="codeline">  /// expansion was successful and populates the Result and Overflow arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5208</td>
    <td class="codeline">  bool expandMULO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">5208</td>
    <td class="codeline">  bool expandMULO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5209</td>
    <td class="codeline">                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5209</td>
    <td class="codeline">                  SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5210</td>
    <td class="codeline"></td>
    <td class="lineNumber">5210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5211</td>
    <td class="codeline">  /// Expand a VECREDUCE_* into an explicit calculation. If Count is specified,</td>
    <td class="lineNumber">5211</td>
    <td class="codeline">  /// Expand a VECREDUCE_* into an explicit calculation. If Count is specified,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5212</td>
    <td class="codeline">  /// only the first Count elements of the vector are used.</td>
    <td class="lineNumber">5212</td>
    <td class="codeline">  /// only the first Count elements of the vector are used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5213</td>
    <td class="codeline">  SDValue expandVecReduce(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5213</td>
    <td class="codeline">  SDValue expandVecReduce(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5214</td>
    <td class="codeline"></td>
    <td class="lineNumber">5214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5215</td>
    <td class="codeline">  /// Expand a VECREDUCE_SEQ_* into an explicit ordered calculation.</td>
    <td class="lineNumber">5215</td>
    <td class="codeline">  /// Expand a VECREDUCE_SEQ_* into an explicit ordered calculation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5216</td>
    <td class="codeline">  SDValue expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5216</td>
    <td class="codeline">  SDValue expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5217</td>
    <td class="codeline"></td>
    <td class="lineNumber">5217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5218</td>
    <td class="codeline">  /// Expand an SREM or UREM using SDIV/UDIV or SDIVREM/UDIVREM, if legal.</td>
    <td class="lineNumber">5218</td>
    <td class="codeline">  /// Expand an SREM or UREM using SDIV/UDIV or SDIVREM/UDIVREM, if legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5219</td>
    <td class="codeline">  /// Returns true if the expansion was successful.</td>
    <td class="lineNumber">5219</td>
    <td class="codeline">  /// Returns true if the expansion was successful.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5220</td>
    <td class="codeline">  bool expandREM(SDNode *Node, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5220</td>
    <td class="codeline">  bool expandREM(SDNode *Node, SDValue &Result, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5221</td>
    <td class="codeline"></td>
    <td class="lineNumber">5221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5222</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::VECTOR_SPLICE. This</td>
    <td class="lineNumber">5222</td>
    <td class="codeline">  /// Method for building the DAG expansion of ISD::VECTOR_SPLICE. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5223</td>
    <td class="codeline">  /// method accepts vectors as its arguments.</td>
    <td class="lineNumber">5223</td>
    <td class="codeline">  /// method accepts vectors as its arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5224</td>
    <td class="codeline">  SDValue expandVectorSplice(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5224</td>
    <td class="codeline">  SDValue expandVectorSplice(SDNode *Node, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5225</td>
    <td class="codeline"></td>
    <td class="lineNumber">5225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5226</td>
    <td class="codeline">  /// Legalize a SETCC or VP_SETCC with given LHS and RHS and condition code CC</td>
    <td class="lineNumber">5226</td>
    <td class="codeline">  /// Legalize a SETCC or VP_SETCC with given LHS and RHS and condition code CC</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5227</td>
    <td class="codeline">  /// on the current target. A VP_SETCC will additionally be given a Mask</td>
    <td class="lineNumber">5227</td>
    <td class="codeline">  /// on the current target. A VP_SETCC will additionally be given a Mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5228</td>
    <td class="codeline">  /// and/or EVL not equal to SDValue().</td>
    <td class="lineNumber">5228</td>
    <td class="codeline">  /// and/or EVL not equal to SDValue().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5229</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">5229</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5230</td>
    <td class="codeline">  /// If the SETCC has been legalized using AND / OR, then the legalized node</td>
    <td class="lineNumber">5230</td>
    <td class="codeline">  /// If the SETCC has been legalized using AND / OR, then the legalized node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5231</td>
    <td class="codeline">  /// will be stored in LHS. RHS and CC will be set to SDValue(). NeedInvert</td>
    <td class="lineNumber">5231</td>
    <td class="codeline">  /// will be stored in LHS. RHS and CC will be set to SDValue(). NeedInvert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5232</td>
    <td class="codeline">  /// will be set to false. This will also hold if the VP_SETCC has been</td>
    <td class="lineNumber">5232</td>
    <td class="codeline">  /// will be set to false. This will also hold if the VP_SETCC has been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5233</td>
    <td class="codeline">  /// legalized using VP_AND / VP_OR.</td>
    <td class="lineNumber">5233</td>
    <td class="codeline">  /// legalized using VP_AND / VP_OR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5234</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">5234</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5235</td>
    <td class="codeline">  /// If the SETCC / VP_SETCC has been legalized by using</td>
    <td class="lineNumber">5235</td>
    <td class="codeline">  /// If the SETCC / VP_SETCC has been legalized by using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5236</td>
    <td class="codeline">  /// getSetCCSwappedOperands(), then the values of LHS and RHS will be</td>
    <td class="lineNumber">5236</td>
    <td class="codeline">  /// getSetCCSwappedOperands(), then the values of LHS and RHS will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5237</td>
    <td class="codeline">  /// swapped, CC will be set to the new condition, and NeedInvert will be set</td>
    <td class="lineNumber">5237</td>
    <td class="codeline">  /// swapped, CC will be set to the new condition, and NeedInvert will be set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5238</td>
    <td class="codeline">  /// to false.</td>
    <td class="lineNumber">5238</td>
    <td class="codeline">  /// to false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5239</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">5239</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5240</td>
    <td class="codeline">  /// If the SETCC / VP_SETCC has been legalized using the inverse condcode,</td>
    <td class="lineNumber">5240</td>
    <td class="codeline">  /// If the SETCC / VP_SETCC has been legalized using the inverse condcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5241</td>
    <td class="codeline">  /// then LHS and RHS will be unchanged, CC will set to the inverted condcode,</td>
    <td class="lineNumber">5241</td>
    <td class="codeline">  /// then LHS and RHS will be unchanged, CC will set to the inverted condcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5242</td>
    <td class="codeline">  /// and NeedInvert will be set to true. The caller must invert the result of</td>
    <td class="lineNumber">5242</td>
    <td class="codeline">  /// and NeedInvert will be set to true. The caller must invert the result of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5243</td>
    <td class="codeline">  /// the SETCC with SelectionDAG::getLogicalNOT() or take equivalent action to</td>
    <td class="lineNumber">5243</td>
    <td class="codeline">  /// the SETCC with SelectionDAG::getLogicalNOT() or take equivalent action to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5244</td>
    <td class="codeline">  /// swap the effect of a true/false result.</td>
    <td class="lineNumber">5244</td>
    <td class="codeline">  /// swap the effect of a true/false result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5245</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">5245</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5246</td>
    <td class="codeline">  /// \returns true if the SETCC / VP_SETCC has been legalized, false if it</td>
    <td class="lineNumber">5246</td>
    <td class="codeline">  /// \returns true if the SETCC / VP_SETCC has been legalized, false if it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5247</td>
    <td class="codeline">  /// hasn't.</td>
    <td class="lineNumber">5247</td>
    <td class="codeline">  /// hasn't.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5248</td>
    <td class="codeline">  bool LegalizeSetCCCondCode(SelectionDAG &DAG, EVT VT, SDValue &LHS,</td>
    <td class="lineNumber">5248</td>
    <td class="codeline">  bool LegalizeSetCCCondCode(SelectionDAG &DAG, EVT VT, SDValue &LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5249</td>
    <td class="codeline">                             SDValue &RHS, SDValue &CC, SDValue Mask,</td>
    <td class="lineNumber">5249</td>
    <td class="codeline">                             SDValue &RHS, SDValue &CC, SDValue Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5250</td>
    <td class="codeline">                             SDValue EVL, bool &NeedInvert, const SDLoc &dl,</td>
    <td class="lineNumber">5250</td>
    <td class="codeline">                             SDValue EVL, bool &NeedInvert, const SDLoc &dl,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5251</td>
    <td class="codeline">                             SDValue &Chain, bool IsSignaling = false) const;</td>
    <td class="lineNumber">5251</td>
    <td class="codeline">                             SDValue &Chain, bool IsSignaling = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5252</td>
    <td class="codeline"></td>
    <td class="lineNumber">5252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5253</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">5253</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5254</td>
    <td class="codeline">  // Instruction Emitting Hooks</td>
    <td class="lineNumber">5254</td>
    <td class="codeline">  // Instruction Emitting Hooks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5255</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">5255</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5256</td>
    <td class="codeline"></td>
    <td class="lineNumber">5256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5257</td>
    <td class="codeline">  /// This method should be implemented by targets that mark instructions with</td>
    <td class="lineNumber">5257</td>
    <td class="codeline">  /// This method should be implemented by targets that mark instructions with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5258</td>
    <td class="codeline">  /// the 'usesCustomInserter' flag.  These instructions are special in various</td>
    <td class="lineNumber">5258</td>
    <td class="codeline">  /// the 'usesCustomInserter' flag.  These instructions are special in various</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5259</td>
    <td class="codeline">  /// ways, which require special support to insert.  The specified MachineInstr</td>
    <td class="lineNumber">5259</td>
    <td class="codeline">  /// ways, which require special support to insert.  The specified MachineInstr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5260</td>
    <td class="codeline">  /// is created but not inserted into any basic blocks, and this method is</td>
    <td class="lineNumber">5260</td>
    <td class="codeline">  /// is created but not inserted into any basic blocks, and this method is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5261</td>
    <td class="codeline">  /// called to expand it into a sequence of instructions, potentially also</td>
    <td class="lineNumber">5261</td>
    <td class="codeline">  /// called to expand it into a sequence of instructions, potentially also</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5262</td>
    <td class="codeline">  /// creating new basic blocks and control flow.</td>
    <td class="lineNumber">5262</td>
    <td class="codeline">  /// creating new basic blocks and control flow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5263</td>
    <td class="codeline">  /// As long as the returned basic block is different (i.e., we created a new</td>
    <td class="lineNumber">5263</td>
    <td class="codeline">  /// As long as the returned basic block is different (i.e., we created a new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5264</td>
    <td class="codeline">  /// one), the custom inserter is free to modify the rest of \p MBB.</td>
    <td class="lineNumber">5264</td>
    <td class="codeline">  /// one), the custom inserter is free to modify the rest of \p MBB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5265</td>
    <td class="codeline">  virtual MachineBasicBlock *</td>
    <td class="lineNumber">5265</td>
    <td class="codeline">  virtual MachineBasicBlock *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5266</td>
    <td class="codeline">  EmitInstrWithCustomInserter(MachineInstr &MI, MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">5266</td>
    <td class="codeline">  EmitInstrWithCustomInserter(MachineInstr &MI, MachineBasicBlock *MBB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5267</td>
    <td class="codeline"></td>
    <td class="lineNumber">5267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5268</td>
    <td class="codeline">  /// This method should be implemented by targets that mark instructions with</td>
    <td class="lineNumber">5268</td>
    <td class="codeline">  /// This method should be implemented by targets that mark instructions with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5269</td>
    <td class="codeline">  /// the 'hasPostISelHook' flag. These instructions must be adjusted after</td>
    <td class="lineNumber">5269</td>
    <td class="codeline">  /// the 'hasPostISelHook' flag. These instructions must be adjusted after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5270</td>
    <td class="codeline">  /// instruction selection by target hooks.  e.g. To fill in optional defs for</td>
    <td class="lineNumber">5270</td>
    <td class="codeline">  /// instruction selection by target hooks.  e.g. To fill in optional defs for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5271</td>
    <td class="codeline">  /// ARM 's' setting instructions.</td>
    <td class="lineNumber">5271</td>
    <td class="codeline">  /// ARM 's' setting instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5272</td>
    <td class="codeline">  virtual void AdjustInstrPostInstrSelection(MachineInstr &MI,</td>
    <td class="lineNumber">5272</td>
    <td class="codeline">  virtual void AdjustInstrPostInstrSelection(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5273</td>
    <td class="codeline">                                             SDNode *Node) const;</td>
    <td class="lineNumber">5273</td>
    <td class="codeline">                                             SDNode *Node) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5274</td>
    <td class="codeline"></td>
    <td class="lineNumber">5274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5275</td>
    <td class="codeline">  /// If this function returns true, SelectionDAGBuilder emits a</td>
    <td class="lineNumber">5275</td>
    <td class="codeline">  /// If this function returns true, SelectionDAGBuilder emits a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5276</td>
    <td class="codeline">  /// LOAD_STACK_GUARD node when it is lowering Intrinsic::stackprotector.</td>
    <td class="lineNumber">5276</td>
    <td class="codeline">  /// LOAD_STACK_GUARD node when it is lowering Intrinsic::stackprotector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5277</td>
    <td class="codeline">  virtual bool useLoadStackGuardNode() const {</td>
    <td class="lineNumber">5277</td>
    <td class="codeline">  virtual bool useLoadStackGuardNode() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5278</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">5278</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5279</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5279</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5280</td>
    <td class="codeline"></td>
    <td class="lineNumber">5280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5281</td>
    <td class="codeline">  virtual SDValue emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,</td>
    <td class="lineNumber">5281</td>
    <td class="codeline">  virtual SDValue emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5282</td>
    <td class="codeline">                                      const SDLoc &DL) const {</td>
    <td class="lineNumber">5282</td>
    <td class="codeline">                                      const SDLoc &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5283</td>
    <td class="codeline">    llvm_unreachable("not implemented for this target");</td>
    <td class="lineNumber">5283</td>
    <td class="codeline">    llvm_unreachable("not implemented for this target");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5284</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5284</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5285</td>
    <td class="codeline"></td>
    <td class="lineNumber">5285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5286</td>
    <td class="codeline">  /// Lower TLS global address SDNode for target independent emulated TLS model.</td>
    <td class="lineNumber">5286</td>
    <td class="codeline">  /// Lower TLS global address SDNode for target independent emulated TLS model.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5287</td>
    <td class="codeline">  virtual SDValue LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,</td>
    <td class="lineNumber">5287</td>
    <td class="codeline">  virtual SDValue LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5288</td>
    <td class="codeline">                                          SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5288</td>
    <td class="codeline">                                          SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5289</td>
    <td class="codeline"></td>
    <td class="lineNumber">5289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5290</td>
    <td class="codeline">  /// Expands target specific indirect branch for the case of JumpTable</td>
    <td class="lineNumber">5290</td>
    <td class="codeline">  /// Expands target specific indirect branch for the case of JumpTable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5291</td>
    <td class="codeline">  /// expanasion.</td>
    <td class="lineNumber">5291</td>
    <td class="codeline">  /// expanasion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5292</td>
    <td class="codeline">  virtual SDValue expandIndirectJTBranch(const SDLoc& dl, SDValue Value, SDValue Addr,</td>
    <td class="lineNumber">5292</td>
    <td class="codeline">  virtual SDValue expandIndirectJTBranch(const SDLoc& dl, SDValue Value, SDValue Addr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5293</td>
    <td class="codeline">                                         SelectionDAG &DAG) const {</td>
    <td class="lineNumber">5293</td>
    <td class="codeline">                                         SelectionDAG &DAG) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5294</td>
    <td class="codeline">    return DAG.getNode(ISD::BRIND, dl, MVT::Other, Value, Addr);</td>
    <td class="lineNumber">5294</td>
    <td class="codeline">    return DAG.getNode(ISD::BRIND, dl, MVT::Other, Value, Addr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5295</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5295</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5296</td>
    <td class="codeline"></td>
    <td class="lineNumber">5296</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5297</td>
    <td class="codeline">  // seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits)))</td>
    <td class="lineNumber">5297</td>
    <td class="codeline">  // seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5298</td>
    <td class="codeline">  // If we're comparing for equality to zero and isCtlzFast is true, expose the</td>
    <td class="lineNumber">5298</td>
    <td class="codeline">  // If we're comparing for equality to zero and isCtlzFast is true, expose the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5299</td>
    <td class="codeline">  // fact that this can be implemented as a ctlz/srl pair, so that the dag</td>
    <td class="lineNumber">5299</td>
    <td class="codeline">  // fact that this can be implemented as a ctlz/srl pair, so that the dag</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5300</td>
    <td class="codeline">  // combiner can fold the new nodes.</td>
    <td class="lineNumber">5300</td>
    <td class="codeline">  // combiner can fold the new nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5301</td>
    <td class="codeline">  SDValue lowerCmpEqZeroToCtlzSrl(SDValue Op, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">5301</td>
    <td class="codeline">  SDValue lowerCmpEqZeroToCtlzSrl(SDValue Op, SelectionDAG &DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5302</td>
    <td class="codeline"></td>
    <td class="lineNumber">5302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5303</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">5303</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5304</td>
    <td class="codeline">  SDValue foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">5304</td>
    <td class="codeline">  SDValue foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5305</td>
    <td class="codeline">                           const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">5305</td>
    <td class="codeline">                           const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5306</td>
    <td class="codeline">  SDValue foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">5306</td>
    <td class="codeline">  SDValue foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5307</td>
    <td class="codeline">                             const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">5307</td>
    <td class="codeline">                             const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5308</td>
    <td class="codeline"></td>
    <td class="lineNumber">5308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5309</td>
    <td class="codeline">  SDValue optimizeSetCCOfSignedTruncationCheck(EVT SCCVT, SDValue N0,</td>
    <td class="lineNumber">5309</td>
    <td class="codeline">  SDValue optimizeSetCCOfSignedTruncationCheck(EVT SCCVT, SDValue N0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5310</td>
    <td class="codeline">                                               SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">5310</td>
    <td class="codeline">                                               SDValue N1, ISD::CondCode Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5311</td>
    <td class="codeline">                                               DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">5311</td>
    <td class="codeline">                                               DAGCombinerInfo &DCI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5312</td>
    <td class="codeline">                                               const SDLoc &DL) const;</td>
    <td class="lineNumber">5312</td>
    <td class="codeline">                                               const SDLoc &DL) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5313</td>
    <td class="codeline"></td>
    <td class="lineNumber">5313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5314</td>
    <td class="codeline">  // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0</td>
    <td class="lineNumber">5314</td>
    <td class="codeline">  // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5315</td>
    <td class="codeline">  SDValue optimizeSetCCByHoistingAndByConstFromLogicalShift(</td>
    <td class="lineNumber">5315</td>
    <td class="codeline">  SDValue optimizeSetCCByHoistingAndByConstFromLogicalShift(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5316</td>
    <td class="codeline">      EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,</td>
    <td class="lineNumber">5316</td>
    <td class="codeline">      EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5317</td>
    <td class="codeline">      DAGCombinerInfo &DCI, const SDLoc &DL) const;</td>
    <td class="lineNumber">5317</td>
    <td class="codeline">      DAGCombinerInfo &DCI, const SDLoc &DL) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5318</td>
    <td class="codeline"></td>
    <td class="lineNumber">5318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5319</td>
    <td class="codeline">  SDValue prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td class="lineNumber">5319</td>
    <td class="codeline">  SDValue prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5320</td>
    <td class="codeline">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td class="lineNumber">5320</td>
    <td class="codeline">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5321</td>
    <td class="codeline">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td class="lineNumber">5321</td>
    <td class="codeline">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5322</td>
    <td class="codeline">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">5322</td>
    <td class="codeline">                            SmallVectorImpl<SDNode *> &Created) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5323</td>
    <td class="codeline">  SDValue buildUREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td class="lineNumber">5323</td>
    <td class="codeline">  SDValue buildUREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5324</td>
    <td class="codeline">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">5324</td>
    <td class="codeline">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5325</td>
    <td class="codeline">                          const SDLoc &DL) const;</td>
    <td class="lineNumber">5325</td>
    <td class="codeline">                          const SDLoc &DL) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5326</td>
    <td class="codeline"></td>
    <td class="lineNumber">5326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5327</td>
    <td class="codeline">  SDValue prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td class="lineNumber">5327</td>
    <td class="codeline">  SDValue prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5328</td>
    <td class="codeline">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td class="lineNumber">5328</td>
    <td class="codeline">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5329</td>
    <td class="codeline">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td class="lineNumber">5329</td>
    <td class="codeline">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5330</td>
    <td class="codeline">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">5330</td>
    <td class="codeline">                            SmallVectorImpl<SDNode *> &Created) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5331</td>
    <td class="codeline">  SDValue buildSREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td class="lineNumber">5331</td>
    <td class="codeline">  SDValue buildSREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5332</td>
    <td class="codeline">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">5332</td>
    <td class="codeline">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5333</td>
    <td class="codeline">                          const SDLoc &DL) const;</td>
    <td class="lineNumber">5333</td>
    <td class="codeline">                          const SDLoc &DL) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5334</td>
    <td class="codeline">};</td>
    <td class="lineNumber">5334</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5335</td>
    <td class="codeline"></td>
    <td class="lineNumber">5335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5336</td>
    <td class="codeline">/// Given an LLVM IR type and return type attributes, compute the return value</td>
    <td class="lineNumber">5336</td>
    <td class="codeline">/// Given an LLVM IR type and return type attributes, compute the return value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5337</td>
    <td class="codeline">/// EVTs and flags, and optionally also the offsets, if the return value is</td>
    <td class="lineNumber">5337</td>
    <td class="codeline">/// EVTs and flags, and optionally also the offsets, if the return value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5338</td>
    <td class="codeline">/// being lowered to memory.</td>
    <td class="lineNumber">5338</td>
    <td class="codeline">/// being lowered to memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5339</td>
    <td class="codeline">void GetReturnInfo(CallingConv::ID CC, Type *ReturnType, AttributeList attr,</td>
    <td class="lineNumber">5339</td>
    <td class="codeline">void GetReturnInfo(CallingConv::ID CC, Type *ReturnType, AttributeList attr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5340</td>
    <td class="codeline">                   SmallVectorImpl<ISD::OutputArg> &Outs,</td>
    <td class="lineNumber">5340</td>
    <td class="codeline">                   SmallVectorImpl<ISD::OutputArg> &Outs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5341</td>
    <td class="codeline">                   const TargetLowering &TLI, const DataLayout &DL);</td>
    <td class="lineNumber">5341</td>
    <td class="codeline">                   const TargetLowering &TLI, const DataLayout &DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5342</td>
    <td class="codeline"></td>
    <td class="lineNumber">5342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5343</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">5343</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5344</td>
    <td class="codeline"></td>
    <td class="lineNumber">5344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5345</td>
    <td class="codeline">#endif // LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">5345</td>
    <td class="codeline">#endif // LLVM_CODEGEN_TARGETLOWERING_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5346</td>
    <td class="codeline"></td>
    <td class="lineNumber">5346</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/TargetLowering.h - Target Lowering Info -----*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/TargetLowering.h - Target Lowering Info -----*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file describes how to lower LLVM code to machine code.  This has two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file describes how to lower LLVM code to machine code.  This has two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// main components:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// main components:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">///  1. Which ValueTypes are natively supported by the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">///  1. Which ValueTypes are natively supported by the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">///  2. Which operations are supported for supported ValueTypes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">///  2. Which operations are supported for supported ValueTypes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">///  3. Cost thresholds for alternative implementations of certain operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">///  3. Cost thresholds for alternative implementations of certain operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">/// In addition it has a few other components, like information about FP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">/// In addition it has a few other components, like information about FP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">/// immediates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">/// immediates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#define LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#define LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/CodeGen/ComplexDeinterleavingPass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/CodeGen/ComplexDeinterleavingPass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/CodeGen/DAGCombine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/CodeGen/DAGCombine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/CodeGen/LowLevelTypeUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/CodeGen/LowLevelTypeUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/CodeGen/RuntimeLibcalls.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/CodeGen/RuntimeLibcalls.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/CodeGen/SelectionDAG.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/CodeGen/SelectionDAG.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/CodeGen/SelectionDAGNodes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/CodeGen/SelectionDAGNodes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetCallingConv.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetCallingConv.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/CallingConv.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/CallingConv.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/InlineAsm.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/InlineAsm.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <climits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <climits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">class AssumptionCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">class AssumptionCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">class CCState;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">class CCState;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">class CCValAssign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">class CCValAssign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">class Constant;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">class Constant;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">class FastISel;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">class FastISel;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">class FunctionLoweringInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">class FunctionLoweringInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">class GlobalValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">class GlobalValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">class Loop;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">class Loop;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">class GISelKnownBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">class GISelKnownBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">class IntrinsicInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">class IntrinsicInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">class IRBuilderBase;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">class IRBuilderBase;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">struct KnownBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">struct KnownBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">class LLVMContext;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">class LLVMContext;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">class MachineBasicBlock;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">class MachineBasicBlock;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">class MachineFunction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">class MachineFunction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">class MachineInstr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">class MachineInstr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">class MachineJumpTableInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">class MachineJumpTableInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">class MachineLoop;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">class MachineLoop;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">class MCContext;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">class MCContext;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">class MCExpr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">class MCExpr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">class Module;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">class Module;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">class ProfileSummaryInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">class ProfileSummaryInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">class TargetLibraryInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">class TargetLibraryInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">class TargetMachine;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">class TargetMachine;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">class TargetRegisterClass;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">class TargetRegisterClass;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">class TargetRegisterInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">class TargetRegisterInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">class TargetTransformInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">class TargetTransformInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">class Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">class Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">namespace Sched {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">namespace Sched {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">enum Preference {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">enum Preference {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  None,        // No preference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  None,        // No preference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  Source,      // Follow source order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  Source,      // Follow source order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  RegPressure, // Scheduling for lowest register pressure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  RegPressure, // Scheduling for lowest register pressure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  Hybrid,      // Scheduling for both latency and register pressure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  Hybrid,      // Scheduling for both latency and register pressure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  ILP,         // Scheduling for ILP in low register pressure mode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  ILP,         // Scheduling for ILP in low register pressure mode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  VLIW,        // Scheduling for VLIW targets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  VLIW,        // Scheduling for VLIW targets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  Fast,        // Fast suboptimal list scheduling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  Fast,        // Fast suboptimal list scheduling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  Linearize    // Linearize DAG, no scheduling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  Linearize    // Linearize DAG, no scheduling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">} // end namespace Sched</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">} // end namespace Sched</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">// MemOp models a memory operation, either memset or memcpy/memmove.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">// MemOp models a memory operation, either memset or memcpy/memmove.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">struct MemOp {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">struct MemOp {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  // Shared</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  // Shared</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">  uint64_t Size;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">  uint64_t Size;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  bool DstAlignCanChange; // true if destination alignment can satisfy any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  bool DstAlignCanChange; // true if destination alignment can satisfy any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">                          // constraint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">                          // constraint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  Align DstAlign;         // Specified alignment of the memory operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  Align DstAlign;         // Specified alignment of the memory operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  bool AllowOverlap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  bool AllowOverlap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  // memset only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  // memset only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  bool IsMemset;   // If setthis memory operation is a memset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  bool IsMemset;   // If setthis memory operation is a memset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  bool ZeroMemset; // If set clears out memory with zeros.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  bool ZeroMemset; // If set clears out memory with zeros.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  // memcpy only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  // memcpy only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  bool MemcpyStrSrc; // Indicates whether the memcpy source is an in-register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  bool MemcpyStrSrc; // Indicates whether the memcpy source is an in-register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">                     // constant so it does not need to be loaded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">                     // constant so it does not need to be loaded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  Align SrcAlign;    // Inferred alignment of the source or default value if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  Align SrcAlign;    // Inferred alignment of the source or default value if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">                     // memory operation does not need to load the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">                     // memory operation does not need to load the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  static MemOp Copy(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  static MemOp Copy(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">                    Align SrcAlign, bool IsVolatile,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">                    Align SrcAlign, bool IsVolatile,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">                    bool MemcpyStrSrc = false) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">                    bool MemcpyStrSrc = false) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    MemOp Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    MemOp Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">    Op.Size = Size;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">    Op.Size = Size;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">    Op.DstAlign = DstAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">    Op.DstAlign = DstAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">    Op.AllowOverlap = !IsVolatile;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">    Op.AllowOverlap = !IsVolatile;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">    Op.IsMemset = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">    Op.IsMemset = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">    Op.ZeroMemset = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">    Op.ZeroMemset = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">    Op.MemcpyStrSrc = MemcpyStrSrc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">    Op.MemcpyStrSrc = MemcpyStrSrc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    Op.SrcAlign = SrcAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    Op.SrcAlign = SrcAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    return Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    return Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  static MemOp Set(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  static MemOp Set(uint64_t Size, bool DstAlignCanChange, Align DstAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">                   bool IsZeroMemset, bool IsVolatile) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">                   bool IsZeroMemset, bool IsVolatile) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">    MemOp Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">    MemOp Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">    Op.Size = Size;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">    Op.Size = Size;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">    Op.DstAlignCanChange = DstAlignCanChange;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    Op.DstAlign = DstAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    Op.DstAlign = DstAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    Op.AllowOverlap = !IsVolatile;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    Op.AllowOverlap = !IsVolatile;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">    Op.IsMemset = true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">    Op.IsMemset = true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">    Op.ZeroMemset = IsZeroMemset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">    Op.ZeroMemset = IsZeroMemset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">    Op.MemcpyStrSrc = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">    Op.MemcpyStrSrc = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">    return Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">    return Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  uint64_t size() const { return Size; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  uint64_t size() const { return Size; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  Align getDstAlign() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  Align getDstAlign() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">    assert(!DstAlignCanChange);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">    assert(!DstAlignCanChange);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">    return DstAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">    return DstAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  bool isFixedDstAlign() const { return !DstAlignCanChange; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  bool isFixedDstAlign() const { return !DstAlignCanChange; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  bool allowOverlap() const { return AllowOverlap; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  bool allowOverlap() const { return AllowOverlap; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  bool isMemset() const { return IsMemset; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  bool isMemset() const { return IsMemset; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  bool isMemcpy() const { return !IsMemset; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  bool isMemcpy() const { return !IsMemset; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  bool isMemcpyWithFixedDstAlign() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  bool isMemcpyWithFixedDstAlign() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">    return isMemcpy() && !DstAlignCanChange;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">    return isMemcpy() && !DstAlignCanChange;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  bool isZeroMemset() const { return isMemset() && ZeroMemset; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  bool isZeroMemset() const { return isMemset() && ZeroMemset; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  bool isMemcpyStrSrc() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  bool isMemcpyStrSrc() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    return MemcpyStrSrc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    return MemcpyStrSrc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  Align getSrcAlign() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  Align getSrcAlign() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">    assert(isMemcpy() && "Must be a memcpy");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">    return SrcAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">    return SrcAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  bool isSrcAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  bool isSrcAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">    return isMemset() || llvm::isAligned(AlignCheck, SrcAlign.value());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">    return isMemset() || llvm::isAligned(AlignCheck, SrcAlign.value());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  bool isDstAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  bool isDstAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">    return DstAlignCanChange || llvm::isAligned(AlignCheck, DstAlign.value());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">    return DstAlignCanChange || llvm::isAligned(AlignCheck, DstAlign.value());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  bool isAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  bool isAligned(Align AlignCheck) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">    return isSrcAligned(AlignCheck) && isDstAligned(AlignCheck);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">    return isSrcAligned(AlignCheck) && isDstAligned(AlignCheck);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">/// This base class for TargetLowering contains the SelectionDAG-independent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">/// This base class for TargetLowering contains the SelectionDAG-independent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">/// parts that can be used from the rest of CodeGen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">/// parts that can be used from the rest of CodeGen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">class TargetLoweringBase {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">class TargetLoweringBase {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">  /// This enum indicates whether operations are valid for a target, and if not,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">  /// This enum indicates whether operations are valid for a target, and if not,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  /// what action should be used to make them valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  /// what action should be used to make them valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  enum LegalizeAction : uint8_t {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  enum LegalizeAction : uint8_t {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">    Legal,      // The target natively supports this operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">    Legal,      // The target natively supports this operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    Promote,    // This operation should be executed in a larger type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    Promote,    // This operation should be executed in a larger type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">    Expand,     // Try to expand this to other ops, otherwise use a libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">    Expand,     // Try to expand this to other ops, otherwise use a libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">    LibCall,    // Don't try to expand this to other ops, always use a libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">    LibCall,    // Don't try to expand this to other ops, always use a libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">    Custom      // Use the LowerOperation hook to implement custom lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">    Custom      // Use the LowerOperation hook to implement custom lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  /// This enum indicates whether a types are legal for a target, and if not,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  /// This enum indicates whether a types are legal for a target, and if not,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// what action should be used to make them valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// what action should be used to make them valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  enum LegalizeTypeAction : uint8_t {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  enum LegalizeTypeAction : uint8_t {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">    TypeLegal,           // The target natively supports this type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">    TypeLegal,           // The target natively supports this type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">    TypePromoteInteger,  // Replace this integer with a larger one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">    TypePromoteInteger,  // Replace this integer with a larger one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    TypeExpandInteger,   // Split this integer into two of half the size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    TypeExpandInteger,   // Split this integer into two of half the size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    TypeSoftenFloat,     // Convert this float to a same size integer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    TypeSoftenFloat,     // Convert this float to a same size integer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">    TypeExpandFloat,     // Split this float into two of half the size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">    TypeExpandFloat,     // Split this float into two of half the size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">    TypeScalarizeVector, // Replace this one-element vector with its element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">    TypeScalarizeVector, // Replace this one-element vector with its element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">    TypeSplitVector,     // Split this vector into two of half the size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">    TypeSplitVector,     // Split this vector into two of half the size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">    TypeWidenVector,     // This vector should be widened into a larger vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">    TypeWidenVector,     // This vector should be widened into a larger vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">    TypePromoteFloat,    // Replace this float with a larger one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">    TypePromoteFloat,    // Replace this float with a larger one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">    TypeSoftPromoteHalf, // Soften half to i16 and use float to do arithmetic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">    TypeSoftPromoteHalf, // Soften half to i16 and use float to do arithmetic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">    TypeScalarizeScalableVector, // This action is explicitly left unimplemented.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">    TypeScalarizeScalableVector, // This action is explicitly left unimplemented.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">                                 // While it is theoretically possible to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">                                 // While it is theoretically possible to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">                                 // legalize operations on scalable types with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">                                 // legalize operations on scalable types with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">                                 // loop that handles the vscale * #lanes of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">                                 // loop that handles the vscale * #lanes of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">                                 // vector, this is non-trivial at SelectionDAG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">                                 // vector, this is non-trivial at SelectionDAG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">                                 // level and these types are better to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">                                 // level and these types are better to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">                                 // widened or promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">                                 // widened or promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  /// LegalizeKind holds the legalization kind that needs to happen to EVT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  /// LegalizeKind holds the legalization kind that needs to happen to EVT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  /// in order to type-legalize it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  /// in order to type-legalize it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  using LegalizeKind = std::pair<LegalizeTypeAction, EVT>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  using LegalizeKind = std::pair<LegalizeTypeAction, EVT>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  /// Enum that describes how the target represents true/false values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  /// Enum that describes how the target represents true/false values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  enum BooleanContent {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  enum BooleanContent {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">    UndefinedBooleanContent,    // Only bit 0 counts, the rest can hold garbage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">    UndefinedBooleanContent,    // Only bit 0 counts, the rest can hold garbage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">    ZeroOrOneBooleanContent,        // All bits zero except for bit 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">    ZeroOrOneBooleanContent,        // All bits zero except for bit 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    ZeroOrNegativeOneBooleanContent // All bits equal to bit 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    ZeroOrNegativeOneBooleanContent // All bits equal to bit 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  /// Enum that describes what type of support for selects the target has.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  /// Enum that describes what type of support for selects the target has.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  enum SelectSupportKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  enum SelectSupportKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    ScalarValSelect,      // The target supports scalar selects (ex: cmov).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    ScalarValSelect,      // The target supports scalar selects (ex: cmov).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    ScalarCondVectorVal,  // The target supports selects with a scalar condition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    ScalarCondVectorVal,  // The target supports selects with a scalar condition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">                          // and vector values (ex: cmov).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">                          // and vector values (ex: cmov).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    VectorMaskSelect      // The target supports vector selects with a vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    VectorMaskSelect      // The target supports vector selects with a vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">                          // mask (ex: x86 blends).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">                          // mask (ex: x86 blends).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  /// Enum that specifies what an atomic load/AtomicRMWInst is expanded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  /// Enum that specifies what an atomic load/AtomicRMWInst is expanded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// to, if at all. Exists because different targets have different levels of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// to, if at all. Exists because different targets have different levels of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// support for these atomic instructions, and also have different options</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// support for these atomic instructions, and also have different options</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  /// w.r.t. what they should expand to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  /// w.r.t. what they should expand to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  enum class AtomicExpansionKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  enum class AtomicExpansionKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">    None,    // Don't expand the instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">    None,    // Don't expand the instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">    CastToInteger,    // Cast the atomic instruction to another type, e.g. from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">    CastToInteger,    // Cast the atomic instruction to another type, e.g. from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">                      // floating-point to integer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">                      // floating-point to integer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">    LLSC,    // Expand the instruction into loadlinked/storeconditional; used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">    LLSC,    // Expand the instruction into loadlinked/storeconditional; used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">             // by ARM/AArch64.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">             // by ARM/AArch64.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">    LLOnly,  // Expand the (load) instruction into just a load-linked, which has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">    LLOnly,  // Expand the (load) instruction into just a load-linked, which has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">             // greater atomic guarantees than a normal load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">             // greater atomic guarantees than a normal load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    CmpXChg, // Expand the instruction into cmpxchg; used by at least X86.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    CmpXChg, // Expand the instruction into cmpxchg; used by at least X86.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">    MaskedIntrinsic,  // Use a target-specific intrinsic for the LL/SC loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">    MaskedIntrinsic,  // Use a target-specific intrinsic for the LL/SC loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    BitTestIntrinsic, // Use a target-specific intrinsic for special bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    BitTestIntrinsic, // Use a target-specific intrinsic for special bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">                      // operations; used by X86.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">                      // operations; used by X86.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    CmpArithIntrinsic,// Use a target-specific intrinsic for special compare</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    CmpArithIntrinsic,// Use a target-specific intrinsic for special compare</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">                      // operations; used by X86.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">                      // operations; used by X86.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">    Expand,           // Generic expansion in terms of other atomic operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">    Expand,           // Generic expansion in terms of other atomic operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    // Rewrite to a non-atomic form for use in a known non-preemptible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    // Rewrite to a non-atomic form for use in a known non-preemptible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">    // environment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">    // environment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    NotAtomic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    NotAtomic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Enum that specifies when a multiplication should be expanded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Enum that specifies when a multiplication should be expanded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  enum class MulExpansionKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  enum class MulExpansionKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    Always,            // Always expand the instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    Always,            // Always expand the instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">    OnlyLegalOrCustom, // Only expand when the resulting instructions are legal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">    OnlyLegalOrCustom, // Only expand when the resulting instructions are legal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">                       // or custom.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">                       // or custom.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// Enum that specifies when a float negation is beneficial.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// Enum that specifies when a float negation is beneficial.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  enum class NegatibleCost {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  enum class NegatibleCost {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">    Cheaper = 0,    // Negated expression is cheaper.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">    Cheaper = 0,    // Negated expression is cheaper.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    Neutral = 1,    // Negated expression has the same cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    Neutral = 1,    // Negated expression has the same cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">    Expensive = 2   // Negated expression is more expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">    Expensive = 2   // Negated expression is more expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// Enum of different potentially desirable ways to fold (and/or (setcc ...),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// Enum of different potentially desirable ways to fold (and/or (setcc ...),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// (setcc ...)).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// (setcc ...)).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  enum AndOrSETCCFoldKind : uint8_t {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  enum AndOrSETCCFoldKind : uint8_t {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">    None = 0,   // No fold is preferable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">    None = 0,   // No fold is preferable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    AddAnd = 1, // Fold with `Add` op and `And` op is preferable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    AddAnd = 1, // Fold with `Add` op and `And` op is preferable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    NotAnd = 2, // Fold with `Not` op and `And` op is preferable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    NotAnd = 2, // Fold with `Not` op and `And` op is preferable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">    ABS = 4,    // Fold with `llvm.abs` op is preferable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">    ABS = 4,    // Fold with `llvm.abs` op is preferable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  class ArgListEntry {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  class ArgListEntry {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    Value *Val = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    Value *Val = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">    SDValue Node = SDValue();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">    SDValue Node = SDValue();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">    Type *Ty = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">    Type *Ty = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">    bool IsSExt : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">    bool IsSExt : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">    bool IsZExt : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">    bool IsZExt : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">    bool IsInReg : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">    bool IsInReg : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    bool IsSRet : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    bool IsSRet : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">    bool IsNest : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">    bool IsNest : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    bool IsByVal : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    bool IsByVal : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    bool IsByRef : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    bool IsByRef : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    bool IsInAlloca : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    bool IsInAlloca : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    bool IsPreallocated : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    bool IsPreallocated : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    bool IsReturned : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    bool IsReturned : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">    bool IsSwiftSelf : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">    bool IsSwiftSelf : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    bool IsSwiftAsync : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    bool IsSwiftAsync : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    bool IsSwiftError : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    bool IsSwiftError : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    bool IsCFGuardTarget : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    bool IsCFGuardTarget : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    MaybeAlign Alignment = std::nullopt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    MaybeAlign Alignment = std::nullopt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">    Type *IndirectType = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">    Type *IndirectType = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    ArgListEntry()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    ArgListEntry()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">        : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">        : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">          IsNest(false), IsByVal(false), IsByRef(false), IsInAlloca(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">          IsNest(false), IsByVal(false), IsByRef(false), IsInAlloca(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">          IsPreallocated(false), IsReturned(false), IsSwiftSelf(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">          IsPreallocated(false), IsReturned(false), IsSwiftSelf(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">          IsSwiftAsync(false), IsSwiftError(false), IsCFGuardTarget(false) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">          IsSwiftAsync(false), IsSwiftError(false), IsCFGuardTarget(false) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">    void setAttributes(const CallBase *Call, unsigned ArgIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">    void setAttributes(const CallBase *Call, unsigned ArgIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  using ArgListTy = std::vector<ArgListEntry>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  using ArgListTy = std::vector<ArgListEntry>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  virtual void markLibCallAttributes(MachineFunction *MF, unsigned CC,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  virtual void markLibCallAttributes(MachineFunction *MF, unsigned CC,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">                                     ArgListTy &Args) const {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">                                     ArgListTy &Args) const {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine coveredLine">  static ISD::NodeType getExtendForContent(BooleanContent Content) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">329</td>
    <td class="codeLine coveredLine">  static ISD::NodeType getExtendForContent(BooleanContent Content) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine coveredLine">    switch (Content) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">330</td>
    <td class="codeLine coveredLine">    switch (Content) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">    case UndefinedBooleanContent:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">    case UndefinedBooleanContent:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">      // Extend by adding rubbish bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">      // Extend by adding rubbish bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">      return ISD::ANY_EXTEND;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">      return ISD::ANY_EXTEND;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine coveredLine">    case ZeroOrOneBooleanContent:</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">334</td>
    <td class="codeLine coveredLine">    case ZeroOrOneBooleanContent:</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">      // Extend by adding zero bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">      // Extend by adding zero bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine coveredLine">      return ISD::ZERO_EXTEND;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">336</td>
    <td class="codeLine coveredLine">      return ISD::ZERO_EXTEND;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">    case ZeroOrNegativeOneBooleanContent:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">    case ZeroOrNegativeOneBooleanContent:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">      // Extend by copying the sign bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">      // Extend by copying the sign bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">      return ISD::SIGN_EXTEND;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">      return ISD::SIGN_EXTEND;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    llvm_unreachable("Invalid content kind");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    llvm_unreachable("Invalid content kind");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  explicit TargetLoweringBase(const TargetMachine &TM);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  explicit TargetLoweringBase(const TargetMachine &TM);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  TargetLoweringBase(const TargetLoweringBase &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  TargetLoweringBase(const TargetLoweringBase &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  TargetLoweringBase &operator=(const TargetLoweringBase &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  TargetLoweringBase &operator=(const TargetLoweringBase &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine coveredLine">  virtual ~TargetLoweringBase() = default;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">347</td>
    <td class="codeLine coveredLine">  virtual ~TargetLoweringBase() = default;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  /// Return true if the target support strict float operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  /// Return true if the target support strict float operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine coveredLine">  bool isStrictFPEnabled() const {</td>
    <td class="lineNumber">28</td>
    <td class="lineNumber">350</td>
    <td class="codeLine coveredLine">  bool isStrictFPEnabled() const {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine coveredLine">    return IsStrictFPEnabled;</td>
    <td class="lineNumber">28</td>
    <td class="lineNumber">351</td>
    <td class="codeLine coveredLine">    return IsStrictFPEnabled;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  /// Initialize all of the actions to default values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  /// Initialize all of the actions to default values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  void initActions();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  void initActions();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  const TargetMachine &getTargetMachine() const { return TM; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  const TargetMachine &getTargetMachine() const { return TM; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">  virtual bool useSoftFloat() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">  virtual bool useSoftFloat() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// Return the pointer type for the given address space, defaults to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// Return the pointer type for the given address space, defaults to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  /// the pointer type from the data layout.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  /// the pointer type from the data layout.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// FIXME: The default needs to be removed once all the code is updated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// FIXME: The default needs to be removed once all the code is updated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine coveredLine">  virtual MVT getPointerTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">366</td>
    <td class="codeLine coveredLine">  virtual MVT getPointerTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td class="lineNumber">7</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine coveredLine">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">367</td>
    <td class="codeLine coveredLine">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td class="lineNumber">7</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// Return the in-memory pointer type for the given address space, defaults to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// Return the in-memory pointer type for the given address space, defaults to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// the pointer type from the data layout.  FIXME: The default needs to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// the pointer type from the data layout.  FIXME: The default needs to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  /// removed once all the code is updated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  /// removed once all the code is updated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  virtual MVT getPointerMemTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  virtual MVT getPointerMemTy(const DataLayout &DL, uint32_t AS = 0) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">  /// Return the type for frame index, which is determined by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">  /// Return the type for frame index, which is determined by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">  /// the alloca address space specified through the data layout.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">  /// the alloca address space specified through the data layout.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  MVT getFrameIndexTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  MVT getFrameIndexTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">    return getPointerTy(DL, DL.getAllocaAddrSpace());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">    return getPointerTy(DL, DL.getAllocaAddrSpace());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  /// Return the type for code pointers, which is determined by the program</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  /// Return the type for code pointers, which is determined by the program</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  /// address space specified through the data layout.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  /// address space specified through the data layout.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  MVT getProgramPointerTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  MVT getProgramPointerTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    return getPointerTy(DL, DL.getProgramAddressSpace());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    return getPointerTy(DL, DL.getProgramAddressSpace());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// Return the type for operands of fence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// Return the type for operands of fence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  /// TODO: Let fence operands be of i32 type and remove this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  /// TODO: Let fence operands be of i32 type and remove this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  virtual MVT getFenceOperandTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  virtual MVT getFenceOperandTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    return getPointerTy(DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    return getPointerTy(DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// Return the type to use for a scalar shift opcode, given the shifted amount</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// Return the type to use for a scalar shift opcode, given the shifted amount</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  /// type. Targets should return a legal type if the input type is legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  /// type. Targets should return a legal type if the input type is legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// Targets can return a type that is too small if the input type is illegal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// Targets can return a type that is too small if the input type is illegal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  virtual MVT getScalarShiftAmountTy(const DataLayout &, EVT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  virtual MVT getScalarShiftAmountTy(const DataLayout &, EVT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  /// Returns the type for the shift amount of a shift opcode. For vectors,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  /// Returns the type for the shift amount of a shift opcode. For vectors,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  /// returns the input type. For scalars, behavior depends on \p LegalTypes. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  /// returns the input type. For scalars, behavior depends on \p LegalTypes. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  /// \p LegalTypes is true, calls getScalarShiftAmountTy, otherwise uses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  /// \p LegalTypes is true, calls getScalarShiftAmountTy, otherwise uses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// pointer type. If getScalarShiftAmountTy or pointer type cannot represent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// pointer type. If getScalarShiftAmountTy or pointer type cannot represent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// all possible shift amounts, returns MVT::i32. In general, \p LegalTypes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// all possible shift amounts, returns MVT::i32. In general, \p LegalTypes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  /// should be set to true for calls during type legalization and after type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  /// should be set to true for calls during type legalization and after type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  /// legalization has been completed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  /// legalization has been completed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  EVT getShiftAmountTy(EVT LHSTy, const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  EVT getShiftAmountTy(EVT LHSTy, const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">                       bool LegalTypes = true) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">                       bool LegalTypes = true) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// Return the preferred type to use for a shift opcode, given the shifted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// Return the preferred type to use for a shift opcode, given the shifted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// amount type is \p ShiftValueTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// amount type is \p ShiftValueTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  LLVM_READONLY</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  LLVM_READONLY</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  virtual LLT getPreferredShiftAmountTy(LLT ShiftValueTy) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  virtual LLT getPreferredShiftAmountTy(LLT ShiftValueTy) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">    return ShiftValueTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">    return ShiftValueTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  /// Returns the type to be used for the index operand of:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  /// Returns the type to be used for the index operand of:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  /// ISD::INSERT_VECTOR_ELT, ISD::EXTRACT_VECTOR_ELT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  /// ISD::INSERT_VECTOR_ELT, ISD::EXTRACT_VECTOR_ELT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// ISD::INSERT_SUBVECTOR, and ISD::EXTRACT_SUBVECTOR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// ISD::INSERT_SUBVECTOR, and ISD::EXTRACT_SUBVECTOR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  virtual MVT getVectorIdxTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  virtual MVT getVectorIdxTy(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">    return getPointerTy(DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">    return getPointerTy(DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// Returns the type to be used for the EVL/AVL operand of VP nodes:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// Returns the type to be used for the EVL/AVL operand of VP nodes:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  /// ISD::VP_ADD, ISD::VP_SUB, etc. It must be a legal scalar integer type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  /// ISD::VP_ADD, ISD::VP_SUB, etc. It must be a legal scalar integer type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// and must be at least as large as i32. The EVL is implicitly zero-extended</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// and must be at least as large as i32. The EVL is implicitly zero-extended</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// to any larger type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// to any larger type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  virtual MVT getVPExplicitVectorLengthTy() const { return MVT::i32; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  virtual MVT getVPExplicitVectorLengthTy() const { return MVT::i32; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// This callback is used to inspect load/store instructions and add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// This callback is used to inspect load/store instructions and add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  /// target-specific MachineMemOperand flags to them.  The default</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  /// target-specific MachineMemOperand flags to them.  The default</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  /// implementation does nothing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  /// implementation does nothing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine coveredLine">  virtual MachineMemOperand::Flags getTargetMMOFlags(const Instruction &I) const {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">433</td>
    <td class="codeLine coveredLine">  virtual MachineMemOperand::Flags getTargetMMOFlags(const Instruction &I) const {</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine coveredLine">    return MachineMemOperand::MONone;</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">434</td>
    <td class="codeLine coveredLine">    return MachineMemOperand::MONone;</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  /// This callback is used to inspect load/store SDNode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  /// This callback is used to inspect load/store SDNode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  /// The default implementation does nothing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  /// The default implementation does nothing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  virtual MachineMemOperand::Flags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  virtual MachineMemOperand::Flags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  getTargetMMOFlags(const MemSDNode &Node) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  getTargetMMOFlags(const MemSDNode &Node) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">    return MachineMemOperand::MONone;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">    return MachineMemOperand::MONone;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  MachineMemOperand::Flags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  MachineMemOperand::Flags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  getLoadMemOperandFlags(const LoadInst &LI, const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  getLoadMemOperandFlags(const LoadInst &LI, const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">                         AssumptionCache *AC = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">                         AssumptionCache *AC = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">                         const TargetLibraryInfo *LibInfo = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">                         const TargetLibraryInfo *LibInfo = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  MachineMemOperand::Flags getStoreMemOperandFlags(const StoreInst &SI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  MachineMemOperand::Flags getStoreMemOperandFlags(const StoreInst &SI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">                                                   const DataLayout &DL) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">                                                   const DataLayout &DL) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  MachineMemOperand::Flags getAtomicMemOperandFlags(const Instruction &AI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  MachineMemOperand::Flags getAtomicMemOperandFlags(const Instruction &AI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">                                                    const DataLayout &DL) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">                                                    const DataLayout &DL) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  virtual bool isSelectSupported(SelectSupportKind /*kind*/) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  virtual bool isSelectSupported(SelectSupportKind /*kind*/) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  /// Return true if the @llvm.get.active.lane.mask intrinsic should be expanded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  /// Return true if the @llvm.get.active.lane.mask intrinsic should be expanded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// using generic code in SelectionDAGBuilder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// using generic code in SelectionDAGBuilder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  virtual bool shouldExpandGetActiveLaneMask(EVT VT, EVT OpVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  virtual bool shouldExpandGetActiveLaneMask(EVT VT, EVT OpVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  virtual bool shouldExpandGetVectorLength(EVT CountVT, unsigned VF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  virtual bool shouldExpandGetVectorLength(EVT CountVT, unsigned VF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">                                           bool IsScalable) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">                                           bool IsScalable) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  // Return true if op(vecreduce(x), vecreduce(y)) should be reassociated to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  // Return true if op(vecreduce(x), vecreduce(y)) should be reassociated to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  // vecreduce(op(x, y)) for the reduction opcode RedOpc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  // vecreduce(op(x, y)) for the reduction opcode RedOpc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  virtual bool shouldReassociateReduction(unsigned RedOpc, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  virtual bool shouldReassociateReduction(unsigned RedOpc, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  /// Return true if it is profitable to convert a select of FP constants into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  /// Return true if it is profitable to convert a select of FP constants into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  /// a constant pool load whose address depends on the select condition. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  /// a constant pool load whose address depends on the select condition. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  /// parameter may be used to differentiate a select with FP compare from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  /// parameter may be used to differentiate a select with FP compare from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  /// integer compare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  /// integer compare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  virtual bool reduceSelectOfFPConstantLoads(EVT CmpOpVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  virtual bool reduceSelectOfFPConstantLoads(EVT CmpOpVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  /// Return true if multiple condition registers are available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  /// Return true if multiple condition registers are available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">  bool hasMultipleConditionRegisters() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">  bool hasMultipleConditionRegisters() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">    return HasMultipleConditionRegisters;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">    return HasMultipleConditionRegisters;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  /// Return true if the target has BitExtract instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  /// Return true if the target has BitExtract instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  bool hasExtractBitsInsn() const { return HasExtractBitsInsn; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  bool hasExtractBitsInsn() const { return HasExtractBitsInsn; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// Return the preferred vector type legalization action.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// Return the preferred vector type legalization action.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  virtual TargetLoweringBase::LegalizeTypeAction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  virtual TargetLoweringBase::LegalizeTypeAction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine coveredLine">  getPreferredVectorAction(MVT VT) const {</td>
    <td class="lineNumber">855</td>
    <td class="lineNumber">492</td>
    <td class="codeLine coveredLine">  getPreferredVectorAction(MVT VT) const {</td>
    <td class="lineNumber">855</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">    // The default action for one element vectors is to scalarize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">    // The default action for one element vectors is to scalarize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine coveredLine">    if (VT.getVectorElementCount().isScalar())</td>
    <td class="lineNumber">855</td>
    <td class="lineNumber">494</td>
    <td class="codeLine coveredLine">    if (VT.getVectorElementCount().isScalar())</td>
    <td class="lineNumber">855</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine coveredLine">      return TypeScalarizeVector;</td>
    <td class="lineNumber">45</td>
    <td class="lineNumber">495</td>
    <td class="codeLine coveredLine">      return TypeScalarizeVector;</td>
    <td class="lineNumber">45</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">    // The default action for an odd-width vector is to widen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">    // The default action for an odd-width vector is to widen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine coveredLine">    if (!VT.isPow2VectorType())</td>
    <td class="lineNumber">810</td>
    <td class="lineNumber">497</td>
    <td class="codeLine coveredLine">    if (!VT.isPow2VectorType())</td>
    <td class="lineNumber">810</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine coveredLine">      return TypeWidenVector;</td>
    <td class="lineNumber">105</td>
    <td class="lineNumber">498</td>
    <td class="codeLine coveredLine">      return TypeWidenVector;</td>
    <td class="lineNumber">105</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    // The default action for other vectors is to promote</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    // The default action for other vectors is to promote</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine coveredLine">    return TypePromoteInteger;</td>
    <td class="lineNumber">705</td>
    <td class="lineNumber">500</td>
    <td class="codeLine coveredLine">    return TypePromoteInteger;</td>
    <td class="lineNumber">705</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  // Return true if the half type should be passed around as i16, but promoted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  // Return true if the half type should be passed around as i16, but promoted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  // to float around arithmetic. The default behavior is to pass around as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  // to float around arithmetic. The default behavior is to pass around as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  // float and convert around loads/stores/bitcasts and other places where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  // float and convert around loads/stores/bitcasts and other places where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  // the size matters.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  // the size matters.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine coveredLine">  virtual bool softPromoteHalfType() const { return false; }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">507</td>
    <td class="codeLine coveredLine">  virtual bool softPromoteHalfType() const { return false; }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  // There are two general methods for expanding a BUILD_VECTOR node:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  // There are two general methods for expanding a BUILD_VECTOR node:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  //  1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  //  1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  //     them together.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  //     them together.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  //  2. Build the vector on the stack and then load it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  //  2. Build the vector on the stack and then load it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  // If this function returns true, then method (1) will be used, subject to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  // If this function returns true, then method (1) will be used, subject to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  // the constraint that all of the necessary shuffles are legal (as determined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  // the constraint that all of the necessary shuffles are legal (as determined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  // by isShuffleMaskLegal). If this function returns false, then method (2) is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  // by isShuffleMaskLegal). If this function returns false, then method (2) is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  // always used. The vector type, and the number of defined values, are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  // always used. The vector type, and the number of defined values, are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  // provided.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  // provided.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  shouldExpandBuildVectorWithShuffles(EVT /* VT */,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  shouldExpandBuildVectorWithShuffles(EVT /* VT */,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">                                      unsigned DefinedValues) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">                                      unsigned DefinedValues) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">    return DefinedValues < 3;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">    return DefinedValues < 3;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// Return true if integer divide is usually cheaper than a sequence of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// Return true if integer divide is usually cheaper than a sequence of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  /// several shifts, adds, and multiplies for this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  /// several shifts, adds, and multiplies for this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// The definition of "cheaper" may depend on whether we're optimizing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// The definition of "cheaper" may depend on whether we're optimizing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// for speed or for size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// for speed or for size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  virtual bool isIntDivCheap(EVT VT, AttributeList Attr) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  virtual bool isIntDivCheap(EVT VT, AttributeList Attr) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// Return true if the target can handle a standalone remainder operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// Return true if the target can handle a standalone remainder operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  virtual bool hasStandaloneRem(EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  virtual bool hasStandaloneRem(EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  /// Return true if SQRT(X) shouldn't be replaced with X*RSQRT(X).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  /// Return true if SQRT(X) shouldn't be replaced with X*RSQRT(X).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  virtual bool isFsqrtCheap(SDValue X, SelectionDAG &DAG) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  virtual bool isFsqrtCheap(SDValue X, SelectionDAG &DAG) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">    // Default behavior is to replace SQRT(X) with X*RSQRT(X).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">    // Default behavior is to replace SQRT(X) with X*RSQRT(X).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  /// Reciprocal estimate status values used by the functions below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  /// Reciprocal estimate status values used by the functions below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  enum ReciprocalEstimate : int {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  enum ReciprocalEstimate : int {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">    Unspecified = -1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">    Unspecified = -1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">    Disabled = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">    Disabled = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">    Enabled = 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">    Enabled = 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// Return a ReciprocalEstimate enum value for a square root of the given type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// Return a ReciprocalEstimate enum value for a square root of the given type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  int getRecipEstimateSqrtEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  int getRecipEstimateSqrtEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  /// Return a ReciprocalEstimate enum value for a division of the given type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  /// Return a ReciprocalEstimate enum value for a division of the given type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// based on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">  int getRecipEstimateDivEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">  int getRecipEstimateDivEnabled(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">  /// Return the refinement step count for a square root of the given type based</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">  /// Return the refinement step count for a square root of the given type based</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  int getSqrtRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  int getSqrtRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  /// Return the refinement step count for a division of the given type based</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  /// Return the refinement step count for a division of the given type based</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  /// on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  /// on the function's attributes. If the operation is not overridden by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">  /// the function's attributes, "Unspecified" is returned and target defaults</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  /// are expected to be used for instruction selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  int getDivRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  int getDivRefinementSteps(EVT VT, MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">  /// Returns true if target has indicated at least one type should be bypassed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">  /// Returns true if target has indicated at least one type should be bypassed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  bool isSlowDivBypassed() const { return !BypassSlowDivWidths.empty(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  bool isSlowDivBypassed() const { return !BypassSlowDivWidths.empty(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  /// Returns map of slow types for division or remainder with corresponding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  /// Returns map of slow types for division or remainder with corresponding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// fast types</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// fast types</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  const DenseMap<unsigned int, unsigned int> &getBypassSlowDivWidths() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  const DenseMap<unsigned int, unsigned int> &getBypassSlowDivWidths() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    return BypassSlowDivWidths;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    return BypassSlowDivWidths;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  /// Return true only if vscale must be a power of two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  /// Return true only if vscale must be a power of two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">  virtual bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">  virtual bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// Return true if Flow Control is an expensive operation that should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// Return true if Flow Control is an expensive operation that should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// avoided.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// avoided.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">  bool isJumpExpensive() const { return JumpIsExpensive; }</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">  bool isJumpExpensive() const { return JumpIsExpensive; }</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">  /// Return true if selects are only cheaper than branches if the branch is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">  /// Return true if selects are only cheaper than branches if the branch is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  /// unlikely to be predicted right.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  /// unlikely to be predicted right.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  bool isPredictableSelectExpensive() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  bool isPredictableSelectExpensive() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    return PredictableSelectIsExpensive;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    return PredictableSelectIsExpensive;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  virtual bool fallBackToDAGISel(const Instruction &Inst) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  virtual bool fallBackToDAGISel(const Instruction &Inst) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// Return true if the following transform is beneficial:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// Return true if the following transform is beneficial:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  /// fold (conv (load x)) -> (load (conv*)x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  /// fold (conv (load x)) -> (load (conv*)x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  /// On architectures that don't natively support some vector loads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  /// On architectures that don't natively support some vector loads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  /// efficiently, casting the load to a smaller vector of larger types and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  /// efficiently, casting the load to a smaller vector of larger types and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// loading is more efficient, however, this can be undone by optimizations in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// loading is more efficient, however, this can be undone by optimizations in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// dag combiner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// dag combiner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  virtual bool isLoadBitCastBeneficial(EVT LoadVT, EVT BitcastVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  virtual bool isLoadBitCastBeneficial(EVT LoadVT, EVT BitcastVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">                                       const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">                                       const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">                                       const MachineMemOperand &MMO) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">                                       const MachineMemOperand &MMO) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  /// Return true if the following transform is beneficial:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  /// Return true if the following transform is beneficial:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  /// (store (y (conv x)), y*)) -> (store x, (x*))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  /// (store (y (conv x)), y*)) -> (store x, (x*))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  virtual bool isStoreBitCastBeneficial(EVT StoreVT, EVT BitcastVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  virtual bool isStoreBitCastBeneficial(EVT StoreVT, EVT BitcastVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">                                        const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">                                        const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">                                        const MachineMemOperand &MMO) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">                                        const MachineMemOperand &MMO) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">    // Default to the same logic as loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">    // Default to the same logic as loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">    return isLoadBitCastBeneficial(StoreVT, BitcastVT, DAG, MMO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">    return isLoadBitCastBeneficial(StoreVT, BitcastVT, DAG, MMO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// Return true if it is expected to be cheaper to do a store of vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// Return true if it is expected to be cheaper to do a store of vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  /// constant with the given size and type for the address space than to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  /// constant with the given size and type for the address space than to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  /// store the individual scalar element constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  /// store the individual scalar element constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  virtual bool storeOfVectorConstantIsCheap(bool IsZero, EVT MemVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  virtual bool storeOfVectorConstantIsCheap(bool IsZero, EVT MemVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">                                            unsigned NumElem,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">                                            unsigned NumElem,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">                                            unsigned AddrSpace) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">                                            unsigned AddrSpace) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">    return IsZero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">    return IsZero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// Allow store merging for the specified type after legalization in addition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// Allow store merging for the specified type after legalization in addition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  /// to before legalization. This may transform stores that do not exist</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  /// to before legalization. This may transform stores that do not exist</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  /// earlier (for example, stores created from intrinsics).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  /// earlier (for example, stores created from intrinsics).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine coveredLine">  virtual bool mergeStoresAfterLegalization(EVT MemVT) const {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">629</td>
    <td class="codeLine coveredLine">  virtual bool mergeStoresAfterLegalization(EVT MemVT) const {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">630</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  /// Returns if it's reasonable to merge stores to MemVT size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  /// Returns if it's reasonable to merge stores to MemVT size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  virtual bool canMergeStoresTo(unsigned AS, EVT MemVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  virtual bool canMergeStoresTo(unsigned AS, EVT MemVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">                                const MachineFunction &MF) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">                                const MachineFunction &MF) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  /// Return true if it is cheap to speculate a call to intrinsic cttz.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  /// Return true if it is cheap to speculate a call to intrinsic cttz.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  virtual bool isCheapToSpeculateCttz(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  virtual bool isCheapToSpeculateCttz(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  /// Return true if it is cheap to speculate a call to intrinsic ctlz.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  /// Return true if it is cheap to speculate a call to intrinsic ctlz.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  virtual bool isCheapToSpeculateCtlz(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  virtual bool isCheapToSpeculateCtlz(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// Return true if ctlz instruction is fast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// Return true if ctlz instruction is fast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  virtual bool isCtlzFast() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  virtual bool isCtlzFast() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  /// Return the maximum number of "x & (x - 1)" operations that can be done</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  /// Return the maximum number of "x & (x - 1)" operations that can be done</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  /// instead of deferring to a custom CTPOP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  /// instead of deferring to a custom CTPOP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  virtual unsigned getCustomCtpopCost(EVT VT, ISD::CondCode Cond) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  virtual unsigned getCustomCtpopCost(EVT VT, ISD::CondCode Cond) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">    return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">    return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  /// Return true if instruction generated for equality comparison is folded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  /// Return true if instruction generated for equality comparison is folded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  /// with instruction generated for signed comparison.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  /// with instruction generated for signed comparison.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  virtual bool isEqualityCmpFoldedWithSignedCmp() const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  virtual bool isEqualityCmpFoldedWithSignedCmp() const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  /// Return true if the heuristic to prefer icmp eq zero should be used in code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  /// Return true if the heuristic to prefer icmp eq zero should be used in code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  /// gen prepare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  /// gen prepare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  virtual bool preferZeroCompareBranch() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  virtual bool preferZeroCompareBranch() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  /// Return true if it is cheaper to split the store of a merged int val</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  /// Return true if it is cheaper to split the store of a merged int val</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  /// from a pair of smaller values into multiple stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  /// from a pair of smaller values into multiple stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  virtual bool isMultiStoresCheaperThanBitsMerge(EVT LTy, EVT HTy) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  virtual bool isMultiStoresCheaperThanBitsMerge(EVT LTy, EVT HTy) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  /// Return if the target supports combining a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  /// Return if the target supports combining a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  /// chain like:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  /// chain like:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  /// \code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  /// \code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  ///   %andResult = and %val1, #mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  ///   %andResult = and %val1, #mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  ///   %icmpResult = icmp %andResult, 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  ///   %icmpResult = icmp %andResult, 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  /// into a single machine instruction of a form like:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  /// into a single machine instruction of a form like:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// \code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// \code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  ///   cc = test %register, #mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  ///   cc = test %register, #mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  virtual bool isMaskAndCmp0FoldingBeneficial(const Instruction &AndI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  virtual bool isMaskAndCmp0FoldingBeneficial(const Instruction &AndI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  /// Return true if it is valid to merge the TargetMMOFlags in two SDNodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  /// Return true if it is valid to merge the TargetMMOFlags in two SDNodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  areTwoSDNodeTargetMMOFlagsMergeable(const MemSDNode &NodeX,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  areTwoSDNodeTargetMMOFlagsMergeable(const MemSDNode &NodeX,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">                                      const MemSDNode &NodeY) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">                                      const MemSDNode &NodeY) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// Use bitwise logic to make pairs of compares more efficient. For example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// Use bitwise logic to make pairs of compares more efficient. For example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">  /// This should be true when it takes more than one instruction to lower</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">  /// This should be true when it takes more than one instruction to lower</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  virtual bool convertSetCCLogicToBitwiseLogic(EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  virtual bool convertSetCCLogicToBitwiseLogic(EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  /// Return the preferred operand type if the target has a quick way to compare</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  /// Return the preferred operand type if the target has a quick way to compare</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  /// integer values of the given size. Assume that any legal integer type can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  /// integer values of the given size. Assume that any legal integer type can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// be compared efficiently. Targets may override this to allow illegal wide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// be compared efficiently. Targets may override this to allow illegal wide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  /// types to return a vector type if there is support to compare that type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  /// types to return a vector type if there is support to compare that type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  virtual MVT hasFastEqualityCompare(unsigned NumBits) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  virtual MVT hasFastEqualityCompare(unsigned NumBits) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">    MVT VT = MVT::getIntegerVT(NumBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">    MVT VT = MVT::getIntegerVT(NumBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">    return isTypeLegal(VT) ? VT : MVT::INVALID_SIMPLE_VALUE_TYPE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">    return isTypeLegal(VT) ? VT : MVT::INVALID_SIMPLE_VALUE_TYPE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Return true if the target should transform:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Return true if the target should transform:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// (X & Y) == Y ---> (~X & Y) == 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// (X & Y) == Y ---> (~X & Y) == 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">  /// (X & Y) != Y ---> (~X & Y) != 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">  /// (X & Y) != Y ---> (~X & Y) != 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  /// This may be profitable if the target has a bitwise and-not operation that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  /// This may be profitable if the target has a bitwise and-not operation that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  /// sets comparison flags. A target may want to limit the transformation based</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  /// sets comparison flags. A target may want to limit the transformation based</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  /// on the type of Y or if Y is a constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  /// on the type of Y or if Y is a constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  /// Note that the transform will not occur if Y is known to be a power-of-2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  /// Note that the transform will not occur if Y is known to be a power-of-2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  /// because a mask and compare of a single bit can be handled by inverting the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  /// because a mask and compare of a single bit can be handled by inverting the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  /// predicate, for example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  /// predicate, for example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">  /// (X & 8) == 8 ---> (X & 8) != 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">  /// (X & 8) == 8 ---> (X & 8) != 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  virtual bool hasAndNotCompare(SDValue Y) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  virtual bool hasAndNotCompare(SDValue Y) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// Return true if the target has a bitwise and-not operation:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// Return true if the target has a bitwise and-not operation:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// X = ~A & B</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// X = ~A & B</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// This can be used to simplify select or other instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// This can be used to simplify select or other instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  virtual bool hasAndNot(SDValue X) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  virtual bool hasAndNot(SDValue X) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    // If the target has the more complex version of this operation, assume that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    // If the target has the more complex version of this operation, assume that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    // it has this operation too.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    // it has this operation too.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    return hasAndNotCompare(X);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    return hasAndNotCompare(X);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Return true if the target has a bit-test instruction:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Return true if the target has a bit-test instruction:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  ///   (X & (1 << Y)) ==/!= 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  ///   (X & (1 << Y)) ==/!= 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  /// This knowledge can be used to prevent breaking the pattern,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  /// This knowledge can be used to prevent breaking the pattern,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  /// or creating it if it could be recognized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  /// or creating it if it could be recognized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">  virtual bool hasBitTest(SDValue X, SDValue Y) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">  virtual bool hasBitTest(SDValue X, SDValue Y) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  /// There are two ways to clear extreme bits (either low or high):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  /// There are two ways to clear extreme bits (either low or high):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  /// Mask:    x &  (-1 << y)  (the instcombine canonical form)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  /// Mask:    x &  (-1 << y)  (the instcombine canonical form)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  /// Shifts:  x >> y << y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  /// Shifts:  x >> y << y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// Return true if the variant with 2 variable shifts is preferred.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// Return true if the variant with 2 variable shifts is preferred.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  /// Return false if there is no preference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  /// Return false if there is no preference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  virtual bool shouldFoldMaskToVariableShiftPair(SDValue X) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  virtual bool shouldFoldMaskToVariableShiftPair(SDValue X) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    // By default, let's assume that no one prefers shifts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    // By default, let's assume that no one prefers shifts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">  /// Return true if it is profitable to fold a pair of shifts into a mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">  /// Return true if it is profitable to fold a pair of shifts into a mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// This is usually true on most targets. But some targets, like Thumb1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// This is usually true on most targets. But some targets, like Thumb1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// have immediate shift instructions, but no immediate "and" instruction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// have immediate shift instructions, but no immediate "and" instruction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  /// this makes the fold unprofitable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  /// this makes the fold unprofitable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  virtual bool shouldFoldConstantShiftPairToMask(const SDNode *N,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  virtual bool shouldFoldConstantShiftPairToMask(const SDNode *N,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">                                                 CombineLevel Level) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">                                                 CombineLevel Level) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  /// Should we tranform the IR-optimal check for whether given truncation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  /// Should we tranform the IR-optimal check for whether given truncation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  /// down into KeptBits would be truncating or not:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  /// down into KeptBits would be truncating or not:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">  ///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">  ///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">  /// Into it's more traditional form:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">  /// Into it's more traditional form:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  ///   ((%x << C) a>> C) dstcond %x</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  ///   ((%x << C) a>> C) dstcond %x</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  /// Return true if we should transform.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  /// Return true if we should transform.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// Return false if there is no preference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// Return false if there is no preference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  virtual bool shouldTransformSignedTruncationCheck(EVT XVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  virtual bool shouldTransformSignedTruncationCheck(EVT XVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">                                                    unsigned KeptBits) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">                                                    unsigned KeptBits) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    // By default, let's assume that no one prefers shifts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    // By default, let's assume that no one prefers shifts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  /// Given the pattern</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  /// Given the pattern</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  ///   (X & (C l>>/<< Y)) ==/!= 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  ///   (X & (C l>>/<< Y)) ==/!= 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">  /// return true if it should be transformed into:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">  /// return true if it should be transformed into:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  ///   ((X <</l>> Y) & C) ==/!= 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  ///   ((X <</l>> Y) & C) ==/!= 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">  /// WARNING: if 'X' is a constant, the fold may deadlock!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">  /// WARNING: if 'X' is a constant, the fold may deadlock!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  ///        here because it can end up being not linked in.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  ///        here because it can end up being not linked in.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  virtual bool shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  virtual bool shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">      SDValue X, ConstantSDNode *XC, ConstantSDNode *CC, SDValue Y,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">      SDValue X, ConstantSDNode *XC, ConstantSDNode *CC, SDValue Y,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">      unsigned OldShiftOpcode, unsigned NewShiftOpcode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">      unsigned OldShiftOpcode, unsigned NewShiftOpcode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">      SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">      SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    if (hasBitTest(X, Y)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    if (hasBitTest(X, Y)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">      // One interesting pattern that we'd want to form is 'bit test':</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">      // One interesting pattern that we'd want to form is 'bit test':</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">      //   ((1 << Y) & C) ==/!= 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">      //   ((1 << Y) & C) ==/!= 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">      // But we also need to be careful not to try to reverse that fold.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">      // But we also need to be careful not to try to reverse that fold.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">      // Is this '1 << Y' ?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">      // Is this '1 << Y' ?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">      if (OldShiftOpcode == ISD::SHL && CC->isOne())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">      if (OldShiftOpcode == ISD::SHL && CC->isOne())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">        return false; // Keep the 'bit test' pattern.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">        return false; // Keep the 'bit test' pattern.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">      // Will it be '1 << Y' after the transform ?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">      // Will it be '1 << Y' after the transform ?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">      if (XC && NewShiftOpcode == ISD::SHL && XC->isOne())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">      if (XC && NewShiftOpcode == ISD::SHL && XC->isOne())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">        return true; // Do form the 'bit test' pattern.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">        return true; // Do form the 'bit test' pattern.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">    // If 'X' is a constant, and we transform, then we will immediately</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">    // If 'X' is a constant, and we transform, then we will immediately</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">    // try to undo the fold, thus causing endless combine loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">    // try to undo the fold, thus causing endless combine loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">    // So by default, let's assume everyone prefers the fold</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">    // So by default, let's assume everyone prefers the fold</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">    // iff 'X' is not a constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">    // iff 'X' is not a constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">    return !XC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">    return !XC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  /// These two forms are equivalent:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  /// These two forms are equivalent:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  ///   sub %y, (xor %x, -1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  ///   sub %y, (xor %x, -1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  ///   add (add %x, 1), %y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  ///   add (add %x, 1), %y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// The variant with two add's is IR-canonical.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// The variant with two add's is IR-canonical.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// Some targets may prefer one to the other.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// Some targets may prefer one to the other.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine coveredLine">  virtual bool preferIncOfAddToSubOfNot(EVT VT) const {</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">813</td>
    <td class="codeLine coveredLine">  virtual bool preferIncOfAddToSubOfNot(EVT VT) const {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">    // By default, let's assume that everyone prefers the form with two add's.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">    // By default, let's assume that everyone prefers the form with two add's.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">815</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  // By default prefer folding (abs (sub nsw x, y)) -> abds(x, y). Some targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  // By default prefer folding (abs (sub nsw x, y)) -> abds(x, y). Some targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  // may want to avoid this to prevent loss of sub_nsw pattern.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  // may want to avoid this to prevent loss of sub_nsw pattern.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  virtual bool preferABDSToABSWithNSW(EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  virtual bool preferABDSToABSWithNSW(EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  // Return true if the target wants to transform Op(Splat(X)) -> Splat(Op(X))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  // Return true if the target wants to transform Op(Splat(X)) -> Splat(Op(X))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  virtual bool preferScalarizeSplat(SDNode *N) const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  virtual bool preferScalarizeSplat(SDNode *N) const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  /// Return true if the target wants to use the optimization that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  /// Return true if the target wants to use the optimization that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  /// turns ext(promotableInst1(...(promotableInstN(load)))) into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  /// turns ext(promotableInst1(...(promotableInstN(load)))) into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  /// promotedInst1(...(promotedInstN(ext(load)))).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  /// promotedInst1(...(promotedInstN(ext(load)))).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  bool enableExtLdPromotion() const { return EnableExtLdPromotion; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  bool enableExtLdPromotion() const { return EnableExtLdPromotion; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  /// Return true if the target can combine store(extractelement VectorTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  /// Return true if the target can combine store(extractelement VectorTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  /// Idx).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  /// Idx).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  /// \p Cost[out] gives the cost of that transformation when this is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  /// \p Cost[out] gives the cost of that transformation when this is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  virtual bool canCombineStoreAndExtract(Type *VectorTy, Value *Idx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  virtual bool canCombineStoreAndExtract(Type *VectorTy, Value *Idx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">                                         unsigned &Cost) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">                                         unsigned &Cost) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  /// Return true if inserting a scalar into a variable element of an undef</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  /// Return true if inserting a scalar into a variable element of an undef</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  /// vector is more efficiently handled by splatting the scalar instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  /// vector is more efficiently handled by splatting the scalar instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  virtual bool shouldSplatInsEltVarIndex(EVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  virtual bool shouldSplatInsEltVarIndex(EVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  /// Return true if target always benefits from combining into FMA for a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  /// Return true if target always benefits from combining into FMA for a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// given value type. This must typically return false on targets where FMA</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// given value type. This must typically return false on targets where FMA</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  /// takes more cycles to execute than FADD.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  /// takes more cycles to execute than FADD.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  virtual bool enableAggressiveFMAFusion(EVT VT) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  virtual bool enableAggressiveFMAFusion(EVT VT) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// Return true if target always benefits from combining into FMA for a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// Return true if target always benefits from combining into FMA for a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  /// given value type. This must typically return false on targets where FMA</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  /// given value type. This must typically return false on targets where FMA</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// takes more cycles to execute than FADD.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// takes more cycles to execute than FADD.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  virtual bool enableAggressiveFMAFusion(LLT Ty) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  virtual bool enableAggressiveFMAFusion(LLT Ty) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  /// Return the ValueType of the result of SETCC operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  /// Return the ValueType of the result of SETCC operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  virtual EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  virtual EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">                                 EVT VT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">                                 EVT VT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  /// Return the ValueType for comparison libcalls. Comparison libcalls include</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  /// Return the ValueType for comparison libcalls. Comparison libcalls include</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// floating point comparison calls, and Ordered/Unordered check calls on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// floating point comparison calls, and Ordered/Unordered check calls on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  /// floating point numbers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  /// floating point numbers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  virtual</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  virtual</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  MVT::SimpleValueType getCmpLibcallReturnType() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  MVT::SimpleValueType getCmpLibcallReturnType() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  /// For targets without i1 registers, this gives the nature of the high-bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  /// For targets without i1 registers, this gives the nature of the high-bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  /// of boolean values held in types wider than i1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  /// of boolean values held in types wider than i1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// "Boolean values" are special true/false values produced by nodes like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// "Boolean values" are special true/false values produced by nodes like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  /// Not to be confused with general values promoted from i1.  Some cpus</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  /// Not to be confused with general values promoted from i1.  Some cpus</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  /// distinguish between vectors of boolean and scalars; the isVec parameter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  /// distinguish between vectors of boolean and scalars; the isVec parameter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  /// selects between the two kinds.  For example on X86 a scalar boolean should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  /// selects between the two kinds.  For example on X86 a scalar boolean should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  /// be zero extended from i1, while the elements of a vector of booleans</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  /// be zero extended from i1, while the elements of a vector of booleans</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// should be sign extended from i1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// should be sign extended from i1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  /// Some cpus also treat floating point types the same way as they treat</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  /// Some cpus also treat floating point types the same way as they treat</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// vectors instead of the way they treat scalars.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// vectors instead of the way they treat scalars.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine coveredLine">  BooleanContent getBooleanContents(bool isVec, bool isFloat) const {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">879</td>
    <td class="codeLine coveredLine">  BooleanContent getBooleanContents(bool isVec, bool isFloat) const {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine coveredLine">    if (isVec)</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">880</td>
    <td class="codeLine coveredLine">    if (isVec)</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">      return BooleanVectorContents;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">      return BooleanVectorContents;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine coveredLine">    return isFloat ? BooleanFloatContents : BooleanContents;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">882</td>
    <td class="codeLine coveredLine">    return isFloat ? BooleanFloatContents : BooleanContents;</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine coveredLine">  BooleanContent getBooleanContents(EVT Type) const {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">885</td>
    <td class="codeLine coveredLine">  BooleanContent getBooleanContents(EVT Type) const {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine coveredLine">    return getBooleanContents(Type.isVector(), Type.isFloatingPoint());</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">886</td>
    <td class="codeLine coveredLine">    return getBooleanContents(Type.isVector(), Type.isFloatingPoint());</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">  /// Promote the given target boolean to a target boolean of the given type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">  /// Promote the given target boolean to a target boolean of the given type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">  /// A target boolean is an integer value, not necessarily of type i1, the bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">  /// A target boolean is an integer value, not necessarily of type i1, the bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  /// of which conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  /// of which conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  /// ValVT is the type of values that produced the boolean.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  /// ValVT is the type of values that produced the boolean.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine coveredLine">  SDValue promoteTargetBoolean(SelectionDAG &DAG, SDValue Bool,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">894</td>
    <td class="codeLine coveredLine">  SDValue promoteTargetBoolean(SelectionDAG &DAG, SDValue Bool,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">                               EVT ValVT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">                               EVT ValVT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine coveredLine">    SDLoc dl(Bool);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">896</td>
    <td class="codeLine coveredLine">    SDLoc dl(Bool);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">    EVT BoolVT =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">    EVT BoolVT =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine coveredLine">        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), ValVT);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">898</td>
    <td class="codeLine coveredLine">        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), ValVT);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine coveredLine">    ISD::NodeType ExtendCode = getExtendForContent(getBooleanContents(ValVT));</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">899</td>
    <td class="codeLine coveredLine">    ISD::NodeType ExtendCode = getExtendForContent(getBooleanContents(ValVT));</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine coveredLine">    return DAG.getNode(ExtendCode, dl, BoolVT, Bool);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">900</td>
    <td class="codeLine coveredLine">    return DAG.getNode(ExtendCode, dl, BoolVT, Bool);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">901</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  /// Return target scheduling preference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  /// Return target scheduling preference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">  Sched::Preference getSchedulingPreference() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">  Sched::Preference getSchedulingPreference() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">    return SchedPreferenceInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">    return SchedPreferenceInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  /// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  /// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">  /// for different nodes. This function returns the preference (or none) for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">  /// for different nodes. This function returns the preference (or none) for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  /// the given node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  /// the given node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine coveredLine">  virtual Sched::Preference getSchedulingPreference(SDNode *) const {</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">911</td>
    <td class="codeLine coveredLine">  virtual Sched::Preference getSchedulingPreference(SDNode *) const {</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine coveredLine">    return Sched::None;</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">912</td>
    <td class="codeLine coveredLine">    return Sched::None;</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// Return the register class that should be used for the specified value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// Return the register class that should be used for the specified value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine coveredLine">  virtual const TargetRegisterClass *getRegClassFor(MVT VT, bool isDivergent = false) const {</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">917</td>
    <td class="codeLine coveredLine">  virtual const TargetRegisterClass *getRegClassFor(MVT VT, bool isDivergent = false) const {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">    (void)isDivergent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">    (void)isDivergent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine coveredLine">    const TargetRegisterClass *RC = RegClassForVT[VT.SimpleTy];</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">919</td>
    <td class="codeLine coveredLine">    const TargetRegisterClass *RC = RegClassForVT[VT.SimpleTy];</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine coveredLine">    assert(RC && "This value type is not natively supported!");</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">920</td>
    <td class="codeLine coveredLine">    assert(RC && "This value type is not natively supported!");</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine coveredLine">    return RC;</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">921</td>
    <td class="codeLine coveredLine">    return RC;</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// Allows target to decide about the register class of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// Allows target to decide about the register class of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  /// specific value that is live outside the defining block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  /// specific value that is live outside the defining block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  /// Returns true if the value needs uniform register class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  /// Returns true if the value needs uniform register class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">  virtual bool requiresUniformRegister(MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">  virtual bool requiresUniformRegister(MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">                                       const Value *) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">                                       const Value *) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// Return the 'representative' register class for the specified value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// Return the 'representative' register class for the specified value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">  /// The 'representative' register class is the largest legal super-reg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">  /// The 'representative' register class is the largest legal super-reg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">  /// register class for the register class of the value type.  For example, on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">  /// register class for the register class of the value type.  For example, on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  /// i386 the rep register class for i8, i16, and i32 are GR32; while the rep</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  /// i386 the rep register class for i8, i16, and i32 are GR32; while the rep</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  /// register class is GR64 on x86_64.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  /// register class is GR64 on x86_64.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  virtual const TargetRegisterClass *getRepRegClassFor(MVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  virtual const TargetRegisterClass *getRepRegClassFor(MVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">    const TargetRegisterClass *RC = RepRegClassForVT[VT.SimpleTy];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">    const TargetRegisterClass *RC = RepRegClassForVT[VT.SimpleTy];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">    return RC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">    return RC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// Return the cost of the 'representative' register class for the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// Return the cost of the 'representative' register class for the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// value type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// value type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  virtual uint8_t getRepRegClassCostFor(MVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  virtual uint8_t getRepRegClassCostFor(MVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">    return RepRegClassCostForVT[VT.SimpleTy];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">    return RepRegClassCostForVT[VT.SimpleTy];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  /// Return the preferred strategy to legalize tihs SHIFT instruction, with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  /// Return the preferred strategy to legalize tihs SHIFT instruction, with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">  /// \p ExpansionFactor being the recursion depth - how many expansion needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">  /// \p ExpansionFactor being the recursion depth - how many expansion needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">  enum class ShiftLegalizationStrategy {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">  enum class ShiftLegalizationStrategy {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">    ExpandToParts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">    ExpandToParts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">    ExpandThroughStack,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">    ExpandThroughStack,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    LowerToLibcall</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    LowerToLibcall</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  virtual ShiftLegalizationStrategy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  virtual ShiftLegalizationStrategy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  preferredShiftLegalizationStrategy(SelectionDAG &DAG, SDNode *N,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  preferredShiftLegalizationStrategy(SelectionDAG &DAG, SDNode *N,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">                                     unsigned ExpansionFactor) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">                                     unsigned ExpansionFactor) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">    if (ExpansionFactor == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">    if (ExpansionFactor == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">      return ShiftLegalizationStrategy::ExpandToParts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">      return ShiftLegalizationStrategy::ExpandToParts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">    return ShiftLegalizationStrategy::ExpandThroughStack;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">    return ShiftLegalizationStrategy::ExpandThroughStack;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">  /// Return true if the target has native support for the specified value type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">  /// Return true if the target has native support for the specified value type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// This means that it has a register that directly holds it without</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// This means that it has a register that directly holds it without</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// promotions or expansions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// promotions or expansions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine coveredLine">  bool isTypeLegal(EVT VT) const {</td>
    <td class="lineNumber">10351</td>
    <td class="lineNumber">968</td>
    <td class="codeLine coveredLine">  bool isTypeLegal(EVT VT) const {</td>
    <td class="lineNumber">10351</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine coveredLine">    assert(!VT.isSimple() ||</td>
    <td class="lineNumber">10351</td>
    <td class="lineNumber">969</td>
    <td class="codeLine coveredLine">    assert(!VT.isSimple() ||</td>
    <td class="lineNumber">10351</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">           (unsigned)VT.getSimpleVT().SimpleTy < std::size(RegClassForVT));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">           (unsigned)VT.getSimpleVT().SimpleTy < std::size(RegClassForVT));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine coveredLine">    return VT.isSimple() && RegClassForVT[VT.getSimpleVT().SimpleTy] != nullptr;</td>
    <td class="lineNumber">10351</td>
    <td class="lineNumber">971</td>
    <td class="codeLine coveredLine">    return VT.isSimple() && RegClassForVT[VT.getSimpleVT().SimpleTy] != nullptr;</td>
    <td class="lineNumber">10351</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  class ValueTypeActionImpl {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  class ValueTypeActionImpl {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">    /// ValueTypeActions - For each value type, keep a LegalizeTypeAction enum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">    /// ValueTypeActions - For each value type, keep a LegalizeTypeAction enum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    /// that indicates how instruction selection should deal with the type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    /// that indicates how instruction selection should deal with the type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    LegalizeTypeAction ValueTypeActions[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    LegalizeTypeAction ValueTypeActions[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine coveredLine">    ValueTypeActionImpl() {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">980</td>
    <td class="codeLine coveredLine">    ValueTypeActionImpl() {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine coveredLine">      std::fill(std::begin(ValueTypeActions), std::end(ValueTypeActions),</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">981</td>
    <td class="codeLine coveredLine">      std::fill(std::begin(ValueTypeActions), std::end(ValueTypeActions),</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine coveredLine">                TypeLegal);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">982</td>
    <td class="codeLine coveredLine">                TypeLegal);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">983</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine coveredLine">    LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td class="lineNumber">434</td>
    <td class="lineNumber">985</td>
    <td class="codeLine coveredLine">    LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td class="lineNumber">434</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine coveredLine">      return ValueTypeActions[VT.SimpleTy];</td>
    <td class="lineNumber">434</td>
    <td class="lineNumber">986</td>
    <td class="codeLine coveredLine">      return ValueTypeActions[VT.SimpleTy];</td>
    <td class="lineNumber">434</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine coveredLine">    void setTypeAction(MVT VT, LegalizeTypeAction Action) {</td>
    <td class="lineNumber">917</td>
    <td class="lineNumber">989</td>
    <td class="codeLine coveredLine">    void setTypeAction(MVT VT, LegalizeTypeAction Action) {</td>
    <td class="lineNumber">917</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine coveredLine">      ValueTypeActions[VT.SimpleTy] = Action;</td>
    <td class="lineNumber">917</td>
    <td class="lineNumber">990</td>
    <td class="codeLine coveredLine">      ValueTypeActions[VT.SimpleTy] = Action;</td>
    <td class="lineNumber">917</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">917</td>
    <td class="lineNumber">991</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">917</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine coveredLine">  const ValueTypeActionImpl &getValueTypeActions() const {</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">994</td>
    <td class="codeLine coveredLine">  const ValueTypeActionImpl &getValueTypeActions() const {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine coveredLine">    return ValueTypeActions;</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">995</td>
    <td class="codeLine coveredLine">    return ValueTypeActions;</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  /// Return pair that represents the legalization kind (first) that needs to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  /// Return pair that represents the legalization kind (first) that needs to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// happen to EVT (second) in order to type-legalize it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// happen to EVT (second) in order to type-legalize it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  /// First: how we should legalize values of this type, either it is already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  /// First: how we should legalize values of this type, either it is already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">  /// Second: for types supported by the target, this is an identity function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">  /// Second: for types supported by the target, this is an identity function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  /// For types that must be promoted to larger types, this returns the larger</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  /// For types that must be promoted to larger types, this returns the larger</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">  /// type to promote to.  For integer types that are larger than the largest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">  /// type to promote to.  For integer types that are larger than the largest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// integer register, this contains one step in the expansion to get to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// integer register, this contains one step in the expansion to get to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// smaller register. For illegal floating point types, this returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// smaller register. For illegal floating point types, this returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  /// integer type to transform to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  /// integer type to transform to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  LegalizeKind getTypeConversion(LLVMContext &Context, EVT VT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  LegalizeKind getTypeConversion(LLVMContext &Context, EVT VT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  /// Return how we should legalize values of this type, either it is already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  /// Return how we should legalize values of this type, either it is already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  /// legal (return 'Legal') or we need to promote it to a larger type (return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// 'Promote'), or we need to expand it into multiple registers of smaller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  /// integer type (return 'Expand').  'Custom' is not an option.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine coveredLine">  LegalizeTypeAction getTypeAction(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">427</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine coveredLine">  LegalizeTypeAction getTypeAction(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">427</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine coveredLine">    return getTypeConversion(Context, VT).first;</td>
    <td class="lineNumber">427</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine coveredLine">    return getTypeConversion(Context, VT).first;</td>
    <td class="lineNumber">427</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  LegalizeTypeAction getTypeAction(MVT VT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">    return ValueTypeActions.getTypeAction(VT);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">    return ValueTypeActions.getTypeAction(VT);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// For types supported by the target, this is an identity function.  For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// For types supported by the target, this is an identity function.  For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// types that must be promoted to larger types, this returns the larger type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// types that must be promoted to larger types, this returns the larger type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// to promote to.  For integer types that are larger than the largest integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// to promote to.  For integer types that are larger than the largest integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  /// register, this contains one step in the expansion to get to the smaller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  /// register, this contains one step in the expansion to get to the smaller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  /// register. For illegal floating point types, this returns the integer type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  /// register. For illegal floating point types, this returns the integer type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">  /// to transform to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">  /// to transform to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine coveredLine">  virtual EVT getTypeToTransformTo(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine coveredLine">  virtual EVT getTypeToTransformTo(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine coveredLine">    return getTypeConversion(Context, VT).second;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine coveredLine">    return getTypeConversion(Context, VT).second;</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  /// For types supported by the target, this is an identity function.  For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  /// For types supported by the target, this is an identity function.  For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  /// types that must be expanded (i.e. integer types that are larger than the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  /// types that must be expanded (i.e. integer types that are larger than the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">  /// largest integer register or illegal floating point types), this returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">  /// largest integer register or illegal floating point types), this returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// the largest legal type it will be expanded to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// the largest legal type it will be expanded to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  EVT getTypeToExpandTo(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  EVT getTypeToExpandTo(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">    assert(!VT.isVector());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">    assert(!VT.isVector());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">      switch (getTypeAction(Context, VT)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">      switch (getTypeAction(Context, VT)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">      case TypeLegal:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">      case TypeLegal:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">        return VT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">        return VT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">      case TypeExpandInteger:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">      case TypeExpandInteger:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">        VT = getTypeToTransformTo(Context, VT);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">        VT = getTypeToTransformTo(Context, VT);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">        llvm_unreachable("Type is not legal nor is it to be expanded!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">        llvm_unreachable("Type is not legal nor is it to be expanded!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// Vector types are broken down into some number of legal first class types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// Vector types are broken down into some number of legal first class types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// promoted EVT::f64 values with the X86 FP stack.  Similarly, EVT::v2i64</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// promoted EVT::f64 values with the X86 FP stack.  Similarly, EVT::v2i64</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  /// turns into 4 EVT::i32 values with both PPC and X86.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  /// turns into 4 EVT::i32 values with both PPC and X86.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// This method returns the number of registers needed, and the VT for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// This method returns the number of registers needed, and the VT for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  /// register.  It also returns the VT and quantity of the intermediate values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  /// register.  It also returns the VT and quantity of the intermediate values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  /// before they are promoted/expanded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  /// before they are promoted/expanded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  unsigned getVectorTypeBreakdown(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  unsigned getVectorTypeBreakdown(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">                                  EVT &IntermediateVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">                                  EVT &IntermediateVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">                                  unsigned &NumIntermediates,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">                                  unsigned &NumIntermediates,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">                                  MVT &RegisterVT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">                                  MVT &RegisterVT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// Certain targets such as MIPS require that some types such as vectors are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// Certain targets such as MIPS require that some types such as vectors are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// always broken down into scalars in some contexts. This occurs even if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// always broken down into scalars in some contexts. This occurs even if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// vector type is legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// vector type is legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  virtual unsigned getVectorTypeBreakdownForCallingConv(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  virtual unsigned getVectorTypeBreakdownForCallingConv(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">      LLVMContext &Context, CallingConv::ID CC, EVT VT, EVT &IntermediateVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">      LLVMContext &Context, CallingConv::ID CC, EVT VT, EVT &IntermediateVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">      unsigned &NumIntermediates, MVT &RegisterVT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">      unsigned &NumIntermediates, MVT &RegisterVT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    return getVectorTypeBreakdown(Context, VT, IntermediateVT, NumIntermediates,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    return getVectorTypeBreakdown(Context, VT, IntermediateVT, NumIntermediates,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">                                  RegisterVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">                                  RegisterVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  struct IntrinsicInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  struct IntrinsicInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">    unsigned     opc = 0;          // target opcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">    unsigned     opc = 0;          // target opcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">    EVT          memVT;            // memory VT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">    EVT          memVT;            // memory VT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">    // value representing memory location</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">    // value representing memory location</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">    PointerUnion<const Value *, const PseudoSourceValue *> ptrVal;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">    PointerUnion<const Value *, const PseudoSourceValue *> ptrVal;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">    // Fallback address space for use if ptrVal is nullptr. std::nullopt means</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">    // Fallback address space for use if ptrVal is nullptr. std::nullopt means</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    // unknown address space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    // unknown address space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    std::optional<unsigned> fallbackAddressSpace;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    std::optional<unsigned> fallbackAddressSpace;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">    int          offset = 0;       // offset off of ptrVal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">    int          offset = 0;       // offset off of ptrVal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">    uint64_t     size = 0;         // the size of the memory location</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">    uint64_t     size = 0;         // the size of the memory location</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">                                   // (taken from memVT if zero)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">                                   // (taken from memVT if zero)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">    MaybeAlign align = Align(1);   // alignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">    MaybeAlign align = Align(1);   // alignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">    MachineMemOperand::Flags flags = MachineMemOperand::MONone;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">    MachineMemOperand::Flags flags = MachineMemOperand::MONone;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">    IntrinsicInfo() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">    IntrinsicInfo() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  /// Given an intrinsic, checks if on the target the intrinsic will need to map</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  /// Given an intrinsic, checks if on the target the intrinsic will need to map</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">  /// to a MemIntrinsicNode (touches memory). If this is the case, it returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">  /// to a MemIntrinsicNode (touches memory). If this is the case, it returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">  /// true and store the intrinsic information into the IntrinsicInfo that was</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">  /// true and store the intrinsic information into the IntrinsicInfo that was</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  /// passed to the function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  /// passed to the function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  virtual bool getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  virtual bool getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">                                  MachineFunction &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">                                  MachineFunction &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">                                  unsigned /*Intrinsic*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">                                  unsigned /*Intrinsic*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// Returns true if the target can instruction select the specified FP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// Returns true if the target can instruction select the specified FP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// immediate natively. If false, the legalizer will materialize the FP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// immediate natively. If false, the legalizer will materialize the FP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  /// immediate as a load from a constant pool.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  /// immediate as a load from a constant pool.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  virtual bool isFPImmLegal(const APFloat & /*Imm*/, EVT /*VT*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  virtual bool isFPImmLegal(const APFloat & /*Imm*/, EVT /*VT*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">                            bool ForCodeSize = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">                            bool ForCodeSize = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// Targets can use this to indicate that they only support *some*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// Targets can use this to indicate that they only support *some*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  /// VECTOR_SHUFFLE operations, those with specific masks.  By default, if a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  /// VECTOR_SHUFFLE operations, those with specific masks.  By default, if a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  /// legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  /// legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  virtual bool isShuffleMaskLegal(ArrayRef<int> /*Mask*/, EVT /*VT*/) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  virtual bool isShuffleMaskLegal(ArrayRef<int> /*Mask*/, EVT /*VT*/) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">  /// Returns true if the operation can trap for the value type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">  /// Returns true if the operation can trap for the value type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// VT must be a legal type. By default, we optimistically assume most</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// VT must be a legal type. By default, we optimistically assume most</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  /// operations don't trap except for integer divide and remainder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  /// operations don't trap except for integer divide and remainder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  virtual bool canOpTrap(unsigned Op, EVT VT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  virtual bool canOpTrap(unsigned Op, EVT VT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">  /// Similar to isShuffleMaskLegal. Targets can use this to indicate if there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">  /// Similar to isShuffleMaskLegal. Targets can use this to indicate if there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">  /// is a suitable VECTOR_SHUFFLE that can be used to replace a VAND with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">  /// is a suitable VECTOR_SHUFFLE that can be used to replace a VAND with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">  /// constant pool entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">  /// constant pool entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">  virtual bool isVectorClearMaskLegal(ArrayRef<int> /*Mask*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">  virtual bool isVectorClearMaskLegal(ArrayRef<int> /*Mask*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">                                      EVT /*VT*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">                                      EVT /*VT*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">  /// How to legalize this custom operation?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">  /// How to legalize this custom operation?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine coveredLine">  virtual LegalizeAction getCustomOperationAction(SDNode &Op) const {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine coveredLine">  virtual LegalizeAction getCustomOperationAction(SDNode &Op) const {</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine coveredLine">    return Legal;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine coveredLine">    return Legal;</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  /// Return how this operation should be treated: either it is legal, needs to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  /// Return how this operation should be treated: either it is legal, needs to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">  /// be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">  /// be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine coveredLine">  LegalizeAction getOperationAction(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">83</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine coveredLine">  LegalizeAction getOperationAction(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine coveredLine">    if (VT.isExtended()) return Expand;</td>
    <td class="lineNumber">83</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine coveredLine">    if (VT.isExtended()) return Expand;</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    // If a target-specific SDNode requires legalization, require the target</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    // If a target-specific SDNode requires legalization, require the target</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // to provide custom legalization for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // to provide custom legalization for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine coveredLine">    if (Op >= std::size(OpActions[0]))</td>
    <td class="lineNumber">83</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine coveredLine">    if (Op >= std::size(OpActions[0]))</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">      return Custom;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">      return Custom;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine coveredLine">    return OpActions[(unsigned)VT.getSimpleVT().SimpleTy][Op];</td>
    <td class="lineNumber">83</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine coveredLine">    return OpActions[(unsigned)VT.getSimpleVT().SimpleTy][Op];</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// Custom method defined by each target to indicate if an operation which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// Custom method defined by each target to indicate if an operation which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// may require a scale is supported natively by the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// may require a scale is supported natively by the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  /// If not, the operation is illegal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  /// If not, the operation is illegal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  virtual bool isSupportedFixedPointOperation(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  virtual bool isSupportedFixedPointOperation(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">                                              unsigned Scale) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">                                              unsigned Scale) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">  /// Some fixed point operations may be natively supported by the target but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">  /// Some fixed point operations may be natively supported by the target but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// only for specific scales. This method allows for checking</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// only for specific scales. This method allows for checking</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  /// if the width is supported by the target for a given operation that may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  /// if the width is supported by the target for a given operation that may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  /// depend on scale.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  /// depend on scale.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  LegalizeAction getFixedPointOperationAction(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  LegalizeAction getFixedPointOperationAction(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                              unsigned Scale) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                              unsigned Scale) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">    auto Action = getOperationAction(Op, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">    auto Action = getOperationAction(Op, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">    if (Action != Legal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">    if (Action != Legal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">      return Action;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">      return Action;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">    // This operation is supported in this type but may only work on specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">    // This operation is supported in this type but may only work on specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">    // scales.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">    // scales.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">    bool Supported;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">    bool Supported;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">    switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">    switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">      llvm_unreachable("Unexpected fixed point operation.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">      llvm_unreachable("Unexpected fixed point operation.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">    case ISD::SMULFIX:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">    case ISD::SMULFIX:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">    case ISD::SMULFIXSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">    case ISD::SMULFIXSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">    case ISD::UMULFIX:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">    case ISD::UMULFIX:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">    case ISD::UMULFIXSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">    case ISD::UMULFIXSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">    case ISD::SDIVFIX:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">    case ISD::SDIVFIX:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    case ISD::SDIVFIXSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    case ISD::SDIVFIXSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">    case ISD::UDIVFIX:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">    case ISD::UDIVFIX:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">    case ISD::UDIVFIXSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">    case ISD::UDIVFIXSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">      Supported = isSupportedFixedPointOperation(Op, VT, Scale);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">      Supported = isSupportedFixedPointOperation(Op, VT, Scale);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">    return Supported ? Action : Expand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">    return Supported ? Action : Expand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  // If Op is a strict floating-point operation, return the result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  // If Op is a strict floating-point operation, return the result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  // of getOperationAction for the equivalent non-strict operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  // of getOperationAction for the equivalent non-strict operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">  LegalizeAction getStrictFPOperationAction(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">  LegalizeAction getStrictFPOperationAction(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">    unsigned EqOpc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">    unsigned EqOpc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">    switch (Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">    switch (Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">      default: llvm_unreachable("Unexpected FP pseudo-opcode");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">      default: llvm_unreachable("Unexpected FP pseudo-opcode");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">      case ISD::STRICT_##DAGN: EqOpc = ISD::DAGN; break;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">      case ISD::STRICT_##DAGN: EqOpc = ISD::DAGN; break;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">      case ISD::STRICT_##DAGN: EqOpc = ISD::SETCC; break;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">      case ISD::STRICT_##DAGN: EqOpc = ISD::SETCC; break;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">#include "llvm/IR/ConstrainedOps.def"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">#include "llvm/IR/ConstrainedOps.def"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">    return getOperationAction(EqOpc, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">    return getOperationAction(EqOpc, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  /// made legal with custom lowering. This is used to help guide high-level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  /// made legal with custom lowering. This is used to help guide high-level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  /// lowering decisions. LegalOnly is an optional convenience for code paths</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  /// lowering decisions. LegalOnly is an optional convenience for code paths</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  /// traversed pre and post legalisation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  /// traversed pre and post legalisation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine coveredLine">  bool isOperationLegalOrCustom(unsigned Op, EVT VT,</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine coveredLine">  bool isOperationLegalOrCustom(unsigned Op, EVT VT,</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">                                bool LegalOnly = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">                                bool LegalOnly = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine coveredLine">    if (LegalOnly)</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine coveredLine">    if (LegalOnly)</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine coveredLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine coveredLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine coveredLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine coveredLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine coveredLine">       getOperationAction(Op, VT) == Custom);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine coveredLine">       getOperationAction(Op, VT) == Custom);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  /// made legal using promotion. This is used to help guide high-level lowering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  /// made legal using promotion. This is used to help guide high-level lowering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">  /// decisions. LegalOnly is an optional convenience for code paths traversed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">  /// decisions. LegalOnly is an optional convenience for code paths traversed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// pre and post legalisation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// pre and post legalisation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  bool isOperationLegalOrPromote(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  bool isOperationLegalOrPromote(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">                                 bool LegalOnly = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">                                 bool LegalOnly = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">    if (LegalOnly)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">    if (LegalOnly)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">       getOperationAction(Op, VT) == Promote);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">       getOperationAction(Op, VT) == Promote);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target or can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  /// made legal with custom lowering or using promotion. This is used to help</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  /// made legal with custom lowering or using promotion. This is used to help</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// guide high-level lowering decisions. LegalOnly is an optional convenience</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// guide high-level lowering decisions. LegalOnly is an optional convenience</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// for code paths traversed pre and post legalisation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// for code paths traversed pre and post legalisation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  bool isOperationLegalOrCustomOrPromote(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  bool isOperationLegalOrCustomOrPromote(unsigned Op, EVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">                                         bool LegalOnly = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">                                         bool LegalOnly = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">    if (LegalOnly)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">    if (LegalOnly)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">      return isOperationLegal(Op, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">      (getOperationAction(Op, VT) == Legal ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">       getOperationAction(Op, VT) == Custom ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">       getOperationAction(Op, VT) == Custom ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">       getOperationAction(Op, VT) == Promote);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">       getOperationAction(Op, VT) == Promote);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// Return true if the operation uses custom lowering, regardless of whether</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// Return true if the operation uses custom lowering, regardless of whether</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  /// the type is legal or not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  /// the type is legal or not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  bool isOperationCustom(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  bool isOperationCustom(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">    return getOperationAction(Op, VT) == Custom;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">    return getOperationAction(Op, VT) == Custom;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// Return true if lowering to a jump table is allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// Return true if lowering to a jump table is allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  virtual bool areJTsAllowed(const Function *Fn) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  virtual bool areJTsAllowed(const Function *Fn) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">    if (Fn->getFnAttribute("no-jump-tables").getValueAsBool())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">    if (Fn->getFnAttribute("no-jump-tables").getValueAsBool())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">    return isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">    return isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">           isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">           isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// Check whether the range [Low,High] fits in a machine word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// Check whether the range [Low,High] fits in a machine word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  bool rangeFitsInWord(const APInt &Low, const APInt &High,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  bool rangeFitsInWord(const APInt &Low, const APInt &High,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">                       const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">                       const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">    // FIXME: Using the pointer type doesn't seem ideal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">    // FIXME: Using the pointer type doesn't seem ideal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">    uint64_t BW = DL.getIndexSizeInBits(0u);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">    uint64_t BW = DL.getIndexSizeInBits(0u);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">    uint64_t Range = (High - Low).getLimitedValue(UINT64_MAX - 1) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">    uint64_t Range = (High - Low).getLimitedValue(UINT64_MAX - 1) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">    return Range <= BW;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">    return Range <= BW;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  /// Return true if lowering to a jump table is suitable for a set of case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  /// Return true if lowering to a jump table is suitable for a set of case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// clusters which may contain \p NumCases cases, \p Range range of values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// clusters which may contain \p NumCases cases, \p Range range of values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  virtual bool isSuitableForJumpTable(const SwitchInst *SI, uint64_t NumCases,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  virtual bool isSuitableForJumpTable(const SwitchInst *SI, uint64_t NumCases,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">                                      uint64_t Range, ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">                                      uint64_t Range, ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">                                      BlockFrequencyInfo *BFI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">                                      BlockFrequencyInfo *BFI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// Returns preferred type for switch condition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// Returns preferred type for switch condition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">  virtual MVT getPreferredSwitchConditionType(LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">  virtual MVT getPreferredSwitchConditionType(LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">                                              EVT ConditionVT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">                                              EVT ConditionVT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// Return true if lowering to a bit test is suitable for a set of case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// Return true if lowering to a bit test is suitable for a set of case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// clusters which contains \p NumDests unique destinations, \p Low and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// clusters which contains \p NumDests unique destinations, \p Low and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// \p High as its lowest and highest case values, and expects \p NumCmps</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// \p High as its lowest and highest case values, and expects \p NumCmps</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// case value comparisons. Check if the number of destinations, comparison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// case value comparisons. Check if the number of destinations, comparison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// metric, and range are all suitable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// metric, and range are all suitable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">  bool isSuitableForBitTests(unsigned NumDests, unsigned NumCmps,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">  bool isSuitableForBitTests(unsigned NumDests, unsigned NumCmps,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">                             const APInt &Low, const APInt &High,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">                             const APInt &Low, const APInt &High,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">                             const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">                             const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">    // FIXME: I don't think NumCmps is the correct metric: a single case and a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">    // FIXME: I don't think NumCmps is the correct metric: a single case and a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // range of cases both require only one branch to lower. Just looking at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // range of cases both require only one branch to lower. Just looking at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // number of clusters and destinations should be enough to decide whether to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // number of clusters and destinations should be enough to decide whether to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // build bit tests.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // build bit tests.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">    // To lower a range with bit tests, the range must fit the bitwidth of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">    // To lower a range with bit tests, the range must fit the bitwidth of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">    // machine word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">    // machine word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">    if (!rangeFitsInWord(Low, High, DL))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">    if (!rangeFitsInWord(Low, High, DL))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">    // Decide whether it's profitable to lower this range with bit tests. Each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">    // Decide whether it's profitable to lower this range with bit tests. Each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">    // destination requires a bit test and branch, and there is an overall range</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">    // destination requires a bit test and branch, and there is an overall range</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">    // check branch. For a small number of clusters, separate comparisons might</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">    // check branch. For a small number of clusters, separate comparisons might</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">    // be cheaper, and for many destinations, splitting the range might be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">    // be cheaper, and for many destinations, splitting the range might be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">    // better.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">    // better.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">    return (NumDests == 1 && NumCmps >= 3) || (NumDests == 2 && NumCmps >= 5) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">    return (NumDests == 1 && NumCmps >= 3) || (NumDests == 2 && NumCmps >= 5) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">           (NumDests == 3 && NumCmps >= 6);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">           (NumDests == 3 && NumCmps >= 6);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  /// Return true if the specified operation is illegal on this target or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  /// Return true if the specified operation is illegal on this target or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  /// unlikely to be made legal with custom lowering. This is used to help guide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  /// unlikely to be made legal with custom lowering. This is used to help guide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  /// high-level lowering decisions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  /// high-level lowering decisions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  bool isOperationExpand(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  bool isOperationExpand(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">    return (!isTypeLegal(VT) || getOperationAction(Op, VT) == Expand);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">    return (!isTypeLegal(VT) || getOperationAction(Op, VT) == Expand);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// Return true if the specified operation is legal on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  bool isOperationLegal(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  bool isOperationLegal(unsigned Op, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    return (VT == MVT::Other || isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">           getOperationAction(Op, VT) == Legal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">           getOperationAction(Op, VT) == Legal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">  /// Return how this load with extension should be treated: either it is legal,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">  /// Return how this load with extension should be treated: either it is legal,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  /// needs to be promoted to a larger size, needs to be expanded to some other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  /// needs to be promoted to a larger size, needs to be expanded to some other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  /// code sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  /// code sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  LegalizeAction getLoadExtAction(unsigned ExtType, EVT ValVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  LegalizeAction getLoadExtAction(unsigned ExtType, EVT ValVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">                                  EVT MemVT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">                                  EVT MemVT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::VALUETYPE_SIZE &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::VALUETYPE_SIZE &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">           MemI < MVT::VALUETYPE_SIZE && "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">           MemI < MVT::VALUETYPE_SIZE && "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">    unsigned Shift = 4 * ExtType;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">    unsigned Shift = 4 * ExtType;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">    return (LegalizeAction)((LoadExtActions[ValI][MemI] >> Shift) & 0xf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">    return (LegalizeAction)((LoadExtActions[ValI][MemI] >> Shift) & 0xf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">  /// Return true if the specified load with extension is legal on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">  /// Return true if the specified load with extension is legal on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  bool isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  bool isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  /// Return true if the specified load with extension is legal or custom</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  /// Return true if the specified load with extension is legal or custom</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  /// on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  /// on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">  bool isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">  bool isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">           getLoadExtAction(ExtType, ValVT, MemVT) == Custom;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">           getLoadExtAction(ExtType, ValVT, MemVT) == Custom;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  /// Return how this store with truncation should be treated: either it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  /// Return how this store with truncation should be treated: either it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  /// legal, needs to be promoted to a larger size, needs to be expanded to some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  /// legal, needs to be promoted to a larger size, needs to be expanded to some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">  /// other code sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">  /// other code sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">  LegalizeAction getTruncStoreAction(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">  LegalizeAction getTruncStoreAction(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">    assert(ValI < MVT::VALUETYPE_SIZE && MemI < MVT::VALUETYPE_SIZE &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">    assert(ValI < MVT::VALUETYPE_SIZE && MemI < MVT::VALUETYPE_SIZE &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">           "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">           "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">    return TruncStoreActions[ValI][MemI];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">    return TruncStoreActions[ValI][MemI];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  /// Return true if the specified store with truncation is legal on this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  /// Return true if the specified store with truncation is legal on this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">  bool isTruncStoreLegal(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">  bool isTruncStoreLegal(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">    return isTypeLegal(ValVT) && getTruncStoreAction(ValVT, MemVT) == Legal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">    return isTypeLegal(ValVT) && getTruncStoreAction(ValVT, MemVT) == Legal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  /// Return true if the specified store with truncation has solution on this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  /// Return true if the specified store with truncation has solution on this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">  bool isTruncStoreLegalOrCustom(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">  bool isTruncStoreLegalOrCustom(EVT ValVT, EVT MemVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    return isTypeLegal(ValVT) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    return isTypeLegal(ValVT) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">      (getTruncStoreAction(ValVT, MemVT) == Legal ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">      (getTruncStoreAction(ValVT, MemVT) == Legal ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">       getTruncStoreAction(ValVT, MemVT) == Custom);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">       getTruncStoreAction(ValVT, MemVT) == Custom);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  virtual bool canCombineTruncStore(EVT ValVT, EVT MemVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  virtual bool canCombineTruncStore(EVT ValVT, EVT MemVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">                                    bool LegalOnly) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">                                    bool LegalOnly) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    if (LegalOnly)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    if (LegalOnly)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">      return isTruncStoreLegal(ValVT, MemVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">      return isTruncStoreLegal(ValVT, MemVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">    return isTruncStoreLegalOrCustom(ValVT, MemVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">    return isTruncStoreLegalOrCustom(ValVT, MemVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine coveredLine">  LegalizeAction getIndexedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine coveredLine">  LegalizeAction getIndexedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">40</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine coveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_Load);</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine coveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_Load);</td>
    <td class="lineNumber">40</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine coveredLine">  bool isIndexedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine coveredLine">  bool isIndexedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine coveredLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine coveredLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">60</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine coveredLine">      (getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine coveredLine">      (getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">40</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine coveredLine">       getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine coveredLine">       getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">40</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine coveredLine">  LegalizeAction getIndexedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">32</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine coveredLine">  LegalizeAction getIndexedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine coveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_Store);</td>
    <td class="lineNumber">32</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine coveredLine">    return getIndexedModeAction(IdxMode, VT, IMAB_Store);</td>
    <td class="lineNumber">32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine coveredLine">  bool isIndexedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine coveredLine">  bool isIndexedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine coveredLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">48</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine coveredLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">48</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine coveredLine">      (getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">32</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine coveredLine">      (getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine coveredLine">       getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">32</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine coveredLine">       getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">  /// Return how the indexed load should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">  LegalizeAction getIndexedMaskedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">  LegalizeAction getIndexedMaskedLoadAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">  bool isIndexedMaskedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">  bool isIndexedMaskedLoadLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">           (getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">           (getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">            getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">            getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  /// Return how the indexed store should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">  /// to be promoted to a larger size, needs to be expanded to some other code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">  /// sequence, or the target has a custom expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">  LegalizeAction getIndexedMaskedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">  LegalizeAction getIndexedMaskedStoreAction(unsigned IdxMode, MVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedStore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedStore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">  /// Return true if the specified indexed load is legal on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">  bool isIndexedMaskedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">  bool isIndexedMaskedStoreLegal(unsigned IdxMode, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">    return VT.isSimple() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">           (getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">           (getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">            getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">            getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">  /// Returns true if the index type for a masked gather/scatter requires</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">  /// Returns true if the index type for a masked gather/scatter requires</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">  /// extending</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">  /// extending</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  virtual bool shouldExtendGSIndex(EVT VT, EVT &EltTy) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  virtual bool shouldExtendGSIndex(EVT VT, EVT &EltTy) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  // Returns true if VT is a legal index type for masked gathers/scatters</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  // Returns true if VT is a legal index type for masked gathers/scatters</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">  // on this target</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">  // on this target</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">  virtual bool shouldRemoveExtendFromGSIndex(EVT IndexVT, EVT DataVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">  virtual bool shouldRemoveExtendFromGSIndex(EVT IndexVT, EVT DataVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  // Return true if the target supports a scatter/gather instruction with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  // Return true if the target supports a scatter/gather instruction with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">  // indices which are scaled by the particular value.  Note that all targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">  // indices which are scaled by the particular value.  Note that all targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">  // must by definition support scale of 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">  // must by definition support scale of 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">  virtual bool isLegalScaleForGatherScatter(uint64_t Scale,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">  virtual bool isLegalScaleForGatherScatter(uint64_t Scale,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">                                            uint64_t ElemSize) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">                                            uint64_t ElemSize) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">    // MGATHER/MSCATTER are only required to support scaling by one or by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">    // MGATHER/MSCATTER are only required to support scaling by one or by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    // element size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    // element size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">    if (Scale != ElemSize && Scale != 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">    if (Scale != ElemSize && Scale != 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  /// Return how the condition code should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  /// Return how the condition code should be treated: either it is legal, needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  /// to be expanded to some other code sequence, or the target has a custom</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  /// to be expanded to some other code sequence, or the target has a custom</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  /// expander for it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  /// expander for it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  LegalizeAction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  LegalizeAction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine coveredLine">  getCondCodeAction(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine coveredLine">  getCondCodeAction(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine coveredLine">    assert((unsigned)CC < std::size(CondCodeActions) &&</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine coveredLine">    assert((unsigned)CC < std::size(CondCodeActions) &&</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">           ((unsigned)VT.SimpleTy >> 3) < std::size(CondCodeActions[0]) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">           ((unsigned)VT.SimpleTy >> 3) < std::size(CondCodeActions[0]) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">           "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">           "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">    // See setCondCodeAction for how this is encoded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">    // See setCondCodeAction for how this is encoded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine coveredLine">    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine coveredLine">    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine coveredLine">    uint32_t Value = CondCodeActions[CC][VT.SimpleTy >> 3];</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine coveredLine">    uint32_t Value = CondCodeActions[CC][VT.SimpleTy >> 3];</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine coveredLine">    LegalizeAction Action = (LegalizeAction) ((Value >> Shift) & 0xF);</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine coveredLine">    LegalizeAction Action = (LegalizeAction) ((Value >> Shift) & 0xF);</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine coveredLine">    assert(Action != Promote && "Can't promote condition code!");</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine coveredLine">    assert(Action != Promote && "Can't promote condition code!");</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine coveredLine">    return Action;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine coveredLine">    return Action;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  /// Return true if the specified condition code is legal on this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  /// Return true if the specified condition code is legal on this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine coveredLine">  bool isCondCodeLegal(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine coveredLine">  bool isCondCodeLegal(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine coveredLine">    return getCondCodeAction(CC, VT) == Legal;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine coveredLine">    return getCondCodeAction(CC, VT) == Legal;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  /// Return true if the specified condition code is legal or custom on this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  /// Return true if the specified condition code is legal or custom on this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  bool isCondCodeLegalOrCustom(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  bool isCondCodeLegalOrCustom(ISD::CondCode CC, MVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">    return getCondCodeAction(CC, VT) == Legal ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">    return getCondCodeAction(CC, VT) == Legal ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">           getCondCodeAction(CC, VT) == Custom;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">           getCondCodeAction(CC, VT) == Custom;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  /// If the action for this operation is to promote, this method returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  /// If the action for this operation is to promote, this method returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  /// ValueType to promote to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  /// ValueType to promote to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  MVT getTypeToPromoteTo(unsigned Op, MVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  MVT getTypeToPromoteTo(unsigned Op, MVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">    assert(getOperationAction(Op, VT) == Promote &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">    assert(getOperationAction(Op, VT) == Promote &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">           "This operation isn't promoted!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">           "This operation isn't promoted!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">    // See if this has an explicit type specified.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">    // See if this has an explicit type specified.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">    std::map<std::pair<unsigned, MVT::SimpleValueType>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">    std::map<std::pair<unsigned, MVT::SimpleValueType>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">             MVT::SimpleValueType>::const_iterator PTTI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">             MVT::SimpleValueType>::const_iterator PTTI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">      PromoteToType.find(std::make_pair(Op, VT.SimpleTy));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">      PromoteToType.find(std::make_pair(Op, VT.SimpleTy));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">    if (PTTI != PromoteToType.end()) return PTTI->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">    if (PTTI != PromoteToType.end()) return PTTI->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">    assert((VT.isInteger() || VT.isFloatingPoint()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">    assert((VT.isInteger() || VT.isFloatingPoint()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">           "Cannot autopromote this type, add it with AddPromotedToType.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">           "Cannot autopromote this type, add it with AddPromotedToType.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">    MVT NVT = VT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">    MVT NVT = VT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">      NVT = (MVT::SimpleValueType)(NVT.SimpleTy+1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">      NVT = (MVT::SimpleValueType)(NVT.SimpleTy+1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">      assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">      assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">             "Didn't find type to promote to!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">             "Didn't find type to promote to!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    } while (!isTypeLegal(NVT) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    } while (!isTypeLegal(NVT) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">              getOperationAction(Op, NVT) == Promote);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">              getOperationAction(Op, NVT) == Promote);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    return NVT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    return NVT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">  virtual EVT getAsmOperandValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">  virtual EVT getAsmOperandValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">                                     bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">                                     bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">  /// Return the EVT corresponding to this LLVM type.  This is fixed by the LLVM</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">  /// Return the EVT corresponding to this LLVM type.  This is fixed by the LLVM</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">  /// operations except for the pointer size.  If AllowUnknown is true, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">  /// operations except for the pointer size.  If AllowUnknown is true, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  /// will return MVT::Other for types with no EVT counterpart (e.g. structs),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  /// will return MVT::Other for types with no EVT counterpart (e.g. structs),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">  /// otherwise it will assert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">  /// otherwise it will assert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine coveredLine">  EVT getValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine coveredLine">  EVT getValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">                   bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">                   bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">    // Lower scalar pointers to native pointer types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">    // Lower scalar pointers to native pointer types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine coveredLine">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine coveredLine">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine coveredLine">      return getPointerTy(DL, PTy->getAddressSpace());</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine coveredLine">      return getPointerTy(DL, PTy->getAddressSpace());</td>
    <td class="lineNumber">7</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine coveredLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">27</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine coveredLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">27</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">      // Lower vectors of pointers to native pointer types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">      // Lower vectors of pointers to native pointer types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">        EVT PointerTy(getPointerTy(DL, PTy->getAddressSpace()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">        EVT PointerTy(getPointerTy(DL, PTy->getAddressSpace()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">                              VTy->getElementCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">                              VTy->getElementCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine coveredLine">    return EVT::getEVT(Ty, AllowUnknown);</td>
    <td class="lineNumber">27</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine coveredLine">    return EVT::getEVT(Ty, AllowUnknown);</td>
    <td class="lineNumber">27</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine coveredLine">  EVT getMemValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine coveredLine">  EVT getMemValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">                      bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">                      bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">    // Lower scalar pointers to native pointer types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">    // Lower scalar pointers to native pointer types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine coveredLine">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine coveredLine">    if (auto *PTy = dyn_cast<PointerType>(Ty))</td>
    <td class="lineNumber">11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">      return getPointerMemTy(DL, PTy->getAddressSpace());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">      return getPointerMemTy(DL, PTy->getAddressSpace());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine coveredLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine coveredLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">        EVT PointerTy(getPointerMemTy(DL, PTy->getAddressSpace()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">        EVT PointerTy(getPointerMemTy(DL, PTy->getAddressSpace()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">        EltTy = PointerTy.getTypeForEVT(Ty->getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">                              VTy->getElementCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">                              VTy->getElementCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine coveredLine">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine coveredLine">    return getValueType(DL, Ty, AllowUnknown);</td>
    <td class="lineNumber">11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">  /// Return the MVT corresponding to this LLVM type. See getValueType.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">  /// Return the MVT corresponding to this LLVM type. See getValueType.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">  MVT getSimpleValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">  MVT getSimpleValueType(const DataLayout &DL, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">                         bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">                         bool AllowUnknown = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">    return getValueType(DL, Ty, AllowUnknown).getSimpleVT();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">    return getValueType(DL, Ty, AllowUnknown).getSimpleVT();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">  /// Return the desired alignment for ByVal or InAlloca aggregate function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">  /// Return the desired alignment for ByVal or InAlloca aggregate function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">  /// arguments in the caller parameter area.  This is the actual alignment, not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">  /// arguments in the caller parameter area.  This is the actual alignment, not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">  /// its logarithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">  /// its logarithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">  virtual uint64_t getByValTypeAlignment(Type *Ty, const DataLayout &DL) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">  virtual uint64_t getByValTypeAlignment(Type *Ty, const DataLayout &DL) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine coveredLine">  MVT getRegisterType(MVT VT) const {</td>
    <td class="lineNumber">861</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine coveredLine">  MVT getRegisterType(MVT VT) const {</td>
    <td class="lineNumber">861</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine coveredLine">    assert((unsigned)VT.SimpleTy < std::size(RegisterTypeForVT));</td>
    <td class="lineNumber">861</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine coveredLine">    assert((unsigned)VT.SimpleTy < std::size(RegisterTypeForVT));</td>
    <td class="lineNumber">861</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine coveredLine">    return RegisterTypeForVT[VT.SimpleTy];</td>
    <td class="lineNumber">861</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine coveredLine">    return RegisterTypeForVT[VT.SimpleTy];</td>
    <td class="lineNumber">861</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">  /// Return the type of registers that this ValueType will eventually require.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine coveredLine">  MVT getRegisterType(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine coveredLine">  MVT getRegisterType(LLVMContext &Context, EVT VT) const {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine coveredLine">    if (VT.isSimple())</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine coveredLine">    if (VT.isSimple())</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine coveredLine">      return getRegisterType(VT.getSimpleVT());</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine coveredLine">      return getRegisterType(VT.getSimpleVT());</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">    if (VT.isVector()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">    if (VT.isVector()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">      EVT VT1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">      EVT VT1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">      MVT RegisterVT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">      MVT RegisterVT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">      unsigned NumIntermediates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">      unsigned NumIntermediates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">      (void)getVectorTypeBreakdown(Context, VT, VT1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">      (void)getVectorTypeBreakdown(Context, VT, VT1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">                                   NumIntermediates, RegisterVT);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">                                   NumIntermediates, RegisterVT);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">      return RegisterVT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">      return RegisterVT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">    if (VT.isInteger()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">    if (VT.isInteger()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">      return getRegisterType(Context, getTypeToTransformTo(Context, VT));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">      return getRegisterType(Context, getTypeToTransformTo(Context, VT));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">    llvm_unreachable("Unsupported extended type!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">    llvm_unreachable("Unsupported extended type!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">  /// Return the number of registers that this ValueType will eventually</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">  /// Return the number of registers that this ValueType will eventually</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// require.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// require.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">  /// This is one for any types promoted to live in larger registers, but may be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">  /// This is one for any types promoted to live in larger registers, but may be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">  /// more than one for types (like i64) that are split into pieces.  For types</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">  /// more than one for types (like i64) that are split into pieces.  For types</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">  /// like i140, which are first promoted then expanded, it is the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">  /// like i140, which are first promoted then expanded, it is the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">  /// registers needed to hold all the bits of the original type.  For an i140</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">  /// registers needed to hold all the bits of the original type.  For an i140</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">  /// on a 32 bit machine this means 5 registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">  /// on a 32 bit machine this means 5 registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">  /// RegisterVT may be passed as a way to override the default settings, for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">  /// RegisterVT may be passed as a way to override the default settings, for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">  /// instance with i128 inline assembly operands on SystemZ.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">  /// instance with i128 inline assembly operands on SystemZ.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine coveredLine">  getNumRegisters(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine coveredLine">  getNumRegisters(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">                  std::optional<MVT> RegisterVT = std::nullopt) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">                  std::optional<MVT> RegisterVT = std::nullopt) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine coveredLine">    if (VT.isSimple()) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine coveredLine">    if (VT.isSimple()) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine coveredLine">      assert((unsigned)VT.getSimpleVT().SimpleTy <</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine coveredLine">      assert((unsigned)VT.getSimpleVT().SimpleTy <</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">             std::size(NumRegistersForVT));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">             std::size(NumRegistersForVT));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine coveredLine">      return NumRegistersForVT[VT.getSimpleVT().SimpleTy];</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine coveredLine">      return NumRegistersForVT[VT.getSimpleVT().SimpleTy];</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">    if (VT.isVector()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">    if (VT.isVector()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">      EVT VT1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">      EVT VT1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">      MVT VT2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">      MVT VT2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">      unsigned NumIntermediates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">      unsigned NumIntermediates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">      return getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">      return getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">    if (VT.isInteger()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">    if (VT.isInteger()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">      unsigned BitWidth = VT.getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">      unsigned BitWidth = VT.getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">      unsigned RegWidth = getRegisterType(Context, VT).getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">      unsigned RegWidth = getRegisterType(Context, VT).getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">      return (BitWidth + RegWidth - 1) / RegWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">      return (BitWidth + RegWidth - 1) / RegWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">    llvm_unreachable("Unsupported extended type!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">    llvm_unreachable("Unsupported extended type!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">  /// Certain combinations of ABIs, Targets and features require that types</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">  /// Certain combinations of ABIs, Targets and features require that types</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">  /// are legal for some operations and not for other operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">  /// are legal for some operations and not for other operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">  /// For MIPS all vector types must be passed through the integer register set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">  /// For MIPS all vector types must be passed through the integer register set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">  virtual MVT getRegisterTypeForCallingConv(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">  virtual MVT getRegisterTypeForCallingConv(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">                                            CallingConv::ID CC, EVT VT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">                                            CallingConv::ID CC, EVT VT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">    return getRegisterType(Context, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">    return getRegisterType(Context, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">  /// Certain targets require unusual breakdowns of certain types. For MIPS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">  /// Certain targets require unusual breakdowns of certain types. For MIPS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">  /// this occurs when a vector type is used, as vector are passed through the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">  /// this occurs when a vector type is used, as vector are passed through the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">  /// integer register set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">  /// integer register set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">  virtual unsigned getNumRegistersForCallingConv(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">  virtual unsigned getNumRegistersForCallingConv(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">                                                 CallingConv::ID CC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">                                                 CallingConv::ID CC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">                                                 EVT VT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">                                                 EVT VT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">    return getNumRegisters(Context, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">    return getNumRegisters(Context, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">  /// Certain targets have context sensitive alignment requirements, where one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">  /// Certain targets have context sensitive alignment requirements, where one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">  /// type has the alignment requirement of another type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">  /// type has the alignment requirement of another type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  virtual Align getABIAlignmentForCallingConv(Type *ArgTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  virtual Align getABIAlignmentForCallingConv(Type *ArgTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">                                              const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">                                              const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">    return DL.getABITypeAlign(ArgTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">    return DL.getABITypeAlign(ArgTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">  /// If true, then instruction selection should seek to shrink the FP constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">  /// If true, then instruction selection should seek to shrink the FP constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">  /// of the specified type to a smaller type in order to save space and / or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">  /// of the specified type to a smaller type in order to save space and / or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">  /// reduce runtime.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">  /// reduce runtime.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">  virtual bool ShouldShrinkFPConstant(EVT) const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">  virtual bool ShouldShrinkFPConstant(EVT) const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  /// Return true if it is profitable to reduce a load to a smaller type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  /// Return true if it is profitable to reduce a load to a smaller type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">  /// Example: (i16 (trunc (i32 (load x))) -> i16 load x</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">  /// Example: (i16 (trunc (i32 (load x))) -> i16 load x</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  virtual bool shouldReduceLoadWidth(SDNode *Load, ISD::LoadExtType ExtTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  virtual bool shouldReduceLoadWidth(SDNode *Load, ISD::LoadExtType ExtTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">                                     EVT NewVT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">                                     EVT NewVT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">    // By default, assume that it is cheaper to extract a subvector from a wide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">    // By default, assume that it is cheaper to extract a subvector from a wide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">    // vector load rather than creating multiple narrow vector loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">    // vector load rather than creating multiple narrow vector loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">    if (NewVT.isVector() && !Load->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">    if (NewVT.isVector() && !Load->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">  /// Return true (the default) if it is profitable to remove a sext_inreg(x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">  /// Return true (the default) if it is profitable to remove a sext_inreg(x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">  /// where the sext is redundant, and use x directly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">  /// where the sext is redundant, and use x directly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  virtual bool shouldRemoveRedundantExtend(SDValue Op) const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  virtual bool shouldRemoveRedundantExtend(SDValue Op) const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// When splitting a value of the specified type into parts, does the Lo</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// When splitting a value of the specified type into parts, does the Lo</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// or Hi part come first?  This usually follows the endianness, except</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// or Hi part come first?  This usually follows the endianness, except</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">  /// for ppcf128, where the Hi part always comes first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">  /// for ppcf128, where the Hi part always comes first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  bool hasBigEndianPartOrdering(EVT VT, const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  bool hasBigEndianPartOrdering(EVT VT, const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">    return DL.isBigEndian() || VT == MVT::ppcf128;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">    return DL.isBigEndian() || VT == MVT::ppcf128;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">  /// If true, the target has custom DAG combine transformations that it can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">  /// If true, the target has custom DAG combine transformations that it can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  /// perform for the specified node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  /// perform for the specified node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine coveredLine">  bool hasTargetDAGCombine(ISD::NodeType NT) const {</td>
    <td class="lineNumber">99</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine coveredLine">  bool hasTargetDAGCombine(ISD::NodeType NT) const {</td>
    <td class="lineNumber">99</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine coveredLine">    assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td class="lineNumber">99</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine coveredLine">    assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td class="lineNumber">99</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine coveredLine">    return TargetDAGCombineArray[NT >> 3] & (1 << (NT&7));</td>
    <td class="lineNumber">99</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine coveredLine">    return TargetDAGCombineArray[NT >> 3] & (1 << (NT&7));</td>
    <td class="lineNumber">99</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">  unsigned getGatherAllAliasesMaxDepth() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">  unsigned getGatherAllAliasesMaxDepth() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">    return GatherAllAliasesMaxDepth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">    return GatherAllAliasesMaxDepth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  /// Returns the size of the platform's va_list object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  /// Returns the size of the platform's va_list object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">  virtual unsigned getVaListSizeInBits(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">  virtual unsigned getVaListSizeInBits(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">    return getPointerTy(DL).getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">    return getPointerTy(DL).getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">  /// Get maximum # of store operations permitted for llvm.memset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">  /// Get maximum # of store operations permitted for llvm.memset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">  /// to replace a call to llvm.memset. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">  /// to replace a call to llvm.memset. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">  unsigned getMaxStoresPerMemset(bool OptSize) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">  unsigned getMaxStoresPerMemset(bool OptSize) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">    return OptSize ? MaxStoresPerMemsetOptSize : MaxStoresPerMemset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">    return OptSize ? MaxStoresPerMemsetOptSize : MaxStoresPerMemset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  /// Get maximum # of store operations permitted for llvm.memcpy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  /// Get maximum # of store operations permitted for llvm.memcpy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">  /// to replace a call to llvm.memcpy. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">  /// to replace a call to llvm.memcpy. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  unsigned getMaxStoresPerMemcpy(bool OptSize) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  unsigned getMaxStoresPerMemcpy(bool OptSize) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">    return OptSize ? MaxStoresPerMemcpyOptSize : MaxStoresPerMemcpy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">    return OptSize ? MaxStoresPerMemcpyOptSize : MaxStoresPerMemcpy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  /// \brief Get maximum # of store operations to be glued together</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  /// \brief Get maximum # of store operations to be glued together</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">  /// to glue together during lowering of llvm.memcpy. The value is set by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">  /// to glue together during lowering of llvm.memcpy. The value is set by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">  //  the target at the performance threshold for such a replacement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">  //  the target at the performance threshold for such a replacement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  virtual unsigned getMaxGluedStoresPerMemcpy() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  virtual unsigned getMaxGluedStoresPerMemcpy() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">    return MaxGluedStoresPerMemcpy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">    return MaxGluedStoresPerMemcpy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">  /// Get maximum # of load operations permitted for memcmp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">  /// Get maximum # of load operations permitted for memcmp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">  /// This function returns the maximum number of load operations permitted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">  /// This function returns the maximum number of load operations permitted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">  /// to replace a call to memcmp. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">  /// to replace a call to memcmp. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">  unsigned getMaxExpandSizeMemcmp(bool OptSize) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">  unsigned getMaxExpandSizeMemcmp(bool OptSize) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">    return OptSize ? MaxLoadsPerMemcmpOptSize : MaxLoadsPerMemcmp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">    return OptSize ? MaxLoadsPerMemcmpOptSize : MaxLoadsPerMemcmp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">  /// Get maximum # of store operations permitted for llvm.memmove</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">  /// Get maximum # of store operations permitted for llvm.memmove</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">  /// This function returns the maximum number of store operations permitted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">  /// to replace a call to llvm.memmove. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">  /// to replace a call to llvm.memmove. The value is set by the target at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">  /// performance threshold for such a replacement. If OptSize is true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">  /// return the limit for functions that have OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">  unsigned getMaxStoresPerMemmove(bool OptSize) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">  unsigned getMaxStoresPerMemmove(bool OptSize) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">    return OptSize ? MaxStoresPerMemmoveOptSize : MaxStoresPerMemmove;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">    return OptSize ? MaxStoresPerMemmoveOptSize : MaxStoresPerMemmove;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">  /// Determine if the target supports unaligned memory accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">  /// Determine if the target supports unaligned memory accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">  /// This function returns true if the target allows unaligned memory accesses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">  /// This function returns true if the target allows unaligned memory accesses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">  /// of the specified type in the given address space. If true, it also returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">  /// of the specified type in the given address space. If true, it also returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">  /// a relative speed of the unaligned memory access in the last argument by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">  /// a relative speed of the unaligned memory access in the last argument by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">  /// reference. The higher the speed number the faster the operation comparing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">  /// reference. The higher the speed number the faster the operation comparing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">  /// to a number returned by another such call. This is used, for example, in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">  /// to a number returned by another such call. This is used, for example, in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">  /// situations where an array copy/move/set is converted to a sequence of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">  /// situations where an array copy/move/set is converted to a sequence of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">  /// store operations. Its use helps to ensure that such replacements don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">  /// store operations. Its use helps to ensure that such replacements don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">  /// generate code that causes an alignment error (trap) on the target machine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">  /// generate code that causes an alignment error (trap) on the target machine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">      EVT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">      EVT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">  /// LLT handling variant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">  /// LLT handling variant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">  virtual bool allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">      LLT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">      LLT, unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">      unsigned * /*Fast*/ = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">  /// This function returns true if the memory access is aligned or if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">  /// This function returns true if the memory access is aligned or if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  /// target allows this specific unaligned memory access. If the access is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  /// target allows this specific unaligned memory access. If the access is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">  /// allowed, the optional final parameter returns a relative speed of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">  /// allowed, the optional final parameter returns a relative speed of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  /// access (as defined by the target).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  /// access (as defined by the target).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  bool allowsMemoryAccessForAlignment(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  bool allowsMemoryAccessForAlignment(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">      LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">      LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">      unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">      unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  /// Return true if the memory access of this type is aligned or if the target</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  /// Return true if the memory access of this type is aligned or if the target</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">  /// allows this specific unaligned access for the given MachineMemOperand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">  /// allows this specific unaligned access for the given MachineMemOperand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  /// If the access is allowed, the optional final parameter returns a relative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  /// If the access is allowed, the optional final parameter returns a relative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">  /// speed of the access (as defined by the target).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">  /// speed of the access (as defined by the target).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  bool allowsMemoryAccessForAlignment(LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  bool allowsMemoryAccessForAlignment(LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">                                      const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">                                      const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">                                      const MachineMemOperand &MMO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">                                      const MachineMemOperand &MMO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">                                      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">                                      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  /// Return true if the target supports a memory access of this type for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  /// Return true if the target supports a memory access of this type for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  /// given address space and alignment. If the access is allowed, the optional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  /// given address space and alignment. If the access is allowed, the optional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  /// final parameter returns the relative speed of the access (as defined by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  /// final parameter returns the relative speed of the access (as defined by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  /// the target).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  /// the target).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">                     unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">                     unsigned AddrSpace = 0, Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">                     MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">                     MachineMemOperand::Flags Flags = MachineMemOperand::MONone,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">                     unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">                     unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  /// Return true if the target supports a memory access of this type for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  /// Return true if the target supports a memory access of this type for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">  /// given MachineMemOperand. If the access is allowed, the optional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">  /// given MachineMemOperand. If the access is allowed, the optional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  /// final parameter returns the relative access speed (as defined by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  /// final parameter returns the relative access speed (as defined by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">  /// target).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">  /// target).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">                          const MachineMemOperand &MMO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">                          const MachineMemOperand &MMO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">                          unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">                          unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  /// LLT handling variant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  /// LLT handling variant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, LLT Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, LLT Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">                          const MachineMemOperand &MMO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">                          const MachineMemOperand &MMO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">                          unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">                          unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">  /// Returns the target specific optimal type for load and store operations as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">  /// Returns the target specific optimal type for load and store operations as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">  /// a result of memset, memcpy, and memmove lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">  /// a result of memset, memcpy, and memmove lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">  /// It returns EVT::Other if the type should be determined using generic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">  /// It returns EVT::Other if the type should be determined using generic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">  /// target-independent logic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">  /// target-independent logic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">  virtual EVT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">  virtual EVT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  getOptimalMemOpType(const MemOp &Op,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  getOptimalMemOpType(const MemOp &Op,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">                      const AttributeList & /*FuncAttributes*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">                      const AttributeList & /*FuncAttributes*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">    return MVT::Other;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">    return MVT::Other;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">  /// LLT returning variant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">  /// LLT returning variant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">  virtual LLT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">  virtual LLT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">  getOptimalMemOpLLT(const MemOp &Op,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">  getOptimalMemOpLLT(const MemOp &Op,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">                     const AttributeList & /*FuncAttributes*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">                     const AttributeList & /*FuncAttributes*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">    return LLT();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">    return LLT();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">  /// Returns true if it's safe to use load / store of the specified type to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">  /// Returns true if it's safe to use load / store of the specified type to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">  /// expand memcpy / memset inline.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">  /// expand memcpy / memset inline.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  /// This is mostly true for all types except for some special cases. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  /// This is mostly true for all types except for some special cases. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">  /// example, on X86 targets without SSE2 f64 load / store are done with fldl /</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">  /// example, on X86 targets without SSE2 f64 load / store are done with fldl /</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">  /// fstpl which also does type conversion. Note the specified type doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">  /// fstpl which also does type conversion. Note the specified type doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">  /// have to be legal as the hook is used before type legalization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">  /// have to be legal as the hook is used before type legalization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">  virtual bool isSafeMemOpType(MVT /*VT*/) const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">  virtual bool isSafeMemOpType(MVT /*VT*/) const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">  /// Return lower limit for number of blocks in a jump table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">  /// Return lower limit for number of blocks in a jump table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">  virtual unsigned getMinimumJumpTableEntries() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">  virtual unsigned getMinimumJumpTableEntries() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">  /// Return lower limit of the density in a jump table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">  /// Return lower limit of the density in a jump table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">  unsigned getMinimumJumpTableDensity(bool OptForSize) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">  unsigned getMinimumJumpTableDensity(bool OptForSize) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  /// Return upper limit for number of entries in a jump table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  /// Return upper limit for number of entries in a jump table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">  /// Zero if no limit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">  /// Zero if no limit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  unsigned getMaximumJumpTableSize() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  unsigned getMaximumJumpTableSize() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">  virtual bool isJumpTableRelative() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">  virtual bool isJumpTableRelative() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  /// If a physical register, this specifies the register that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  /// If a physical register, this specifies the register that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine coveredLine">  Register getStackPointerRegisterToSaveRestore() const {</td>
    <td class="lineNumber">21</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  Register getStackPointerRegisterToSaveRestore() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine coveredLine">    return StackPointerRegisterToSaveRestore;</td>
    <td class="lineNumber">21</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">    return StackPointerRegisterToSaveRestore;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// If a physical register, this returns the register that receives the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// If a physical register, this returns the register that receives the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  /// exception address on entry to an EH pad.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  /// exception address on entry to an EH pad.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  virtual Register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  virtual Register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">  getExceptionPointerRegister(const Constant *PersonalityFn) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">  getExceptionPointerRegister(const Constant *PersonalityFn) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">    return Register();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">    return Register();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">  /// If a physical register, this returns the register that receives the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">  /// If a physical register, this returns the register that receives the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">  /// exception typeid on entry to a landing pad.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">  /// exception typeid on entry to a landing pad.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">  virtual Register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">  virtual Register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  getExceptionSelectorRegister(const Constant *PersonalityFn) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  getExceptionSelectorRegister(const Constant *PersonalityFn) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">    return Register();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">    return Register();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">  virtual bool needsFixedCatchObjects() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">  virtual bool needsFixedCatchObjects() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">    report_fatal_error("Funclet EH is not implemented for this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">    report_fatal_error("Funclet EH is not implemented for this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">  /// Return the minimum stack alignment of an argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">  /// Return the minimum stack alignment of an argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  Align getMinStackArgumentAlignment() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  Align getMinStackArgumentAlignment() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">    return MinStackArgumentAlignment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">    return MinStackArgumentAlignment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// Return the minimum function alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// Return the minimum function alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine coveredLine">  Align getMinFunctionAlignment() const { return MinFunctionAlignment; }</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine coveredLine">  Align getMinFunctionAlignment() const { return MinFunctionAlignment; }</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// Return the preferred function alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// Return the preferred function alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine coveredLine">  Align getPrefFunctionAlignment() const { return PrefFunctionAlignment; }</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine coveredLine">  Align getPrefFunctionAlignment() const { return PrefFunctionAlignment; }</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">  /// Return the preferred loop alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">  /// Return the preferred loop alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  virtual Align getPrefLoopAlignment(MachineLoop *ML = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  virtual Align getPrefLoopAlignment(MachineLoop *ML = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">  /// Return the maximum amount of bytes allowed to be emitted when padding for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">  /// Return the maximum amount of bytes allowed to be emitted when padding for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  /// alignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  /// alignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">  getMaxPermittedBytesForAlignment(MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">  getMaxPermittedBytesForAlignment(MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">  /// Should loops be aligned even when the function is marked OptSize (but not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">  /// Should loops be aligned even when the function is marked OptSize (but not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">  /// MinSize).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">  /// MinSize).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">  virtual bool alignLoopsWithOptSize() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">  virtual bool alignLoopsWithOptSize() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">  /// If the target has a standard location for the stack protector guard,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">  /// If the target has a standard location for the stack protector guard,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">  /// returns the address of that location. Otherwise, returns nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">  /// returns the address of that location. Otherwise, returns nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">  /// DEPRECATED: please override useLoadStackGuardNode and customize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">  /// DEPRECATED: please override useLoadStackGuardNode and customize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">  ///             LOAD_STACK_GUARD, or customize \@llvm.stackguard().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">  ///             LOAD_STACK_GUARD, or customize \@llvm.stackguard().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">  virtual Value *getIRStackGuard(IRBuilderBase &IRB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">  virtual Value *getIRStackGuard(IRBuilderBase &IRB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  /// Inserts necessary declarations for SSP (stack protection) purpose.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  /// Inserts necessary declarations for SSP (stack protection) purpose.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">  virtual void insertSSPDeclarations(Module &M) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">  virtual void insertSSPDeclarations(Module &M) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  /// Return the variable that's previously inserted by insertSSPDeclarations,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  /// Return the variable that's previously inserted by insertSSPDeclarations,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  /// if any, otherwise return nullptr. Should be used only when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  /// if any, otherwise return nullptr. Should be used only when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  /// getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  /// getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">  virtual Value *getSDagStackGuard(const Module &M) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">  virtual Value *getSDagStackGuard(const Module &M) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">  /// If this function returns true, stack protection checks should XOR the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">  /// If this function returns true, stack protection checks should XOR the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">  /// frame pointer (or whichever pointer is used to address locals) into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">  /// frame pointer (or whichever pointer is used to address locals) into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">  /// stack guard value before checking it. getIRStackGuard must return nullptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">  /// stack guard value before checking it. getIRStackGuard must return nullptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">  /// if this returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">  /// if this returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">  virtual bool useStackGuardXorFP() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">  virtual bool useStackGuardXorFP() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  /// If the target has a standard stack protection check function that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  /// If the target has a standard stack protection check function that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">  /// performs validation and error handling, returns the function. Otherwise,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">  /// performs validation and error handling, returns the function. Otherwise,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">  /// returns nullptr. Must be previously inserted by insertSSPDeclarations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">  /// returns nullptr. Must be previously inserted by insertSSPDeclarations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">  /// Should be used only when getIRStackGuard returns nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">  virtual Function *getSSPStackGuardCheck(const Module &M) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">  virtual Function *getSSPStackGuardCheck(const Module &M) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  /// \returns true if a constant G_UBFX is legal on the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  /// \returns true if a constant G_UBFX is legal on the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  virtual bool isConstantUnsignedBitfieldExtractLegal(unsigned Opc, LLT Ty1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  virtual bool isConstantUnsignedBitfieldExtractLegal(unsigned Opc, LLT Ty1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">                                                      LLT Ty2) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">                                                      LLT Ty2) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  Value *getDefaultSafeStackPointerLocation(IRBuilderBase &IRB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  Value *getDefaultSafeStackPointerLocation(IRBuilderBase &IRB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">                                            bool UseTLS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">                                            bool UseTLS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">  /// Returns the target-specific address of the unsafe stack pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">  /// Returns the target-specific address of the unsafe stack pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  virtual Value *getSafeStackPointerLocation(IRBuilderBase &IRB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  virtual Value *getSafeStackPointerLocation(IRBuilderBase &IRB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">  /// Returns the name of the symbol used to emit stack probes or the empty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">  /// Returns the name of the symbol used to emit stack probes or the empty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  /// string if not applicable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  /// string if not applicable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">  virtual bool hasStackProbeSymbol(const MachineFunction &MF) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">  virtual bool hasStackProbeSymbol(const MachineFunction &MF) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  virtual bool hasInlineStackProbe(const MachineFunction &MF) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  virtual bool hasInlineStackProbe(const MachineFunction &MF) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">  virtual StringRef getStackProbeSymbolName(const MachineFunction &MF) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">  virtual StringRef getStackProbeSymbolName(const MachineFunction &MF) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">    return "";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">    return "";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">  /// Returns true if a cast from SrcAS to DestAS is "cheap", such that e.g. we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">  /// Returns true if a cast from SrcAS to DestAS is "cheap", such that e.g. we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">  /// are happy to sink it into basic blocks. A cast may be free, but not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">  /// are happy to sink it into basic blocks. A cast may be free, but not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">  /// necessarily a no-op. e.g. a free truncate from a 64-bit to 32-bit pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">  /// necessarily a no-op. e.g. a free truncate from a 64-bit to 32-bit pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  virtual bool isFreeAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  virtual bool isFreeAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  /// Return true if the pointer arguments to CI should be aligned by aligning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  /// Return true if the pointer arguments to CI should be aligned by aligning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  /// the object whose address is being passed. If so then MinSize is set to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  /// the object whose address is being passed. If so then MinSize is set to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  /// minimum size the object must be to be aligned and PrefAlign is set to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  /// minimum size the object must be to be aligned and PrefAlign is set to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  /// preferred alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  /// preferred alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  virtual bool shouldAlignPointerArgs(CallInst * /*CI*/, unsigned & /*MinSize*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  virtual bool shouldAlignPointerArgs(CallInst * /*CI*/, unsigned & /*MinSize*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">                                      Align & /*PrefAlign*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">                                      Align & /*PrefAlign*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">  /// \name Helpers for TargetTransformInfo implementations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">  /// \name Helpers for TargetTransformInfo implementations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">  /// Get the ISD node that corresponds to the Instruction class opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">  /// Get the ISD node that corresponds to the Instruction class opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">  int InstructionOpcodeToISD(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">  int InstructionOpcodeToISD(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  /// \name Helpers for atomic expansion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  /// \name Helpers for atomic expansion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">  /// Returns the maximum atomic operation size (in bits) supported by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">  /// Returns the maximum atomic operation size (in bits) supported by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">  /// the backend. Atomic operations greater than this size (as well</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">  /// the backend. Atomic operations greater than this size (as well</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">  /// as ones that are not naturally aligned), will be expanded by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">  /// as ones that are not naturally aligned), will be expanded by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  unsigned getMaxAtomicSizeInBitsSupported() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  unsigned getMaxAtomicSizeInBitsSupported() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">    return MaxAtomicSizeInBitsSupported;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">    return MaxAtomicSizeInBitsSupported;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">  /// Returns the size in bits of the maximum div/rem the backend supports.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">  /// Returns the size in bits of the maximum div/rem the backend supports.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine coveredLine">  unsigned getMaxDivRemBitWidthSupported() const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine coveredLine">  unsigned getMaxDivRemBitWidthSupported() const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine coveredLine">    return MaxDivRemBitWidthSupported;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine coveredLine">    return MaxDivRemBitWidthSupported;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">  /// Returns the size in bits of the maximum larget fp convert the backend</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">  /// Returns the size in bits of the maximum larget fp convert the backend</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine coveredLine">  unsigned getMaxLargeFPConvertBitWidthSupported() const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine coveredLine">  unsigned getMaxLargeFPConvertBitWidthSupported() const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine coveredLine">    return MaxLargeFPConvertBitWidthSupported;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine coveredLine">    return MaxLargeFPConvertBitWidthSupported;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">  /// Returns the size of the smallest cmpxchg or ll/sc instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">  /// Returns the size of the smallest cmpxchg or ll/sc instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">  /// the backend supports.  Any smaller operations are widened in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">  /// the backend supports.  Any smaller operations are widened in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">  /// AtomicExpandPass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">  /// AtomicExpandPass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">  /// Note that *unlike* operations above the maximum size, atomic ops</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">  /// Note that *unlike* operations above the maximum size, atomic ops</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">  /// are still natively supported below the minimum; they just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">  /// are still natively supported below the minimum; they just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">  /// require a more complex expansion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">  /// require a more complex expansion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">  unsigned getMinCmpXchgSizeInBits() const { return MinCmpXchgSizeInBits; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">  unsigned getMinCmpXchgSizeInBits() const { return MinCmpXchgSizeInBits; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">  /// Whether the target supports unaligned atomic operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">  /// Whether the target supports unaligned atomic operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">  bool supportsUnalignedAtomics() const { return SupportsUnalignedAtomics; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">  bool supportsUnalignedAtomics() const { return SupportsUnalignedAtomics; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">  /// Whether AtomicExpandPass should automatically insert fences and reduce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">  /// Whether AtomicExpandPass should automatically insert fences and reduce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  /// ordering for this atomic. This should be true for most architectures with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  /// ordering for this atomic. This should be true for most architectures with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  /// weak memory ordering. Defaults to false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  /// weak memory ordering. Defaults to false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">  virtual bool shouldInsertFencesForAtomic(const Instruction *I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">  virtual bool shouldInsertFencesForAtomic(const Instruction *I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">  /// Whether AtomicExpandPass should automatically insert a trailing fence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">  /// Whether AtomicExpandPass should automatically insert a trailing fence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">  /// without reducing the ordering for this atomic. Defaults to false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">  /// without reducing the ordering for this atomic. Defaults to false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  shouldInsertTrailingFenceForAtomicStore(const Instruction *I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  shouldInsertTrailingFenceForAtomicStore(const Instruction *I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">  /// Perform a load-linked operation on Addr, returning a "Value *" with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">  /// Perform a load-linked operation on Addr, returning a "Value *" with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  /// corresponding pointee type. This may entail some non-trivial operations to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  /// corresponding pointee type. This may entail some non-trivial operations to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">  /// truncate or reconstruct types that will be illegal in the backend. See</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">  /// truncate or reconstruct types that will be illegal in the backend. See</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">  /// ARMISelLowering for an example implementation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">  /// ARMISelLowering for an example implementation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">  virtual Value *emitLoadLinked(IRBuilderBase &Builder, Type *ValueTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">  virtual Value *emitLoadLinked(IRBuilderBase &Builder, Type *ValueTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">                                Value *Addr, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">                                Value *Addr, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">    llvm_unreachable("Load linked unimplemented on this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">    llvm_unreachable("Load linked unimplemented on this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  /// Perform a store-conditional operation to Addr. Return the status of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  /// Perform a store-conditional operation to Addr. Return the status of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  /// store. This should be 0 if the store succeeded, non-zero otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  /// store. This should be 0 if the store succeeded, non-zero otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">  virtual Value *emitStoreConditional(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">  virtual Value *emitStoreConditional(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">                                      Value *Addr, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">                                      Value *Addr, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">    llvm_unreachable("Store conditional unimplemented on this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">    llvm_unreachable("Store conditional unimplemented on this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">  /// Perform a masked atomicrmw using a target-specific intrinsic. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">  /// Perform a masked atomicrmw using a target-specific intrinsic. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">  /// is not responsible for masking and shifting the result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">  /// is not responsible for masking and shifting the result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">  virtual Value *emitMaskedAtomicRMWIntrinsic(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">  virtual Value *emitMaskedAtomicRMWIntrinsic(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">                                              AtomicRMWInst *AI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">                                              AtomicRMWInst *AI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">                                              Value *AlignedAddr, Value *Incr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">                                              Value *AlignedAddr, Value *Incr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">                                              Value *Mask, Value *ShiftAmt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">                                              Value *Mask, Value *ShiftAmt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">                                              AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">                                              AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">    llvm_unreachable("Masked atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">    llvm_unreachable("Masked atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  /// Perform a atomicrmw expansion using a target-specific way. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  /// Perform a atomicrmw expansion using a target-specific way. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  /// expected to be called when masked atomicrmw and bit test atomicrmw don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  /// expected to be called when masked atomicrmw and bit test atomicrmw don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  /// work, and the target supports another way to lower atomicrmw.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  /// work, and the target supports another way to lower atomicrmw.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  virtual void emitExpandAtomicRMW(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  virtual void emitExpandAtomicRMW(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">        "Generic atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">        "Generic atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">  /// Perform a bit test atomicrmw using a target-specific intrinsic. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">  /// Perform a bit test atomicrmw using a target-specific intrinsic. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">  /// represents the combined bit test intrinsic which will be lowered at a late</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">  /// represents the combined bit test intrinsic which will be lowered at a late</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">  /// stage by the backend.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">  /// stage by the backend.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">  virtual void emitBitTestAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">  virtual void emitBitTestAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">        "Bit test atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">        "Bit test atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">  /// Perform a atomicrmw which the result is only used by comparison, using a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">  /// Perform a atomicrmw which the result is only used by comparison, using a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">  /// target-specific intrinsic. This represents the combined atomic and compare</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">  /// target-specific intrinsic. This represents the combined atomic and compare</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">  /// intrinsic which will be lowered at a late stage by the backend.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">  /// intrinsic which will be lowered at a late stage by the backend.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">  virtual void emitCmpArithAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">  virtual void emitCmpArithAtomicRMWIntrinsic(AtomicRMWInst *AI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">        "Compare arith atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">        "Compare arith atomicrmw expansion unimplemented on this target");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">  /// Perform a masked cmpxchg using a target-specific intrinsic. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">  /// Perform a masked cmpxchg using a target-specific intrinsic. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">  /// represents the core LL/SC loop which will be lowered at a late stage by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  /// the backend. The target-specific intrinsic returns the loaded value and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">  /// is not responsible for masking and shifting the result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">  /// is not responsible for masking and shifting the result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  virtual Value *emitMaskedAtomicCmpXchgIntrinsic(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  virtual Value *emitMaskedAtomicCmpXchgIntrinsic(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">      IRBuilderBase &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">      IRBuilderBase &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">      Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">      Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">    llvm_unreachable("Masked cmpxchg expansion unimplemented on this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">    llvm_unreachable("Masked cmpxchg expansion unimplemented on this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">  /// \name KCFI check lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">  /// \name KCFI check lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  virtual MachineInstr *EmitKCFICheck(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  virtual MachineInstr *EmitKCFICheck(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">                                      MachineBasicBlock::instr_iterator &MBBI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">                                      MachineBasicBlock::instr_iterator &MBBI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">                                      const TargetInstrInfo *TII) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">                                      const TargetInstrInfo *TII) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">    llvm_unreachable("KCFI is not supported on this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">    llvm_unreachable("KCFI is not supported on this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  /// Inserts in the IR a target-specific intrinsic specifying a fence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  /// Inserts in the IR a target-specific intrinsic specifying a fence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">  /// It is called by AtomicExpandPass before expanding an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">  /// It is called by AtomicExpandPass before expanding an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  ///   AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  ///   AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  ///   if shouldInsertFencesForAtomic returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  ///   if shouldInsertFencesForAtomic returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  /// Inst is the original atomic instruction, prior to other expansions that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  /// Inst is the original atomic instruction, prior to other expansions that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  /// may be performed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  /// may be performed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  /// This function should either return a nullptr, or a pointer to an IR-level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  /// This function should either return a nullptr, or a pointer to an IR-level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">  ///   Instruction*. Even complex fence sequences can be represented by a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">  ///   Instruction*. Even complex fence sequences can be represented by a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">  ///   single Instruction* through an intrinsic to be lowered later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">  ///   single Instruction* through an intrinsic to be lowered later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">  /// Backends should override this method to produce target-specific intrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">  /// Backends should override this method to produce target-specific intrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  ///   for their fences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  ///   for their fences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">  /// FIXME: Please note that the default implementation here in terms of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">  /// FIXME: Please note that the default implementation here in terms of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  ///   IR-level fences exists for historical/compatibility reasons and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  ///   IR-level fences exists for historical/compatibility reasons and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">  ///   *unsound* ! Fences cannot, in general, be used to restore sequential</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">  ///   *unsound* ! Fences cannot, in general, be used to restore sequential</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">  ///   consistency. For example, consider the following example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">  ///   consistency. For example, consider the following example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">  /// atomic<int> x = y = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">  /// atomic<int> x = y = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">  /// int r1, r2, r3, r4;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">  /// int r1, r2, r3, r4;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">  /// Thread 0:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">  /// Thread 0:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">  ///   x.store(1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">  ///   x.store(1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  /// Thread 1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  /// Thread 1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">  ///   y.store(1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">  ///   y.store(1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">  /// Thread 2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">  /// Thread 2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  ///   r1 = x.load();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  ///   r1 = x.load();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">  ///   r2 = y.load();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">  ///   r2 = y.load();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">  /// Thread 3:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">  /// Thread 3:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">  ///   r3 = y.load();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">  ///   r3 = y.load();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">  ///   r4 = x.load();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">  ///   r4 = x.load();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">  ///  r1 = r3 = 1 and r2 = r4 = 0 is impossible as long as the accesses are all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">  ///  r1 = r3 = 1 and r2 = r4 = 0 is impossible as long as the accesses are all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  ///  seq_cst. But if they are lowered to monotonic accesses, no amount of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  ///  seq_cst. But if they are lowered to monotonic accesses, no amount of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  ///  IR-level fences can prevent it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  ///  IR-level fences can prevent it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">  virtual Instruction *emitLeadingFence(IRBuilderBase &Builder,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">  virtual Instruction *emitLeadingFence(IRBuilderBase &Builder,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">                                        Instruction *Inst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">                                        Instruction *Inst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">                                        AtomicOrdering Ord) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">                                        AtomicOrdering Ord) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  virtual Instruction *emitTrailingFence(IRBuilderBase &Builder,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  virtual Instruction *emitTrailingFence(IRBuilderBase &Builder,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">                                         Instruction *Inst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">                                         Instruction *Inst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">                                         AtomicOrdering Ord) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">                                         AtomicOrdering Ord) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // Emits code that executes when the comparison result in the ll/sc</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // Emits code that executes when the comparison result in the ll/sc</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // expansion of a cmpxchg instruction is such that the store-conditional will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // expansion of a cmpxchg instruction is such that the store-conditional will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  // not execute.  This makes it possible to balance out the load-linked with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  // not execute.  This makes it possible to balance out the load-linked with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">  // a dedicated instruction, if desired.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">  // a dedicated instruction, if desired.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">  // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">  // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">  // be unnecessarily held, except if clrex, inserted by this hook, is executed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">  // be unnecessarily held, except if clrex, inserted by this hook, is executed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">  virtual void emitAtomicCmpXchgNoStoreLLBalance(IRBuilderBase &Builder) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">  virtual void emitAtomicCmpXchgNoStoreLLBalance(IRBuilderBase &Builder) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">  /// Returns true if arguments should be sign-extended in lib calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">  /// Returns true if arguments should be sign-extended in lib calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">  virtual bool shouldSignExtendTypeInLibCall(EVT Type, bool IsSigned) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">  virtual bool shouldSignExtendTypeInLibCall(EVT Type, bool IsSigned) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">    return IsSigned;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">    return IsSigned;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  /// Returns true if arguments should be extended in lib calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  /// Returns true if arguments should be extended in lib calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">  virtual bool shouldExtendTypeInLibCall(EVT Type) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">  virtual bool shouldExtendTypeInLibCall(EVT Type) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  /// Returns how the given (atomic) load should be expanded by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  /// Returns how the given (atomic) load should be expanded by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">  /// IR-level AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">  /// IR-level AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldExpandAtomicLoadInIR(LoadInst *LI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldExpandAtomicLoadInIR(LoadInst *LI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">  /// Returns how the given (atomic) load should be cast by the IR-level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">  /// Returns how the given (atomic) load should be cast by the IR-level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  /// AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  /// AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldCastAtomicLoadInIR(LoadInst *LI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldCastAtomicLoadInIR(LoadInst *LI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">    if (LI->getType()->isFloatingPointTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">    if (LI->getType()->isFloatingPointTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">  /// Returns how the given (atomic) store should be expanded by the IR-level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">  /// Returns how the given (atomic) store should be expanded by the IR-level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">  /// AtomicExpand pass into. For instance AtomicExpansionKind::Expand will try</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">  /// AtomicExpand pass into. For instance AtomicExpansionKind::Expand will try</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">  /// to use an atomicrmw xchg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">  /// to use an atomicrmw xchg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldExpandAtomicStoreInIR(StoreInst *SI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldExpandAtomicStoreInIR(StoreInst *SI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">  /// Returns how the given (atomic) store should be cast by the IR-level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">  /// Returns how the given (atomic) store should be cast by the IR-level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">  /// AtomicExpand pass into. For instance AtomicExpansionKind::CastToInteger</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">  /// AtomicExpand pass into. For instance AtomicExpansionKind::CastToInteger</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">  /// will try to cast the operands to integer values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">  /// will try to cast the operands to integer values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldCastAtomicStoreInIR(StoreInst *SI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldCastAtomicStoreInIR(StoreInst *SI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">    if (SI->getValueOperand()->getType()->isFloatingPointTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">    if (SI->getValueOperand()->getType()->isFloatingPointTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">  /// Returns how the given atomic cmpxchg should be expanded by the IR-level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">  /// Returns how the given atomic cmpxchg should be expanded by the IR-level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">  /// AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">  /// AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">  virtual AtomicExpansionKind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">  virtual AtomicExpansionKind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *AI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *AI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">  /// Returns how the IR-level AtomicExpand pass should expand the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">  /// Returns how the IR-level AtomicExpand pass should expand the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">  /// AtomicRMW, if at all. Default is to never expand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">  /// AtomicRMW, if at all. Default is to never expand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">  virtual AtomicExpansionKind shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">    return RMW->isFloatingPointOperation() ?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">    return RMW->isFloatingPointOperation() ?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">      AtomicExpansionKind::CmpXChg : AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">      AtomicExpansionKind::CmpXChg : AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">  /// Returns how the given atomic atomicrmw should be cast by the IR-level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">  /// Returns how the given atomic atomicrmw should be cast by the IR-level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">  /// AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">  /// AtomicExpand pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">  virtual AtomicExpansionKind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">  virtual AtomicExpansionKind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">  shouldCastAtomicRMWIInIR(AtomicRMWInst *RMWI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">  shouldCastAtomicRMWIInIR(AtomicRMWInst *RMWI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">    if (RMWI->getOperation() == AtomicRMWInst::Xchg &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">    if (RMWI->getOperation() == AtomicRMWInst::Xchg &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">        (RMWI->getValOperand()->getType()->isFloatingPointTy() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">        (RMWI->getValOperand()->getType()->isFloatingPointTy() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">         RMWI->getValOperand()->getType()->isPointerTy()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">         RMWI->getValOperand()->getType()->isPointerTy()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">      return AtomicExpansionKind::CastToInteger;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">    return AtomicExpansionKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">  /// On some platforms, an AtomicRMW that never actually modifies the value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">  /// On some platforms, an AtomicRMW that never actually modifies the value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">  /// (such as fetch_add of 0) can be turned into a fence followed by an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">  /// (such as fetch_add of 0) can be turned into a fence followed by an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">  /// atomic load. This may sound useless, but it makes it possible for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">  /// atomic load. This may sound useless, but it makes it possible for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">  /// processor to keep the cacheline shared, dramatically improving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">  /// processor to keep the cacheline shared, dramatically improving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">  /// performance. And such idempotent RMWs are useful for implementing some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">  /// performance. And such idempotent RMWs are useful for implementing some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">  /// kinds of locks, see for example (justification + benchmarks):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">  /// kinds of locks, see for example (justification + benchmarks):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">  /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">  /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">  /// This method tries doing that transformation, returning the atomic load if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">  /// This method tries doing that transformation, returning the atomic load if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">  /// it succeeds, and nullptr otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">  /// it succeeds, and nullptr otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">  /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">  /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">  /// another round of expansion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">  /// another round of expansion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">  virtual LoadInst *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">  virtual LoadInst *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">  lowerIdempotentRMWIntoFencedLoad(AtomicRMWInst *RMWI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">  lowerIdempotentRMWIntoFencedLoad(AtomicRMWInst *RMWI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">  /// Returns how the platform's atomic operations are extended (ZERO_EXTEND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">  /// Returns how the platform's atomic operations are extended (ZERO_EXTEND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  /// SIGN_EXTEND, or ANY_EXTEND).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  /// SIGN_EXTEND, or ANY_EXTEND).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">  virtual ISD::NodeType getExtendForAtomicOps() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">  virtual ISD::NodeType getExtendForAtomicOps() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">    return ISD::ZERO_EXTEND;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">    return ISD::ZERO_EXTEND;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  /// Returns how the platform's atomic compare and swap expects its comparison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  /// Returns how the platform's atomic compare and swap expects its comparison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  /// separate from getExtendForAtomicOps, which is concerned with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  /// separate from getExtendForAtomicOps, which is concerned with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">  /// sign-extension of the instruction's output, whereas here we are concerned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">  /// sign-extension of the instruction's output, whereas here we are concerned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  /// with the sign-extension of the input. For targets with compare-and-swap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  /// with the sign-extension of the input. For targets with compare-and-swap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">  /// instructions (or sub-word comparisons in their LL/SC loop expansions),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">  /// instructions (or sub-word comparisons in their LL/SC loop expansions),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">  /// the input can be ANY_EXTEND, but the output will still have a specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">  /// the input can be ANY_EXTEND, but the output will still have a specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">  /// extension.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">  /// extension.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  virtual ISD::NodeType getExtendForAtomicCmpSwapArg() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  virtual ISD::NodeType getExtendForAtomicCmpSwapArg() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">    return ISD::ANY_EXTEND;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">    return ISD::ANY_EXTEND;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">  /// Returns true if we should normalize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">  /// Returns true if we should normalize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">  /// that it saves us from materializing N0 and N1 in an integer register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">  /// that it saves us from materializing N0 and N1 in an integer register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  /// Targets that are able to perform and/or on flags should return false here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  /// Targets that are able to perform and/or on flags should return false here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  virtual bool shouldNormalizeToSelectSequence(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  virtual bool shouldNormalizeToSelectSequence(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">                                               EVT VT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">                                               EVT VT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    // If a target has multiple condition registers, then it likely has logical</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    // If a target has multiple condition registers, then it likely has logical</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">    // operations on those registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">    // operations on those registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">    if (hasMultipleConditionRegisters())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">    if (hasMultipleConditionRegisters())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">    // Only do the transform if the value won't be split into multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">    // Only do the transform if the value won't be split into multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">    // registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">    // registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">    LegalizeTypeAction Action = getTypeAction(Context, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">    LegalizeTypeAction Action = getTypeAction(Context, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">    return Action != TypeExpandInteger && Action != TypeExpandFloat &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">    return Action != TypeExpandInteger && Action != TypeExpandFloat &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">      Action != TypeSplitVector;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">      Action != TypeSplitVector;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">  virtual bool isProfitableToCombineMinNumMaxNum(EVT VT) const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">  virtual bool isProfitableToCombineMinNumMaxNum(EVT VT) const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">  /// Return true if a select of constants (select Cond, C1, C2) should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">  /// Return true if a select of constants (select Cond, C1, C2) should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">  /// transformed into simple math ops with the condition value. For example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">  /// transformed into simple math ops with the condition value. For example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">  /// select Cond, C1, C1-1 --> add (zext Cond), C1-1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">  /// select Cond, C1, C1-1 --> add (zext Cond), C1-1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">  virtual bool convertSelectOfConstantsToMath(EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">  virtual bool convertSelectOfConstantsToMath(EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">  /// Return true if it is profitable to transform an integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">  /// Return true if it is profitable to transform an integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">  /// multiplication-by-constant into simpler operations like shifts and adds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">  /// multiplication-by-constant into simpler operations like shifts and adds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">  /// This may be true if the target does not directly support the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">  /// This may be true if the target does not directly support the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">  /// multiplication operation for the specified type or the sequence of simpler</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">  /// multiplication operation for the specified type or the sequence of simpler</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">  /// ops is faster than the multiply.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">  /// ops is faster than the multiply.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">  virtual bool decomposeMulByConstant(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">  virtual bool decomposeMulByConstant(LLVMContext &Context,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">                                      EVT VT, SDValue C) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">                                      EVT VT, SDValue C) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">  /// Return true if it may be profitable to transform</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">  /// Return true if it may be profitable to transform</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">  /// (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">  /// (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">  /// This may not be true if c1 and c2 can be represented as immediates but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">  /// This may not be true if c1 and c2 can be represented as immediates but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">  /// c1*c2 cannot, for example.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">  /// c1*c2 cannot, for example.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">  /// The target should check if c1, c2 and c1*c2 can be represented as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">  /// The target should check if c1, c2 and c1*c2 can be represented as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">  /// immediates, or have to be materialized into registers. If it is not sure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">  /// immediates, or have to be materialized into registers. If it is not sure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">  /// about some cases, a default true can be returned to let the DAGCombiner</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">  /// about some cases, a default true can be returned to let the DAGCombiner</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">  /// decide.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">  /// decide.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">  /// AddNode is (add x, c1), and ConstNode is c2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">  /// AddNode is (add x, c1), and ConstNode is c2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">  virtual bool isMulAddWithConstProfitable(SDValue AddNode,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">  virtual bool isMulAddWithConstProfitable(SDValue AddNode,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">                                           SDValue ConstNode) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">                                           SDValue ConstNode) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">  /// Return true if it is more correct/profitable to use strict FP_TO_INT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">  /// Return true if it is more correct/profitable to use strict FP_TO_INT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">  /// conversion operations - canonicalizing the FP source value instead of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">  /// conversion operations - canonicalizing the FP source value instead of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">  /// converting all cases and then selecting based on value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">  /// converting all cases and then selecting based on value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">  /// This may be true if the target throws exceptions for out of bounds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">  /// This may be true if the target throws exceptions for out of bounds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">  /// conversions or has fast FP CMOV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">  /// conversions or has fast FP CMOV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">  virtual bool shouldUseStrictFP_TO_INT(EVT FpVT, EVT IntVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">  virtual bool shouldUseStrictFP_TO_INT(EVT FpVT, EVT IntVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">                                        bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">                                        bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">  /// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">  /// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">  /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">  /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">  /// considered beneficial.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">  /// considered beneficial.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">  /// If optimizing for size, expansion is only considered beneficial for upto</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">  /// If optimizing for size, expansion is only considered beneficial for upto</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">  /// 5 multiplies and a divide (if the exponent is negative).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">  /// 5 multiplies and a divide (if the exponent is negative).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">  bool isBeneficialToExpandPowI(int64_t Exponent, bool OptForSize) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">  bool isBeneficialToExpandPowI(int64_t Exponent, bool OptForSize) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">    if (Exponent < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">    if (Exponent < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">      Exponent = -Exponent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">      Exponent = -Exponent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">    uint64_t E = static_cast<uint64_t>(Exponent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">    uint64_t E = static_cast<uint64_t>(Exponent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">    return !OptForSize || (llvm::popcount(E) + Log2_64(E) < 7);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">    return !OptForSize || (llvm::popcount(E) + Log2_64(E) < 7);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">  // TargetLowering Configuration Methods - These methods should be invoked by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">  // TargetLowering Configuration Methods - These methods should be invoked by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">  // the derived class constructor to configure this object for the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">  // the derived class constructor to configure this object for the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">  /// Specify how the target extends the result of integer and floating point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">  /// Specify how the target extends the result of integer and floating point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine coveredLine">  void setBooleanContents(BooleanContent Ty) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine coveredLine">  void setBooleanContents(BooleanContent Ty) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine coveredLine">    BooleanContents = Ty;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine coveredLine">    BooleanContents = Ty;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine coveredLine">    BooleanFloatContents = Ty;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine coveredLine">    BooleanFloatContents = Ty;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  /// Specify how the target extends the result of integer and floating point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  /// Specify how the target extends the result of integer and floating point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  /// boolean values from i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">  void setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">  void setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">    BooleanContents = IntTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">    BooleanContents = IntTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">    BooleanFloatContents = FloatTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">    BooleanFloatContents = FloatTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">  /// Specify how the target extends the result of a vector boolean value from a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">  /// Specify how the target extends the result of a vector boolean value from a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">  /// vector of i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">  /// vector of i1 to a wider type.  See getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine coveredLine">  void setBooleanVectorContents(BooleanContent Ty) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine coveredLine">  void setBooleanVectorContents(BooleanContent Ty) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine coveredLine">    BooleanVectorContents = Ty;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine coveredLine">    BooleanVectorContents = Ty;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">  /// Specify the target scheduling preference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">  /// Specify the target scheduling preference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">  void setSchedulingPreference(Sched::Preference Pref) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">  void setSchedulingPreference(Sched::Preference Pref) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">    SchedPreferenceInfo = Pref;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">    SchedPreferenceInfo = Pref;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">  /// Indicate the minimum number of blocks to generate jump tables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">  /// Indicate the minimum number of blocks to generate jump tables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">  void setMinimumJumpTableEntries(unsigned Val);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">  void setMinimumJumpTableEntries(unsigned Val);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  /// Indicate the maximum number of entries in jump tables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  /// Indicate the maximum number of entries in jump tables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">  /// Set to zero to generate unlimited jump tables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">  /// Set to zero to generate unlimited jump tables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  void setMaximumJumpTableSize(unsigned);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  void setMaximumJumpTableSize(unsigned);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  /// If set to a physical register, this specifies the register that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  /// If set to a physical register, this specifies the register that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine coveredLine">  void setStackPointerRegisterToSaveRestore(Register R) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine coveredLine">  void setStackPointerRegisterToSaveRestore(Register R) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine coveredLine">    StackPointerRegisterToSaveRestore = R;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine coveredLine">    StackPointerRegisterToSaveRestore = R;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  /// condition registers that can be used to store the results of comparisons</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  /// condition registers that can be used to store the results of comparisons</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  /// for use by selects and conditional branches. With multiple condition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  /// for use by selects and conditional branches. With multiple condition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">  /// the blocks of their users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">  /// the blocks of their users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  void setHasMultipleConditionRegisters(bool hasManyRegs = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  void setHasMultipleConditionRegisters(bool hasManyRegs = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    HasMultipleConditionRegisters = hasManyRegs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    HasMultipleConditionRegisters = hasManyRegs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">  /// their users if the users will generate "and" instructions which can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">  /// their users if the users will generate "and" instructions which can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">  /// combined with "shift" to BitExtract instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">  /// combined with "shift" to BitExtract instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">  void setHasExtractBitsInsn(bool hasExtractInsn = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">  void setHasExtractBitsInsn(bool hasExtractInsn = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">    HasExtractBitsInsn = hasExtractInsn;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">    HasExtractBitsInsn = hasExtractInsn;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">  /// Tells the code generator not to expand logic operations on comparison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">  /// Tells the code generator not to expand logic operations on comparison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">  /// predicates into separate sequences that increase the amount of flow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">  /// predicates into separate sequences that increase the amount of flow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">  /// control.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">  /// control.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">  void setJumpIsExpensive(bool isExpensive = true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">  void setJumpIsExpensive(bool isExpensive = true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">  /// Tells the code generator which bitwidths to bypass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">  /// Tells the code generator which bitwidths to bypass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">  void addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">  void addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">    BypassSlowDivWidths[SlowBitWidth] = FastBitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">    BypassSlowDivWidths[SlowBitWidth] = FastBitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">  /// Add the specified register class as an available regclass for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">  /// Add the specified register class as an available regclass for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">  /// specified value type. This indicates the selector can handle values of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">  /// specified value type. This indicates the selector can handle values of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">  /// that class natively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">  /// that class natively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine coveredLine">  void addRegisterClass(MVT VT, const TargetRegisterClass *RC) {</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine coveredLine">  void addRegisterClass(MVT VT, const TargetRegisterClass *RC) {</td>
    <td class="lineNumber">13</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine coveredLine">    assert((unsigned)VT.SimpleTy < std::size(RegClassForVT));</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine coveredLine">    assert((unsigned)VT.SimpleTy < std::size(RegClassForVT));</td>
    <td class="lineNumber">13</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine coveredLine">    RegClassForVT[VT.SimpleTy] = RC;</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine coveredLine">    RegClassForVT[VT.SimpleTy] = RC;</td>
    <td class="lineNumber">13</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">13</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">  /// Return the largest legal super-reg register class of the register class</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">  /// Return the largest legal super-reg register class of the register class</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  /// for the specified type and its associated "cost".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  /// for the specified type and its associated "cost".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">  virtual std::pair<const TargetRegisterClass *, uint8_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">  virtual std::pair<const TargetRegisterClass *, uint8_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  /// Once all of the register classes are added, this allows us to compute</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  /// Once all of the register classes are added, this allows us to compute</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">  /// derived properties we expose.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">  /// derived properties we expose.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">  void computeRegisterProperties(const TargetRegisterInfo *TRI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">  void computeRegisterProperties(const TargetRegisterInfo *TRI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">  /// Indicate that the specified operation does not work with the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">  /// Indicate that the specified operation does not work with the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">  /// type and indicate what to do about it. Note that VT may refer to either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">  /// type and indicate what to do about it. Note that VT may refer to either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">  /// the type of a result or that of an operand of Op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">  /// the type of a result or that of an operand of Op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine coveredLine">  void setOperationAction(unsigned Op, MVT VT, LegalizeAction Action) {</td>
    <td class="lineNumber">211813</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine coveredLine">  void setOperationAction(unsigned Op, MVT VT, LegalizeAction Action) {</td>
    <td class="lineNumber">211813</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine coveredLine">    assert(Op < std::size(OpActions[0]) && "Table isn't big enough!");</td>
    <td class="lineNumber">211813</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine coveredLine">    assert(Op < std::size(OpActions[0]) && "Table isn't big enough!");</td>
    <td class="lineNumber">211813</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine coveredLine">    OpActions[(unsigned)VT.SimpleTy][Op] = Action;</td>
    <td class="lineNumber">211813</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine coveredLine">    OpActions[(unsigned)VT.SimpleTy][Op] = Action;</td>
    <td class="lineNumber">211813</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">211813</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">211813</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine coveredLine">  void setOperationAction(ArrayRef<unsigned> Ops, MVT VT,</td>
    <td class="lineNumber">10745</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine coveredLine">  void setOperationAction(ArrayRef<unsigned> Ops, MVT VT,</td>
    <td class="lineNumber">10745</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">                          LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">                          LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine coveredLine">    for (auto Op : Ops)</td>
    <td class="lineNumber">94925</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine coveredLine">    for (auto Op : Ops)</td>
    <td class="lineNumber">94925</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine coveredLine">      setOperationAction(Op, VT, Action);</td>
    <td class="lineNumber">84180</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine coveredLine">      setOperationAction(Op, VT, Action);</td>
    <td class="lineNumber">84180</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">10745</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">10745</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine coveredLine">  void setOperationAction(ArrayRef<unsigned> Ops, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine coveredLine">  void setOperationAction(ArrayRef<unsigned> Ops, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">                          LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">                          LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine coveredLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">50</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine coveredLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine coveredLine">      setOperationAction(Ops, VT, Action);</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine coveredLine">      setOperationAction(Ops, VT, Action);</td>
    <td class="lineNumber">40</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">  /// Indicate that the specified load with extension does not work with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">  /// Indicate that the specified load with extension does not work with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine coveredLine">  void setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT,</td>
    <td class="lineNumber">8270</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine coveredLine">  void setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT,</td>
    <td class="lineNumber">8270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">                        LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">                        LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine coveredLine">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() &&</td>
    <td class="lineNumber">8270</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine coveredLine">    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() &&</td>
    <td class="lineNumber">8270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">           MemVT.isValid() && "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">           MemVT.isValid() && "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine coveredLine">    assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td class="lineNumber">8270</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine coveredLine">    assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td class="lineNumber">8270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine coveredLine">    unsigned Shift = 4 * ExtType;</td>
    <td class="lineNumber">8270</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine coveredLine">    unsigned Shift = 4 * ExtType;</td>
    <td class="lineNumber">8270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine coveredLine">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] &= ~((uint16_t)0xF << Shift);</td>
    <td class="lineNumber">8270</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine coveredLine">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] &= ~((uint16_t)0xF << Shift);</td>
    <td class="lineNumber">8270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine coveredLine">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] |= (uint16_t)Action << Shift;</td>
    <td class="lineNumber">8270</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine coveredLine">    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] |= (uint16_t)Action << Shift;</td>
    <td class="lineNumber">8270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">8270</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">8270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT, MVT MemVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT, MVT MemVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">                        LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">                        LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">    for (auto ExtType : ExtTypes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">    for (auto ExtType : ExtTypes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">      setLoadExtAction(ExtType, ValVT, MemVT, Action);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">      setLoadExtAction(ExtType, ValVT, MemVT, Action);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  void setLoadExtAction(ArrayRef<unsigned> ExtTypes, MVT ValVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">                        ArrayRef<MVT> MemVTs, LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">                        ArrayRef<MVT> MemVTs, LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">    for (auto MemVT : MemVTs)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">    for (auto MemVT : MemVTs)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">      setLoadExtAction(ExtTypes, ValVT, MemVT, Action);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">      setLoadExtAction(ExtTypes, ValVT, MemVT, Action);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">  /// Indicate that the specified truncating store does not work with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">  /// Indicate that the specified truncating store does not work with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine coveredLine">  void setTruncStoreAction(MVT ValVT, MVT MemVT, LegalizeAction Action) {</td>
    <td class="lineNumber">3955</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine coveredLine">  void setTruncStoreAction(MVT ValVT, MVT MemVT, LegalizeAction Action) {</td>
    <td class="lineNumber">3955</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine coveredLine">    assert(ValVT.isValid() && MemVT.isValid() && "Table isn't big enough!");</td>
    <td class="lineNumber">3955</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine coveredLine">    assert(ValVT.isValid() && MemVT.isValid() && "Table isn't big enough!");</td>
    <td class="lineNumber">3955</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine coveredLine">    TruncStoreActions[(unsigned)ValVT.SimpleTy][MemVT.SimpleTy] = Action;</td>
    <td class="lineNumber">3955</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine coveredLine">    TruncStoreActions[(unsigned)ValVT.SimpleTy][MemVT.SimpleTy] = Action;</td>
    <td class="lineNumber">3955</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3955</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3955</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">  /// Indicate that the specified indexed load does or does not work with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">  /// Indicate that the specified indexed load does or does not work with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">  /// specified type and indicate what to do abort it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">  /// specified type and indicate what to do abort it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">  /// NOTE: All indexed mode loads are initialized to Expand in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">  /// NOTE: All indexed mode loads are initialized to Expand in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine coveredLine">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine coveredLine">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">                            LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">                            LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine coveredLine">    for (auto IdxMode : IdxModes)</td>
    <td class="lineNumber">7960</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine coveredLine">    for (auto IdxMode : IdxModes)</td>
    <td class="lineNumber">7960</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine coveredLine">      setIndexedModeAction(IdxMode, VT, IMAB_Load, Action);</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine coveredLine">      setIndexedModeAction(IdxMode, VT, IMAB_Load, Action);</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">  void setIndexedLoadAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">                            LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">                            LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">      setIndexedLoadAction(IdxModes, VT, Action);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">      setIndexedLoadAction(IdxModes, VT, Action);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">  /// Indicate that the specified indexed store does or does not work with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">  /// Indicate that the specified indexed store does or does not work with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">  /// specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">  /// NOTE: All indexed mode stores are initialized to Expand in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">  /// NOTE: All indexed mode stores are initialized to Expand in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine coveredLine">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine coveredLine">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, MVT VT,</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">                             LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">                             LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine coveredLine">    for (auto IdxMode : IdxModes)</td>
    <td class="lineNumber">7960</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine coveredLine">    for (auto IdxMode : IdxModes)</td>
    <td class="lineNumber">7960</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine coveredLine">      setIndexedModeAction(IdxMode, VT, IMAB_Store, Action);</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine coveredLine">      setIndexedModeAction(IdxMode, VT, IMAB_Store, Action);</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">  void setIndexedStoreAction(ArrayRef<unsigned> IdxModes, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">                             LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">                             LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">      setIndexedStoreAction(IdxModes, VT, Action);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">      setIndexedStoreAction(IdxModes, VT, Action);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">  /// Indicate that the specified indexed masked load does or does not work with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">  /// Indicate that the specified indexed masked load does or does not work with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">  /// the specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">  /// the specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">  /// NOTE: All indexed mode masked loads are initialized to Expand in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">  /// NOTE: All indexed mode masked loads are initialized to Expand in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine coveredLine">  void setIndexedMaskedLoadAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine coveredLine">  void setIndexedMaskedLoadAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">                                  LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">                                  LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine coveredLine">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad, Action);</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine coveredLine">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad, Action);</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">  /// Indicate that the specified indexed masked store does or does not work</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">  /// Indicate that the specified indexed masked store does or does not work</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">  /// with the specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">  /// with the specified type and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">  /// NOTE: All indexed mode masked stores are initialized to Expand in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">  /// NOTE: All indexed mode masked stores are initialized to Expand in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">  /// TargetLowering.cpp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine coveredLine">  void setIndexedMaskedStoreAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine coveredLine">  void setIndexedMaskedStoreAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">                                   LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">                                   LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine coveredLine">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedStore, Action);</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine coveredLine">    setIndexedModeAction(IdxMode, VT, IMAB_MaskedStore, Action);</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3980</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">  /// Indicate that the specified condition code is or isn't supported on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">  /// Indicate that the specified condition code is or isn't supported on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">  /// target and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">  /// target and indicate what to do about it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, MVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, MVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">                         LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">                         LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">    for (auto CC : CCs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">    for (auto CC : CCs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">      assert(VT.isValid() && (unsigned)CC < std::size(CondCodeActions) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">      assert(VT.isValid() && (unsigned)CC < std::size(CondCodeActions) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">             "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">             "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">      assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">      assert((unsigned)Action < 0x10 && "too many bits for bitfield array");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">      /// The lower 3 bits of the SimpleTy index into Nth 4bit set from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">      /// The lower 3 bits of the SimpleTy index into Nth 4bit set from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">      /// 32-bit value and the upper 29 bits index into the second dimension of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">      /// 32-bit value and the upper 29 bits index into the second dimension of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">      /// the array to select what 32-bit value to use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">      /// the array to select what 32-bit value to use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">      uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">      uint32_t Shift = 4 * (VT.SimpleTy & 0x7);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">      CondCodeActions[CC][VT.SimpleTy >> 3] &= ~((uint32_t)0xF << Shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">      CondCodeActions[CC][VT.SimpleTy >> 3] &= ~((uint32_t)0xF << Shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">      CondCodeActions[CC][VT.SimpleTy >> 3] |= (uint32_t)Action << Shift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">      CondCodeActions[CC][VT.SimpleTy >> 3] |= (uint32_t)Action << Shift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">  void setCondCodeAction(ArrayRef<ISD::CondCode> CCs, ArrayRef<MVT> VTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">                         LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">                         LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">    for (auto VT : VTs)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">      setCondCodeAction(CCs, VT, Action);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">      setCondCodeAction(CCs, VT, Action);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">  /// If Opc/OrigVT is specified as being promoted, the promotion code defaults</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">  /// If Opc/OrigVT is specified as being promoted, the promotion code defaults</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">  /// to trying a larger integer/fp until it can find one that works. If that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">  /// to trying a larger integer/fp until it can find one that works. If that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">  /// default is insufficient, this method can be used by the target to override</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">  /// default is insufficient, this method can be used by the target to override</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">  /// the default.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">  /// the default.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine coveredLine">  void AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td class="lineNumber">35</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine coveredLine">  void AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td class="lineNumber">35</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine coveredLine">    PromoteToType[std::make_pair(Opc, OrigVT.SimpleTy)] = DestVT.SimpleTy;</td>
    <td class="lineNumber">35</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine coveredLine">    PromoteToType[std::make_pair(Opc, OrigVT.SimpleTy)] = DestVT.SimpleTy;</td>
    <td class="lineNumber">35</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">35</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">35</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">  /// Convenience method to set an operation to Promote and specify the type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">  /// Convenience method to set an operation to Promote and specify the type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">  /// in a single call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">  /// in a single call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">  void setOperationPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">  void setOperationPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">    setOperationAction(Opc, OrigVT, Promote);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">    setOperationAction(Opc, OrigVT, Promote);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">    AddPromotedToType(Opc, OrigVT, DestVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">    AddPromotedToType(Opc, OrigVT, DestVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">  /// Targets should invoke this method for each target independent node that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">  /// Targets should invoke this method for each target independent node that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">  /// they want to provide a custom DAG combiner for by implementing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">  /// they want to provide a custom DAG combiner for by implementing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">  /// PerformDAGCombine virtual method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">  /// PerformDAGCombine virtual method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine coveredLine">  void setTargetDAGCombine(ArrayRef<ISD::NodeType> NTs) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine coveredLine">  void setTargetDAGCombine(ArrayRef<ISD::NodeType> NTs) {</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine coveredLine">    for (auto NT : NTs) {</td>
    <td class="lineNumber">58</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine coveredLine">    for (auto NT : NTs) {</td>
    <td class="lineNumber">58</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine coveredLine">      assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td class="lineNumber">49</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine coveredLine">      assert(unsigned(NT >> 3) < std::size(TargetDAGCombineArray));</td>
    <td class="lineNumber">49</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine coveredLine">      TargetDAGCombineArray[NT >> 3] |= 1 << (NT & 7);</td>
    <td class="lineNumber">49</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine coveredLine">      TargetDAGCombineArray[NT >> 3] |= 1 << (NT & 7);</td>
    <td class="lineNumber">49</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">  /// Set the target's minimum function alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">  /// Set the target's minimum function alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine coveredLine">  void setMinFunctionAlignment(Align Alignment) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine coveredLine">  void setMinFunctionAlignment(Align Alignment) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine coveredLine">    MinFunctionAlignment = Alignment;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine coveredLine">    MinFunctionAlignment = Alignment;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">  /// Set the target's preferred function alignment.  This should be set if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">  /// Set the target's preferred function alignment.  This should be set if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">  /// there is a performance benefit to higher-than-minimum alignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">  /// there is a performance benefit to higher-than-minimum alignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">  void setPrefFunctionAlignment(Align Alignment) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">  void setPrefFunctionAlignment(Align Alignment) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">    PrefFunctionAlignment = Alignment;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">    PrefFunctionAlignment = Alignment;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">  /// Set the target's preferred loop alignment. Default alignment is one, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">  /// Set the target's preferred loop alignment. Default alignment is one, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">  /// means the target does not care about loop alignment. The target may also</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">  /// means the target does not care about loop alignment. The target may also</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">  /// override getPrefLoopAlignment to provide per-loop values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">  /// override getPrefLoopAlignment to provide per-loop values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">  void setPrefLoopAlignment(Align Alignment) { PrefLoopAlignment = Alignment; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">  void setPrefLoopAlignment(Align Alignment) { PrefLoopAlignment = Alignment; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">  void setMaxBytesForAlignment(unsigned MaxBytes) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">  void setMaxBytesForAlignment(unsigned MaxBytes) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">    MaxBytesForAlignment = MaxBytes;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">    MaxBytesForAlignment = MaxBytes;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">  /// Set the minimum stack alignment of an argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">  /// Set the minimum stack alignment of an argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine coveredLine">  void setMinStackArgumentAlignment(Align Alignment) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine coveredLine">  void setMinStackArgumentAlignment(Align Alignment) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine coveredLine">    MinStackArgumentAlignment = Alignment;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine coveredLine">    MinStackArgumentAlignment = Alignment;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine">  /// Set the maximum atomic operation size supported by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine">  /// Set the maximum atomic operation size supported by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">  /// backend. Atomic operations greater than this size (as well as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">  /// backend. Atomic operations greater than this size (as well as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">  /// ones that are not naturally aligned), will be expanded by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">  /// ones that are not naturally aligned), will be expanded by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">  /// AtomicExpandPass into an __atomic_* library call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine coveredLine">  void setMaxAtomicSizeInBitsSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine coveredLine">  void setMaxAtomicSizeInBitsSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine coveredLine">    MaxAtomicSizeInBitsSupported = SizeInBits;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine coveredLine">    MaxAtomicSizeInBitsSupported = SizeInBits;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">  /// Set the size in bits of the maximum div/rem the backend supports.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">  /// Set the size in bits of the maximum div/rem the backend supports.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">  void setMaxDivRemBitWidthSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">  void setMaxDivRemBitWidthSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">    MaxDivRemBitWidthSupported = SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">    MaxDivRemBitWidthSupported = SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">  /// Set the size in bits of the maximum fp convert the backend supports.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">  /// Set the size in bits of the maximum fp convert the backend supports.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">  void setMaxLargeFPConvertBitWidthSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">  void setMaxLargeFPConvertBitWidthSupported(unsigned SizeInBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">    MaxLargeFPConvertBitWidthSupported = SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">    MaxLargeFPConvertBitWidthSupported = SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">  /// Sets the minimum cmpxchg or ll/sc size supported by the backend.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">  /// Sets the minimum cmpxchg or ll/sc size supported by the backend.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">  void setMinCmpXchgSizeInBits(unsigned SizeInBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">  void setMinCmpXchgSizeInBits(unsigned SizeInBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">    MinCmpXchgSizeInBits = SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">    MinCmpXchgSizeInBits = SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">  /// Sets whether unaligned atomic operations are supported.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">  /// Sets whether unaligned atomic operations are supported.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">  void setSupportsUnalignedAtomics(bool UnalignedSupported) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">  void setSupportsUnalignedAtomics(bool UnalignedSupported) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">    SupportsUnalignedAtomics = UnalignedSupported;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">    SupportsUnalignedAtomics = UnalignedSupported;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">  // Addressing mode description hooks (used by LSR etc).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">  // Addressing mode description hooks (used by LSR etc).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">  /// CodeGenPrepare sinks address calculations into the same BB as Load/Store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">  /// CodeGenPrepare sinks address calculations into the same BB as Load/Store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">  /// instructions reading the address. This allows as much computation as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">  /// instructions reading the address. This allows as much computation as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">  /// possible to be done in the address mode for that operand. This hook lets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">  /// possible to be done in the address mode for that operand. This hook lets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">  /// targets also pass back when this should be done on intrinsics which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">  /// targets also pass back when this should be done on intrinsics which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine">  /// load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine">  /// load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">  virtual bool getAddrModeArguments(IntrinsicInst * /*I*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">  virtual bool getAddrModeArguments(IntrinsicInst * /*I*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">                                    SmallVectorImpl<Value*> &/*Ops*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">                                    SmallVectorImpl<Value*> &/*Ops*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">                                    Type *&/*AccessTy*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">                                    Type *&/*AccessTy*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">  /// This represents an addressing mode of:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">  /// This represents an addressing mode of:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">  ///    BaseGV + BaseOffs + BaseReg + Scale*ScaleReg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">  ///    BaseGV + BaseOffs + BaseReg + Scale*ScaleReg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">  /// If BaseGV is null,  there is no BaseGV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">  /// If BaseGV is null,  there is no BaseGV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">  /// If BaseOffs is zero, there is no base offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">  /// If BaseOffs is zero, there is no base offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">  /// If HasBaseReg is false, there is no base register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">  /// If HasBaseReg is false, there is no base register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">  /// If Scale is zero, there is no ScaleReg.  Scale of 1 indicates a reg with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">  /// If Scale is zero, there is no ScaleReg.  Scale of 1 indicates a reg with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">  /// no scale.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">  /// no scale.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine">  struct AddrMode {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine">  struct AddrMode {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">    GlobalValue *BaseGV = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">    GlobalValue *BaseGV = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">    int64_t      BaseOffs = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">    int64_t      BaseOffs = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">    bool         HasBaseReg = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">    bool         HasBaseReg = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">    int64_t      Scale = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">    int64_t      Scale = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">    AddrMode() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">    AddrMode() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">  /// Return true if the addressing mode represented by AM is legal for this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">  /// Return true if the addressing mode represented by AM is legal for this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine">  /// target, for a load/store of the specified type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine">  /// target, for a load/store of the specified type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">  /// mode is legal for a load/store of any legal type.  TODO: Handle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">  /// mode is legal for a load/store of any legal type.  TODO: Handle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine">  /// pre/postinc as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine">  /// pre/postinc as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">  /// If the address space cannot be determined, it will be -1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">  /// If the address space cannot be determined, it will be -1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">  /// TODO: Remove default argument</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">  /// TODO: Remove default argument</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">  virtual bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">  virtual bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine">                                     Type *Ty, unsigned AddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine">                                     Type *Ty, unsigned AddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine">                                     Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine">                                     Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal icmp immediate, that is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal icmp immediate, that is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">  /// the target has icmp instructions which can compare a register against the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">  /// the target has icmp instructions which can compare a register against the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">  /// immediate without having to materialize the immediate into a register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">  /// immediate without having to materialize the immediate into a register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">  virtual bool isLegalICmpImmediate(int64_t) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">  virtual bool isLegalICmpImmediate(int64_t) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal add immediate, that is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal add immediate, that is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine">  /// target has add instructions which can add a register with the immediate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine">  /// target has add instructions which can add a register with the immediate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">  /// without having to materialize the immediate into a register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">  /// without having to materialize the immediate into a register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine">  virtual bool isLegalAddImmediate(int64_t) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine">  virtual bool isLegalAddImmediate(int64_t) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal for the value input of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal for the value input of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine">  /// store instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine">  /// store instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine">  virtual bool isLegalStoreImmediate(int64_t Value) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine">  virtual bool isLegalStoreImmediate(int64_t Value) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine">    // Default implementation assumes that at least 0 works since it is likely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine">    // Default implementation assumes that at least 0 works since it is likely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">    // that a zero register exists or a zero immediate is allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">    // that a zero register exists or a zero immediate is allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">    return Value == 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">    return Value == 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">  /// Return true if it's significantly cheaper to shift a vector by a uniform</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">  /// Return true if it's significantly cheaper to shift a vector by a uniform</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine">  /// scalar than by an amount which will vary across each lane. On x86 before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine">  /// scalar than by an amount which will vary across each lane. On x86 before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine">  /// AVX2 for example, there is a "psllw" instruction for the former case, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine">  /// AVX2 for example, there is a "psllw" instruction for the former case, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine">  /// no simple instruction for a general "a << b" operation on vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine">  /// no simple instruction for a general "a << b" operation on vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine">  /// This should also apply to lowering for vector funnel shifts (rotates).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine">  /// This should also apply to lowering for vector funnel shifts (rotates).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">  virtual bool isVectorShiftByScalarCheap(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">  virtual bool isVectorShiftByScalarCheap(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine">  /// Given a shuffle vector SVI representing a vector splat, return a new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine">  /// Given a shuffle vector SVI representing a vector splat, return a new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">  /// scalar type of size equal to SVI's scalar type if the new type is more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">  /// scalar type of size equal to SVI's scalar type if the new type is more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">  /// profitable. Returns nullptr otherwise. For example under MVE float splats</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">  /// profitable. Returns nullptr otherwise. For example under MVE float splats</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine">  /// are converted to integer to prevent the need to move from SPR to GPR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine">  /// are converted to integer to prevent the need to move from SPR to GPR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine">  /// registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine">  /// registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine">  virtual Type* shouldConvertSplatType(ShuffleVectorInst* SVI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine">  virtual Type* shouldConvertSplatType(ShuffleVectorInst* SVI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine">  /// Given a set in interconnected phis of type 'From' that are loaded/stored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine">  /// Given a set in interconnected phis of type 'From' that are loaded/stored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine">  /// or bitcast to type 'To', return true if the set should be converted to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine">  /// or bitcast to type 'To', return true if the set should be converted to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine">  /// 'To'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine">  /// 'To'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine">  virtual bool shouldConvertPhiType(Type *From, Type *To) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine">  virtual bool shouldConvertPhiType(Type *From, Type *To) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine">    return (From->isIntegerTy() || From->isFloatingPointTy()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine">    return (From->isIntegerTy() || From->isFloatingPointTy()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">           (To->isIntegerTy() || To->isFloatingPointTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">           (To->isIntegerTy() || To->isFloatingPointTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">  /// Returns true if the opcode is a commutative binary operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">  /// Returns true if the opcode is a commutative binary operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine coveredLine">  virtual bool isCommutativeBinOp(unsigned Opcode) const {</td>
    <td class="lineNumber">129</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine coveredLine">  virtual bool isCommutativeBinOp(unsigned Opcode) const {</td>
    <td class="lineNumber">129</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine">    // FIXME: This should get its info from the td file.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine">    // FIXME: This should get its info from the td file.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine coveredLine">    switch (Opcode) {</td>
    <td class="lineNumber">129</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine coveredLine">    switch (Opcode) {</td>
    <td class="lineNumber">129</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine coveredLine">    case ISD::ADD:</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine coveredLine">    case ISD::ADD:</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">    case ISD::SMIN:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">    case ISD::SMIN:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine">    case ISD::SMAX:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine">    case ISD::SMAX:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine">    case ISD::UMIN:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine">    case ISD::UMIN:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">    case ISD::UMAX:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">    case ISD::UMAX:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine">    case ISD::MUL:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine">    case ISD::MUL:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine">    case ISD::MULHU:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine">    case ISD::MULHU:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine">    case ISD::MULHS:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine">    case ISD::MULHS:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine">    case ISD::SMUL_LOHI:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine">    case ISD::SMUL_LOHI:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine">    case ISD::UMUL_LOHI:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine">    case ISD::UMUL_LOHI:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine">    case ISD::FADD:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine">    case ISD::FADD:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine">    case ISD::FMUL:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine">    case ISD::FMUL:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine">    case ISD::AND:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine">    case ISD::AND:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine">    case ISD::OR:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine">    case ISD::OR:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine">    case ISD::XOR:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine">    case ISD::XOR:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine">    case ISD::SADDO:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine">    case ISD::SADDO:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeLine">    case ISD::UADDO:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2728</td>
    <td class="codeLine">    case ISD::UADDO:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeLine">    case ISD::ADDC:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2729</td>
    <td class="codeLine">    case ISD::ADDC:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeLine">    case ISD::ADDE:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2730</td>
    <td class="codeLine">    case ISD::ADDE:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeLine">    case ISD::SADDSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2731</td>
    <td class="codeLine">    case ISD::SADDSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeLine">    case ISD::UADDSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2732</td>
    <td class="codeLine">    case ISD::UADDSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeLine">    case ISD::FMINNUM:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2733</td>
    <td class="codeLine">    case ISD::FMINNUM:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeLine">    case ISD::FMAXNUM:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2734</td>
    <td class="codeLine">    case ISD::FMAXNUM:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeLine">    case ISD::FMINNUM_IEEE:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2735</td>
    <td class="codeLine">    case ISD::FMINNUM_IEEE:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeLine">    case ISD::FMAXNUM_IEEE:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2736</td>
    <td class="codeLine">    case ISD::FMAXNUM_IEEE:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeLine">    case ISD::FMINIMUM:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2737</td>
    <td class="codeLine">    case ISD::FMINIMUM:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeLine">    case ISD::FMAXIMUM:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2738</td>
    <td class="codeLine">    case ISD::FMAXIMUM:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeLine">    case ISD::AVGFLOORS:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2739</td>
    <td class="codeLine">    case ISD::AVGFLOORS:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeLine">    case ISD::AVGFLOORU:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2740</td>
    <td class="codeLine">    case ISD::AVGFLOORU:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeLine">    case ISD::AVGCEILS:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2741</td>
    <td class="codeLine">    case ISD::AVGCEILS:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeLine">    case ISD::AVGCEILU:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2742</td>
    <td class="codeLine">    case ISD::AVGCEILU:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeLine">    case ISD::ABDS:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2743</td>
    <td class="codeLine">    case ISD::ABDS:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeLine">    case ISD::ABDU:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2744</td>
    <td class="codeLine">    case ISD::ABDU:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">2745</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeLine coveredLine">    default: return false;</td>
    <td class="lineNumber">107</td>
    <td class="lineNumber">2746</td>
    <td class="codeLine coveredLine">    default: return false;</td>
    <td class="lineNumber">107</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2747</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeLine">  /// Return true if the node is a math/logic binary operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2750</td>
    <td class="codeLine">  /// Return true if the node is a math/logic binary operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeLine coveredLine">  virtual bool isBinOp(unsigned Opcode) const {</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">2751</td>
    <td class="codeLine coveredLine">  virtual bool isBinOp(unsigned Opcode) const {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeLine">    // A commutative binop must be a binop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2752</td>
    <td class="codeLine">    // A commutative binop must be a binop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeLine coveredLine">    if (isCommutativeBinOp(Opcode))</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">2753</td>
    <td class="codeLine coveredLine">    if (isCommutativeBinOp(Opcode))</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">2754</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeLine">    // These are non-commutative binops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2755</td>
    <td class="codeLine">    // These are non-commutative binops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeLine">    switch (Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2756</td>
    <td class="codeLine">    switch (Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeLine">    case ISD::SUB:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2757</td>
    <td class="codeLine">    case ISD::SUB:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeLine">    case ISD::SHL:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2758</td>
    <td class="codeLine">    case ISD::SHL:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeLine">    case ISD::SRL:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2759</td>
    <td class="codeLine">    case ISD::SRL:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeLine">    case ISD::SRA:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2760</td>
    <td class="codeLine">    case ISD::SRA:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeLine">    case ISD::ROTL:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2761</td>
    <td class="codeLine">    case ISD::ROTL:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeLine">    case ISD::ROTR:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2762</td>
    <td class="codeLine">    case ISD::ROTR:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeLine">    case ISD::SDIV:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2763</td>
    <td class="codeLine">    case ISD::SDIV:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeLine">    case ISD::UDIV:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2764</td>
    <td class="codeLine">    case ISD::UDIV:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeLine">    case ISD::SREM:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2765</td>
    <td class="codeLine">    case ISD::SREM:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeLine">    case ISD::UREM:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2766</td>
    <td class="codeLine">    case ISD::UREM:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeLine">    case ISD::SSUBSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2767</td>
    <td class="codeLine">    case ISD::SSUBSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeLine">    case ISD::USUBSAT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2768</td>
    <td class="codeLine">    case ISD::USUBSAT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeLine">    case ISD::FSUB:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2769</td>
    <td class="codeLine">    case ISD::FSUB:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeLine">    case ISD::FDIV:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2770</td>
    <td class="codeLine">    case ISD::FDIV:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeLine">    case ISD::FREM:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2771</td>
    <td class="codeLine">    case ISD::FREM:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2772</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2773</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2774</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2775</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2776</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeLine">  /// Return true if it's free to truncate a value of type FromTy to type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2778</td>
    <td class="codeLine">  /// Return true if it's free to truncate a value of type FromTy to type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeLine">  /// ToTy. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2779</td>
    <td class="codeLine">  /// ToTy. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeLine">  /// by referencing its sub-register AX.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2780</td>
    <td class="codeLine">  /// by referencing its sub-register AX.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeLine">  /// Targets must return false when FromTy <= ToTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2781</td>
    <td class="codeLine">  /// Targets must return false when FromTy <= ToTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeLine">  virtual bool isTruncateFree(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2782</td>
    <td class="codeLine">  virtual bool isTruncateFree(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2783</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2784</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeLine">  /// Return true if a truncation from FromTy to ToTy is permitted when deciding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2786</td>
    <td class="codeLine">  /// Return true if a truncation from FromTy to ToTy is permitted when deciding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeLine">  /// whether a call is in tail position. Typically this means that both results</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2787</td>
    <td class="codeLine">  /// whether a call is in tail position. Typically this means that both results</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeLine">  /// would be assigned to the same register or stack slot, but it could mean</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2788</td>
    <td class="codeLine">  /// would be assigned to the same register or stack slot, but it could mean</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeLine">  /// the target performs adequate checks of its own before proceeding with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2789</td>
    <td class="codeLine">  /// the target performs adequate checks of its own before proceeding with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeLine">  /// tail call.  Targets must return false when FromTy <= ToTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2790</td>
    <td class="codeLine">  /// tail call.  Targets must return false when FromTy <= ToTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeLine">  virtual bool allowTruncateForTailCall(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2791</td>
    <td class="codeLine">  virtual bool allowTruncateForTailCall(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2792</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2793</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeLine">  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2795</td>
    <td class="codeLine">  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeLine">  virtual bool isTruncateFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2796</td>
    <td class="codeLine">  virtual bool isTruncateFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeLine">                              LLVMContext &Ctx) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2797</td>
    <td class="codeLine">                              LLVMContext &Ctx) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeLine">    return isTruncateFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2798</td>
    <td class="codeLine">    return isTruncateFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeLine">                          getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2799</td>
    <td class="codeLine">                          getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2800</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeLine">  virtual bool isProfitableToHoist(Instruction *I) const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2802</td>
    <td class="codeLine">  virtual bool isProfitableToHoist(Instruction *I) const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeLine">  /// Return true if the extension represented by \p I is free.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2804</td>
    <td class="codeLine">  /// Return true if the extension represented by \p I is free.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeLine">  /// Unlikely the is[Z|FP]ExtFree family which is based on types,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2805</td>
    <td class="codeLine">  /// Unlikely the is[Z|FP]ExtFree family which is based on types,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeLine">  /// this method can use the context provided by \p I to decide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2806</td>
    <td class="codeLine">  /// this method can use the context provided by \p I to decide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeLine">  /// whether or not \p I is free.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2807</td>
    <td class="codeLine">  /// whether or not \p I is free.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeLine">  /// This method extends the behavior of the is[Z|FP]ExtFree family.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2808</td>
    <td class="codeLine">  /// This method extends the behavior of the is[Z|FP]ExtFree family.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeLine">  /// In other words, if is[Z|FP]Free returns true, then this method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2809</td>
    <td class="codeLine">  /// In other words, if is[Z|FP]Free returns true, then this method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeLine">  /// returns true as well. The converse is not true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2810</td>
    <td class="codeLine">  /// returns true as well. The converse is not true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeLine">  /// The target can perform the adequate checks by overriding isExtFreeImpl.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2811</td>
    <td class="codeLine">  /// The target can perform the adequate checks by overriding isExtFreeImpl.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeLine">  /// \pre \p I must be a sign, zero, or fp extension.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2812</td>
    <td class="codeLine">  /// \pre \p I must be a sign, zero, or fp extension.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeLine">  bool isExtFree(const Instruction *I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2813</td>
    <td class="codeLine">  bool isExtFree(const Instruction *I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeLine">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2814</td>
    <td class="codeLine">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeLine">    case Instruction::FPExt:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2815</td>
    <td class="codeLine">    case Instruction::FPExt:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeLine">      if (isFPExtFree(EVT::getEVT(I->getType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2816</td>
    <td class="codeLine">      if (isFPExtFree(EVT::getEVT(I->getType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeLine">                      EVT::getEVT(I->getOperand(0)->getType())))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2817</td>
    <td class="codeLine">                      EVT::getEVT(I->getOperand(0)->getType())))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2818</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2819</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2820</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeLine">      if (isZExtFree(I->getOperand(0)->getType(), I->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2821</td>
    <td class="codeLine">      if (isZExtFree(I->getOperand(0)->getType(), I->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2822</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2823</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeLine">    case Instruction::SExt:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2824</td>
    <td class="codeLine">    case Instruction::SExt:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2825</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2826</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeLine">      llvm_unreachable("Instruction is not an extension");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2827</td>
    <td class="codeLine">      llvm_unreachable("Instruction is not an extension");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2828</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeLine">    return isExtFreeImpl(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2829</td>
    <td class="codeLine">    return isExtFreeImpl(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2830</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeLine">  /// Return true if \p Load and \p Ext can form an ExtLoad.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2832</td>
    <td class="codeLine">  /// Return true if \p Load and \p Ext can form an ExtLoad.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeLine">  /// For example, in AArch64</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2833</td>
    <td class="codeLine">  /// For example, in AArch64</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeLine">  ///   %L = load i8, i8* %ptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2834</td>
    <td class="codeLine">  ///   %L = load i8, i8* %ptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeLine">  ///   %E = zext i8 %L to i32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2835</td>
    <td class="codeLine">  ///   %E = zext i8 %L to i32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeLine">  /// can be lowered into one load instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2836</td>
    <td class="codeLine">  /// can be lowered into one load instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeLine">  ///   ldrb w0, [x0]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2837</td>
    <td class="codeLine">  ///   ldrb w0, [x0]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeLine">  bool isExtLoad(const LoadInst *Load, const Instruction *Ext,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2838</td>
    <td class="codeLine">  bool isExtLoad(const LoadInst *Load, const Instruction *Ext,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeLine">                 const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2839</td>
    <td class="codeLine">                 const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeLine">    EVT VT = getValueType(DL, Ext->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2840</td>
    <td class="codeLine">    EVT VT = getValueType(DL, Ext->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeLine">    EVT LoadVT = getValueType(DL, Load->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2841</td>
    <td class="codeLine">    EVT LoadVT = getValueType(DL, Load->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeLine">    // If the load has other users and the truncate is not free, the ext</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2843</td>
    <td class="codeLine">    // If the load has other users and the truncate is not free, the ext</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeLine">    // probably isn't free.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2844</td>
    <td class="codeLine">    // probably isn't free.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeLine">    if (!Load->hasOneUse() && (isTypeLegal(LoadVT) || !isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2845</td>
    <td class="codeLine">    if (!Load->hasOneUse() && (isTypeLegal(LoadVT) || !isTypeLegal(VT)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeLine">        !isTruncateFree(Ext->getType(), Load->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2846</td>
    <td class="codeLine">        !isTruncateFree(Ext->getType(), Load->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2847</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeLine">    // Check whether the target supports casts folded into loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2849</td>
    <td class="codeLine">    // Check whether the target supports casts folded into loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeLine">    unsigned LType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2850</td>
    <td class="codeLine">    unsigned LType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeLine">    if (isa<ZExtInst>(Ext))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2851</td>
    <td class="codeLine">    if (isa<ZExtInst>(Ext))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeLine">      LType = ISD::ZEXTLOAD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2852</td>
    <td class="codeLine">      LType = ISD::ZEXTLOAD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2853</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeLine">      assert(isa<SExtInst>(Ext) && "Unexpected ext type!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2854</td>
    <td class="codeLine">      assert(isa<SExtInst>(Ext) && "Unexpected ext type!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeLine">      LType = ISD::SEXTLOAD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2855</td>
    <td class="codeLine">      LType = ISD::SEXTLOAD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2856</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeLine">    return isLoadExtLegal(LType, VT, LoadVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2858</td>
    <td class="codeLine">    return isLoadExtLegal(LType, VT, LoadVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeLine">  /// Return true if any actual instruction that defines a value of type FromTy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2861</td>
    <td class="codeLine">  /// Return true if any actual instruction that defines a value of type FromTy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeLine">  /// implicitly zero-extends the value to ToTy in the result register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2862</td>
    <td class="codeLine">  /// implicitly zero-extends the value to ToTy in the result register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2863</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeLine">  /// The function should return true when it is likely that the truncate can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2864</td>
    <td class="codeLine">  /// The function should return true when it is likely that the truncate can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeLine">  /// be freely folded with an instruction defining a value of FromTy. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2865</td>
    <td class="codeLine">  /// be freely folded with an instruction defining a value of FromTy. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeLine">  /// the defining instruction is unknown (because you're looking at a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2866</td>
    <td class="codeLine">  /// the defining instruction is unknown (because you're looking at a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeLine">  /// function argument, PHI, etc.) then the target may require an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2867</td>
    <td class="codeLine">  /// function argument, PHI, etc.) then the target may require an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeLine">  /// explicit truncate, which is not necessarily free, but this function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2868</td>
    <td class="codeLine">  /// explicit truncate, which is not necessarily free, but this function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeLine">  /// does not deal with those cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2869</td>
    <td class="codeLine">  /// does not deal with those cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeLine">  /// Targets must return false when FromTy >= ToTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2870</td>
    <td class="codeLine">  /// Targets must return false when FromTy >= ToTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeLine">  virtual bool isZExtFree(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2871</td>
    <td class="codeLine">  virtual bool isZExtFree(Type *FromTy, Type *ToTy) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2872</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeLine">  virtual bool isZExtFree(EVT FromTy, EVT ToTy) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2875</td>
    <td class="codeLine">  virtual bool isZExtFree(EVT FromTy, EVT ToTy) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeLine">  virtual bool isZExtFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2876</td>
    <td class="codeLine">  virtual bool isZExtFree(LLT FromTy, LLT ToTy, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeLine">                          LLVMContext &Ctx) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2877</td>
    <td class="codeLine">                          LLVMContext &Ctx) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeLine">    return isZExtFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2878</td>
    <td class="codeLine">    return isZExtFree(getApproximateEVTForLLT(FromTy, DL, Ctx),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeLine">                      getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2879</td>
    <td class="codeLine">                      getApproximateEVTForLLT(ToTy, DL, Ctx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeLine">  /// Return true if zero-extending the specific node Val to type VT2 is free</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2882</td>
    <td class="codeLine">  /// Return true if zero-extending the specific node Val to type VT2 is free</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeLine">  /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2883</td>
    <td class="codeLine">  /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeLine">  /// because it's folded such as X86 zero-extending loads).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2884</td>
    <td class="codeLine">  /// because it's folded such as X86 zero-extending loads).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeLine">  virtual bool isZExtFree(SDValue Val, EVT VT2) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2885</td>
    <td class="codeLine">  virtual bool isZExtFree(SDValue Val, EVT VT2) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeLine">    return isZExtFree(Val.getValueType(), VT2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2886</td>
    <td class="codeLine">    return isZExtFree(Val.getValueType(), VT2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2887</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeLine">  /// Return true if sign-extension from FromTy to ToTy is cheaper than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2889</td>
    <td class="codeLine">  /// Return true if sign-extension from FromTy to ToTy is cheaper than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeLine">  /// zero-extension.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2890</td>
    <td class="codeLine">  /// zero-extension.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeLine">  virtual bool isSExtCheaperThanZExt(EVT FromTy, EVT ToTy) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2891</td>
    <td class="codeLine">  virtual bool isSExtCheaperThanZExt(EVT FromTy, EVT ToTy) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2892</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2893</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeLine">  /// Return true if this constant should be sign extended when promoting to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2895</td>
    <td class="codeLine">  /// Return true if this constant should be sign extended when promoting to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeLine">  /// a larger type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2896</td>
    <td class="codeLine">  /// a larger type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeLine">  virtual bool signExtendConstant(const ConstantInt *C) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2897</td>
    <td class="codeLine">  virtual bool signExtendConstant(const ConstantInt *C) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeLine">  /// Return true if sinking I's operands to the same basic block as I is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2899</td>
    <td class="codeLine">  /// Return true if sinking I's operands to the same basic block as I is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeLine">  /// profitable, e.g. because the operands can be folded into a target</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2900</td>
    <td class="codeLine">  /// profitable, e.g. because the operands can be folded into a target</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeLine">  /// instruction during instruction selection. After calling the function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2901</td>
    <td class="codeLine">  /// instruction during instruction selection. After calling the function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeLine">  /// \p Ops contains the Uses to sink ordered by dominance (dominating users</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2902</td>
    <td class="codeLine">  /// \p Ops contains the Uses to sink ordered by dominance (dominating users</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeLine">  /// come first).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2903</td>
    <td class="codeLine">  /// come first).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeLine">  virtual bool shouldSinkOperands(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2904</td>
    <td class="codeLine">  virtual bool shouldSinkOperands(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeLine">                                  SmallVectorImpl<Use *> &Ops) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2905</td>
    <td class="codeLine">                                  SmallVectorImpl<Use *> &Ops) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2906</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2907</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeLine">  /// Try to optimize extending or truncating conversion instructions (like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2909</td>
    <td class="codeLine">  /// Try to optimize extending or truncating conversion instructions (like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeLine">  /// zext, trunc, fptoui, uitofp) for the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2910</td>
    <td class="codeLine">  /// zext, trunc, fptoui, uitofp) for the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2911</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeLine">  optimizeExtendOrTruncateConversion(Instruction *I, Loop *L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2912</td>
    <td class="codeLine">  optimizeExtendOrTruncateConversion(Instruction *I, Loop *L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeLine">                                     const TargetTransformInfo &TTI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2913</td>
    <td class="codeLine">                                     const TargetTransformInfo &TTI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2914</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeLine">  /// Return true if the target supplies and combines to a paired load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2917</td>
    <td class="codeLine">  /// Return true if the target supplies and combines to a paired load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeLine">  /// two loaded values of type LoadedType next to each other in memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2918</td>
    <td class="codeLine">  /// two loaded values of type LoadedType next to each other in memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeLine">  /// RequiredAlignment gives the minimal alignment constraints that must be met</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2919</td>
    <td class="codeLine">  /// RequiredAlignment gives the minimal alignment constraints that must be met</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeLine">  /// to be able to select this paired load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2920</td>
    <td class="codeLine">  /// to be able to select this paired load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2921</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeLine">  /// This information is *not* used to generate actual paired loads, but it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2922</td>
    <td class="codeLine">  /// This information is *not* used to generate actual paired loads, but it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeLine">  /// used to generate a sequence of loads that is easier to combine into a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2923</td>
    <td class="codeLine">  /// used to generate a sequence of loads that is easier to combine into a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeLine">  /// paired load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2924</td>
    <td class="codeLine">  /// paired load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeLine">  /// For instance, something like this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2925</td>
    <td class="codeLine">  /// For instance, something like this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeLine">  /// a = load i64* addr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2926</td>
    <td class="codeLine">  /// a = load i64* addr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeLine">  /// b = trunc i64 a to i32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2927</td>
    <td class="codeLine">  /// b = trunc i64 a to i32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeLine">  /// c = lshr i64 a, 32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2928</td>
    <td class="codeLine">  /// c = lshr i64 a, 32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeLine">  /// d = trunc i64 c to i32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2929</td>
    <td class="codeLine">  /// d = trunc i64 c to i32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeLine">  /// will be optimized into:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2930</td>
    <td class="codeLine">  /// will be optimized into:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeLine">  /// b = load i32* addr1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2931</td>
    <td class="codeLine">  /// b = load i32* addr1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeLine">  /// d = load i32* addr2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2932</td>
    <td class="codeLine">  /// d = load i32* addr2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeLine">  /// Where addr1 = addr2 +/- sizeof(i32).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2933</td>
    <td class="codeLine">  /// Where addr1 = addr2 +/- sizeof(i32).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeLine">  /// In other words, unless the target performs a post-isel load combining,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2935</td>
    <td class="codeLine">  /// In other words, unless the target performs a post-isel load combining,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeLine">  /// this information should not be provided because it will generate more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2936</td>
    <td class="codeLine">  /// this information should not be provided because it will generate more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeLine">  /// loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2937</td>
    <td class="codeLine">  /// loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeLine">  virtual bool hasPairedLoad(EVT /*LoadedType*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2938</td>
    <td class="codeLine">  virtual bool hasPairedLoad(EVT /*LoadedType*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeLine">                             Align & /*RequiredAlignment*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2939</td>
    <td class="codeLine">                             Align & /*RequiredAlignment*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2940</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2941</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeLine">  /// Return true if the target has a vector blend instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2943</td>
    <td class="codeLine">  /// Return true if the target has a vector blend instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeLine">  virtual bool hasVectorBlend() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2944</td>
    <td class="codeLine">  virtual bool hasVectorBlend() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeLine">  /// Get the maximum supported factor for interleaved memory accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2946</td>
    <td class="codeLine">  /// Get the maximum supported factor for interleaved memory accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeLine">  /// Default to be the minimum interleave factor: 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2947</td>
    <td class="codeLine">  /// Default to be the minimum interleave factor: 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeLine">  virtual unsigned getMaxSupportedInterleaveFactor() const { return 2; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2948</td>
    <td class="codeLine">  virtual unsigned getMaxSupportedInterleaveFactor() const { return 2; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeLine">  /// Lower an interleaved load to target specific intrinsics. Return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2950</td>
    <td class="codeLine">  /// Lower an interleaved load to target specific intrinsics. Return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeLine">  /// true on success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2951</td>
    <td class="codeLine">  /// true on success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2952</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeLine">  /// \p LI is the vector load instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2953</td>
    <td class="codeLine">  /// \p LI is the vector load instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeLine">  /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2954</td>
    <td class="codeLine">  /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeLine">  /// \p Indices is the corresponding indices for each shufflevector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2955</td>
    <td class="codeLine">  /// \p Indices is the corresponding indices for each shufflevector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeLine">  /// \p Factor is the interleave factor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2956</td>
    <td class="codeLine">  /// \p Factor is the interleave factor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeLine">  virtual bool lowerInterleavedLoad(LoadInst *LI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2957</td>
    <td class="codeLine">  virtual bool lowerInterleavedLoad(LoadInst *LI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeLine">                                    ArrayRef<ShuffleVectorInst *> Shuffles,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2958</td>
    <td class="codeLine">                                    ArrayRef<ShuffleVectorInst *> Shuffles,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeLine">                                    ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2959</td>
    <td class="codeLine">                                    ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeLine">                                    unsigned Factor) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2960</td>
    <td class="codeLine">                                    unsigned Factor) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2961</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2962</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeLine">  /// Lower an interleaved store to target specific intrinsics. Return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2964</td>
    <td class="codeLine">  /// Lower an interleaved store to target specific intrinsics. Return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeLine">  /// true on success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2965</td>
    <td class="codeLine">  /// true on success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2966</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeLine">  /// \p SI is the vector store instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2967</td>
    <td class="codeLine">  /// \p SI is the vector store instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeLine">  /// \p SVI is the shufflevector to RE-interleave the stored vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2968</td>
    <td class="codeLine">  /// \p SVI is the shufflevector to RE-interleave the stored vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeLine">  /// \p Factor is the interleave factor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2969</td>
    <td class="codeLine">  /// \p Factor is the interleave factor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeLine">  virtual bool lowerInterleavedStore(StoreInst *SI, ShuffleVectorInst *SVI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2970</td>
    <td class="codeLine">  virtual bool lowerInterleavedStore(StoreInst *SI, ShuffleVectorInst *SVI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeLine">                                     unsigned Factor) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2971</td>
    <td class="codeLine">                                     unsigned Factor) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2972</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeLine">  /// Lower a deinterleave intrinsic to a target specific load intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2975</td>
    <td class="codeLine">  /// Lower a deinterleave intrinsic to a target specific load intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeLine">  /// Return true on success. Currently only supports</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2976</td>
    <td class="codeLine">  /// Return true on success. Currently only supports</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeLine">  /// llvm.experimental.vector.deinterleave2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2977</td>
    <td class="codeLine">  /// llvm.experimental.vector.deinterleave2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2978</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeLine">  /// \p DI is the deinterleave intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2979</td>
    <td class="codeLine">  /// \p DI is the deinterleave intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeLine">  /// \p LI is the accompanying load instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2980</td>
    <td class="codeLine">  /// \p LI is the accompanying load instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeLine">  virtual bool lowerDeinterleaveIntrinsicToLoad(IntrinsicInst *DI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2981</td>
    <td class="codeLine">  virtual bool lowerDeinterleaveIntrinsicToLoad(IntrinsicInst *DI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeLine">                                                LoadInst *LI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2982</td>
    <td class="codeLine">                                                LoadInst *LI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2983</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2984</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeLine">  /// Lower an interleave intrinsic to a target specific store intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2986</td>
    <td class="codeLine">  /// Lower an interleave intrinsic to a target specific store intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeLine">  /// Return true on success. Currently only supports</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2987</td>
    <td class="codeLine">  /// Return true on success. Currently only supports</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeLine">  /// llvm.experimental.vector.interleave2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2988</td>
    <td class="codeLine">  /// llvm.experimental.vector.interleave2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2989</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeLine">  /// \p II is the interleave intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2990</td>
    <td class="codeLine">  /// \p II is the interleave intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeLine">  /// \p SI is the accompanying store instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2991</td>
    <td class="codeLine">  /// \p SI is the accompanying store instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeLine">  virtual bool lowerInterleaveIntrinsicToStore(IntrinsicInst *II,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2992</td>
    <td class="codeLine">  virtual bool lowerInterleaveIntrinsicToStore(IntrinsicInst *II,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeLine">                                               StoreInst *SI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2993</td>
    <td class="codeLine">                                               StoreInst *SI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2994</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2995</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeLine">  /// Return true if an fpext operation is free (for instance, because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2997</td>
    <td class="codeLine">  /// Return true if an fpext operation is free (for instance, because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeLine">  /// single-precision floating-point numbers are implicitly extended to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2998</td>
    <td class="codeLine">  /// single-precision floating-point numbers are implicitly extended to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeLine">  /// double-precision).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2999</td>
    <td class="codeLine">  /// double-precision).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeLine">  virtual bool isFPExtFree(EVT DestVT, EVT SrcVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3000</td>
    <td class="codeLine">  virtual bool isFPExtFree(EVT DestVT, EVT SrcVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeLine">    assert(SrcVT.isFloatingPoint() && DestVT.isFloatingPoint() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3001</td>
    <td class="codeLine">    assert(SrcVT.isFloatingPoint() && DestVT.isFloatingPoint() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeLine">           "invalid fpext types");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3002</td>
    <td class="codeLine">           "invalid fpext types");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3003</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3004</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeLine">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3006</td>
    <td class="codeLine">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeLine">  /// (for instance, because half-precision floating-point numbers are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3007</td>
    <td class="codeLine">  /// (for instance, because half-precision floating-point numbers are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeLine">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3008</td>
    <td class="codeLine">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeLine">  virtual bool isFPExtFoldable(const MachineInstr &MI, unsigned Opcode,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3009</td>
    <td class="codeLine">  virtual bool isFPExtFoldable(const MachineInstr &MI, unsigned Opcode,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeLine">                               LLT DestTy, LLT SrcTy) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3010</td>
    <td class="codeLine">                               LLT DestTy, LLT SrcTy) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3011</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeLine">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3014</td>
    <td class="codeLine">  /// Return true if an fpext operation input to an \p Opcode operation is free</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeLine">  /// (for instance, because half-precision floating-point numbers are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3015</td>
    <td class="codeLine">  /// (for instance, because half-precision floating-point numbers are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeLine">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3016</td>
    <td class="codeLine">  /// implicitly extended to float-precision) for an FMA instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeLine">  virtual bool isFPExtFoldable(const SelectionDAG &DAG, unsigned Opcode,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3017</td>
    <td class="codeLine">  virtual bool isFPExtFoldable(const SelectionDAG &DAG, unsigned Opcode,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeLine">                               EVT DestVT, EVT SrcVT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3018</td>
    <td class="codeLine">                               EVT DestVT, EVT SrcVT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeLine">    assert(DestVT.isFloatingPoint() && SrcVT.isFloatingPoint() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3019</td>
    <td class="codeLine">    assert(DestVT.isFloatingPoint() && SrcVT.isFloatingPoint() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeLine">           "invalid fpext types");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3020</td>
    <td class="codeLine">           "invalid fpext types");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeLine">    return isFPExtFree(DestVT, SrcVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3021</td>
    <td class="codeLine">    return isFPExtFree(DestVT, SrcVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3022</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeLine">  /// Return true if folding a vector load into ExtVal (a sign, zero, or any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3024</td>
    <td class="codeLine">  /// Return true if folding a vector load into ExtVal (a sign, zero, or any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeLine">  /// extend node) is profitable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3025</td>
    <td class="codeLine">  /// extend node) is profitable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeLine">  virtual bool isVectorLoadExtDesirable(SDValue ExtVal) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3026</td>
    <td class="codeLine">  virtual bool isVectorLoadExtDesirable(SDValue ExtVal) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeLine">  /// Return true if an fneg operation is free to the point where it is never</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3028</td>
    <td class="codeLine">  /// Return true if an fneg operation is free to the point where it is never</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeLine">  /// worthwhile to replace it with a bitwise operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3029</td>
    <td class="codeLine">  /// worthwhile to replace it with a bitwise operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeLine">  virtual bool isFNegFree(EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3030</td>
    <td class="codeLine">  virtual bool isFNegFree(EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeLine">    assert(VT.isFloatingPoint());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3031</td>
    <td class="codeLine">    assert(VT.isFloatingPoint());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3032</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3033</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeLine">  /// Return true if an fabs operation is free to the point where it is never</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3035</td>
    <td class="codeLine">  /// Return true if an fabs operation is free to the point where it is never</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeLine">  /// worthwhile to replace it with a bitwise operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3036</td>
    <td class="codeLine">  /// worthwhile to replace it with a bitwise operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeLine">  virtual bool isFAbsFree(EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3037</td>
    <td class="codeLine">  virtual bool isFAbsFree(EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeLine">    assert(VT.isFloatingPoint());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3038</td>
    <td class="codeLine">    assert(VT.isFloatingPoint());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3039</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3040</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeLine">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3042</td>
    <td class="codeLine">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeLine">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3043</td>
    <td class="codeLine">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeLine">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3044</td>
    <td class="codeLine">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3045</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeLine">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3046</td>
    <td class="codeLine">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeLine">  /// not legal, but should return true if those types will eventually legalize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3047</td>
    <td class="codeLine">  /// not legal, but should return true if those types will eventually legalize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeLine">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3048</td>
    <td class="codeLine">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeLine">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3049</td>
    <td class="codeLine">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeLine">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3050</td>
    <td class="codeLine">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeLine">                                          EVT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3051</td>
    <td class="codeLine">                                          EVT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3052</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeLine">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3055</td>
    <td class="codeLine">  /// Return true if an FMA operation is faster than a pair of fmul and fadd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeLine">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3056</td>
    <td class="codeLine">  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeLine">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3057</td>
    <td class="codeLine">  /// returns true, otherwise fmuladd is expanded to fmul + fadd.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3058</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeLine">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3059</td>
    <td class="codeLine">  /// NOTE: This may be called before legalization on types for which FMAs are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeLine">  /// not legal, but should return true if those types will eventually legalize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3060</td>
    <td class="codeLine">  /// not legal, but should return true if those types will eventually legalize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeLine">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3061</td>
    <td class="codeLine">  /// to types that support FMAs. After legalization, it will only be called on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeLine">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3062</td>
    <td class="codeLine">  /// types that support FMAs (via Legal or Custom actions)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeLine">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3063</td>
    <td class="codeLine">  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeLine">                                          LLT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3064</td>
    <td class="codeLine">                                          LLT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3065</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3066</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeLine">  /// IR version</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3068</td>
    <td class="codeLine">  /// IR version</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeLine">  virtual bool isFMAFasterThanFMulAndFAdd(const Function &F, Type *) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3069</td>
    <td class="codeLine">  virtual bool isFMAFasterThanFMulAndFAdd(const Function &F, Type *) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3070</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3071</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeLine">  /// Returns true if \p MI can be combined with another instruction to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3073</td>
    <td class="codeLine">  /// Returns true if \p MI can be combined with another instruction to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeLine">  /// form TargetOpcode::G_FMAD. \p N may be an TargetOpcode::G_FADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3074</td>
    <td class="codeLine">  /// form TargetOpcode::G_FMAD. \p N may be an TargetOpcode::G_FADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeLine">  /// TargetOpcode::G_FSUB, or an TargetOpcode::G_FMUL which will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3075</td>
    <td class="codeLine">  /// TargetOpcode::G_FSUB, or an TargetOpcode::G_FMUL which will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeLine">  /// distributed into an fadd/fsub.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3076</td>
    <td class="codeLine">  /// distributed into an fadd/fsub.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeLine">  virtual bool isFMADLegal(const MachineInstr &MI, LLT Ty) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3077</td>
    <td class="codeLine">  virtual bool isFMADLegal(const MachineInstr &MI, LLT Ty) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeLine">    assert((MI.getOpcode() == TargetOpcode::G_FADD ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3078</td>
    <td class="codeLine">    assert((MI.getOpcode() == TargetOpcode::G_FADD ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeLine">            MI.getOpcode() == TargetOpcode::G_FSUB ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3079</td>
    <td class="codeLine">            MI.getOpcode() == TargetOpcode::G_FSUB ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeLine">            MI.getOpcode() == TargetOpcode::G_FMUL) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3080</td>
    <td class="codeLine">            MI.getOpcode() == TargetOpcode::G_FMUL) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeLine">           "unexpected node in FMAD forming combine");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3081</td>
    <td class="codeLine">           "unexpected node in FMAD forming combine");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeLine">    switch (Ty.getScalarSizeInBits()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3082</td>
    <td class="codeLine">    switch (Ty.getScalarSizeInBits()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeLine">    case 16:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3083</td>
    <td class="codeLine">    case 16:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f16);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3084</td>
    <td class="codeLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f16);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeLine">    case 32:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3085</td>
    <td class="codeLine">    case 32:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3086</td>
    <td class="codeLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeLine">    case 64:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3087</td>
    <td class="codeLine">    case 64:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f64);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3088</td>
    <td class="codeLine">      return isOperationLegal(TargetOpcode::G_FMAD, MVT::f64);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3089</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3090</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3091</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3093</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3094</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeLine">  /// Returns true if be combined with to form an ISD::FMAD. \p N may be an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3096</td>
    <td class="codeLine">  /// Returns true if be combined with to form an ISD::FMAD. \p N may be an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeLine">  /// ISD::FADD, ISD::FSUB, or an ISD::FMUL which will be distributed into an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3097</td>
    <td class="codeLine">  /// ISD::FADD, ISD::FSUB, or an ISD::FMUL which will be distributed into an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeLine">  /// fadd/fsub.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3098</td>
    <td class="codeLine">  /// fadd/fsub.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeLine">  virtual bool isFMADLegal(const SelectionDAG &DAG, const SDNode *N) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3099</td>
    <td class="codeLine">  virtual bool isFMADLegal(const SelectionDAG &DAG, const SDNode *N) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeLine">    assert((N->getOpcode() == ISD::FADD || N->getOpcode() == ISD::FSUB ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3100</td>
    <td class="codeLine">    assert((N->getOpcode() == ISD::FADD || N->getOpcode() == ISD::FSUB ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeLine">            N->getOpcode() == ISD::FMUL) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3101</td>
    <td class="codeLine">            N->getOpcode() == ISD::FMUL) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeLine">           "unexpected node in FMAD forming combine");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3102</td>
    <td class="codeLine">           "unexpected node in FMAD forming combine");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeLine">    return isOperationLegal(ISD::FMAD, N->getValueType(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3103</td>
    <td class="codeLine">    return isOperationLegal(ISD::FMAD, N->getValueType(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3104</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeLine">  // Return true when the decision to generate FMA's (or FMS, FMLA etc) rather</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3106</td>
    <td class="codeLine">  // Return true when the decision to generate FMA's (or FMS, FMLA etc) rather</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeLine">  // than FMUL and ADD is delegated to the machine combiner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3107</td>
    <td class="codeLine">  // than FMUL and ADD is delegated to the machine combiner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeLine">  virtual bool generateFMAsInMachineCombiner(EVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3108</td>
    <td class="codeLine">  virtual bool generateFMAsInMachineCombiner(EVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeLine">                                             CodeGenOpt::Level OptLevel) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3109</td>
    <td class="codeLine">                                             CodeGenOpt::Level OptLevel) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3110</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3111</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeLine">  /// Return true if it's profitable to narrow operations of type SrcVT to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3113</td>
    <td class="codeLine">  /// Return true if it's profitable to narrow operations of type SrcVT to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeLine">  /// DestVT. e.g. on x86, it's profitable to narrow from i32 to i8 but not from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3114</td>
    <td class="codeLine">  /// DestVT. e.g. on x86, it's profitable to narrow from i32 to i8 but not from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeLine">  /// i32 to i16.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3115</td>
    <td class="codeLine">  /// i32 to i16.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeLine">  virtual bool isNarrowingProfitable(EVT SrcVT, EVT DestVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3116</td>
    <td class="codeLine">  virtual bool isNarrowingProfitable(EVT SrcVT, EVT DestVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3117</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeLine">  /// Return true if pulling a binary operation into a select with an identity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3120</td>
    <td class="codeLine">  /// Return true if pulling a binary operation into a select with an identity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeLine">  /// constant is profitable. This is the inverse of an IR transform.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3121</td>
    <td class="codeLine">  /// constant is profitable. This is the inverse of an IR transform.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeLine">  /// Example: X + (Cond ? Y : 0) --> Cond ? (X + Y) : X</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3122</td>
    <td class="codeLine">  /// Example: X + (Cond ? Y : 0) --> Cond ? (X + Y) : X</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeLine coveredLine">  virtual bool shouldFoldSelectWithIdentityConstant(unsigned BinOpcode,</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">3123</td>
    <td class="codeLine coveredLine">  virtual bool shouldFoldSelectWithIdentityConstant(unsigned BinOpcode,</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeLine">                                                    EVT VT) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3124</td>
    <td class="codeLine">                                                    EVT VT) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">3125</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeLine">  /// Return true if it is beneficial to convert a load of a constant to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3128</td>
    <td class="codeLine">  /// Return true if it is beneficial to convert a load of a constant to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeLine">  /// just the constant itself.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3129</td>
    <td class="codeLine">  /// just the constant itself.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeLine">  /// On some targets it might be more efficient to use a combination of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3130</td>
    <td class="codeLine">  /// On some targets it might be more efficient to use a combination of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeLine">  /// arithmetic instructions to materialize the constant instead of loading it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3131</td>
    <td class="codeLine">  /// arithmetic instructions to materialize the constant instead of loading it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeLine">  /// from a constant pool.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3132</td>
    <td class="codeLine">  /// from a constant pool.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeLine">  virtual bool shouldConvertConstantLoadToIntImm(const APInt &Imm,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3133</td>
    <td class="codeLine">  virtual bool shouldConvertConstantLoadToIntImm(const APInt &Imm,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeLine">                                                 Type *Ty) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3134</td>
    <td class="codeLine">                                                 Type *Ty) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3135</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeLine">  /// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3138</td>
    <td class="codeLine">  /// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeLine">  /// from this source type with this index. This is needed because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3139</td>
    <td class="codeLine">  /// from this source type with this index. This is needed because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeLine">  /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3140</td>
    <td class="codeLine">  /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeLine">  /// the first element, and only the target knows which lowering is cheap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3141</td>
    <td class="codeLine">  /// the first element, and only the target knows which lowering is cheap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeLine">  virtual bool isExtractSubvectorCheap(EVT ResVT, EVT SrcVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3142</td>
    <td class="codeLine">  virtual bool isExtractSubvectorCheap(EVT ResVT, EVT SrcVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeLine">                                       unsigned Index) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3143</td>
    <td class="codeLine">                                       unsigned Index) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3144</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3145</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeLine">  /// Try to convert an extract element of a vector binary operation into an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3147</td>
    <td class="codeLine">  /// Try to convert an extract element of a vector binary operation into an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeLine">  /// extract element followed by a scalar operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3148</td>
    <td class="codeLine">  /// extract element followed by a scalar operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeLine">  virtual bool shouldScalarizeBinop(SDValue VecOp) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3149</td>
    <td class="codeLine">  virtual bool shouldScalarizeBinop(SDValue VecOp) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3150</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3151</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeLine">  /// Return true if extraction of a scalar element from the given vector type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3153</td>
    <td class="codeLine">  /// Return true if extraction of a scalar element from the given vector type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeLine">  /// at the given index is cheap. For example, if scalar operations occur on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3154</td>
    <td class="codeLine">  /// at the given index is cheap. For example, if scalar operations occur on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeLine">  /// the same register file as vector operations, then an extract element may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3155</td>
    <td class="codeLine">  /// the same register file as vector operations, then an extract element may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeLine">  /// be a sub-register rename rather than an actual instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3156</td>
    <td class="codeLine">  /// be a sub-register rename rather than an actual instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeLine">  virtual bool isExtractVecEltCheap(EVT VT, unsigned Index) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3157</td>
    <td class="codeLine">  virtual bool isExtractVecEltCheap(EVT VT, unsigned Index) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3158</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3159</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeLine">  /// Try to convert math with an overflow comparison into the corresponding DAG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3161</td>
    <td class="codeLine">  /// Try to convert math with an overflow comparison into the corresponding DAG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeLine">  /// node operation. Targets may want to override this independently of whether</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3162</td>
    <td class="codeLine">  /// node operation. Targets may want to override this independently of whether</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeLine">  /// the operation is legal/custom for the given type because it may obscure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3163</td>
    <td class="codeLine">  /// the operation is legal/custom for the given type because it may obscure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeLine">  /// matching of other patterns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3164</td>
    <td class="codeLine">  /// matching of other patterns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeLine">  virtual bool shouldFormOverflowOp(unsigned Opcode, EVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3165</td>
    <td class="codeLine">  virtual bool shouldFormOverflowOp(unsigned Opcode, EVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeLine">                                    bool MathUsed) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3166</td>
    <td class="codeLine">                                    bool MathUsed) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeLine">    // TODO: The default logic is inherited from code in CodeGenPrepare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3167</td>
    <td class="codeLine">    // TODO: The default logic is inherited from code in CodeGenPrepare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeLine">    // The opcode should not make a difference by default?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3168</td>
    <td class="codeLine">    // The opcode should not make a difference by default?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeLine">    if (Opcode != ISD::UADDO)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3169</td>
    <td class="codeLine">    if (Opcode != ISD::UADDO)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3170</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeLine">    // Allow the transform as long as we have an integer type that is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3172</td>
    <td class="codeLine">    // Allow the transform as long as we have an integer type that is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeLine">    // obviously illegal and unsupported and if the math result is used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3173</td>
    <td class="codeLine">    // obviously illegal and unsupported and if the math result is used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeLine">    // besides the overflow check. On some targets (e.g. SPARC), it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3174</td>
    <td class="codeLine">    // besides the overflow check. On some targets (e.g. SPARC), it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeLine">    // not profitable to form on overflow op if the math result has no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3175</td>
    <td class="codeLine">    // not profitable to form on overflow op if the math result has no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeLine">    // concrete users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3176</td>
    <td class="codeLine">    // concrete users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeLine">    if (VT.isVector())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3177</td>
    <td class="codeLine">    if (VT.isVector())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3178</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeLine">    return MathUsed && (VT.isSimple() || !isOperationExpand(Opcode, VT));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3179</td>
    <td class="codeLine">    return MathUsed && (VT.isSimple() || !isOperationExpand(Opcode, VT));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeLine">  // Return true if it is profitable to use a scalar input to a BUILD_VECTOR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3182</td>
    <td class="codeLine">  // Return true if it is profitable to use a scalar input to a BUILD_VECTOR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeLine">  // even if the vector itself has multiple uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3183</td>
    <td class="codeLine">  // even if the vector itself has multiple uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeLine">  virtual bool aggressivelyPreferBuildVectorSources(EVT VecVT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3184</td>
    <td class="codeLine">  virtual bool aggressivelyPreferBuildVectorSources(EVT VecVT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3185</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3186</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeLine">  // Return true if CodeGenPrepare should consider splitting large offset of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3188</td>
    <td class="codeLine">  // Return true if CodeGenPrepare should consider splitting large offset of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeLine">  // GEP to make the GEP fit into the addressing mode and can be sunk into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3189</td>
    <td class="codeLine">  // GEP to make the GEP fit into the addressing mode and can be sunk into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeLine">  // same blocks of its users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3190</td>
    <td class="codeLine">  // same blocks of its users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeLine">  virtual bool shouldConsiderGEPOffsetSplit() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3191</td>
    <td class="codeLine">  virtual bool shouldConsiderGEPOffsetSplit() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeLine">  /// Return true if creating a shift of the type by the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3193</td>
    <td class="codeLine">  /// Return true if creating a shift of the type by the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeLine">  /// amount is not profitable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3194</td>
    <td class="codeLine">  /// amount is not profitable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeLine">  virtual bool shouldAvoidTransformToShift(EVT VT, unsigned Amount) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3195</td>
    <td class="codeLine">  virtual bool shouldAvoidTransformToShift(EVT VT, unsigned Amount) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3196</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeLine">  /// Does this target require the clearing of high-order bits in a register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3199</td>
    <td class="codeLine">  /// Does this target require the clearing of high-order bits in a register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeLine">  /// passed to the fp16 to fp conversion library function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3200</td>
    <td class="codeLine">  /// passed to the fp16 to fp conversion library function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeLine">  virtual bool shouldKeepZExtForFP16Conv() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3201</td>
    <td class="codeLine">  virtual bool shouldKeepZExtForFP16Conv() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeLine">  /// Should we generate fp_to_si_sat and fp_to_ui_sat from type FPVT to type VT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3203</td>
    <td class="codeLine">  /// Should we generate fp_to_si_sat and fp_to_ui_sat from type FPVT to type VT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeLine">  /// from min(max(fptoi)) saturation patterns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3204</td>
    <td class="codeLine">  /// from min(max(fptoi)) saturation patterns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeLine">  virtual bool shouldConvertFpToSat(unsigned Op, EVT FPVT, EVT VT) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3205</td>
    <td class="codeLine">  virtual bool shouldConvertFpToSat(unsigned Op, EVT FPVT, EVT VT) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeLine">    return isOperationLegalOrCustom(Op, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3206</td>
    <td class="codeLine">    return isOperationLegalOrCustom(Op, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3207</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeLine">  /// Does this target support complex deinterleaving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3209</td>
    <td class="codeLine">  /// Does this target support complex deinterleaving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeLine">  virtual bool isComplexDeinterleavingSupported() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3210</td>
    <td class="codeLine">  virtual bool isComplexDeinterleavingSupported() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeLine">  /// Does this target support complex deinterleaving with the given operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3212</td>
    <td class="codeLine">  /// Does this target support complex deinterleaving with the given operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeLine">  /// and type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3213</td>
    <td class="codeLine">  /// and type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeLine">  virtual bool isComplexDeinterleavingOperationSupported(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3214</td>
    <td class="codeLine">  virtual bool isComplexDeinterleavingOperationSupported(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeLine">      ComplexDeinterleavingOperation Operation, Type *Ty) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3215</td>
    <td class="codeLine">      ComplexDeinterleavingOperation Operation, Type *Ty) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3216</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3217</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeLine">  /// Create the IR node for the given complex deinterleaving operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3219</td>
    <td class="codeLine">  /// Create the IR node for the given complex deinterleaving operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeLine">  /// If one cannot be created using all the given inputs, nullptr should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3220</td>
    <td class="codeLine">  /// If one cannot be created using all the given inputs, nullptr should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeLine">  /// returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3221</td>
    <td class="codeLine">  /// returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeLine">  virtual Value *createComplexDeinterleavingIR(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3222</td>
    <td class="codeLine">  virtual Value *createComplexDeinterleavingIR(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeLine">      IRBuilderBase &B, ComplexDeinterleavingOperation OperationType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3223</td>
    <td class="codeLine">      IRBuilderBase &B, ComplexDeinterleavingOperation OperationType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeLine">      ComplexDeinterleavingRotation Rotation, Value *InputA, Value *InputB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3224</td>
    <td class="codeLine">      ComplexDeinterleavingRotation Rotation, Value *InputA, Value *InputB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeLine">      Value *Accumulator = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3225</td>
    <td class="codeLine">      Value *Accumulator = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3226</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3229</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeLine">  // Runtime Library hooks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3230</td>
    <td class="codeLine">  // Runtime Library hooks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3231</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeLine">  /// Rename the default libcall routine name for the specified libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3233</td>
    <td class="codeLine">  /// Rename the default libcall routine name for the specified libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeLine coveredLine">  void setLibcallName(RTLIB::Libcall Call, const char *Name) {</td>
    <td class="lineNumber">3320</td>
    <td class="lineNumber">3234</td>
    <td class="codeLine coveredLine">  void setLibcallName(RTLIB::Libcall Call, const char *Name) {</td>
    <td class="lineNumber">3320</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeLine coveredLine">    LibcallRoutineNames[Call] = Name;</td>
    <td class="lineNumber">3320</td>
    <td class="lineNumber">3235</td>
    <td class="codeLine coveredLine">    LibcallRoutineNames[Call] = Name;</td>
    <td class="lineNumber">3320</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3320</td>
    <td class="lineNumber">3236</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3320</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeLine">  void setLibcallName(ArrayRef<RTLIB::Libcall> Calls, const char *Name) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3237</td>
    <td class="codeLine">  void setLibcallName(ArrayRef<RTLIB::Libcall> Calls, const char *Name) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeLine">    for (auto Call : Calls)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3238</td>
    <td class="codeLine">    for (auto Call : Calls)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeLine">      setLibcallName(Call, Name);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3239</td>
    <td class="codeLine">      setLibcallName(Call, Name);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeLine">  /// Get the libcall routine name for the specified libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3242</td>
    <td class="codeLine">  /// Get the libcall routine name for the specified libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeLine">  const char *getLibcallName(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3243</td>
    <td class="codeLine">  const char *getLibcallName(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeLine">    return LibcallRoutineNames[Call];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3244</td>
    <td class="codeLine">    return LibcallRoutineNames[Call];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3245</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeLine">  /// Override the default CondCode to be used to test the result of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3247</td>
    <td class="codeLine">  /// Override the default CondCode to be used to test the result of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeLine">  /// comparison libcall against zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3248</td>
    <td class="codeLine">  /// comparison libcall against zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeLine">  void setCmpLibcallCC(RTLIB::Libcall Call, ISD::CondCode CC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3249</td>
    <td class="codeLine">  void setCmpLibcallCC(RTLIB::Libcall Call, ISD::CondCode CC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeLine">    CmpLibcallCCs[Call] = CC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3250</td>
    <td class="codeLine">    CmpLibcallCCs[Call] = CC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3251</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeLine">  /// Get the CondCode that's to be used to test the result of the comparison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3253</td>
    <td class="codeLine">  /// Get the CondCode that's to be used to test the result of the comparison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeLine">  /// libcall against zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3254</td>
    <td class="codeLine">  /// libcall against zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeLine">  ISD::CondCode getCmpLibcallCC(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3255</td>
    <td class="codeLine">  ISD::CondCode getCmpLibcallCC(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeLine">    return CmpLibcallCCs[Call];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3256</td>
    <td class="codeLine">    return CmpLibcallCCs[Call];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeLine">  /// Set the CallingConv that should be used for the specified libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3259</td>
    <td class="codeLine">  /// Set the CallingConv that should be used for the specified libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeLine coveredLine">  void setLibcallCallingConv(RTLIB::Libcall Call, CallingConv::ID CC) {</td>
    <td class="lineNumber">3220</td>
    <td class="lineNumber">3260</td>
    <td class="codeLine coveredLine">  void setLibcallCallingConv(RTLIB::Libcall Call, CallingConv::ID CC) {</td>
    <td class="lineNumber">3220</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeLine coveredLine">    LibcallCallingConvs[Call] = CC;</td>
    <td class="lineNumber">3220</td>
    <td class="lineNumber">3261</td>
    <td class="codeLine coveredLine">    LibcallCallingConvs[Call] = CC;</td>
    <td class="lineNumber">3220</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3220</td>
    <td class="lineNumber">3262</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">3220</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeLine">  /// Get the CallingConv that should be used for the specified libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3264</td>
    <td class="codeLine">  /// Get the CallingConv that should be used for the specified libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeLine">  CallingConv::ID getLibcallCallingConv(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3265</td>
    <td class="codeLine">  CallingConv::ID getLibcallCallingConv(RTLIB::Libcall Call) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeLine">    return LibcallCallingConvs[Call];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3266</td>
    <td class="codeLine">    return LibcallCallingConvs[Call];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3267</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeLine">  /// Execute target specific actions to finalize target lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3269</td>
    <td class="codeLine">  /// Execute target specific actions to finalize target lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeLine">  /// This is used to set extra flags in MachineFrameInformation and freezing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3270</td>
    <td class="codeLine">  /// This is used to set extra flags in MachineFrameInformation and freezing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeLine">  /// the set of reserved registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3271</td>
    <td class="codeLine">  /// the set of reserved registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeLine">  /// The default implementation just freezes the set of reserved registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3272</td>
    <td class="codeLine">  /// The default implementation just freezes the set of reserved registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeLine">  virtual void finalizeLowering(MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3273</td>
    <td class="codeLine">  virtual void finalizeLowering(MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeLine">  //===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3275</td>
    <td class="codeLine">  //===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeLine">  //  GlobalISel Hooks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3276</td>
    <td class="codeLine">  //  GlobalISel Hooks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeLine">  //===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3277</td>
    <td class="codeLine">  //===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="codeLine">  /// Check whether or not \p MI needs to be moved close to its uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3278</td>
    <td class="codeLine">  /// Check whether or not \p MI needs to be moved close to its uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="codeLine">  virtual bool shouldLocalize(const MachineInstr &MI, const TargetTransformInfo *TTI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3279</td>
    <td class="codeLine">  virtual bool shouldLocalize(const MachineInstr &MI, const TargetTransformInfo *TTI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3282</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="codeLine">  const TargetMachine &TM;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3283</td>
    <td class="codeLine">  const TargetMachine &TM;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="codeLine">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3285</td>
    <td class="codeLine">  /// Tells the code generator that the target has multiple (allocatable)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="codeLine">  /// condition registers that can be used to store the results of comparisons</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3286</td>
    <td class="codeLine">  /// condition registers that can be used to store the results of comparisons</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="codeLine">  /// for use by selects and conditional branches. With multiple condition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3287</td>
    <td class="codeLine">  /// for use by selects and conditional branches. With multiple condition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="codeLine">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3288</td>
    <td class="codeLine">  /// registers, the code generator will not aggressively sink comparisons into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="codeLine">  /// the blocks of their users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3289</td>
    <td class="codeLine">  /// the blocks of their users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="codeLine">  bool HasMultipleConditionRegisters;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3290</td>
    <td class="codeLine">  bool HasMultipleConditionRegisters;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="codeLine">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3292</td>
    <td class="codeLine">  /// Tells the code generator that the target has BitExtract instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="codeLine">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3293</td>
    <td class="codeLine">  /// The code generator will aggressively sink "shift"s into the blocks of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="codeLine">  /// their users if the users will generate "and" instructions which can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3294</td>
    <td class="codeLine">  /// their users if the users will generate "and" instructions which can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="codeLine">  /// combined with "shift" to BitExtract instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3295</td>
    <td class="codeLine">  /// combined with "shift" to BitExtract instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="codeLine">  bool HasExtractBitsInsn;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3296</td>
    <td class="codeLine">  bool HasExtractBitsInsn;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="codeLine">  /// Tells the code generator to bypass slow divide or remainder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3298</td>
    <td class="codeLine">  /// Tells the code generator to bypass slow divide or remainder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="codeLine">  /// instructions. For example, BypassSlowDivWidths[32,8] tells the code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3299</td>
    <td class="codeLine">  /// instructions. For example, BypassSlowDivWidths[32,8] tells the code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="codeLine">  /// generator to bypass 32-bit integer div/rem with an 8-bit unsigned integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3300</td>
    <td class="codeLine">  /// generator to bypass 32-bit integer div/rem with an 8-bit unsigned integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="codeLine">  /// div/rem when the operands are positive and less than 256.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3301</td>
    <td class="codeLine">  /// div/rem when the operands are positive and less than 256.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class="codeLine">  DenseMap <unsigned int, unsigned int> BypassSlowDivWidths;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3302</td>
    <td class="codeLine">  DenseMap <unsigned int, unsigned int> BypassSlowDivWidths;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="codeLine">  /// Tells the code generator that it shouldn't generate extra flow control</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3304</td>
    <td class="codeLine">  /// Tells the code generator that it shouldn't generate extra flow control</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="codeLine">  /// instructions and should attempt to combine flow control instructions via</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3305</td>
    <td class="codeLine">  /// instructions and should attempt to combine flow control instructions via</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="codeLine">  /// predication.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3306</td>
    <td class="codeLine">  /// predication.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="codeLine">  bool JumpIsExpensive;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3307</td>
    <td class="codeLine">  bool JumpIsExpensive;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="codeLine">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3309</td>
    <td class="codeLine">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="codeLine">  /// a type wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3310</td>
    <td class="codeLine">  /// a type wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="codeLine">  BooleanContent BooleanContents;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3311</td>
    <td class="codeLine">  BooleanContent BooleanContents;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="codeLine">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3313</td>
    <td class="codeLine">  /// Information about the contents of the high-bits in boolean values held in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="codeLine">  /// a type wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3314</td>
    <td class="codeLine">  /// a type wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="codeLine">  BooleanContent BooleanFloatContents;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3315</td>
    <td class="codeLine">  BooleanContent BooleanFloatContents;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="codeLine">  /// Information about the contents of the high-bits in boolean vector values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3317</td>
    <td class="codeLine">  /// Information about the contents of the high-bits in boolean vector values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="codeLine">  /// when the element type is wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3318</td>
    <td class="codeLine">  /// when the element type is wider than i1. See getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="codeLine">  BooleanContent BooleanVectorContents;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3319</td>
    <td class="codeLine">  BooleanContent BooleanVectorContents;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="codeLine">  /// The target scheduling preference: shortest possible total cycles or lowest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3321</td>
    <td class="codeLine">  /// The target scheduling preference: shortest possible total cycles or lowest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="codeLine">  /// register usage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3322</td>
    <td class="codeLine">  /// register usage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="codeLine">  Sched::Preference SchedPreferenceInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3323</td>
    <td class="codeLine">  Sched::Preference SchedPreferenceInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="codeLine">  /// The minimum alignment that any argument on the stack needs to have.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3325</td>
    <td class="codeLine">  /// The minimum alignment that any argument on the stack needs to have.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="codeLine">  Align MinStackArgumentAlignment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3326</td>
    <td class="codeLine">  Align MinStackArgumentAlignment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="codeLine">  /// The minimum function alignment (used when optimizing for size, and to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3328</td>
    <td class="codeLine">  /// The minimum function alignment (used when optimizing for size, and to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="codeLine">  /// prevent explicitly provided alignment from leading to incorrect code).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3329</td>
    <td class="codeLine">  /// prevent explicitly provided alignment from leading to incorrect code).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="codeLine">  Align MinFunctionAlignment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3330</td>
    <td class="codeLine">  Align MinFunctionAlignment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="codeLine">  /// The preferred function alignment (used when alignment unspecified and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3332</td>
    <td class="codeLine">  /// The preferred function alignment (used when alignment unspecified and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="codeLine">  /// optimizing for speed).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3333</td>
    <td class="codeLine">  /// optimizing for speed).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class="codeLine">  Align PrefFunctionAlignment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3334</td>
    <td class="codeLine">  Align PrefFunctionAlignment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="codeLine">  /// The preferred loop alignment (in log2 bot in bytes).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3336</td>
    <td class="codeLine">  /// The preferred loop alignment (in log2 bot in bytes).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="codeLine">  Align PrefLoopAlignment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3337</td>
    <td class="codeLine">  Align PrefLoopAlignment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="codeLine">  /// The maximum amount of bytes permitted to be emitted for alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3338</td>
    <td class="codeLine">  /// The maximum amount of bytes permitted to be emitted for alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="codeLine">  unsigned MaxBytesForAlignment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3339</td>
    <td class="codeLine">  unsigned MaxBytesForAlignment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="codeLine">  /// Size in bits of the maximum atomics size the backend supports.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3341</td>
    <td class="codeLine">  /// Size in bits of the maximum atomics size the backend supports.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="codeLine">  /// Accesses larger than this will be expanded by AtomicExpandPass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3342</td>
    <td class="codeLine">  /// Accesses larger than this will be expanded by AtomicExpandPass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="codeLine">  unsigned MaxAtomicSizeInBitsSupported;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3343</td>
    <td class="codeLine">  unsigned MaxAtomicSizeInBitsSupported;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="codeLine">  /// Size in bits of the maximum div/rem size the backend supports.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3345</td>
    <td class="codeLine">  /// Size in bits of the maximum div/rem size the backend supports.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3346</td>
    <td class="codeLine">  /// Larger operations will be expanded by ExpandLargeDivRem.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="codeLine">  unsigned MaxDivRemBitWidthSupported;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3347</td>
    <td class="codeLine">  unsigned MaxDivRemBitWidthSupported;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="codeLine">  /// Size in bits of the maximum larget fp convert size the backend</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3349</td>
    <td class="codeLine">  /// Size in bits of the maximum larget fp convert size the backend</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="codeLine">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3350</td>
    <td class="codeLine">  /// supports. Larger operations will be expanded by ExpandLargeFPConvert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="codeLine">  unsigned MaxLargeFPConvertBitWidthSupported;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3351</td>
    <td class="codeLine">  unsigned MaxLargeFPConvertBitWidthSupported;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class="codeLine">  /// Size in bits of the minimum cmpxchg or ll/sc operation the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3353</td>
    <td class="codeLine">  /// Size in bits of the minimum cmpxchg or ll/sc operation the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="codeLine">  /// backend supports.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3354</td>
    <td class="codeLine">  /// backend supports.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="codeLine">  unsigned MinCmpXchgSizeInBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3355</td>
    <td class="codeLine">  unsigned MinCmpXchgSizeInBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="codeLine">  /// This indicates if the target supports unaligned atomic operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3357</td>
    <td class="codeLine">  /// This indicates if the target supports unaligned atomic operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="codeLine">  bool SupportsUnalignedAtomics;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3358</td>
    <td class="codeLine">  bool SupportsUnalignedAtomics;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="codeLine">  /// If set to a physical register, this specifies the register that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3360</td>
    <td class="codeLine">  /// If set to a physical register, this specifies the register that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="codeLine">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3361</td>
    <td class="codeLine">  /// llvm.savestack/llvm.restorestack should save and restore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="codeLine">  Register StackPointerRegisterToSaveRestore;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3362</td>
    <td class="codeLine">  Register StackPointerRegisterToSaveRestore;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="codeLine">  /// This indicates the default register class to use for each ValueType the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3364</td>
    <td class="codeLine">  /// This indicates the default register class to use for each ValueType the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class="codeLine">  /// target supports natively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3365</td>
    <td class="codeLine">  /// target supports natively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="codeLine">  const TargetRegisterClass *RegClassForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3366</td>
    <td class="codeLine">  const TargetRegisterClass *RegClassForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="codeLine">  uint16_t NumRegistersForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3367</td>
    <td class="codeLine">  uint16_t NumRegistersForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="codeLine">  MVT RegisterTypeForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3368</td>
    <td class="codeLine">  MVT RegisterTypeForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="codeLine">  /// This indicates the "representative" register class to use for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3370</td>
    <td class="codeLine">  /// This indicates the "representative" register class to use for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="codeLine">  /// ValueType the target supports natively. This information is used by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3371</td>
    <td class="codeLine">  /// ValueType the target supports natively. This information is used by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="codeLine">  /// scheduler to track register pressure. By default, the representative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3372</td>
    <td class="codeLine">  /// scheduler to track register pressure. By default, the representative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="codeLine">  /// register class is the largest legal super-reg register class of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3373</td>
    <td class="codeLine">  /// register class is the largest legal super-reg register class of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="codeLine">  /// register class of the specified type. e.g. On x86, i8, i16, and i32's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3374</td>
    <td class="codeLine">  /// register class of the specified type. e.g. On x86, i8, i16, and i32's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="codeLine">  /// representative class would be GR32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3375</td>
    <td class="codeLine">  /// representative class would be GR32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="codeLine">  const TargetRegisterClass *RepRegClassForVT[MVT::VALUETYPE_SIZE] = {0};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3376</td>
    <td class="codeLine">  const TargetRegisterClass *RepRegClassForVT[MVT::VALUETYPE_SIZE] = {0};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="codeLine">  /// This indicates the "cost" of the "representative" register class for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3378</td>
    <td class="codeLine">  /// This indicates the "cost" of the "representative" register class for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="codeLine">  /// ValueType. The cost is used by the scheduler to approximate register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3379</td>
    <td class="codeLine">  /// ValueType. The cost is used by the scheduler to approximate register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="codeLine">  /// pressure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3380</td>
    <td class="codeLine">  /// pressure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="codeLine">  uint8_t RepRegClassCostForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3381</td>
    <td class="codeLine">  uint8_t RepRegClassCostForVT[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="codeLine">  /// For any value types we are promoting or expanding, this contains the value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3383</td>
    <td class="codeLine">  /// For any value types we are promoting or expanding, this contains the value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="codeLine">  /// type that we are changing to.  For Expanded types, this contains one step</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3384</td>
    <td class="codeLine">  /// type that we are changing to.  For Expanded types, this contains one step</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="codeLine">  /// of the expand (e.g. i64 -> i32), even if there are multiple steps required</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3385</td>
    <td class="codeLine">  /// of the expand (e.g. i64 -> i32), even if there are multiple steps required</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="codeLine">  /// (e.g. i64 -> i16).  For types natively supported by the system, this holds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3386</td>
    <td class="codeLine">  /// (e.g. i64 -> i16).  For types natively supported by the system, this holds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="codeLine">  /// the same type (e.g. i32 -> i32).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3387</td>
    <td class="codeLine">  /// the same type (e.g. i32 -> i32).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="codeLine">  MVT TransformToType[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3388</td>
    <td class="codeLine">  MVT TransformToType[MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="codeLine">  /// For each operation and each value type, keep a LegalizeAction that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3390</td>
    <td class="codeLine">  /// For each operation and each value type, keep a LegalizeAction that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="codeLine">  /// indicates how instruction selection should deal with the operation.  Most</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3391</td>
    <td class="codeLine">  /// indicates how instruction selection should deal with the operation.  Most</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="codeLine">  /// operations are Legal (aka, supported natively by the target), but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3392</td>
    <td class="codeLine">  /// operations are Legal (aka, supported natively by the target), but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="codeLine">  /// operations that are not should be described.  Note that operations on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3393</td>
    <td class="codeLine">  /// operations that are not should be described.  Note that operations on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="codeLine">  /// non-legal value types are not described here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3394</td>
    <td class="codeLine">  /// non-legal value types are not described here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="codeLine">  LegalizeAction OpActions[MVT::VALUETYPE_SIZE][ISD::BUILTIN_OP_END];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3395</td>
    <td class="codeLine">  LegalizeAction OpActions[MVT::VALUETYPE_SIZE][ISD::BUILTIN_OP_END];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="codeLine">  /// For each load extension type and each value type, keep a LegalizeAction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3397</td>
    <td class="codeLine">  /// For each load extension type and each value type, keep a LegalizeAction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="codeLine">  /// that indicates how instruction selection should deal with a load of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3398</td>
    <td class="codeLine">  /// that indicates how instruction selection should deal with a load of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="codeLine">  /// specific value type and extension type. Uses 4-bits to store the action</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3399</td>
    <td class="codeLine">  /// specific value type and extension type. Uses 4-bits to store the action</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="codeLine">  /// for each of the 4 load ext types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3400</td>
    <td class="codeLine">  /// for each of the 4 load ext types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="codeLine">  uint16_t LoadExtActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3401</td>
    <td class="codeLine">  uint16_t LoadExtActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="codeLine">  /// For each value type pair keep a LegalizeAction that indicates whether a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3403</td>
    <td class="codeLine">  /// For each value type pair keep a LegalizeAction that indicates whether a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="codeLine">  /// truncating store of a specific value type and truncating type is legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3404</td>
    <td class="codeLine">  /// truncating store of a specific value type and truncating type is legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="codeLine">  LegalizeAction TruncStoreActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3405</td>
    <td class="codeLine">  LegalizeAction TruncStoreActions[MVT::VALUETYPE_SIZE][MVT::VALUETYPE_SIZE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="codeLine">  /// For each indexed mode and each value type, keep a quad of LegalizeAction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3407</td>
    <td class="codeLine">  /// For each indexed mode and each value type, keep a quad of LegalizeAction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="codeLine">  /// that indicates how instruction selection should deal with the load /</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3408</td>
    <td class="codeLine">  /// that indicates how instruction selection should deal with the load /</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="codeLine">  /// store / maskedload / maskedstore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3409</td>
    <td class="codeLine">  /// store / maskedload / maskedstore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3410</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="codeLine">  /// The first dimension is the value_type for the reference. The second</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3411</td>
    <td class="codeLine">  /// The first dimension is the value_type for the reference. The second</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="codeLine">  /// dimension represents the various modes for load store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3412</td>
    <td class="codeLine">  /// dimension represents the various modes for load store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class="codeLine">  uint16_t IndexedModeActions[MVT::VALUETYPE_SIZE][ISD::LAST_INDEXED_MODE];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3413</td>
    <td class="codeLine">  uint16_t IndexedModeActions[MVT::VALUETYPE_SIZE][ISD::LAST_INDEXED_MODE];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="codeLine">  /// For each condition code (ISD::CondCode) keep a LegalizeAction that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3415</td>
    <td class="codeLine">  /// For each condition code (ISD::CondCode) keep a LegalizeAction that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="codeLine">  /// indicates how instruction selection should deal with the condition code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3416</td>
    <td class="codeLine">  /// indicates how instruction selection should deal with the condition code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3417</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="codeLine">  /// Because each CC action takes up 4 bits, we need to have the array size be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3418</td>
    <td class="codeLine">  /// Because each CC action takes up 4 bits, we need to have the array size be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="codeLine">  /// large enough to fit all of the value types. This can be done by rounding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3419</td>
    <td class="codeLine">  /// large enough to fit all of the value types. This can be done by rounding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="codeLine">  /// up the MVT::VALUETYPE_SIZE value to the next multiple of 8.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3420</td>
    <td class="codeLine">  /// up the MVT::VALUETYPE_SIZE value to the next multiple of 8.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="codeLine">  uint32_t CondCodeActions[ISD::SETCC_INVALID][(MVT::VALUETYPE_SIZE + 7) / 8];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3421</td>
    <td class="codeLine">  uint32_t CondCodeActions[ISD::SETCC_INVALID][(MVT::VALUETYPE_SIZE + 7) / 8];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="codeLine">  ValueTypeActionImpl ValueTypeActions;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3423</td>
    <td class="codeLine">  ValueTypeActionImpl ValueTypeActions;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3425</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="codeLine">  /// Targets can specify ISD nodes that they would like PerformDAGCombine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3426</td>
    <td class="codeLine">  /// Targets can specify ISD nodes that they would like PerformDAGCombine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="codeLine">  /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3427</td>
    <td class="codeLine">  /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="codeLine">  /// array.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3428</td>
    <td class="codeLine">  /// array.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="codeLine">  unsigned char</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3429</td>
    <td class="codeLine">  unsigned char</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="codeLine">  TargetDAGCombineArray[(ISD::BUILTIN_OP_END+CHAR_BIT-1)/CHAR_BIT];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3430</td>
    <td class="codeLine">  TargetDAGCombineArray[(ISD::BUILTIN_OP_END+CHAR_BIT-1)/CHAR_BIT];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="codeLine">  /// For operations that must be promoted to a specific type, this holds the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3432</td>
    <td class="codeLine">  /// For operations that must be promoted to a specific type, this holds the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="codeLine">  /// destination type.  This map should be sparse, so don't hold it as an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3433</td>
    <td class="codeLine">  /// destination type.  This map should be sparse, so don't hold it as an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="codeLine">  /// array.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3434</td>
    <td class="codeLine">  /// array.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3435</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="codeLine">  /// Targets add entries to this map with AddPromotedToType(..), clients access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3436</td>
    <td class="codeLine">  /// Targets add entries to this map with AddPromotedToType(..), clients access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="codeLine">  /// this with getTypeToPromoteTo(..).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3437</td>
    <td class="codeLine">  /// this with getTypeToPromoteTo(..).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="codeLine">  std::map<std::pair<unsigned, MVT::SimpleValueType>, MVT::SimpleValueType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3438</td>
    <td class="codeLine">  std::map<std::pair<unsigned, MVT::SimpleValueType>, MVT::SimpleValueType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class="codeLine">    PromoteToType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3439</td>
    <td class="codeLine">    PromoteToType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="codeLine">  /// Stores the name each libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3441</td>
    <td class="codeLine">  /// Stores the name each libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="codeLine">  const char *LibcallRoutineNames[RTLIB::UNKNOWN_LIBCALL + 1];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3442</td>
    <td class="codeLine">  const char *LibcallRoutineNames[RTLIB::UNKNOWN_LIBCALL + 1];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="codeLine">  /// The ISD::CondCode that should be used to test the result of each of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3444</td>
    <td class="codeLine">  /// The ISD::CondCode that should be used to test the result of each of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="codeLine">  /// comparison libcall against zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3445</td>
    <td class="codeLine">  /// comparison libcall against zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class="codeLine">  ISD::CondCode CmpLibcallCCs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3446</td>
    <td class="codeLine">  ISD::CondCode CmpLibcallCCs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="codeLine">  /// Stores the CallingConv that should be used for each libcall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3448</td>
    <td class="codeLine">  /// Stores the CallingConv that should be used for each libcall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="codeLine">  CallingConv::ID LibcallCallingConvs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3449</td>
    <td class="codeLine">  CallingConv::ID LibcallCallingConvs[RTLIB::UNKNOWN_LIBCALL];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="codeLine">  /// Set default libcall names and calling conventions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3451</td>
    <td class="codeLine">  /// Set default libcall names and calling conventions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="codeLine">  void InitLibcalls(const Triple &TT);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3452</td>
    <td class="codeLine">  void InitLibcalls(const Triple &TT);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="codeLine">  /// The bits of IndexedModeActions used to store the legalisation actions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3454</td>
    <td class="codeLine">  /// The bits of IndexedModeActions used to store the legalisation actions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="codeLine">  /// We store the data as   | ML | MS |  L |  S | each taking 4 bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3455</td>
    <td class="codeLine">  /// We store the data as   | ML | MS |  L |  S | each taking 4 bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="codeLine">  enum IndexedModeActionsBits {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3456</td>
    <td class="codeLine">  enum IndexedModeActionsBits {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="codeLine">    IMAB_Store = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3457</td>
    <td class="codeLine">    IMAB_Store = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="codeLine">    IMAB_Load = 4,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3458</td>
    <td class="codeLine">    IMAB_Load = 4,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="codeLine">    IMAB_MaskedStore = 8,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3459</td>
    <td class="codeLine">    IMAB_MaskedStore = 8,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="codeLine">    IMAB_MaskedLoad = 12</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3460</td>
    <td class="codeLine">    IMAB_MaskedLoad = 12</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3461</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="codeLine coveredLine">  void setIndexedModeAction(unsigned IdxMode, MVT VT, unsigned Shift,</td>
    <td class="lineNumber">15920</td>
    <td class="lineNumber">3463</td>
    <td class="codeLine coveredLine">  void setIndexedModeAction(unsigned IdxMode, MVT VT, unsigned Shift,</td>
    <td class="lineNumber">15920</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="codeLine">                            LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3464</td>
    <td class="codeLine">                            LegalizeAction Action) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="codeLine coveredLine">    assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE &&</td>
    <td class="lineNumber">15920</td>
    <td class="lineNumber">3465</td>
    <td class="codeLine coveredLine">    assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE &&</td>
    <td class="lineNumber">15920</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="codeLine">           (unsigned)Action < 0xf && "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3466</td>
    <td class="codeLine">           (unsigned)Action < 0xf && "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="codeLine coveredLine">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td class="lineNumber">15920</td>
    <td class="lineNumber">3467</td>
    <td class="codeLine coveredLine">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td class="lineNumber">15920</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="codeLine coveredLine">    IndexedModeActions[Ty][IdxMode] &= ~(0xf << Shift);</td>
    <td class="lineNumber">15920</td>
    <td class="lineNumber">3468</td>
    <td class="codeLine coveredLine">    IndexedModeActions[Ty][IdxMode] &= ~(0xf << Shift);</td>
    <td class="lineNumber">15920</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="codeLine coveredLine">    IndexedModeActions[Ty][IdxMode] |= ((uint16_t)Action) << Shift;</td>
    <td class="lineNumber">15920</td>
    <td class="lineNumber">3469</td>
    <td class="codeLine coveredLine">    IndexedModeActions[Ty][IdxMode] |= ((uint16_t)Action) << Shift;</td>
    <td class="lineNumber">15920</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">15920</td>
    <td class="lineNumber">3470</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">15920</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="codeLine coveredLine">  LegalizeAction getIndexedModeAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">72</td>
    <td class="lineNumber">3472</td>
    <td class="codeLine coveredLine">  LegalizeAction getIndexedModeAction(unsigned IdxMode, MVT VT,</td>
    <td class="lineNumber">72</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="codeLine">                                      unsigned Shift) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3473</td>
    <td class="codeLine">                                      unsigned Shift) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="codeLine coveredLine">    assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() &&</td>
    <td class="lineNumber">72</td>
    <td class="lineNumber">3474</td>
    <td class="codeLine coveredLine">    assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() &&</td>
    <td class="lineNumber">72</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="codeLine">           "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3475</td>
    <td class="codeLine">           "Table isn't big enough!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="codeLine coveredLine">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td class="lineNumber">72</td>
    <td class="lineNumber">3476</td>
    <td class="codeLine coveredLine">    unsigned Ty = (unsigned)VT.SimpleTy;</td>
    <td class="lineNumber">72</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="codeLine coveredLine">    return (LegalizeAction)((IndexedModeActions[Ty][IdxMode] >> Shift) & 0xf);</td>
    <td class="lineNumber">72</td>
    <td class="lineNumber">3477</td>
    <td class="codeLine coveredLine">    return (LegalizeAction)((IndexedModeActions[Ty][IdxMode] >> Shift) & 0xf);</td>
    <td class="lineNumber">72</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3480</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="codeLine">  /// Return true if the extension represented by \p I is free.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3481</td>
    <td class="codeLine">  /// Return true if the extension represented by \p I is free.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="codeLine">  /// \pre \p I is a sign, zero, or fp extension and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3482</td>
    <td class="codeLine">  /// \pre \p I is a sign, zero, or fp extension and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="codeLine">  ///      is[Z|FP]ExtFree of the related types is not true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3483</td>
    <td class="codeLine">  ///      is[Z|FP]ExtFree of the related types is not true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="codeLine">  virtual bool isExtFreeImpl(const Instruction *I) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3484</td>
    <td class="codeLine">  virtual bool isExtFreeImpl(const Instruction *I) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="codeLine">  /// Depth that GatherAllAliases should should continue looking for chain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3486</td>
    <td class="codeLine">  /// Depth that GatherAllAliases should should continue looking for chain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="codeLine">  /// dependencies when trying to find a more preferable chain. As an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3487</td>
    <td class="codeLine">  /// dependencies when trying to find a more preferable chain. As an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="codeLine">  /// approximation, this should be more than the number of consecutive stores</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3488</td>
    <td class="codeLine">  /// approximation, this should be more than the number of consecutive stores</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="codeLine">  /// expected to be merged.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3489</td>
    <td class="codeLine">  /// expected to be merged.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="codeLine">  unsigned GatherAllAliasesMaxDepth;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3490</td>
    <td class="codeLine">  unsigned GatherAllAliasesMaxDepth;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="codeLine">  /// \brief Specify maximum number of store instructions per memset call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3492</td>
    <td class="codeLine">  /// \brief Specify maximum number of store instructions per memset call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3493</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="codeLine">  /// When lowering \@llvm.memset this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3494</td>
    <td class="codeLine">  /// When lowering \@llvm.memset this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class="codeLine">  /// store operations that may be substituted for the call to memset. Targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3495</td>
    <td class="codeLine">  /// store operations that may be substituted for the call to memset. Targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="codeLine">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3496</td>
    <td class="codeLine">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="codeLine">  /// should assume that the memset will be done using as many of the largest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3497</td>
    <td class="codeLine">  /// should assume that the memset will be done using as many of the largest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="codeLine">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3498</td>
    <td class="codeLine">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="codeLine">  /// alignment restrictions. For example, storing 9 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3499</td>
    <td class="codeLine">  /// alignment restrictions. For example, storing 9 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="codeLine">  /// with 16-bit alignment would result in four 2-byte stores and one 1-byte</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3500</td>
    <td class="codeLine">  /// with 16-bit alignment would result in four 2-byte stores and one 1-byte</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="codeLine">  /// store.  This only applies to setting a constant array of a constant size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3501</td>
    <td class="codeLine">  /// store.  This only applies to setting a constant array of a constant size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="codeLine">  unsigned MaxStoresPerMemset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3502</td>
    <td class="codeLine">  unsigned MaxStoresPerMemset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3503</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="codeLine">  unsigned MaxStoresPerMemsetOptSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3504</td>
    <td class="codeLine">  unsigned MaxStoresPerMemsetOptSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="codeLine">  /// \brief Specify maximum number of store instructions per memcpy call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3506</td>
    <td class="codeLine">  /// \brief Specify maximum number of store instructions per memcpy call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3507</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="codeLine">  /// When lowering \@llvm.memcpy this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3508</td>
    <td class="codeLine">  /// When lowering \@llvm.memcpy this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="codeLine">  /// store operations that may be substituted for a call to memcpy. Targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3509</td>
    <td class="codeLine">  /// store operations that may be substituted for a call to memcpy. Targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="codeLine">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3510</td>
    <td class="codeLine">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="codeLine">  /// should assume that the memcpy will be done using as many of the largest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3511</td>
    <td class="codeLine">  /// should assume that the memcpy will be done using as many of the largest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="codeLine">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3512</td>
    <td class="codeLine">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="codeLine">  /// alignment restrictions. For example, storing 7 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3513</td>
    <td class="codeLine">  /// alignment restrictions. For example, storing 7 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="codeLine">  /// with 32-bit alignment would result in one 4-byte store, a one 2-byte store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3514</td>
    <td class="codeLine">  /// with 32-bit alignment would result in one 4-byte store, a one 2-byte store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="codeLine">  /// and one 1-byte store. This only applies to copying a constant array of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3515</td>
    <td class="codeLine">  /// and one 1-byte store. This only applies to copying a constant array of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="codeLine">  /// constant size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3516</td>
    <td class="codeLine">  /// constant size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="codeLine">  unsigned MaxStoresPerMemcpy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3517</td>
    <td class="codeLine">  unsigned MaxStoresPerMemcpy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3518</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="codeLine">  unsigned MaxStoresPerMemcpyOptSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3519</td>
    <td class="codeLine">  unsigned MaxStoresPerMemcpyOptSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="codeLine">  /// \brief Specify max number of store instructions to glue in inlined memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3520</td>
    <td class="codeLine">  /// \brief Specify max number of store instructions to glue in inlined memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3521</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="codeLine">  /// When memcpy is inlined based on MaxStoresPerMemcpy, specify maximum number</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3522</td>
    <td class="codeLine">  /// When memcpy is inlined based on MaxStoresPerMemcpy, specify maximum number</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="codeLine">  /// of store instructions to keep together. This helps in pairing and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3523</td>
    <td class="codeLine">  /// of store instructions to keep together. This helps in pairing and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="codeLine">  //  vectorization later on.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3524</td>
    <td class="codeLine">  //  vectorization later on.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="codeLine">  unsigned MaxGluedStoresPerMemcpy = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3525</td>
    <td class="codeLine">  unsigned MaxGluedStoresPerMemcpy = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="codeLine">  /// \brief Specify maximum number of load instructions per memcmp call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3527</td>
    <td class="codeLine">  /// \brief Specify maximum number of load instructions per memcmp call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3528</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="codeLine">  /// When lowering \@llvm.memcmp this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3529</td>
    <td class="codeLine">  /// When lowering \@llvm.memcmp this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="codeLine">  /// pairs of load operations that may be substituted for a call to memcmp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3530</td>
    <td class="codeLine">  /// pairs of load operations that may be substituted for a call to memcmp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="codeLine">  /// Targets must set this value based on the cost threshold for that target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3531</td>
    <td class="codeLine">  /// Targets must set this value based on the cost threshold for that target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="codeLine">  /// Targets should assume that the memcmp will be done using as many of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3532</td>
    <td class="codeLine">  /// Targets should assume that the memcmp will be done using as many of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="codeLine">  /// largest load operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3533</td>
    <td class="codeLine">  /// largest load operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="codeLine">  /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3534</td>
    <td class="codeLine">  /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="codeLine">  /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3535</td>
    <td class="codeLine">  /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="codeLine">  /// and one 1-byte load. This only applies to copying a constant array of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3536</td>
    <td class="codeLine">  /// and one 1-byte load. This only applies to copying a constant array of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="codeLine">  /// constant size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3537</td>
    <td class="codeLine">  /// constant size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="codeLine">  unsigned MaxLoadsPerMemcmp;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3538</td>
    <td class="codeLine">  unsigned MaxLoadsPerMemcmp;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3539</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="codeLine">  unsigned MaxLoadsPerMemcmpOptSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3540</td>
    <td class="codeLine">  unsigned MaxLoadsPerMemcmpOptSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="codeLine">  /// \brief Specify maximum number of store instructions per memmove call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3542</td>
    <td class="codeLine">  /// \brief Specify maximum number of store instructions per memmove call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3543</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="codeLine">  /// When lowering \@llvm.memmove this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3544</td>
    <td class="codeLine">  /// When lowering \@llvm.memmove this field specifies the maximum number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="codeLine">  /// store instructions that may be substituted for a call to memmove. Targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3545</td>
    <td class="codeLine">  /// store instructions that may be substituted for a call to memmove. Targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="codeLine">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3546</td>
    <td class="codeLine">  /// must set this value based on the cost threshold for that target. Targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="codeLine">  /// should assume that the memmove will be done using as many of the largest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3547</td>
    <td class="codeLine">  /// should assume that the memmove will be done using as many of the largest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="codeLine">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3548</td>
    <td class="codeLine">  /// store operations first, followed by smaller ones, if necessary, per</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="codeLine">  /// alignment restrictions. For example, moving 9 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3549</td>
    <td class="codeLine">  /// alignment restrictions. For example, moving 9 bytes on a 32-bit machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="codeLine">  /// with 8-bit alignment would result in nine 1-byte stores.  This only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3550</td>
    <td class="codeLine">  /// with 8-bit alignment would result in nine 1-byte stores.  This only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="codeLine">  /// applies to copying a constant array of constant size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3551</td>
    <td class="codeLine">  /// applies to copying a constant array of constant size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="codeLine">  unsigned MaxStoresPerMemmove;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3552</td>
    <td class="codeLine">  unsigned MaxStoresPerMemmove;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3553</td>
    <td class="codeLine">  /// Likewise for functions with the OptSize attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="codeLine">  unsigned MaxStoresPerMemmoveOptSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3554</td>
    <td class="codeLine">  unsigned MaxStoresPerMemmoveOptSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="codeLine">  /// Tells the code generator that select is more expensive than a branch if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3556</td>
    <td class="codeLine">  /// Tells the code generator that select is more expensive than a branch if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class="codeLine">  /// the branch is usually predicted right.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3557</td>
    <td class="codeLine">  /// the branch is usually predicted right.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="codeLine">  bool PredictableSelectIsExpensive;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3558</td>
    <td class="codeLine">  bool PredictableSelectIsExpensive;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="codeLine">  /// \see enableExtLdPromotion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3560</td>
    <td class="codeLine">  /// \see enableExtLdPromotion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="codeLine">  bool EnableExtLdPromotion;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3561</td>
    <td class="codeLine">  bool EnableExtLdPromotion;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="codeLine">  /// Return true if the value types that can be represented by the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3563</td>
    <td class="codeLine">  /// Return true if the value types that can be represented by the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="codeLine">  /// register class are all legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3564</td>
    <td class="codeLine">  /// register class are all legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="codeLine">  bool isLegalRC(const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3565</td>
    <td class="codeLine">  bool isLegalRC(const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="codeLine">                 const TargetRegisterClass &RC) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3566</td>
    <td class="codeLine">                 const TargetRegisterClass &RC) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="codeLine">  /// Replace/modify any TargetFrameIndex operands with a targte-dependent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3568</td>
    <td class="codeLine">  /// Replace/modify any TargetFrameIndex operands with a targte-dependent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="codeLine">  /// sequence of memory operands that is recognized by PrologEpilogInserter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3569</td>
    <td class="codeLine">  /// sequence of memory operands that is recognized by PrologEpilogInserter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="codeLine">  MachineBasicBlock *emitPatchPoint(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3570</td>
    <td class="codeLine">  MachineBasicBlock *emitPatchPoint(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="codeLine">                                    MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3571</td>
    <td class="codeLine">                                    MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="codeLine">  bool IsStrictFPEnabled;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3573</td>
    <td class="codeLine">  bool IsStrictFPEnabled;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3574</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="codeLine">/// This class defines information used to lower LLVM code to legal SelectionDAG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3576</td>
    <td class="codeLine">/// This class defines information used to lower LLVM code to legal SelectionDAG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="codeLine">/// operators that the target instruction selector can accept natively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3577</td>
    <td class="codeLine">/// operators that the target instruction selector can accept natively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3578</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="codeLine">/// This class also defines callbacks that targets must implement to lower</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3579</td>
    <td class="codeLine">/// This class also defines callbacks that targets must implement to lower</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="codeLine">/// target-specific constructs to SelectionDAG operators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3580</td>
    <td class="codeLine">/// target-specific constructs to SelectionDAG operators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="codeLine">class TargetLowering : public TargetLoweringBase {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3581</td>
    <td class="codeLine">class TargetLowering : public TargetLoweringBase {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3582</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="codeLine">  struct DAGCombinerInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3583</td>
    <td class="codeLine">  struct DAGCombinerInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="codeLine">  struct MakeLibCallOptions;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3584</td>
    <td class="codeLine">  struct MakeLibCallOptions;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="codeLine">  TargetLowering(const TargetLowering &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3586</td>
    <td class="codeLine">  TargetLowering(const TargetLowering &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class="codeLine">  TargetLowering &operator=(const TargetLowering &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3587</td>
    <td class="codeLine">  TargetLowering &operator=(const TargetLowering &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="codeLine">  explicit TargetLowering(const TargetMachine &TM);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3589</td>
    <td class="codeLine">  explicit TargetLowering(const TargetMachine &TM);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="codeLine">  bool isPositionIndependent() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3591</td>
    <td class="codeLine">  bool isPositionIndependent() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="codeLine coveredLine">  virtual bool isSDNodeSourceOfDivergence(const SDNode *N,</td>
    <td class="lineNumber">44</td>
    <td class="lineNumber">3593</td>
    <td class="codeLine coveredLine">  virtual bool isSDNodeSourceOfDivergence(const SDNode *N,</td>
    <td class="lineNumber">44</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="codeLine">                                          FunctionLoweringInfo *FLI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3594</td>
    <td class="codeLine">                                          FunctionLoweringInfo *FLI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="codeLine">                                          UniformityInfo *UA) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3595</td>
    <td class="codeLine">                                          UniformityInfo *UA) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">44</td>
    <td class="lineNumber">3596</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">44</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3597</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="codeLine">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3599</td>
    <td class="codeLine">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="codeLine">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3600</td>
    <td class="codeLine">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="codeLine">  // default consider profitable any case where N0 has single use.  This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3601</td>
    <td class="codeLine">  // default consider profitable any case where N0 has single use.  This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class="codeLine">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3602</td>
    <td class="codeLine">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="codeLine">  // DAGCombiner.  Any particular target can implement its own heuristic to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3603</td>
    <td class="codeLine">  // DAGCombiner.  Any particular target can implement its own heuristic to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="codeLine">  // restrict common combiner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3604</td>
    <td class="codeLine">  // restrict common combiner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="codeLine">  virtual bool isReassocProfitable(SelectionDAG &DAG, SDValue N0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3605</td>
    <td class="codeLine">  virtual bool isReassocProfitable(SelectionDAG &DAG, SDValue N0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="codeLine">                                   SDValue N1) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3606</td>
    <td class="codeLine">                                   SDValue N1) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="codeLine">    return N0.hasOneUse();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3607</td>
    <td class="codeLine">    return N0.hasOneUse();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3608</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="codeLine">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3610</td>
    <td class="codeLine">  // Lets target to control the following reassociation of operands: (op (op x,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="codeLine">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3611</td>
    <td class="codeLine">  // c1), y) -> (op (op x, y), c1) where N0 is (op x, c1) and N1 is y. By</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="codeLine">  // default consider profitable any case where N0 has single use.  This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3612</td>
    <td class="codeLine">  // default consider profitable any case where N0 has single use.  This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="codeLine">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3613</td>
    <td class="codeLine">  // behavior reflects the condition replaced by this target hook call in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="codeLine">  // combiner.  Any particular target can implement its own heuristic to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3614</td>
    <td class="codeLine">  // combiner.  Any particular target can implement its own heuristic to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="codeLine">  // restrict common combiner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3615</td>
    <td class="codeLine">  // restrict common combiner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="codeLine">  virtual bool isReassocProfitable(MachineRegisterInfo &MRI, Register N0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3616</td>
    <td class="codeLine">  virtual bool isReassocProfitable(MachineRegisterInfo &MRI, Register N0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="codeLine">                                   Register N1) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3617</td>
    <td class="codeLine">                                   Register N1) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="codeLine">    return MRI.hasOneNonDBGUse(N0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3618</td>
    <td class="codeLine">    return MRI.hasOneNonDBGUse(N0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3619</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="codeLine coveredLine">  virtual bool isSDNodeAlwaysUniform(const SDNode * N) const {</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">3621</td>
    <td class="codeLine coveredLine">  virtual bool isSDNodeAlwaysUniform(const SDNode * N) const {</td>
    <td class="lineNumber">40</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">3622</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">40</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="codeLine">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3625</td>
    <td class="codeLine">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="codeLine">  /// by reference if the node's address can be legally represented as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3626</td>
    <td class="codeLine">  /// by reference if the node's address can be legally represented as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="codeLine">  /// pre-indexed load / store address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3627</td>
    <td class="codeLine">  /// pre-indexed load / store address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="codeLine">  virtual bool getPreIndexedAddressParts(SDNode * /*N*/, SDValue &/*Base*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3628</td>
    <td class="codeLine">  virtual bool getPreIndexedAddressParts(SDNode * /*N*/, SDValue &/*Base*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="codeLine">                                         SDValue &/*Offset*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3629</td>
    <td class="codeLine">                                         SDValue &/*Offset*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="codeLine">                                         ISD::MemIndexedMode &/*AM*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3630</td>
    <td class="codeLine">                                         ISD::MemIndexedMode &/*AM*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="codeLine">                                         SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3631</td>
    <td class="codeLine">                                         SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3632</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="codeLine">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3635</td>
    <td class="codeLine">  /// Returns true by value, base pointer and offset pointer and addressing mode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="codeLine">  /// by reference if this node can be combined with a load / store to form a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3636</td>
    <td class="codeLine">  /// by reference if this node can be combined with a load / store to form a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="codeLine">  /// post-indexed load / store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3637</td>
    <td class="codeLine">  /// post-indexed load / store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="codeLine">  virtual bool getPostIndexedAddressParts(SDNode * /*N*/, SDNode * /*Op*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3638</td>
    <td class="codeLine">  virtual bool getPostIndexedAddressParts(SDNode * /*N*/, SDNode * /*Op*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="codeLine">                                          SDValue &/*Base*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3639</td>
    <td class="codeLine">                                          SDValue &/*Base*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="codeLine">                                          SDValue &/*Offset*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3640</td>
    <td class="codeLine">                                          SDValue &/*Offset*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class="codeLine">                                          ISD::MemIndexedMode &/*AM*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3641</td>
    <td class="codeLine">                                          ISD::MemIndexedMode &/*AM*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="codeLine">                                          SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3642</td>
    <td class="codeLine">                                          SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3643</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3644</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="codeLine">  /// Returns true if the specified base+offset is a legal indexed addressing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3646</td>
    <td class="codeLine">  /// Returns true if the specified base+offset is a legal indexed addressing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class="codeLine">  /// mode for this target. \p MI is the load or store instruction that is being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3647</td>
    <td class="codeLine">  /// mode for this target. \p MI is the load or store instruction that is being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="codeLine">  /// considered for transformation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3648</td>
    <td class="codeLine">  /// considered for transformation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="codeLine">  virtual bool isIndexingLegal(MachineInstr &MI, Register Base, Register Offset,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3649</td>
    <td class="codeLine">  virtual bool isIndexingLegal(MachineInstr &MI, Register Base, Register Offset,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="codeLine">                               bool IsPre, MachineRegisterInfo &MRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3650</td>
    <td class="codeLine">                               bool IsPre, MachineRegisterInfo &MRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3651</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="codeLine">  /// Return the entry encoding for a jump table in the current function.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3654</td>
    <td class="codeLine">  /// Return the entry encoding for a jump table in the current function.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="codeLine">  /// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3655</td>
    <td class="codeLine">  /// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="codeLine">  virtual unsigned getJumpTableEncoding() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3656</td>
    <td class="codeLine">  virtual unsigned getJumpTableEncoding() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="codeLine">  virtual const MCExpr *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3658</td>
    <td class="codeLine">  virtual const MCExpr *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="codeLine">  LowerCustomJumpTableEntry(const MachineJumpTableInfo * /*MJTI*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3659</td>
    <td class="codeLine">  LowerCustomJumpTableEntry(const MachineJumpTableInfo * /*MJTI*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="codeLine">                            const MachineBasicBlock * /*MBB*/, unsigned /*uid*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3660</td>
    <td class="codeLine">                            const MachineBasicBlock * /*MBB*/, unsigned /*uid*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="codeLine">                            MCContext &/*Ctx*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3661</td>
    <td class="codeLine">                            MCContext &/*Ctx*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="codeLine">    llvm_unreachable("Need to implement this hook if target has custom JTIs");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3662</td>
    <td class="codeLine">    llvm_unreachable("Need to implement this hook if target has custom JTIs");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3663</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="codeLine">  /// Returns relocation base for the given PIC jumptable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3665</td>
    <td class="codeLine">  /// Returns relocation base for the given PIC jumptable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="codeLine">  virtual SDValue getPICJumpTableRelocBase(SDValue Table,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3666</td>
    <td class="codeLine">  virtual SDValue getPICJumpTableRelocBase(SDValue Table,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="codeLine">                                           SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3667</td>
    <td class="codeLine">                                           SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="codeLine">  /// This returns the relocation base for the given PIC jumptable, the same as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3669</td>
    <td class="codeLine">  /// This returns the relocation base for the given PIC jumptable, the same as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="codeLine">  /// getPICJumpTableRelocBase, but as an MCExpr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3670</td>
    <td class="codeLine">  /// getPICJumpTableRelocBase, but as an MCExpr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="codeLine">  virtual const MCExpr *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3671</td>
    <td class="codeLine">  virtual const MCExpr *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="codeLine">  getPICJumpTableRelocBaseExpr(const MachineFunction *MF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3672</td>
    <td class="codeLine">  getPICJumpTableRelocBaseExpr(const MachineFunction *MF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="codeLine">                               unsigned JTI, MCContext &Ctx) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3673</td>
    <td class="codeLine">                               unsigned JTI, MCContext &Ctx) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="codeLine">  /// Return true if folding a constant offset with the given GlobalAddress is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3675</td>
    <td class="codeLine">  /// Return true if folding a constant offset with the given GlobalAddress is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="codeLine">  /// legal.  It is frequently not legal in PIC relocation models.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3676</td>
    <td class="codeLine">  /// legal.  It is frequently not legal in PIC relocation models.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="codeLine">  virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3677</td>
    <td class="codeLine">  virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="codeLine">  /// On x86, return true if the operand with index OpNo is a CALL or JUMP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3679</td>
    <td class="codeLine">  /// On x86, return true if the operand with index OpNo is a CALL or JUMP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="codeLine">  /// instruction, which can use either a memory constraint or an address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3680</td>
    <td class="codeLine">  /// instruction, which can use either a memory constraint or an address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="codeLine">  /// constraint. -fasm-blocks "__asm call foo" lowers to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3681</td>
    <td class="codeLine">  /// constraint. -fasm-blocks "__asm call foo" lowers to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="codeLine">  /// call void asm sideeffect inteldialect "call ${0:P}", "*m..."</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3682</td>
    <td class="codeLine">  /// call void asm sideeffect inteldialect "call ${0:P}", "*m..."</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3683</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="codeLine">  /// This function is used by a hack to choose the address constraint,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3684</td>
    <td class="codeLine">  /// This function is used by a hack to choose the address constraint,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="codeLine">  /// lowering to a direct call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3685</td>
    <td class="codeLine">  /// lowering to a direct call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3686</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="codeLine">  isInlineAsmTargetBranch(const SmallVectorImpl<StringRef> &AsmStrs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3687</td>
    <td class="codeLine">  isInlineAsmTargetBranch(const SmallVectorImpl<StringRef> &AsmStrs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="codeLine">                          unsigned OpNo) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3688</td>
    <td class="codeLine">                          unsigned OpNo) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3689</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3690</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="codeLine">  bool isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3692</td>
    <td class="codeLine">  bool isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="codeLine">                            SDValue &Chain) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3693</td>
    <td class="codeLine">                            SDValue &Chain) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="codeLine">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3695</td>
    <td class="codeLine">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="codeLine">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3696</td>
    <td class="codeLine">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="codeLine">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3697</td>
    <td class="codeLine">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="codeLine">                           const SDValue OldRHS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3698</td>
    <td class="codeLine">                           const SDValue OldRHS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="codeLine">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3700</td>
    <td class="codeLine">  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="codeLine">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3701</td>
    <td class="codeLine">                           SDValue &NewRHS, ISD::CondCode &CCCode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="codeLine">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3702</td>
    <td class="codeLine">                           const SDLoc &DL, const SDValue OldLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="codeLine">                           const SDValue OldRHS, SDValue &Chain,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3703</td>
    <td class="codeLine">                           const SDValue OldRHS, SDValue &Chain,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="codeLine">                           bool IsSignaling = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3704</td>
    <td class="codeLine">                           bool IsSignaling = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3705</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="codeLine">  /// Returns a pair of (return value, chain).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3706</td>
    <td class="codeLine">  /// Returns a pair of (return value, chain).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="codeLine">  /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \p LC.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3707</td>
    <td class="codeLine">  /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \p LC.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3708</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="codeLine">                                          EVT RetVT, ArrayRef<SDValue> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3709</td>
    <td class="codeLine">                                          EVT RetVT, ArrayRef<SDValue> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="codeLine">                                          MakeLibCallOptions CallOptions,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3710</td>
    <td class="codeLine">                                          MakeLibCallOptions CallOptions,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="codeLine">                                          const SDLoc &dl,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3711</td>
    <td class="codeLine">                                          const SDLoc &dl,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="codeLine">                                          SDValue Chain = SDValue()) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3712</td>
    <td class="codeLine">                                          SDValue Chain = SDValue()) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="codeLine">  /// Check whether parameters to a call that are passed in callee saved</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3714</td>
    <td class="codeLine">  /// Check whether parameters to a call that are passed in callee saved</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="codeLine">  /// registers are the same as from the calling function.  This needs to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3715</td>
    <td class="codeLine">  /// registers are the same as from the calling function.  This needs to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="codeLine">  /// checked for tail call eligibility.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3716</td>
    <td class="codeLine">  /// checked for tail call eligibility.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="codeLine">  bool parametersInCSRMatch(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3717</td>
    <td class="codeLine">  bool parametersInCSRMatch(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="codeLine">      const uint32_t *CallerPreservedMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3718</td>
    <td class="codeLine">      const uint32_t *CallerPreservedMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="codeLine">      const SmallVectorImpl<CCValAssign> &ArgLocs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3719</td>
    <td class="codeLine">      const SmallVectorImpl<CCValAssign> &ArgLocs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="codeLine">      const SmallVectorImpl<SDValue> &OutVals) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3720</td>
    <td class="codeLine">      const SmallVectorImpl<SDValue> &OutVals) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3722</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="codeLine">  // TargetLowering Optimization Methods</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3723</td>
    <td class="codeLine">  // TargetLowering Optimization Methods</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3724</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="codeLine">  /// A convenience struct that encapsulates a DAG, and two SDValues for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3726</td>
    <td class="codeLine">  /// A convenience struct that encapsulates a DAG, and two SDValues for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="codeLine">  /// returning information from TargetLowering to its clients that want to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3727</td>
    <td class="codeLine">  /// returning information from TargetLowering to its clients that want to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="codeLine">  /// combine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3728</td>
    <td class="codeLine">  /// combine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="codeLine">  struct TargetLoweringOpt {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3729</td>
    <td class="codeLine">  struct TargetLoweringOpt {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="codeLine">    SelectionDAG &DAG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3730</td>
    <td class="codeLine">    SelectionDAG &DAG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="codeLine">    bool LegalTys;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3731</td>
    <td class="codeLine">    bool LegalTys;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="codeLine">    bool LegalOps;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3732</td>
    <td class="codeLine">    bool LegalOps;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="codeLine">    SDValue Old;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3733</td>
    <td class="codeLine">    SDValue Old;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="codeLine">    SDValue New;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3734</td>
    <td class="codeLine">    SDValue New;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="codeLine coveredLine">    explicit TargetLoweringOpt(SelectionDAG &InDAG,</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">3736</td>
    <td class="codeLine coveredLine">    explicit TargetLoweringOpt(SelectionDAG &InDAG,</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="codeLine">                               bool LT, bool LO) :</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3737</td>
    <td class="codeLine">                               bool LT, bool LO) :</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="codeLine coveredLine">      DAG(InDAG), LegalTys(LT), LegalOps(LO) {}</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">3738</td>
    <td class="codeLine coveredLine">      DAG(InDAG), LegalTys(LT), LegalOps(LO) {}</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="codeLine">    bool LegalTypes() const { return LegalTys; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3740</td>
    <td class="codeLine">    bool LegalTypes() const { return LegalTys; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="codeLine">    bool LegalOperations() const { return LegalOps; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3741</td>
    <td class="codeLine">    bool LegalOperations() const { return LegalOps; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="codeLine coveredLine">    bool CombineTo(SDValue O, SDValue N) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">3743</td>
    <td class="codeLine coveredLine">    bool CombineTo(SDValue O, SDValue N) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="codeLine coveredLine">      Old = O;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">3744</td>
    <td class="codeLine coveredLine">      Old = O;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="codeLine coveredLine">      New = N;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">3745</td>
    <td class="codeLine coveredLine">      New = N;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">3746</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3747</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3748</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="codeLine">  /// Determines the optimal series of memory ops to replace the memset / memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3750</td>
    <td class="codeLine">  /// Determines the optimal series of memory ops to replace the memset / memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="codeLine">  /// Return true if the number of memory ops is below the threshold (Limit).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3751</td>
    <td class="codeLine">  /// Return true if the number of memory ops is below the threshold (Limit).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="codeLine">  /// Note that this is always the case when Limit is ~0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3752</td>
    <td class="codeLine">  /// Note that this is always the case when Limit is ~0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="codeLine">  /// It returns the types of the sequence of memory ops to perform</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3753</td>
    <td class="codeLine">  /// It returns the types of the sequence of memory ops to perform</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="codeLine">  /// memset / memcpy by reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3754</td>
    <td class="codeLine">  /// memset / memcpy by reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3755</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="codeLine">  findOptimalMemOpLowering(std::vector<EVT> &MemOps, unsigned Limit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3756</td>
    <td class="codeLine">  findOptimalMemOpLowering(std::vector<EVT> &MemOps, unsigned Limit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="codeLine">                           const MemOp &Op, unsigned DstAS, unsigned SrcAS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3757</td>
    <td class="codeLine">                           const MemOp &Op, unsigned DstAS, unsigned SrcAS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="codeLine">                           const AttributeList &FuncAttributes) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3758</td>
    <td class="codeLine">                           const AttributeList &FuncAttributes) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="codeLine">  /// Check to see if the specified operand of the specified instruction is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3760</td>
    <td class="codeLine">  /// Check to see if the specified operand of the specified instruction is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="codeLine">  /// constant integer.  If so, check to see if there are any bits set in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3761</td>
    <td class="codeLine">  /// constant integer.  If so, check to see if there are any bits set in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="codeLine">  /// constant that are not demanded.  If so, shrink the constant and return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3762</td>
    <td class="codeLine">  /// constant that are not demanded.  If so, shrink the constant and return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3763</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="codeLine">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3764</td>
    <td class="codeLine">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class="codeLine">                              const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3765</td>
    <td class="codeLine">                              const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="codeLine">                              TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3766</td>
    <td class="codeLine">                              TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="codeLine">  /// Helper wrapper around ShrinkDemandedConstant, demanding all elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3768</td>
    <td class="codeLine">  /// Helper wrapper around ShrinkDemandedConstant, demanding all elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="codeLine">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3769</td>
    <td class="codeLine">  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class="codeLine">                              TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3770</td>
    <td class="codeLine">                              TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class="codeLine">  // Target hook to do target-specific const optimization, which is called by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3772</td>
    <td class="codeLine">  // Target hook to do target-specific const optimization, which is called by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="codeLine">  // ShrinkDemandedConstant. This function should return true if the target</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3773</td>
    <td class="codeLine">  // ShrinkDemandedConstant. This function should return true if the target</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="codeLine">  // doesn't want ShrinkDemandedConstant to further optimize the constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3774</td>
    <td class="codeLine">  // doesn't want ShrinkDemandedConstant to further optimize the constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="codeLine">  virtual bool targetShrinkDemandedConstant(SDValue Op,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3775</td>
    <td class="codeLine">  virtual bool targetShrinkDemandedConstant(SDValue Op,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="codeLine">                                            const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3776</td>
    <td class="codeLine">                                            const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="codeLine">                                            const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3777</td>
    <td class="codeLine">                                            const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="codeLine">                                            TargetLoweringOpt &TLO) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3778</td>
    <td class="codeLine">                                            TargetLoweringOpt &TLO) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3779</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3780</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="codeLine">  /// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.  This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3782</td>
    <td class="codeLine">  /// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.  This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="codeLine">  /// uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3783</td>
    <td class="codeLine">  /// uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="codeLine">  /// generalized for targets with other types of implicit widening casts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3784</td>
    <td class="codeLine">  /// generalized for targets with other types of implicit widening casts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="codeLine">  bool ShrinkDemandedOp(SDValue Op, unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3785</td>
    <td class="codeLine">  bool ShrinkDemandedOp(SDValue Op, unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="codeLine">                        const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3786</td>
    <td class="codeLine">                        const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="codeLine">                        TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3787</td>
    <td class="codeLine">                        TargetLoweringOpt &TLO) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="codeLine">  /// Look at Op.  At this point, we know that only the DemandedBits bits of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3789</td>
    <td class="codeLine">  /// Look at Op.  At this point, we know that only the DemandedBits bits of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="codeLine">  /// result of Op are ever used downstream.  If we can use this information to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3790</td>
    <td class="codeLine">  /// result of Op are ever used downstream.  If we can use this information to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="codeLine">  /// simplify Op, create a new simplified DAG node and return true, returning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3791</td>
    <td class="codeLine">  /// simplify Op, create a new simplified DAG node and return true, returning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="codeLine">  /// the original and new nodes in Old and New.  Otherwise, analyze the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3792</td>
    <td class="codeLine">  /// the original and new nodes in Old and New.  Otherwise, analyze the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="codeLine">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3793</td>
    <td class="codeLine">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="codeLine">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3794</td>
    <td class="codeLine">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="codeLine">  /// be accurate for those bits in the Demanded masks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3795</td>
    <td class="codeLine">  /// be accurate for those bits in the Demanded masks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="codeLine">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3796</td>
    <td class="codeLine">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="codeLine">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3797</td>
    <td class="codeLine">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="codeLine">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3798</td>
    <td class="codeLine">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="codeLine">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3799</td>
    <td class="codeLine">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="codeLine">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3800</td>
    <td class="codeLine">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="codeLine">  ///    has multiple uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3801</td>
    <td class="codeLine">  ///    has multiple uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3802</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="codeLine">                            const APInt &DemandedElts, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3803</td>
    <td class="codeLine">                            const APInt &DemandedElts, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="codeLine">                            TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3804</td>
    <td class="codeLine">                            TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="codeLine">                            bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3805</td>
    <td class="codeLine">                            bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedBits, demanding all elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3807</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedBits, demanding all elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3808</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3809</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="codeLine">                            KnownBits &Known, TargetLoweringOpt &TLO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3810</td>
    <td class="codeLine">                            KnownBits &Known, TargetLoweringOpt &TLO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="codeLine">                            unsigned Depth = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3811</td>
    <td class="codeLine">                            unsigned Depth = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="codeLine">                            bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3812</td>
    <td class="codeLine">                            bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3814</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3815</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3816</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3817</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3819</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedBits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3820</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3821</td>
    <td class="codeLine">  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="codeLine">                            const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3822</td>
    <td class="codeLine">                            const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3823</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="codeLine">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3825</td>
    <td class="codeLine">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="codeLine">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3826</td>
    <td class="codeLine">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="codeLine">  /// bitwise ops etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3827</td>
    <td class="codeLine">  /// bitwise ops etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="codeLine">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3828</td>
    <td class="codeLine">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="codeLine">                                          const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3829</td>
    <td class="codeLine">                                          const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="codeLine">                                          SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3830</td>
    <td class="codeLine">                                          SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="codeLine">                                          unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3831</td>
    <td class="codeLine">                                          unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3833</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="codeLine">  /// elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3834</td>
    <td class="codeLine">  /// elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="codeLine">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3835</td>
    <td class="codeLine">  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="codeLine">                                          SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3836</td>
    <td class="codeLine">                                          SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="codeLine">                                          unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3837</td>
    <td class="codeLine">                                          unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3839</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="codeLine">  /// bits from only some vector elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3840</td>
    <td class="codeLine">  /// bits from only some vector elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="codeLine">  SDValue SimplifyMultipleUseDemandedVectorElts(SDValue Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3841</td>
    <td class="codeLine">  SDValue SimplifyMultipleUseDemandedVectorElts(SDValue Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="codeLine">                                                const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3842</td>
    <td class="codeLine">                                                const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="codeLine">                                                SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3843</td>
    <td class="codeLine">                                                SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="codeLine">                                                unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3844</td>
    <td class="codeLine">                                                unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="codeLine">  /// Look at Vector Op. At this point, we know that only the DemandedElts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3846</td>
    <td class="codeLine">  /// Look at Vector Op. At this point, we know that only the DemandedElts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="codeLine">  /// elements of the result of Op are ever used downstream.  If we can use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3847</td>
    <td class="codeLine">  /// elements of the result of Op are ever used downstream.  If we can use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="codeLine">  /// this information to simplify Op, create a new simplified DAG node and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3848</td>
    <td class="codeLine">  /// this information to simplify Op, create a new simplified DAG node and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="codeLine">  /// return true, storing the original and new nodes in TLO.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3849</td>
    <td class="codeLine">  /// return true, storing the original and new nodes in TLO.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="codeLine">  /// Otherwise, analyze the expression and return a mask of KnownUndef and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3850</td>
    <td class="codeLine">  /// Otherwise, analyze the expression and return a mask of KnownUndef and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="codeLine">  /// KnownZero elements for the expression (used to simplify the caller).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3851</td>
    <td class="codeLine">  /// KnownZero elements for the expression (used to simplify the caller).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="codeLine">  /// The KnownUndef/Zero elements may only be accurate for those bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3852</td>
    <td class="codeLine">  /// The KnownUndef/Zero elements may only be accurate for those bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="codeLine">  /// in the DemandedMask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3853</td>
    <td class="codeLine">  /// in the DemandedMask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="codeLine">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3854</td>
    <td class="codeLine">  /// \p AssumeSingleUse When this parameter is true, this function will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="codeLine">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3855</td>
    <td class="codeLine">  ///    attempt to simplify \p Op even if there are multiple uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="codeLine">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3856</td>
    <td class="codeLine">  ///    Callers are responsible for correctly updating the DAG based on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="codeLine">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3857</td>
    <td class="codeLine">  ///    results of this function, because simply replacing replacing TLO.Old</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="codeLine">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3858</td>
    <td class="codeLine">  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="codeLine">  ///    has multiple uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3859</td>
    <td class="codeLine">  ///    has multiple uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="codeLine">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedEltMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3860</td>
    <td class="codeLine">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedEltMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="codeLine">                                  APInt &KnownUndef, APInt &KnownZero,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3861</td>
    <td class="codeLine">                                  APInt &KnownUndef, APInt &KnownZero,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="codeLine">                                  TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3862</td>
    <td class="codeLine">                                  TargetLoweringOpt &TLO, unsigned Depth = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="codeLine">                                  bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3863</td>
    <td class="codeLine">                                  bool AssumeSingleUse = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedVectorElts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3865</td>
    <td class="codeLine">  /// Helper wrapper around SimplifyDemandedVectorElts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3866</td>
    <td class="codeLine">  /// Adds Op back to the worklist upon success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="codeLine">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3867</td>
    <td class="codeLine">  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="codeLine">                                  DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3868</td>
    <td class="codeLine">                                  DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="codeLine">  /// Return true if the target supports simplifying demanded vector elements by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3870</td>
    <td class="codeLine">  /// Return true if the target supports simplifying demanded vector elements by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="codeLine">  /// converting them to undefs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3871</td>
    <td class="codeLine">  /// converting them to undefs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3872</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="codeLine">  shouldSimplifyDemandedVectorElts(SDValue Op,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3873</td>
    <td class="codeLine">  shouldSimplifyDemandedVectorElts(SDValue Op,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="codeLine">                                   const TargetLoweringOpt &TLO) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3874</td>
    <td class="codeLine">                                   const TargetLoweringOpt &TLO) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3875</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3876</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="codeLine">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3878</td>
    <td class="codeLine">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="codeLine">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3879</td>
    <td class="codeLine">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="codeLine">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3880</td>
    <td class="codeLine">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="codeLine">  /// requested vector elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3881</td>
    <td class="codeLine">  /// requested vector elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="codeLine">  virtual void computeKnownBitsForTargetNode(const SDValue Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3882</td>
    <td class="codeLine">  virtual void computeKnownBitsForTargetNode(const SDValue Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="codeLine">                                             KnownBits &Known,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3883</td>
    <td class="codeLine">                                             KnownBits &Known,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="codeLine">                                             const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3884</td>
    <td class="codeLine">                                             const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="codeLine">                                             const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3885</td>
    <td class="codeLine">                                             const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="codeLine">                                             unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3886</td>
    <td class="codeLine">                                             unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="codeLine">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3888</td>
    <td class="codeLine">  /// Determine which of the bits specified in Mask are known to be either zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="codeLine">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3889</td>
    <td class="codeLine">  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="codeLine">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3890</td>
    <td class="codeLine">  /// argument allows us to only collect the known bits that are shared by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="codeLine">  /// requested vector elements. This is for GISel.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3891</td>
    <td class="codeLine">  /// requested vector elements. This is for GISel.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="codeLine">  virtual void computeKnownBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3892</td>
    <td class="codeLine">  virtual void computeKnownBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="codeLine">                                              Register R, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3893</td>
    <td class="codeLine">                                              Register R, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="codeLine">                                              const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3894</td>
    <td class="codeLine">                                              const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="codeLine">                                              const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3895</td>
    <td class="codeLine">                                              const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="codeLine">                                              unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3896</td>
    <td class="codeLine">                                              unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="codeLine">  /// Determine the known alignment for the pointer value \p R. This is can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3898</td>
    <td class="codeLine">  /// Determine the known alignment for the pointer value \p R. This is can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="codeLine">  /// typically be inferred from the number of low known 0 bits. However, for a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3899</td>
    <td class="codeLine">  /// typically be inferred from the number of low known 0 bits. However, for a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="codeLine">  /// pointer with a non-integral address space, the alignment value may be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3900</td>
    <td class="codeLine">  /// pointer with a non-integral address space, the alignment value may be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="codeLine">  /// independent from the known low bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3901</td>
    <td class="codeLine">  /// independent from the known low bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="codeLine">  virtual Align computeKnownAlignForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3902</td>
    <td class="codeLine">  virtual Align computeKnownAlignForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="codeLine">                                                Register R,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3903</td>
    <td class="codeLine">                                                Register R,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="codeLine">                                                const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3904</td>
    <td class="codeLine">                                                const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="codeLine">                                                unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3905</td>
    <td class="codeLine">                                                unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="codeLine">  /// Determine which of the bits of FrameIndex \p FIOp are known to be 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3907</td>
    <td class="codeLine">  /// Determine which of the bits of FrameIndex \p FIOp are known to be 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="codeLine">  /// Default implementation computes low bits based on alignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3908</td>
    <td class="codeLine">  /// Default implementation computes low bits based on alignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="codeLine">  /// information. This should preserve known bits passed into it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3909</td>
    <td class="codeLine">  /// information. This should preserve known bits passed into it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="codeLine">  virtual void computeKnownBitsForFrameIndex(int FIOp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3910</td>
    <td class="codeLine">  virtual void computeKnownBitsForFrameIndex(int FIOp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="codeLine">                                             KnownBits &Known,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3911</td>
    <td class="codeLine">                                             KnownBits &Known,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="codeLine">                                             const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3912</td>
    <td class="codeLine">                                             const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="codeLine">  /// This method can be implemented by targets that want to expose additional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3914</td>
    <td class="codeLine">  /// This method can be implemented by targets that want to expose additional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="codeLine">  /// information about sign bits to the DAG Combiner. The DemandedElts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3915</td>
    <td class="codeLine">  /// information about sign bits to the DAG Combiner. The DemandedElts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="codeLine">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3916</td>
    <td class="codeLine">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="codeLine">  /// by the requested vector elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3917</td>
    <td class="codeLine">  /// by the requested vector elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="codeLine">  virtual unsigned ComputeNumSignBitsForTargetNode(SDValue Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3918</td>
    <td class="codeLine">  virtual unsigned ComputeNumSignBitsForTargetNode(SDValue Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="codeLine">                                                   const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3919</td>
    <td class="codeLine">                                                   const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="codeLine">                                                   const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3920</td>
    <td class="codeLine">                                                   const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="codeLine">                                                   unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3921</td>
    <td class="codeLine">                                                   unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="codeLine">  /// This method can be implemented by targets that want to expose additional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3923</td>
    <td class="codeLine">  /// This method can be implemented by targets that want to expose additional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="codeLine">  /// information about sign bits to GlobalISel combiners. The DemandedElts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3924</td>
    <td class="codeLine">  /// information about sign bits to GlobalISel combiners. The DemandedElts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="codeLine">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3925</td>
    <td class="codeLine">  /// argument allows us to only collect the minimum sign bits that are shared</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="codeLine">  /// by the requested vector elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3926</td>
    <td class="codeLine">  /// by the requested vector elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="codeLine">  virtual unsigned computeNumSignBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3927</td>
    <td class="codeLine">  virtual unsigned computeNumSignBitsForTargetInstr(GISelKnownBits &Analysis,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="codeLine">                                                    Register R,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3928</td>
    <td class="codeLine">                                                    Register R,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="codeLine">                                                    const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3929</td>
    <td class="codeLine">                                                    const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="codeLine">                                                    const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3930</td>
    <td class="codeLine">                                                    const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="codeLine">                                                    unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3931</td>
    <td class="codeLine">                                                    unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="codeLine">  /// Attempt to simplify any target nodes based on the demanded vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3933</td>
    <td class="codeLine">  /// Attempt to simplify any target nodes based on the demanded vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="codeLine">  /// elements, returning true on success. Otherwise, analyze the expression and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3934</td>
    <td class="codeLine">  /// elements, returning true on success. Otherwise, analyze the expression and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="codeLine">  /// return a mask of KnownUndef and KnownZero elements for the expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3935</td>
    <td class="codeLine">  /// return a mask of KnownUndef and KnownZero elements for the expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="codeLine">  /// (used to simplify the caller). The KnownUndef/Zero elements may only be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3936</td>
    <td class="codeLine">  /// (used to simplify the caller). The KnownUndef/Zero elements may only be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="codeLine">  /// accurate for those bits in the DemandedMask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3937</td>
    <td class="codeLine">  /// accurate for those bits in the DemandedMask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="codeLine">  virtual bool SimplifyDemandedVectorEltsForTargetNode(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3938</td>
    <td class="codeLine">  virtual bool SimplifyDemandedVectorEltsForTargetNode(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="codeLine">      SDValue Op, const APInt &DemandedElts, APInt &KnownUndef,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3939</td>
    <td class="codeLine">      SDValue Op, const APInt &DemandedElts, APInt &KnownUndef,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="codeLine">      APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3940</td>
    <td class="codeLine">      APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="codeLine">  /// Attempt to simplify any target nodes based on the demanded bits/elts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3942</td>
    <td class="codeLine">  /// Attempt to simplify any target nodes based on the demanded bits/elts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="codeLine">  /// returning true on success. Otherwise, analyze the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3943</td>
    <td class="codeLine">  /// returning true on success. Otherwise, analyze the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="codeLine">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3944</td>
    <td class="codeLine">  /// expression and return a mask of KnownOne and KnownZero bits for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="codeLine">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3945</td>
    <td class="codeLine">  /// expression (used to simplify the caller).  The KnownZero/One bits may only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="codeLine">  /// be accurate for those bits in the Demanded masks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3946</td>
    <td class="codeLine">  /// be accurate for those bits in the Demanded masks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="codeLine">  virtual bool SimplifyDemandedBitsForTargetNode(SDValue Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3947</td>
    <td class="codeLine">  virtual bool SimplifyDemandedBitsForTargetNode(SDValue Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="codeLine">                                                 const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3948</td>
    <td class="codeLine">                                                 const APInt &DemandedBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="codeLine">                                                 const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3949</td>
    <td class="codeLine">                                                 const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="codeLine">                                                 KnownBits &Known,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3950</td>
    <td class="codeLine">                                                 KnownBits &Known,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="codeLine">                                                 TargetLoweringOpt &TLO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3951</td>
    <td class="codeLine">                                                 TargetLoweringOpt &TLO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class="codeLine">                                                 unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3952</td>
    <td class="codeLine">                                                 unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="codeLine">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3954</td>
    <td class="codeLine">  /// More limited version of SimplifyDemandedBits that can be used to "look</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="codeLine">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3955</td>
    <td class="codeLine">  /// through" ops that don't contribute to the DemandedBits/DemandedElts -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="codeLine">  /// bitwise ops etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3956</td>
    <td class="codeLine">  /// bitwise ops etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="codeLine">  virtual SDValue SimplifyMultipleUseDemandedBitsForTargetNode(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3957</td>
    <td class="codeLine">  virtual SDValue SimplifyMultipleUseDemandedBitsForTargetNode(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="codeLine">      SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3958</td>
    <td class="codeLine">      SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="codeLine">      SelectionDAG &DAG, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3959</td>
    <td class="codeLine">      SelectionDAG &DAG, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="codeLine">  /// Return true if this function can prove that \p Op is never poison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3961</td>
    <td class="codeLine">  /// Return true if this function can prove that \p Op is never poison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="codeLine">  /// and, if \p PoisonOnly is false, does not have undef bits. The DemandedElts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3962</td>
    <td class="codeLine">  /// and, if \p PoisonOnly is false, does not have undef bits. The DemandedElts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="codeLine">  /// argument limits the check to the requested vector elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3963</td>
    <td class="codeLine">  /// argument limits the check to the requested vector elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="codeLine">  virtual bool isGuaranteedNotToBeUndefOrPoisonForTargetNode(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3964</td>
    <td class="codeLine">  virtual bool isGuaranteedNotToBeUndefOrPoisonForTargetNode(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class="codeLine">      SDValue Op, const APInt &DemandedElts, const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3965</td>
    <td class="codeLine">      SDValue Op, const APInt &DemandedElts, const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="codeLine">      bool PoisonOnly, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3966</td>
    <td class="codeLine">      bool PoisonOnly, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="codeLine">  /// Return true if Op can create undef or poison from non-undef & non-poison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3968</td>
    <td class="codeLine">  /// Return true if Op can create undef or poison from non-undef & non-poison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="codeLine">  /// operands. The DemandedElts argument limits the check to the requested</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3969</td>
    <td class="codeLine">  /// operands. The DemandedElts argument limits the check to the requested</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="codeLine">  /// vector elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3970</td>
    <td class="codeLine">  /// vector elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3971</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="codeLine">  canCreateUndefOrPoisonForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3972</td>
    <td class="codeLine">  canCreateUndefOrPoisonForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="codeLine">                                      const SelectionDAG &DAG, bool PoisonOnly,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3973</td>
    <td class="codeLine">                                      const SelectionDAG &DAG, bool PoisonOnly,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="codeLine">                                      bool ConsiderFlags, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3974</td>
    <td class="codeLine">                                      bool ConsiderFlags, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class="codeLine">  /// Tries to build a legal vector shuffle using the provided parameters</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3976</td>
    <td class="codeLine">  /// Tries to build a legal vector shuffle using the provided parameters</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="codeLine">  /// or equivalent variations. The Mask argument maybe be modified as the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3977</td>
    <td class="codeLine">  /// or equivalent variations. The Mask argument maybe be modified as the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="codeLine">  /// function tries different variations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3978</td>
    <td class="codeLine">  /// function tries different variations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class="codeLine">  /// Returns an empty SDValue if the operation fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3979</td>
    <td class="codeLine">  /// Returns an empty SDValue if the operation fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="codeLine">  SDValue buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3980</td>
    <td class="codeLine">  SDValue buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="codeLine">                                  SDValue N1, MutableArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3981</td>
    <td class="codeLine">                                  SDValue N1, MutableArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="codeLine">                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3982</td>
    <td class="codeLine">                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="codeLine">  /// This method returns the constant pool value that will be loaded by LD.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3984</td>
    <td class="codeLine">  /// This method returns the constant pool value that will be loaded by LD.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="codeLine">  /// NOTE: You must check for implicit extensions of the constant by LD.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3985</td>
    <td class="codeLine">  /// NOTE: You must check for implicit extensions of the constant by LD.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="codeLine">  virtual const Constant *getTargetConstantFromLoad(LoadSDNode *LD) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3986</td>
    <td class="codeLine">  virtual const Constant *getTargetConstantFromLoad(LoadSDNode *LD) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="codeLine">  /// If \p SNaN is false, \returns true if \p Op is known to never be any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3988</td>
    <td class="codeLine">  /// If \p SNaN is false, \returns true if \p Op is known to never be any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="codeLine">  /// NaN. If \p sNaN is true, returns if \p Op is known to never be a signaling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3989</td>
    <td class="codeLine">  /// NaN. If \p sNaN is true, returns if \p Op is known to never be a signaling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="codeLine">  /// NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3990</td>
    <td class="codeLine">  /// NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="codeLine">  virtual bool isKnownNeverNaNForTargetNode(SDValue Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3991</td>
    <td class="codeLine">  virtual bool isKnownNeverNaNForTargetNode(SDValue Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="codeLine">                                            const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3992</td>
    <td class="codeLine">                                            const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="codeLine">                                            bool SNaN = false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3993</td>
    <td class="codeLine">                                            bool SNaN = false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="codeLine">                                            unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3994</td>
    <td class="codeLine">                                            unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="codeLine">  /// Return true if vector \p Op has the same value across all \p DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3996</td>
    <td class="codeLine">  /// Return true if vector \p Op has the same value across all \p DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="codeLine">  /// indicating any elements which may be undef in the output \p UndefElts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3997</td>
    <td class="codeLine">  /// indicating any elements which may be undef in the output \p UndefElts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="codeLine">  virtual bool isSplatValueForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3998</td>
    <td class="codeLine">  virtual bool isSplatValueForTargetNode(SDValue Op, const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="codeLine">                                         APInt &UndefElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3999</td>
    <td class="codeLine">                                         APInt &UndefElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="codeLine">                                         const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4000</td>
    <td class="codeLine">                                         const SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="codeLine">                                         unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4001</td>
    <td class="codeLine">                                         unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="codeLine">  /// Returns true if the given Opc is considered a canonical constant for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4003</td>
    <td class="codeLine">  /// Returns true if the given Opc is considered a canonical constant for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="codeLine">  /// target, which should not be transformed back into a BUILD_VECTOR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4004</td>
    <td class="codeLine">  /// target, which should not be transformed back into a BUILD_VECTOR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="codeLine coveredLine">  virtual bool isTargetCanonicalConstantNode(SDValue Op) const {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">4005</td>
    <td class="codeLine coveredLine">  virtual bool isTargetCanonicalConstantNode(SDValue Op) const {</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="codeLine coveredLine">    return Op.getOpcode() == ISD::SPLAT_VECTOR;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">4006</td>
    <td class="codeLine coveredLine">    return Op.getOpcode() == ISD::SPLAT_VECTOR;</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4007</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class="codeLine">  struct DAGCombinerInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4009</td>
    <td class="codeLine">  struct DAGCombinerInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="codeLine">    void *DC;  // The DAG Combiner object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4010</td>
    <td class="codeLine">    void *DC;  // The DAG Combiner object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="codeLine">    CombineLevel Level;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4011</td>
    <td class="codeLine">    CombineLevel Level;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="codeLine">    bool CalledByLegalizer;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4012</td>
    <td class="codeLine">    bool CalledByLegalizer;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4014</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="codeLine">    SelectionDAG &DAG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4015</td>
    <td class="codeLine">    SelectionDAG &DAG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="codeLine coveredLine">    DAGCombinerInfo(SelectionDAG &dag, CombineLevel level,  bool cl, void *dc)</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">4017</td>
    <td class="codeLine coveredLine">    DAGCombinerInfo(SelectionDAG &dag, CombineLevel level,  bool cl, void *dc)</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="codeLine coveredLine">      : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag) {}</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">4018</td>
    <td class="codeLine coveredLine">      : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag) {}</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class="codeLine">    bool isBeforeLegalize() const { return Level == BeforeLegalizeTypes; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4020</td>
    <td class="codeLine">    bool isBeforeLegalize() const { return Level == BeforeLegalizeTypes; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="codeLine coveredLine">    bool isBeforeLegalizeOps() const { return Level < AfterLegalizeVectorOps; }</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">4021</td>
    <td class="codeLine coveredLine">    bool isBeforeLegalizeOps() const { return Level < AfterLegalizeVectorOps; }</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="codeLine">    bool isAfterLegalizeDAG() const { return Level >= AfterLegalizeDAG; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4022</td>
    <td class="codeLine">    bool isAfterLegalizeDAG() const { return Level >= AfterLegalizeDAG; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="codeLine">    CombineLevel getDAGCombineLevel() { return Level; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4023</td>
    <td class="codeLine">    CombineLevel getDAGCombineLevel() { return Level; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="codeLine">    bool isCalledByLegalizer() const { return CalledByLegalizer; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4024</td>
    <td class="codeLine">    bool isCalledByLegalizer() const { return CalledByLegalizer; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="codeLine">    void AddToWorklist(SDNode *N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4026</td>
    <td class="codeLine">    void AddToWorklist(SDNode *N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="codeLine">    SDValue CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4027</td>
    <td class="codeLine">    SDValue CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="codeLine">    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4028</td>
    <td class="codeLine">    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="codeLine">    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4029</td>
    <td class="codeLine">    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="codeLine">    bool recursivelyDeleteUnusedNodes(SDNode *N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4031</td>
    <td class="codeLine">    bool recursivelyDeleteUnusedNodes(SDNode *N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="codeLine">    void CommitTargetLoweringOpt(const TargetLoweringOpt &TLO);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4033</td>
    <td class="codeLine">    void CommitTargetLoweringOpt(const TargetLoweringOpt &TLO);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4034</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="codeLine">  /// Return if the N is a constant or constant vector equal to the true value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4036</td>
    <td class="codeLine">  /// Return if the N is a constant or constant vector equal to the true value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="codeLine">  /// from getBooleanContents().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4037</td>
    <td class="codeLine">  /// from getBooleanContents().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="codeLine">  bool isConstTrueVal(SDValue N) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4038</td>
    <td class="codeLine">  bool isConstTrueVal(SDValue N) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="codeLine">  /// Return if the N is a constant or constant vector equal to the false value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4040</td>
    <td class="codeLine">  /// Return if the N is a constant or constant vector equal to the false value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="codeLine">  /// from getBooleanContents().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4041</td>
    <td class="codeLine">  /// from getBooleanContents().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="codeLine">  bool isConstFalseVal(SDValue N) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4042</td>
    <td class="codeLine">  bool isConstFalseVal(SDValue N) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="codeLine">  /// Return if \p N is a True value when extended to \p VT.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4044</td>
    <td class="codeLine">  /// Return if \p N is a True value when extended to \p VT.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="codeLine">  bool isExtendedTrueVal(const ConstantSDNode *N, EVT VT, bool SExt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4045</td>
    <td class="codeLine">  bool isExtendedTrueVal(const ConstantSDNode *N, EVT VT, bool SExt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="codeLine">  /// Try to simplify a setcc built with the specified operands and cc. If it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4047</td>
    <td class="codeLine">  /// Try to simplify a setcc built with the specified operands and cc. If it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="codeLine">  /// unable to simplify it, return a null SDValue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4048</td>
    <td class="codeLine">  /// unable to simplify it, return a null SDValue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="codeLine">  SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4049</td>
    <td class="codeLine">  SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="codeLine">                        bool foldBooleans, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4050</td>
    <td class="codeLine">                        bool foldBooleans, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="codeLine">                        const SDLoc &dl) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4051</td>
    <td class="codeLine">                        const SDLoc &dl) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="codeLine">  // For targets which wrap address, unwrap for analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4053</td>
    <td class="codeLine">  // For targets which wrap address, unwrap for analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="codeLine">  virtual SDValue unwrapAddress(SDValue N) const { return N; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4054</td>
    <td class="codeLine">  virtual SDValue unwrapAddress(SDValue N) const { return N; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="codeLine">  /// Returns true (and the GlobalValue and the offset) if the node is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4056</td>
    <td class="codeLine">  /// Returns true (and the GlobalValue and the offset) if the node is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="codeLine">  /// GlobalAddress + offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4057</td>
    <td class="codeLine">  /// GlobalAddress + offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4058</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="codeLine">  isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4059</td>
    <td class="codeLine">  isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4060</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="codeLine">  /// This method will be invoked for all target nodes and for any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4061</td>
    <td class="codeLine">  /// This method will be invoked for all target nodes and for any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="codeLine">  /// target-independent nodes that the target has registered with invoke it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4062</td>
    <td class="codeLine">  /// target-independent nodes that the target has registered with invoke it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="codeLine">  /// for.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4063</td>
    <td class="codeLine">  /// for.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4064</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="codeLine">  /// The semantics are as follows:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4065</td>
    <td class="codeLine">  /// The semantics are as follows:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="codeLine">  /// Return Value:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4066</td>
    <td class="codeLine">  /// Return Value:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="codeLine">  ///   SDValue.Val == 0   - No change was made</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4067</td>
    <td class="codeLine">  ///   SDValue.Val == 0   - No change was made</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="codeLine">  ///   SDValue.Val == N   - N was replaced, is dead, and is already handled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4068</td>
    <td class="codeLine">  ///   SDValue.Val == N   - N was replaced, is dead, and is already handled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="codeLine">  ///   otherwise          - N should be replaced by the returned Operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4069</td>
    <td class="codeLine">  ///   otherwise          - N should be replaced by the returned Operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4070</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="codeLine">  /// In addition, methods provided by DAGCombinerInfo may be used to perform</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4071</td>
    <td class="codeLine">  /// In addition, methods provided by DAGCombinerInfo may be used to perform</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="codeLine">  /// more complex transformations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4072</td>
    <td class="codeLine">  /// more complex transformations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4073</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="codeLine">  virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4074</td>
    <td class="codeLine">  virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="codeLine">  /// Return true if it is profitable to move this shift by a constant amount</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4076</td>
    <td class="codeLine">  /// Return true if it is profitable to move this shift by a constant amount</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="codeLine">  /// through its operand, adjusting any immediate operands as necessary to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4077</td>
    <td class="codeLine">  /// through its operand, adjusting any immediate operands as necessary to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="codeLine">  /// preserve semantics. This transformation may not be desirable if it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4078</td>
    <td class="codeLine">  /// preserve semantics. This transformation may not be desirable if it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="codeLine">  /// disrupts a particularly auspicious target-specific tree (e.g. bitfield</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4079</td>
    <td class="codeLine">  /// disrupts a particularly auspicious target-specific tree (e.g. bitfield</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="codeLine">  /// extraction in AArch64). By default, it returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4080</td>
    <td class="codeLine">  /// extraction in AArch64). By default, it returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4081</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="codeLine">  /// @param N the shift node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4082</td>
    <td class="codeLine">  /// @param N the shift node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="codeLine">  /// @param Level the current DAGCombine legalization level.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4083</td>
    <td class="codeLine">  /// @param Level the current DAGCombine legalization level.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="codeLine">  virtual bool isDesirableToCommuteWithShift(const SDNode *N,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4084</td>
    <td class="codeLine">  virtual bool isDesirableToCommuteWithShift(const SDNode *N,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="codeLine">                                             CombineLevel Level) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4085</td>
    <td class="codeLine">                                             CombineLevel Level) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4086</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="codeLine">  /// GlobalISel - return true if it is profitable to move this shift by a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4089</td>
    <td class="codeLine">  /// GlobalISel - return true if it is profitable to move this shift by a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="codeLine">  /// constant amount through its operand, adjusting any immediate operands as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4090</td>
    <td class="codeLine">  /// constant amount through its operand, adjusting any immediate operands as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="codeLine">  /// necessary to preserve semantics. This transformation may not be desirable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4091</td>
    <td class="codeLine">  /// necessary to preserve semantics. This transformation may not be desirable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="codeLine">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4092</td>
    <td class="codeLine">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="codeLine">  /// bitfield extraction in AArch64). By default, it returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4093</td>
    <td class="codeLine">  /// bitfield extraction in AArch64). By default, it returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4094</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="codeLine">  /// @param MI the shift instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4095</td>
    <td class="codeLine">  /// @param MI the shift instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="codeLine">  /// @param IsAfterLegal true if running after legalization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4096</td>
    <td class="codeLine">  /// @param IsAfterLegal true if running after legalization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="codeLine">  virtual bool isDesirableToCommuteWithShift(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4097</td>
    <td class="codeLine">  virtual bool isDesirableToCommuteWithShift(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="codeLine">                                             bool IsAfterLegal) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4098</td>
    <td class="codeLine">                                             bool IsAfterLegal) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4099</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="codeLine">  // Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4102</td>
    <td class="codeLine">  // Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class="codeLine">  // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4103</td>
    <td class="codeLine">  // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="codeLine">  // writing this) is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4104</td>
    <td class="codeLine">  // writing this) is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="codeLine">  //    With C as a power of 2 and C != 0 and C != INT_MIN:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4105</td>
    <td class="codeLine">  //    With C as a power of 2 and C != 0 and C != INT_MIN:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="codeLine">  //    AddAnd:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4106</td>
    <td class="codeLine">  //    AddAnd:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="codeLine">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4107</td>
    <td class="codeLine">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="codeLine">  //            -> (icmp eq and(add(A, C), ~(C + C)), 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4108</td>
    <td class="codeLine">  //            -> (icmp eq and(add(A, C), ~(C + C)), 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="codeLine">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4109</td>
    <td class="codeLine">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="codeLine">  //            -> (icmp ne and(add(A, C), ~(C + C)), 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4110</td>
    <td class="codeLine">  //            -> (icmp ne and(add(A, C), ~(C + C)), 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="codeLine">  //    ABS:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4111</td>
    <td class="codeLine">  //    ABS:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="codeLine">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4112</td>
    <td class="codeLine">  //     (icmp eq A, C) | (icmp eq A, -C)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="codeLine">  //            -> (icmp eq Abs(A), C)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4113</td>
    <td class="codeLine">  //            -> (icmp eq Abs(A), C)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="codeLine">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4114</td>
    <td class="codeLine">  //     (icmp ne A, C) & (icmp ne A, -C)w</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="codeLine">  //            -> (icmp ne Abs(A), C)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4115</td>
    <td class="codeLine">  //            -> (icmp ne Abs(A), C)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4116</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="codeLine">  // @param LogicOp the logic op</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4117</td>
    <td class="codeLine">  // @param LogicOp the logic op</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="codeLine">  // @param SETCC0 the first of the SETCC nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4118</td>
    <td class="codeLine">  // @param SETCC0 the first of the SETCC nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="codeLine">  // @param SETCC0 the second of the SETCC nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4119</td>
    <td class="codeLine">  // @param SETCC0 the second of the SETCC nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="codeLine">  virtual AndOrSETCCFoldKind isDesirableToCombineLogicOpOfSETCC(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4120</td>
    <td class="codeLine">  virtual AndOrSETCCFoldKind isDesirableToCombineLogicOpOfSETCC(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="codeLine">      const SDNode *LogicOp, const SDNode *SETCC0, const SDNode *SETCC1) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4121</td>
    <td class="codeLine">      const SDNode *LogicOp, const SDNode *SETCC0, const SDNode *SETCC1) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="codeLine">    return AndOrSETCCFoldKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4122</td>
    <td class="codeLine">    return AndOrSETCCFoldKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="codeLine">  /// Return true if it is profitable to combine an XOR of a logical shift</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4125</td>
    <td class="codeLine">  /// Return true if it is profitable to combine an XOR of a logical shift</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="codeLine">  /// to create a logical shift of NOT. This transformation may not be desirable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4126</td>
    <td class="codeLine">  /// to create a logical shift of NOT. This transformation may not be desirable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="codeLine">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4127</td>
    <td class="codeLine">  /// if it disrupts a particularly auspicious target-specific tree (e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="codeLine">  /// BIC on ARM/AArch64). By default, it returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4128</td>
    <td class="codeLine">  /// BIC on ARM/AArch64). By default, it returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="codeLine">  virtual bool isDesirableToCommuteXorWithShift(const SDNode *N) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4129</td>
    <td class="codeLine">  virtual bool isDesirableToCommuteXorWithShift(const SDNode *N) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4130</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4131</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="codeLine">  /// Return true if the target has native support for the specified value type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4133</td>
    <td class="codeLine">  /// Return true if the target has native support for the specified value type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="codeLine">  /// and it is 'desirable' to use the type for the given node type. e.g. On x86</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4134</td>
    <td class="codeLine">  /// and it is 'desirable' to use the type for the given node type. e.g. On x86</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="codeLine">  /// i16 is legal, but undesirable since i16 instruction encodings are longer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4135</td>
    <td class="codeLine">  /// i16 is legal, but undesirable since i16 instruction encodings are longer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="codeLine">  /// and some i16 instructions are slow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4136</td>
    <td class="codeLine">  /// and some i16 instructions are slow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="codeLine coveredLine">  virtual bool isTypeDesirableForOp(unsigned /*Opc*/, EVT VT) const {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">4137</td>
    <td class="codeLine coveredLine">  virtual bool isTypeDesirableForOp(unsigned /*Opc*/, EVT VT) const {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="codeLine">    // By default, assume all legal types are desirable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4138</td>
    <td class="codeLine">    // By default, assume all legal types are desirable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="codeLine coveredLine">    return isTypeLegal(VT);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">4139</td>
    <td class="codeLine coveredLine">    return isTypeLegal(VT);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="codeLine">  /// Return true if it is profitable for dag combiner to transform a floating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4142</td>
    <td class="codeLine">  /// Return true if it is profitable for dag combiner to transform a floating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="codeLine">  /// point op of specified opcode to a equivalent op of an integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4143</td>
    <td class="codeLine">  /// point op of specified opcode to a equivalent op of an integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="codeLine">  /// type. e.g. f32 load -> i32 load can be profitable on ARM.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4144</td>
    <td class="codeLine">  /// type. e.g. f32 load -> i32 load can be profitable on ARM.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="codeLine">  virtual bool isDesirableToTransformToIntegerOp(unsigned /*Opc*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4145</td>
    <td class="codeLine">  virtual bool isDesirableToTransformToIntegerOp(unsigned /*Opc*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="codeLine">                                                 EVT /*VT*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4146</td>
    <td class="codeLine">                                                 EVT /*VT*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4147</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="codeLine">  /// This method query the target whether it is beneficial for dag combiner to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4150</td>
    <td class="codeLine">  /// This method query the target whether it is beneficial for dag combiner to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="codeLine">  /// promote the specified node. If true, it should return the desired</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4151</td>
    <td class="codeLine">  /// promote the specified node. If true, it should return the desired</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="codeLine">  /// promotion type by reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4152</td>
    <td class="codeLine">  /// promotion type by reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="codeLine">  virtual bool IsDesirableToPromoteOp(SDValue /*Op*/, EVT &/*PVT*/) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4153</td>
    <td class="codeLine">  virtual bool IsDesirableToPromoteOp(SDValue /*Op*/, EVT &/*PVT*/) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4154</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="codeLine">  /// Return true if the target supports swifterror attribute. It optimizes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4157</td>
    <td class="codeLine">  /// Return true if the target supports swifterror attribute. It optimizes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="codeLine">  /// loads and stores to reading and writing a specific register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4158</td>
    <td class="codeLine">  /// loads and stores to reading and writing a specific register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="codeLine coveredLine">  virtual bool supportSwiftError() const {</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">4159</td>
    <td class="codeLine coveredLine">  virtual bool supportSwiftError() const {</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">4160</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="codeLine">  /// Return true if the target supports that a subset of CSRs for the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4163</td>
    <td class="codeLine">  /// Return true if the target supports that a subset of CSRs for the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="codeLine">  /// machine function is handled explicitly via copies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4164</td>
    <td class="codeLine">  /// machine function is handled explicitly via copies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="codeLine">  virtual bool supportSplitCSR(MachineFunction *MF) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4165</td>
    <td class="codeLine">  virtual bool supportSplitCSR(MachineFunction *MF) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4166</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="codeLine">  /// Return true if the target supports kcfi operand bundles.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4169</td>
    <td class="codeLine">  /// Return true if the target supports kcfi operand bundles.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="codeLine">  virtual bool supportKCFIBundles() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4170</td>
    <td class="codeLine">  virtual bool supportKCFIBundles() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="codeLine">  /// Perform necessary initialization to handle a subset of CSRs explicitly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4172</td>
    <td class="codeLine">  /// Perform necessary initialization to handle a subset of CSRs explicitly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="codeLine">  /// via copies. This function is called at the beginning of instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4173</td>
    <td class="codeLine">  /// via copies. This function is called at the beginning of instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="codeLine">  /// selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4174</td>
    <td class="codeLine">  /// selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="codeLine">  virtual void initializeSplitCSR(MachineBasicBlock *Entry) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4175</td>
    <td class="codeLine">  virtual void initializeSplitCSR(MachineBasicBlock *Entry) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4176</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="codeLine">  /// Insert explicit copies in entry and exit blocks. We copy a subset of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4179</td>
    <td class="codeLine">  /// Insert explicit copies in entry and exit blocks. We copy a subset of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="codeLine">  /// CSRs to virtual registers in the entry block, and copy them back to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4180</td>
    <td class="codeLine">  /// CSRs to virtual registers in the entry block, and copy them back to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="codeLine">  /// physical registers in the exit blocks. This function is called at the end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4181</td>
    <td class="codeLine">  /// physical registers in the exit blocks. This function is called at the end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="codeLine">  /// of instruction selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4182</td>
    <td class="codeLine">  /// of instruction selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="codeLine">  virtual void insertCopiesSplitCSR(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4183</td>
    <td class="codeLine">  virtual void insertCopiesSplitCSR(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="codeLine">      MachineBasicBlock *Entry,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4184</td>
    <td class="codeLine">      MachineBasicBlock *Entry,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="codeLine">      const SmallVectorImpl<MachineBasicBlock *> &Exits) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4185</td>
    <td class="codeLine">      const SmallVectorImpl<MachineBasicBlock *> &Exits) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4186</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="codeLine">  /// Return the newly negated expression if the cost is not expensive and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4189</td>
    <td class="codeLine">  /// Return the newly negated expression if the cost is not expensive and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="codeLine">  /// set the cost in \p Cost to indicate that if it is cheaper or neutral to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4190</td>
    <td class="codeLine">  /// set the cost in \p Cost to indicate that if it is cheaper or neutral to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="codeLine">  /// do the negation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4191</td>
    <td class="codeLine">  /// do the negation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="codeLine">  virtual SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4192</td>
    <td class="codeLine">  virtual SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="codeLine">                                       bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4193</td>
    <td class="codeLine">                                       bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="codeLine">                                       NegatibleCost &Cost,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4194</td>
    <td class="codeLine">                                       NegatibleCost &Cost,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="codeLine">                                       unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4195</td>
    <td class="codeLine">                                       unsigned Depth = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="codeLine">  SDValue getCheaperOrNeutralNegatedExpression(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4197</td>
    <td class="codeLine">  SDValue getCheaperOrNeutralNegatedExpression(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="codeLine">      SDValue Op, SelectionDAG &DAG, bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4198</td>
    <td class="codeLine">      SDValue Op, SelectionDAG &DAG, bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="codeLine">      const NegatibleCost CostThreshold = NegatibleCost::Neutral,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4199</td>
    <td class="codeLine">      const NegatibleCost CostThreshold = NegatibleCost::Neutral,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="codeLine">      unsigned Depth = 0) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4200</td>
    <td class="codeLine">      unsigned Depth = 0) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="codeLine">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4201</td>
    <td class="codeLine">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="codeLine">    SDValue Neg =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4202</td>
    <td class="codeLine">    SDValue Neg =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="codeLine">        getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4203</td>
    <td class="codeLine">        getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="codeLine">    if (!Neg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4204</td>
    <td class="codeLine">    if (!Neg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="codeLine">      return SDValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4205</td>
    <td class="codeLine">      return SDValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="codeLine">    if (Cost <= CostThreshold)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4207</td>
    <td class="codeLine">    if (Cost <= CostThreshold)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="codeLine">      return Neg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4208</td>
    <td class="codeLine">      return Neg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="codeLine">    // Remove the new created node to avoid the side effect to the DAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4210</td>
    <td class="codeLine">    // Remove the new created node to avoid the side effect to the DAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="codeLine">    if (Neg->use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4211</td>
    <td class="codeLine">    if (Neg->use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="codeLine">      DAG.RemoveDeadNode(Neg.getNode());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4212</td>
    <td class="codeLine">      DAG.RemoveDeadNode(Neg.getNode());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="codeLine">    return SDValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4213</td>
    <td class="codeLine">    return SDValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4214</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="codeLine">  /// This is the helper function to return the newly negated expression only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4216</td>
    <td class="codeLine">  /// This is the helper function to return the newly negated expression only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="codeLine">  /// when the cost is cheaper.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4217</td>
    <td class="codeLine">  /// when the cost is cheaper.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="codeLine">  SDValue getCheaperNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4218</td>
    <td class="codeLine">  SDValue getCheaperNegatedExpression(SDValue Op, SelectionDAG &DAG,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="codeLine">                                      bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4219</td>
    <td class="codeLine">                                      bool LegalOps, bool OptForSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="codeLine">                                      unsigned Depth = 0) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4220</td>
    <td class="codeLine">                                      unsigned Depth = 0) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="codeLine">    return getCheaperOrNeutralNegatedExpression(Op, DAG, LegalOps, OptForSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4221</td>
    <td class="codeLine">    return getCheaperOrNeutralNegatedExpression(Op, DAG, LegalOps, OptForSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="codeLine">                                                NegatibleCost::Cheaper, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4222</td>
    <td class="codeLine">                                                NegatibleCost::Cheaper, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="codeLine">  /// This is the helper function to return the newly negated expression if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4225</td>
    <td class="codeLine">  /// This is the helper function to return the newly negated expression if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="codeLine">  /// the cost is not expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4226</td>
    <td class="codeLine">  /// the cost is not expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="codeLine">  SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG, bool LegalOps,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4227</td>
    <td class="codeLine">  SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG, bool LegalOps,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="codeLine">                               bool OptForSize, unsigned Depth = 0) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4228</td>
    <td class="codeLine">                               bool OptForSize, unsigned Depth = 0) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="codeLine">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4229</td>
    <td class="codeLine">    NegatibleCost Cost = NegatibleCost::Expensive;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="codeLine">    return getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4230</td>
    <td class="codeLine">    return getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4231</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4233</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="codeLine">  // Lowering methods - These methods must be implemented by targets so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4234</td>
    <td class="codeLine">  // Lowering methods - These methods must be implemented by targets so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="codeLine">  // the SelectionDAGBuilder code knows how to lower these.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4235</td>
    <td class="codeLine">  // the SelectionDAGBuilder code knows how to lower these.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4236</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="codeLine">  /// Target-specific splitting of values into parts that fit a register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4238</td>
    <td class="codeLine">  /// Target-specific splitting of values into parts that fit a register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="codeLine">  /// storing a legal type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4239</td>
    <td class="codeLine">  /// storing a legal type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="codeLine coveredLine">  virtual bool splitValueIntoRegisterParts(</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">4240</td>
    <td class="codeLine coveredLine">  virtual bool splitValueIntoRegisterParts(</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="codeLine">      SelectionDAG & DAG, const SDLoc &DL, SDValue Val, SDValue *Parts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4241</td>
    <td class="codeLine">      SelectionDAG & DAG, const SDLoc &DL, SDValue Val, SDValue *Parts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="codeLine">      unsigned NumParts, MVT PartVT, std::optional<CallingConv::ID> CC) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4242</td>
    <td class="codeLine">      unsigned NumParts, MVT PartVT, std::optional<CallingConv::ID> CC) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">4243</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4244</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="codeLine">  /// Allows the target to handle physreg-carried dependency</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4246</td>
    <td class="codeLine">  /// Allows the target to handle physreg-carried dependency</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="codeLine">  /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4247</td>
    <td class="codeLine">  /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="codeLine">  /// to add the edge to the dependency graph.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4248</td>
    <td class="codeLine">  /// to add the edge to the dependency graph.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="codeLine">  /// Def - input: Selection DAG node defininfg physical register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4249</td>
    <td class="codeLine">  /// Def - input: Selection DAG node defininfg physical register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="codeLine">  /// User - input: Selection DAG node using physical register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4250</td>
    <td class="codeLine">  /// User - input: Selection DAG node using physical register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="codeLine">  /// Op - input: Number of User operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4251</td>
    <td class="codeLine">  /// Op - input: Number of User operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="codeLine">  /// PhysReg - inout: set to the physical register if the edge is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4252</td>
    <td class="codeLine">  /// PhysReg - inout: set to the physical register if the edge is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="codeLine">  /// necessary, unchanged otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4253</td>
    <td class="codeLine">  /// necessary, unchanged otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="codeLine">  /// Cost - inout: physical register copy cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4254</td>
    <td class="codeLine">  /// Cost - inout: physical register copy cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="codeLine">  /// Returns 'true' is the edge is necessary, 'false' otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4255</td>
    <td class="codeLine">  /// Returns 'true' is the edge is necessary, 'false' otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="codeLine coveredLine">  virtual bool checkForPhysRegDependency(SDNode *Def, SDNode *User, unsigned Op,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">4256</td>
    <td class="codeLine coveredLine">  virtual bool checkForPhysRegDependency(SDNode *Def, SDNode *User, unsigned Op,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="codeLine">                                         const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4257</td>
    <td class="codeLine">                                         const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="codeLine">                                         const TargetInstrInfo *TII,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4258</td>
    <td class="codeLine">                                         const TargetInstrInfo *TII,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="codeLine">                                         unsigned &PhysReg, int &Cost) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4259</td>
    <td class="codeLine">                                         unsigned &PhysReg, int &Cost) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">4260</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4261</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="codeLine">  /// Target-specific combining of register parts into its original value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4263</td>
    <td class="codeLine">  /// Target-specific combining of register parts into its original value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="codeLine">  virtual SDValue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4264</td>
    <td class="codeLine">  virtual SDValue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class="codeLine coveredLine">  joinRegisterPartsIntoValue(SelectionDAG &DAG, const SDLoc &DL,</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">4265</td>
    <td class="codeLine coveredLine">  joinRegisterPartsIntoValue(SelectionDAG &DAG, const SDLoc &DL,</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="codeLine">                             const SDValue *Parts, unsigned NumParts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4266</td>
    <td class="codeLine">                             const SDValue *Parts, unsigned NumParts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="codeLine">                             MVT PartVT, EVT ValueVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4267</td>
    <td class="codeLine">                             MVT PartVT, EVT ValueVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="codeLine">                             std::optional<CallingConv::ID> CC) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4268</td>
    <td class="codeLine">                             std::optional<CallingConv::ID> CC) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="codeLine coveredLine">    return SDValue();</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">4269</td>
    <td class="codeLine coveredLine">    return SDValue();</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4270</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="codeLine">  /// This hook must be implemented to lower the incoming (formal) arguments,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4272</td>
    <td class="codeLine">  /// This hook must be implemented to lower the incoming (formal) arguments,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="codeLine">  /// described by the Ins array, into the specified DAG. The implementation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4273</td>
    <td class="codeLine">  /// described by the Ins array, into the specified DAG. The implementation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="codeLine">  /// should fill in the InVals array with legal-type argument values, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4274</td>
    <td class="codeLine">  /// should fill in the InVals array with legal-type argument values, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="codeLine">  /// return the resulting token chain value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4275</td>
    <td class="codeLine">  /// return the resulting token chain value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="codeLine">  virtual SDValue LowerFormalArguments(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4276</td>
    <td class="codeLine">  virtual SDValue LowerFormalArguments(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="codeLine">      SDValue /*Chain*/, CallingConv::ID /*CallConv*/, bool /*isVarArg*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4277</td>
    <td class="codeLine">      SDValue /*Chain*/, CallingConv::ID /*CallConv*/, bool /*isVarArg*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="codeLine">      const SmallVectorImpl<ISD::InputArg> & /*Ins*/, const SDLoc & /*dl*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4278</td>
    <td class="codeLine">      const SmallVectorImpl<ISD::InputArg> & /*Ins*/, const SDLoc & /*dl*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="codeLine">      SelectionDAG & /*DAG*/, SmallVectorImpl<SDValue> & /*InVals*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4279</td>
    <td class="codeLine">      SelectionDAG & /*DAG*/, SmallVectorImpl<SDValue> & /*InVals*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4280</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4281</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="codeLine">  /// This structure contains all information that is necessary for lowering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4283</td>
    <td class="codeLine">  /// This structure contains all information that is necessary for lowering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="codeLine">  /// calls. It is passed to TLI::LowerCallTo when the SelectionDAG builder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4284</td>
    <td class="codeLine">  /// calls. It is passed to TLI::LowerCallTo when the SelectionDAG builder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class="codeLine">  /// needs to lower a call, and targets will see this struct in their LowerCall</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4285</td>
    <td class="codeLine">  /// needs to lower a call, and targets will see this struct in their LowerCall</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="codeLine">  /// implementation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4286</td>
    <td class="codeLine">  /// implementation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="codeLine">  struct CallLoweringInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4287</td>
    <td class="codeLine">  struct CallLoweringInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="codeLine">    SDValue Chain;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4288</td>
    <td class="codeLine">    SDValue Chain;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="codeLine">    Type *RetTy = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4289</td>
    <td class="codeLine">    Type *RetTy = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="codeLine">    bool RetSExt           : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4290</td>
    <td class="codeLine">    bool RetSExt           : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="codeLine">    bool RetZExt           : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4291</td>
    <td class="codeLine">    bool RetZExt           : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="codeLine">    bool IsVarArg          : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4292</td>
    <td class="codeLine">    bool IsVarArg          : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="codeLine">    bool IsInReg           : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4293</td>
    <td class="codeLine">    bool IsInReg           : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class="codeLine">    bool DoesNotReturn     : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4294</td>
    <td class="codeLine">    bool DoesNotReturn     : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="codeLine">    bool IsReturnValueUsed : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4295</td>
    <td class="codeLine">    bool IsReturnValueUsed : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="codeLine">    bool IsConvergent      : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4296</td>
    <td class="codeLine">    bool IsConvergent      : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="codeLine">    bool IsPatchPoint      : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4297</td>
    <td class="codeLine">    bool IsPatchPoint      : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="codeLine">    bool IsPreallocated : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4298</td>
    <td class="codeLine">    bool IsPreallocated : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="codeLine">    bool NoMerge           : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4299</td>
    <td class="codeLine">    bool NoMerge           : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="codeLine">    // IsTailCall should be modified by implementations of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4301</td>
    <td class="codeLine">    // IsTailCall should be modified by implementations of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="codeLine">    // TargetLowering::LowerCall that perform tail call conversions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4302</td>
    <td class="codeLine">    // TargetLowering::LowerCall that perform tail call conversions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="codeLine">    bool IsTailCall = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4303</td>
    <td class="codeLine">    bool IsTailCall = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="codeLine">    // Is Call lowering done post SelectionDAG type legalization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4305</td>
    <td class="codeLine">    // Is Call lowering done post SelectionDAG type legalization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="codeLine">    bool IsPostTypeLegalization = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4306</td>
    <td class="codeLine">    bool IsPostTypeLegalization = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="codeLine">    unsigned NumFixedArgs = -1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4308</td>
    <td class="codeLine">    unsigned NumFixedArgs = -1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="codeLine">    CallingConv::ID CallConv = CallingConv::C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4309</td>
    <td class="codeLine">    CallingConv::ID CallConv = CallingConv::C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="codeLine">    SDValue Callee;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4310</td>
    <td class="codeLine">    SDValue Callee;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="codeLine">    ArgListTy Args;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4311</td>
    <td class="codeLine">    ArgListTy Args;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="codeLine">    SelectionDAG &DAG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4312</td>
    <td class="codeLine">    SelectionDAG &DAG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="codeLine">    SDLoc DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4313</td>
    <td class="codeLine">    SDLoc DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="codeLine">    const CallBase *CB = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4314</td>
    <td class="codeLine">    const CallBase *CB = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="codeLine">    SmallVector<ISD::OutputArg, 32> Outs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4315</td>
    <td class="codeLine">    SmallVector<ISD::OutputArg, 32> Outs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="codeLine">    SmallVector<SDValue, 32> OutVals;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4316</td>
    <td class="codeLine">    SmallVector<SDValue, 32> OutVals;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class="codeLine">    SmallVector<ISD::InputArg, 32> Ins;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4317</td>
    <td class="codeLine">    SmallVector<ISD::InputArg, 32> Ins;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="codeLine">    SmallVector<SDValue, 4> InVals;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4318</td>
    <td class="codeLine">    SmallVector<SDValue, 4> InVals;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="codeLine">    const ConstantInt *CFIType = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4319</td>
    <td class="codeLine">    const ConstantInt *CFIType = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="codeLine">    CallLoweringInfo(SelectionDAG &DAG)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4321</td>
    <td class="codeLine">    CallLoweringInfo(SelectionDAG &DAG)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="codeLine">        : RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4322</td>
    <td class="codeLine">        : RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="codeLine">          DoesNotReturn(false), IsReturnValueUsed(true), IsConvergent(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4323</td>
    <td class="codeLine">          DoesNotReturn(false), IsReturnValueUsed(true), IsConvergent(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="codeLine">          IsPatchPoint(false), IsPreallocated(false), NoMerge(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4324</td>
    <td class="codeLine">          IsPatchPoint(false), IsPreallocated(false), NoMerge(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="codeLine">          DAG(DAG) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4325</td>
    <td class="codeLine">          DAG(DAG) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="codeLine">    CallLoweringInfo &setDebugLoc(const SDLoc &dl) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4327</td>
    <td class="codeLine">    CallLoweringInfo &setDebugLoc(const SDLoc &dl) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="codeLine">      DL = dl;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4328</td>
    <td class="codeLine">      DL = dl;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4329</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4330</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="codeLine">    CallLoweringInfo &setChain(SDValue InChain) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4332</td>
    <td class="codeLine">    CallLoweringInfo &setChain(SDValue InChain) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="codeLine">      Chain = InChain;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4333</td>
    <td class="codeLine">      Chain = InChain;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4334</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4335</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="codeLine">    // setCallee with target/module-specific attributes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4337</td>
    <td class="codeLine">    // setCallee with target/module-specific attributes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="codeLine">    CallLoweringInfo &setLibCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4338</td>
    <td class="codeLine">    CallLoweringInfo &setLibCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="codeLine">                                   SDValue Target, ArgListTy &&ArgsList) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4339</td>
    <td class="codeLine">                                   SDValue Target, ArgListTy &&ArgsList) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="codeLine">      RetTy = ResultType;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4340</td>
    <td class="codeLine">      RetTy = ResultType;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="codeLine">      Callee = Target;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4341</td>
    <td class="codeLine">      Callee = Target;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="codeLine">      CallConv = CC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4342</td>
    <td class="codeLine">      CallConv = CC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="codeLine">      NumFixedArgs = ArgsList.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4343</td>
    <td class="codeLine">      NumFixedArgs = ArgsList.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="codeLine">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4344</td>
    <td class="codeLine">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="codeLine">      DAG.getTargetLoweringInfo().markLibCallAttributes(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4346</td>
    <td class="codeLine">      DAG.getTargetLoweringInfo().markLibCallAttributes(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="codeLine">          &(DAG.getMachineFunction()), CC, Args);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4347</td>
    <td class="codeLine">          &(DAG.getMachineFunction()), CC, Args);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4348</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4349</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="codeLine">    CallLoweringInfo &setCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4351</td>
    <td class="codeLine">    CallLoweringInfo &setCallee(CallingConv::ID CC, Type *ResultType,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="codeLine">                                SDValue Target, ArgListTy &&ArgsList) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4352</td>
    <td class="codeLine">                                SDValue Target, ArgListTy &&ArgsList) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="codeLine">      RetTy = ResultType;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4353</td>
    <td class="codeLine">      RetTy = ResultType;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="codeLine">      Callee = Target;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4354</td>
    <td class="codeLine">      Callee = Target;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="codeLine">      CallConv = CC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4355</td>
    <td class="codeLine">      CallConv = CC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="codeLine">      NumFixedArgs = ArgsList.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4356</td>
    <td class="codeLine">      NumFixedArgs = ArgsList.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="codeLine">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4357</td>
    <td class="codeLine">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4358</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4359</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="codeLine">    CallLoweringInfo &setCallee(Type *ResultType, FunctionType *FTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4361</td>
    <td class="codeLine">    CallLoweringInfo &setCallee(Type *ResultType, FunctionType *FTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="codeLine">                                SDValue Target, ArgListTy &&ArgsList,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4362</td>
    <td class="codeLine">                                SDValue Target, ArgListTy &&ArgsList,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="codeLine">                                const CallBase &Call) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4363</td>
    <td class="codeLine">                                const CallBase &Call) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="codeLine">      RetTy = ResultType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4364</td>
    <td class="codeLine">      RetTy = ResultType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="codeLine">      IsInReg = Call.hasRetAttr(Attribute::InReg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4366</td>
    <td class="codeLine">      IsInReg = Call.hasRetAttr(Attribute::InReg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="codeLine">      DoesNotReturn =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4367</td>
    <td class="codeLine">      DoesNotReturn =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="codeLine">          Call.doesNotReturn() ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4368</td>
    <td class="codeLine">          Call.doesNotReturn() ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="codeLine">          (!isa<InvokeInst>(Call) && isa<UnreachableInst>(Call.getNextNode()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4369</td>
    <td class="codeLine">          (!isa<InvokeInst>(Call) && isa<UnreachableInst>(Call.getNextNode()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="codeLine">      IsVarArg = FTy->isVarArg();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4370</td>
    <td class="codeLine">      IsVarArg = FTy->isVarArg();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="codeLine">      IsReturnValueUsed = !Call.use_empty();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4371</td>
    <td class="codeLine">      IsReturnValueUsed = !Call.use_empty();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="codeLine">      RetSExt = Call.hasRetAttr(Attribute::SExt);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4372</td>
    <td class="codeLine">      RetSExt = Call.hasRetAttr(Attribute::SExt);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="codeLine">      RetZExt = Call.hasRetAttr(Attribute::ZExt);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4373</td>
    <td class="codeLine">      RetZExt = Call.hasRetAttr(Attribute::ZExt);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="codeLine">      NoMerge = Call.hasFnAttr(Attribute::NoMerge);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4374</td>
    <td class="codeLine">      NoMerge = Call.hasFnAttr(Attribute::NoMerge);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="codeLine">      Callee = Target;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4376</td>
    <td class="codeLine">      Callee = Target;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="codeLine">      CallConv = Call.getCallingConv();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4378</td>
    <td class="codeLine">      CallConv = Call.getCallingConv();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="codeLine">      NumFixedArgs = FTy->getNumParams();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4379</td>
    <td class="codeLine">      NumFixedArgs = FTy->getNumParams();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="codeLine">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4380</td>
    <td class="codeLine">      Args = std::move(ArgsList);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="codeLine">      CB = &Call;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4382</td>
    <td class="codeLine">      CB = &Call;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4384</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4385</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="codeLine">    CallLoweringInfo &setInRegister(bool Value = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4387</td>
    <td class="codeLine">    CallLoweringInfo &setInRegister(bool Value = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="codeLine">      IsInReg = Value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4388</td>
    <td class="codeLine">      IsInReg = Value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4389</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4390</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="codeLine">    CallLoweringInfo &setNoReturn(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4392</td>
    <td class="codeLine">    CallLoweringInfo &setNoReturn(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="codeLine">      DoesNotReturn = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4393</td>
    <td class="codeLine">      DoesNotReturn = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4394</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4395</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="codeLine">    CallLoweringInfo &setVarArg(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4397</td>
    <td class="codeLine">    CallLoweringInfo &setVarArg(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="codeLine">      IsVarArg = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4398</td>
    <td class="codeLine">      IsVarArg = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4399</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4400</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="codeLine">    CallLoweringInfo &setTailCall(bool Value = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4402</td>
    <td class="codeLine">    CallLoweringInfo &setTailCall(bool Value = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="codeLine">      IsTailCall = Value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4403</td>
    <td class="codeLine">      IsTailCall = Value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4404</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4405</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="codeLine">    CallLoweringInfo &setDiscardResult(bool Value = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4407</td>
    <td class="codeLine">    CallLoweringInfo &setDiscardResult(bool Value = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="codeLine">      IsReturnValueUsed = !Value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4408</td>
    <td class="codeLine">      IsReturnValueUsed = !Value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4409</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4410</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="codeLine">    CallLoweringInfo &setConvergent(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4412</td>
    <td class="codeLine">    CallLoweringInfo &setConvergent(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="codeLine">      IsConvergent = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4413</td>
    <td class="codeLine">      IsConvergent = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4414</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4415</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="codeLine">    CallLoweringInfo &setSExtResult(bool Value = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4417</td>
    <td class="codeLine">    CallLoweringInfo &setSExtResult(bool Value = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="codeLine">      RetSExt = Value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4418</td>
    <td class="codeLine">      RetSExt = Value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4419</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4420</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="codeLine">    CallLoweringInfo &setZExtResult(bool Value = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4422</td>
    <td class="codeLine">    CallLoweringInfo &setZExtResult(bool Value = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="codeLine">      RetZExt = Value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4423</td>
    <td class="codeLine">      RetZExt = Value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4424</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4425</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="codeLine">    CallLoweringInfo &setIsPatchPoint(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4427</td>
    <td class="codeLine">    CallLoweringInfo &setIsPatchPoint(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="codeLine">      IsPatchPoint = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4428</td>
    <td class="codeLine">      IsPatchPoint = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4429</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4430</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="codeLine">    CallLoweringInfo &setIsPreallocated(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4432</td>
    <td class="codeLine">    CallLoweringInfo &setIsPreallocated(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="codeLine">      IsPreallocated = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4433</td>
    <td class="codeLine">      IsPreallocated = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4434</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4435</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="codeLine">    CallLoweringInfo &setIsPostTypeLegalization(bool Value=true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4437</td>
    <td class="codeLine">    CallLoweringInfo &setIsPostTypeLegalization(bool Value=true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="codeLine">      IsPostTypeLegalization = Value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4438</td>
    <td class="codeLine">      IsPostTypeLegalization = Value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4439</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4440</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="codeLine">    CallLoweringInfo &setCFIType(const ConstantInt *Type) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4442</td>
    <td class="codeLine">    CallLoweringInfo &setCFIType(const ConstantInt *Type) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="codeLine">      CFIType = Type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4443</td>
    <td class="codeLine">      CFIType = Type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4444</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4445</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="codeLine">    ArgListTy &getArgs() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4447</td>
    <td class="codeLine">    ArgListTy &getArgs() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="codeLine">      return Args;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4448</td>
    <td class="codeLine">      return Args;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4449</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4450</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="codeLine">  /// This structure is used to pass arguments to makeLibCall function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4452</td>
    <td class="codeLine">  /// This structure is used to pass arguments to makeLibCall function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="codeLine">  struct MakeLibCallOptions {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4453</td>
    <td class="codeLine">  struct MakeLibCallOptions {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="codeLine">    // By passing type list before soften to makeLibCall, the target hook</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4454</td>
    <td class="codeLine">    // By passing type list before soften to makeLibCall, the target hook</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="codeLine">    // shouldExtendTypeInLibCall can get the original type before soften.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4455</td>
    <td class="codeLine">    // shouldExtendTypeInLibCall can get the original type before soften.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="codeLine">    ArrayRef<EVT> OpsVTBeforeSoften;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4456</td>
    <td class="codeLine">    ArrayRef<EVT> OpsVTBeforeSoften;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="codeLine">    EVT RetVTBeforeSoften;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4457</td>
    <td class="codeLine">    EVT RetVTBeforeSoften;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="codeLine">    bool IsSExt : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4458</td>
    <td class="codeLine">    bool IsSExt : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="codeLine">    bool DoesNotReturn : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4459</td>
    <td class="codeLine">    bool DoesNotReturn : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="codeLine">    bool IsReturnValueUsed : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4460</td>
    <td class="codeLine">    bool IsReturnValueUsed : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="codeLine">    bool IsPostTypeLegalization : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4461</td>
    <td class="codeLine">    bool IsPostTypeLegalization : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="codeLine">    bool IsSoften : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4462</td>
    <td class="codeLine">    bool IsSoften : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="codeLine">    MakeLibCallOptions()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4464</td>
    <td class="codeLine">    MakeLibCallOptions()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="codeLine">        : IsSExt(false), DoesNotReturn(false), IsReturnValueUsed(true),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4465</td>
    <td class="codeLine">        : IsSExt(false), DoesNotReturn(false), IsReturnValueUsed(true),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="codeLine">          IsPostTypeLegalization(false), IsSoften(false) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4466</td>
    <td class="codeLine">          IsPostTypeLegalization(false), IsSoften(false) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="codeLine">    MakeLibCallOptions &setSExt(bool Value = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4468</td>
    <td class="codeLine">    MakeLibCallOptions &setSExt(bool Value = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="codeLine">      IsSExt = Value;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4469</td>
    <td class="codeLine">      IsSExt = Value;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4470</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4471</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="codeLine">    MakeLibCallOptions &setNoReturn(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4473</td>
    <td class="codeLine">    MakeLibCallOptions &setNoReturn(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="codeLine">      DoesNotReturn = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4474</td>
    <td class="codeLine">      DoesNotReturn = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4475</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4476</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="codeLine">    MakeLibCallOptions &setDiscardResult(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4478</td>
    <td class="codeLine">    MakeLibCallOptions &setDiscardResult(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="codeLine">      IsReturnValueUsed = !Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4479</td>
    <td class="codeLine">      IsReturnValueUsed = !Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4480</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4481</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="codeLine">    MakeLibCallOptions &setIsPostTypeLegalization(bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4483</td>
    <td class="codeLine">    MakeLibCallOptions &setIsPostTypeLegalization(bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="codeLine">      IsPostTypeLegalization = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4484</td>
    <td class="codeLine">      IsPostTypeLegalization = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4485</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4486</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="codeLine">    MakeLibCallOptions &setTypeListBeforeSoften(ArrayRef<EVT> OpsVT, EVT RetVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4488</td>
    <td class="codeLine">    MakeLibCallOptions &setTypeListBeforeSoften(ArrayRef<EVT> OpsVT, EVT RetVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="codeLine">                                                bool Value = true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4489</td>
    <td class="codeLine">                                                bool Value = true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="codeLine">      OpsVTBeforeSoften = OpsVT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4490</td>
    <td class="codeLine">      OpsVTBeforeSoften = OpsVT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="codeLine">      RetVTBeforeSoften = RetVT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4491</td>
    <td class="codeLine">      RetVTBeforeSoften = RetVT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="codeLine">      IsSoften = Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4492</td>
    <td class="codeLine">      IsSoften = Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4493</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4494</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4495</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="codeLine">  /// This function lowers an abstract call to a function into an actual call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4497</td>
    <td class="codeLine">  /// This function lowers an abstract call to a function into an actual call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="codeLine">  /// This returns a pair of operands.  The first element is the return value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4498</td>
    <td class="codeLine">  /// This returns a pair of operands.  The first element is the return value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="codeLine">  /// for the function (if RetTy is not VoidTy).  The second element is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4499</td>
    <td class="codeLine">  /// for the function (if RetTy is not VoidTy).  The second element is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="codeLine">  /// outgoing token chain. It calls LowerCall to do the actual lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4500</td>
    <td class="codeLine">  /// outgoing token chain. It calls LowerCall to do the actual lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> LowerCallTo(CallLoweringInfo &CLI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4501</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> LowerCallTo(CallLoweringInfo &CLI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="codeLine">  /// This hook must be implemented to lower calls into the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4503</td>
    <td class="codeLine">  /// This hook must be implemented to lower calls into the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="codeLine">  /// DAG. The outgoing arguments to the call are described by the Outs array,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4504</td>
    <td class="codeLine">  /// DAG. The outgoing arguments to the call are described by the Outs array,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="codeLine">  /// and the values to be returned by the call are described by the Ins</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4505</td>
    <td class="codeLine">  /// and the values to be returned by the call are described by the Ins</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="codeLine">  /// array. The implementation should fill in the InVals array with legal-type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4506</td>
    <td class="codeLine">  /// array. The implementation should fill in the InVals array with legal-type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="codeLine">  /// return values from the call, and return the resulting token chain value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4507</td>
    <td class="codeLine">  /// return values from the call, and return the resulting token chain value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="codeLine">  virtual SDValue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4508</td>
    <td class="codeLine">  virtual SDValue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="codeLine">    LowerCall(CallLoweringInfo &/*CLI*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4509</td>
    <td class="codeLine">    LowerCall(CallLoweringInfo &/*CLI*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="codeLine">              SmallVectorImpl<SDValue> &/*InVals*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4510</td>
    <td class="codeLine">              SmallVectorImpl<SDValue> &/*InVals*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4511</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4512</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="codeLine">  /// Target-specific cleanup for formal ByVal parameters.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4514</td>
    <td class="codeLine">  /// Target-specific cleanup for formal ByVal parameters.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="codeLine">  virtual void HandleByVal(CCState *, unsigned &, Align) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4515</td>
    <td class="codeLine">  virtual void HandleByVal(CCState *, unsigned &, Align) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="codeLine">  /// This hook should be implemented to check whether the return values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4517</td>
    <td class="codeLine">  /// This hook should be implemented to check whether the return values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="codeLine">  /// described by the Outs array can fit into the return registers.  If false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4518</td>
    <td class="codeLine">  /// described by the Outs array can fit into the return registers.  If false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="codeLine">  /// is returned, an sret-demotion is performed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4519</td>
    <td class="codeLine">  /// is returned, an sret-demotion is performed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="codeLine">  virtual bool CanLowerReturn(CallingConv::ID /*CallConv*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4520</td>
    <td class="codeLine">  virtual bool CanLowerReturn(CallingConv::ID /*CallConv*/,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="codeLine">                              MachineFunction &/*MF*/, bool /*isVarArg*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4521</td>
    <td class="codeLine">                              MachineFunction &/*MF*/, bool /*isVarArg*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="codeLine">               const SmallVectorImpl<ISD::OutputArg> &/*Outs*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4522</td>
    <td class="codeLine">               const SmallVectorImpl<ISD::OutputArg> &/*Outs*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="codeLine">               LLVMContext &/*Context*/) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4523</td>
    <td class="codeLine">               LLVMContext &/*Context*/) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4524</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="codeLine">    // Return true by default to get preexisting behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4525</td>
    <td class="codeLine">    // Return true by default to get preexisting behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4526</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="codeLine">  /// This hook must be implemented to lower outgoing return values, described</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4529</td>
    <td class="codeLine">  /// This hook must be implemented to lower outgoing return values, described</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="codeLine">  /// by the Outs array, into the specified DAG. The implementation should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4530</td>
    <td class="codeLine">  /// by the Outs array, into the specified DAG. The implementation should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="codeLine">  /// return the resulting token chain value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4531</td>
    <td class="codeLine">  /// return the resulting token chain value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="codeLine">  virtual SDValue LowerReturn(SDValue /*Chain*/, CallingConv::ID /*CallConv*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4532</td>
    <td class="codeLine">  virtual SDValue LowerReturn(SDValue /*Chain*/, CallingConv::ID /*CallConv*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="codeLine">                              bool /*isVarArg*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4533</td>
    <td class="codeLine">                              bool /*isVarArg*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="codeLine">                              const SmallVectorImpl<ISD::OutputArg> & /*Outs*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4534</td>
    <td class="codeLine">                              const SmallVectorImpl<ISD::OutputArg> & /*Outs*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="codeLine">                              const SmallVectorImpl<SDValue> & /*OutVals*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4535</td>
    <td class="codeLine">                              const SmallVectorImpl<SDValue> & /*OutVals*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="codeLine">                              const SDLoc & /*dl*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4536</td>
    <td class="codeLine">                              const SDLoc & /*dl*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="codeLine">                              SelectionDAG & /*DAG*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4537</td>
    <td class="codeLine">                              SelectionDAG & /*DAG*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4538</td>
    <td class="codeLine">    llvm_unreachable("Not Implemented");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="codeLine">  /// Return true if result of the specified node is used by a return node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4541</td>
    <td class="codeLine">  /// Return true if result of the specified node is used by a return node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="codeLine">  /// only. It also compute and return the input chain for the tail call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4542</td>
    <td class="codeLine">  /// only. It also compute and return the input chain for the tail call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4543</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="codeLine">  /// This is used to determine whether it is possible to codegen a libcall as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4544</td>
    <td class="codeLine">  /// This is used to determine whether it is possible to codegen a libcall as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="codeLine">  /// tail call at legalization time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4545</td>
    <td class="codeLine">  /// tail call at legalization time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="codeLine">  virtual bool isUsedByReturnOnly(SDNode *, SDValue &/*Chain*/) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4546</td>
    <td class="codeLine">  virtual bool isUsedByReturnOnly(SDNode *, SDValue &/*Chain*/) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4547</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="codeLine">  /// Return true if the target may be able emit the call instruction as a tail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4550</td>
    <td class="codeLine">  /// Return true if the target may be able emit the call instruction as a tail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="codeLine">  /// call. This is used by optimization passes to determine if it's profitable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4551</td>
    <td class="codeLine">  /// call. This is used by optimization passes to determine if it's profitable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="codeLine">  /// to duplicate return instructions to enable tailcall optimization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4552</td>
    <td class="codeLine">  /// to duplicate return instructions to enable tailcall optimization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="codeLine">  virtual bool mayBeEmittedAsTailCall(const CallInst *) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4553</td>
    <td class="codeLine">  virtual bool mayBeEmittedAsTailCall(const CallInst *) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4554</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4555</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="codeLine">  /// Return the builtin name for the __builtin___clear_cache intrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4557</td>
    <td class="codeLine">  /// Return the builtin name for the __builtin___clear_cache intrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="codeLine">  /// Default is to invoke the clear cache library call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4558</td>
    <td class="codeLine">  /// Default is to invoke the clear cache library call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="codeLine">  virtual const char * getClearCacheBuiltinName() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4559</td>
    <td class="codeLine">  virtual const char * getClearCacheBuiltinName() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="codeLine">    return "__clear_cache";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4560</td>
    <td class="codeLine">    return "__clear_cache";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="codeLine">  /// Return the register ID of the name passed in. Used by named register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4563</td>
    <td class="codeLine">  /// Return the register ID of the name passed in. Used by named register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="codeLine">  /// global variables extension. There is no target-independent behaviour</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4564</td>
    <td class="codeLine">  /// global variables extension. There is no target-independent behaviour</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="codeLine">  /// so the default action is to bail.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4565</td>
    <td class="codeLine">  /// so the default action is to bail.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="codeLine">  virtual Register getRegisterByName(const char* RegName, LLT Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4566</td>
    <td class="codeLine">  virtual Register getRegisterByName(const char* RegName, LLT Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="codeLine">                                     const MachineFunction &MF) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4567</td>
    <td class="codeLine">                                     const MachineFunction &MF) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="codeLine">    report_fatal_error("Named registers not implemented for this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4568</td>
    <td class="codeLine">    report_fatal_error("Named registers not implemented for this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4569</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="codeLine">  /// Return the type that should be used to zero or sign extend a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4571</td>
    <td class="codeLine">  /// Return the type that should be used to zero or sign extend a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="codeLine">  /// zeroext/signext integer return value.  FIXME: Some C calling conventions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4572</td>
    <td class="codeLine">  /// zeroext/signext integer return value.  FIXME: Some C calling conventions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="codeLine">  /// require the return type to be promoted, but this is not true all the time,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4573</td>
    <td class="codeLine">  /// require the return type to be promoted, but this is not true all the time,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="codeLine">  /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4574</td>
    <td class="codeLine">  /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="codeLine">  /// conventions. The frontend should handle this and include all of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4575</td>
    <td class="codeLine">  /// conventions. The frontend should handle this and include all of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="codeLine">  /// necessary information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4576</td>
    <td class="codeLine">  /// necessary information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="codeLine">  virtual EVT getTypeForExtReturn(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4577</td>
    <td class="codeLine">  virtual EVT getTypeForExtReturn(LLVMContext &Context, EVT VT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="codeLine">                                       ISD::NodeType /*ExtendKind*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4578</td>
    <td class="codeLine">                                       ISD::NodeType /*ExtendKind*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="codeLine">    EVT MinVT = getRegisterType(MVT::i32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4579</td>
    <td class="codeLine">    EVT MinVT = getRegisterType(MVT::i32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="codeLine">    return VT.bitsLT(MinVT) ? MinVT : VT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4580</td>
    <td class="codeLine">    return VT.bitsLT(MinVT) ? MinVT : VT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4581</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="codeLine">  /// For some targets, an LLVM struct type must be broken down into multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4583</td>
    <td class="codeLine">  /// For some targets, an LLVM struct type must be broken down into multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="codeLine">  /// simple types, but the calling convention specifies that the entire struct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4584</td>
    <td class="codeLine">  /// simple types, but the calling convention specifies that the entire struct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="codeLine">  /// must be passed in a block of consecutive registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4585</td>
    <td class="codeLine">  /// must be passed in a block of consecutive registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4586</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="codeLine coveredLine">  functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv,</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">4587</td>
    <td class="codeLine coveredLine">  functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv,</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="codeLine">                                            bool isVarArg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4588</td>
    <td class="codeLine">                                            bool isVarArg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="codeLine">                                            const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4589</td>
    <td class="codeLine">                                            const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">4590</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4591</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="codeLine">  /// For most targets, an LLVM type must be broken down into multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4593</td>
    <td class="codeLine">  /// For most targets, an LLVM type must be broken down into multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="codeLine">  /// smaller types. Usually the halves are ordered according to the endianness</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4594</td>
    <td class="codeLine">  /// smaller types. Usually the halves are ordered according to the endianness</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="codeLine">  /// but for some platform that would break. So this method will default to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4595</td>
    <td class="codeLine">  /// but for some platform that would break. So this method will default to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="codeLine">  /// matching the endianness but can be overridden.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4596</td>
    <td class="codeLine">  /// matching the endianness but can be overridden.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4597</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="codeLine">  shouldSplitFunctionArgumentsAsLittleEndian(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4598</td>
    <td class="codeLine">  shouldSplitFunctionArgumentsAsLittleEndian(const DataLayout &DL) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="codeLine">    return DL.isLittleEndian();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4599</td>
    <td class="codeLine">    return DL.isLittleEndian();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4600</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="codeLine">  /// Returns a 0 terminated array of registers that can be safely used as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4602</td>
    <td class="codeLine">  /// Returns a 0 terminated array of registers that can be safely used as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="codeLine">  /// scratch registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4603</td>
    <td class="codeLine">  /// scratch registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="codeLine">  virtual const MCPhysReg *getScratchRegisters(CallingConv::ID CC) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4604</td>
    <td class="codeLine">  virtual const MCPhysReg *getScratchRegisters(CallingConv::ID CC) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4605</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="codeLine">  /// Returns a 0 terminated array of rounding control registers that can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4608</td>
    <td class="codeLine">  /// Returns a 0 terminated array of rounding control registers that can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="codeLine">  /// attached into strict FP call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4609</td>
    <td class="codeLine">  /// attached into strict FP call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="codeLine">  virtual ArrayRef<MCPhysReg> getRoundingControlRegisters() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4610</td>
    <td class="codeLine">  virtual ArrayRef<MCPhysReg> getRoundingControlRegisters() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="codeLine">    return ArrayRef<MCPhysReg>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4611</td>
    <td class="codeLine">    return ArrayRef<MCPhysReg>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4612</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="codeLine">  /// This callback is used to prepare for a volatile or atomic load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4614</td>
    <td class="codeLine">  /// This callback is used to prepare for a volatile or atomic load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="codeLine">  /// It takes a chain node as input and returns the chain for the load itself.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4615</td>
    <td class="codeLine">  /// It takes a chain node as input and returns the chain for the load itself.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4616</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="codeLine">  /// Having a callback like this is necessary for targets like SystemZ,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4617</td>
    <td class="codeLine">  /// Having a callback like this is necessary for targets like SystemZ,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="codeLine">  /// which allows a CPU to reuse the result of a previous load indefinitely,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4618</td>
    <td class="codeLine">  /// which allows a CPU to reuse the result of a previous load indefinitely,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="codeLine">  /// even if a cache-coherent store is performed by another CPU.  The default</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4619</td>
    <td class="codeLine">  /// even if a cache-coherent store is performed by another CPU.  The default</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="codeLine">  /// implementation does nothing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4620</td>
    <td class="codeLine">  /// implementation does nothing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="codeLine">  virtual SDValue prepareVolatileOrAtomicLoad(SDValue Chain, const SDLoc &DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4621</td>
    <td class="codeLine">  virtual SDValue prepareVolatileOrAtomicLoad(SDValue Chain, const SDLoc &DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4622</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="codeLine">    return Chain;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4623</td>
    <td class="codeLine">    return Chain;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="codeLine">  /// Should SelectionDAG lower an atomic store of the given kind as a normal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4626</td>
    <td class="codeLine">  /// Should SelectionDAG lower an atomic store of the given kind as a normal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="codeLine">  /// StoreSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4627</td>
    <td class="codeLine">  /// StoreSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="codeLine">  /// eventually migrate all targets to the using StoreSDNodes, but porting is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4628</td>
    <td class="codeLine">  /// eventually migrate all targets to the using StoreSDNodes, but porting is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="codeLine">  /// being done target at a time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4629</td>
    <td class="codeLine">  /// being done target at a time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="codeLine">  virtual bool lowerAtomicStoreAsStoreSDNode(const StoreInst &SI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4630</td>
    <td class="codeLine">  virtual bool lowerAtomicStoreAsStoreSDNode(const StoreInst &SI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="codeLine">    assert(SI.isAtomic() && "violated precondition");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4631</td>
    <td class="codeLine">    assert(SI.isAtomic() && "violated precondition");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4632</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="codeLine">  /// Should SelectionDAG lower an atomic load of the given kind as a normal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4635</td>
    <td class="codeLine">  /// Should SelectionDAG lower an atomic load of the given kind as a normal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="codeLine">  /// LoadSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4636</td>
    <td class="codeLine">  /// LoadSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="codeLine">  /// eventually migrate all targets to the using LoadSDNodes, but porting is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4637</td>
    <td class="codeLine">  /// eventually migrate all targets to the using LoadSDNodes, but porting is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="codeLine">  /// being done target at a time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4638</td>
    <td class="codeLine">  /// being done target at a time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="codeLine">  virtual bool lowerAtomicLoadAsLoadSDNode(const LoadInst &LI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4639</td>
    <td class="codeLine">  virtual bool lowerAtomicLoadAsLoadSDNode(const LoadInst &LI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="codeLine">    assert(LI.isAtomic() && "violated precondition");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4640</td>
    <td class="codeLine">    assert(LI.isAtomic() && "violated precondition");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4641</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4642</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="codeLine">  /// This callback is invoked by the type legalizer to legalize nodes with an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4645</td>
    <td class="codeLine">  /// This callback is invoked by the type legalizer to legalize nodes with an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="codeLine">  /// illegal operand type but legal result types.  It replaces the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4646</td>
    <td class="codeLine">  /// illegal operand type but legal result types.  It replaces the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="codeLine">  /// LowerOperation callback in the type Legalizer.  The reason we can not do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4647</td>
    <td class="codeLine">  /// LowerOperation callback in the type Legalizer.  The reason we can not do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="codeLine">  /// away with LowerOperation entirely is that LegalizeDAG isn't yet ready to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4648</td>
    <td class="codeLine">  /// away with LowerOperation entirely is that LegalizeDAG isn't yet ready to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="codeLine">  /// use this callback.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4649</td>
    <td class="codeLine">  /// use this callback.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4650</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="codeLine">  /// TODO: Consider merging with ReplaceNodeResults.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4651</td>
    <td class="codeLine">  /// TODO: Consider merging with ReplaceNodeResults.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4652</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="codeLine">  /// The target places new result values for the node in Results (their number</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4653</td>
    <td class="codeLine">  /// The target places new result values for the node in Results (their number</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="codeLine">  /// and types must exactly match those of the original return values of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4654</td>
    <td class="codeLine">  /// and types must exactly match those of the original return values of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="codeLine">  /// the node), or leaves Results empty, which indicates that the node is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4655</td>
    <td class="codeLine">  /// the node), or leaves Results empty, which indicates that the node is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="codeLine">  /// to be custom lowered after all.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4656</td>
    <td class="codeLine">  /// to be custom lowered after all.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="codeLine">  /// The default implementation calls LowerOperation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4657</td>
    <td class="codeLine">  /// The default implementation calls LowerOperation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="codeLine">  virtual void LowerOperationWrapper(SDNode *N,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4658</td>
    <td class="codeLine">  virtual void LowerOperationWrapper(SDNode *N,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="codeLine">                                     SmallVectorImpl<SDValue> &Results,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4659</td>
    <td class="codeLine">                                     SmallVectorImpl<SDValue> &Results,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="codeLine">                                     SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4660</td>
    <td class="codeLine">                                     SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="codeLine">  /// This callback is invoked for operations that are unsupported by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4662</td>
    <td class="codeLine">  /// This callback is invoked for operations that are unsupported by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="codeLine">  /// target, which are registered to use 'custom' lowering, and whose defined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4663</td>
    <td class="codeLine">  /// target, which are registered to use 'custom' lowering, and whose defined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="codeLine">  /// values are all legal.  If the target has no operations that require custom</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4664</td>
    <td class="codeLine">  /// values are all legal.  If the target has no operations that require custom</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="codeLine">  /// lowering, it need not implement this.  The default implementation of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4665</td>
    <td class="codeLine">  /// lowering, it need not implement this.  The default implementation of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="codeLine">  /// aborts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4666</td>
    <td class="codeLine">  /// aborts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="codeLine">  virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4667</td>
    <td class="codeLine">  virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="codeLine">  /// This callback is invoked when a node result type is illegal for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4669</td>
    <td class="codeLine">  /// This callback is invoked when a node result type is illegal for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="codeLine">  /// target, and the operation was registered to use 'custom' lowering for that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4670</td>
    <td class="codeLine">  /// target, and the operation was registered to use 'custom' lowering for that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="codeLine">  /// result type.  The target places new result values for the node in Results</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4671</td>
    <td class="codeLine">  /// result type.  The target places new result values for the node in Results</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="codeLine">  /// (their number and types must exactly match those of the original return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4672</td>
    <td class="codeLine">  /// (their number and types must exactly match those of the original return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="codeLine">  /// values of the node), or leaves Results empty, which indicates that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4673</td>
    <td class="codeLine">  /// values of the node), or leaves Results empty, which indicates that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="codeLine">  /// node is not to be custom lowered after all.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4674</td>
    <td class="codeLine">  /// node is not to be custom lowered after all.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4675</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="codeLine">  /// If the target has no operations that require custom lowering, it need not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4676</td>
    <td class="codeLine">  /// If the target has no operations that require custom lowering, it need not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="codeLine">  /// implement this.  The default implementation aborts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4677</td>
    <td class="codeLine">  /// implement this.  The default implementation aborts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="codeLine">  virtual void ReplaceNodeResults(SDNode * /*N*/,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4678</td>
    <td class="codeLine">  virtual void ReplaceNodeResults(SDNode * /*N*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="codeLine">                                  SmallVectorImpl<SDValue> &/*Results*/,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4679</td>
    <td class="codeLine">                                  SmallVectorImpl<SDValue> &/*Results*/,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="codeLine">                                  SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4680</td>
    <td class="codeLine">                                  SelectionDAG &/*DAG*/) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="codeLine">    llvm_unreachable("ReplaceNodeResults not implemented for this target!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4681</td>
    <td class="codeLine">    llvm_unreachable("ReplaceNodeResults not implemented for this target!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4682</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="codeLine">  /// This method returns the name of a target specific DAG node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4684</td>
    <td class="codeLine">  /// This method returns the name of a target specific DAG node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="codeLine">  virtual const char *getTargetNodeName(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4685</td>
    <td class="codeLine">  virtual const char *getTargetNodeName(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="codeLine">  /// This method returns a target specific FastISel object, or null if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4687</td>
    <td class="codeLine">  /// This method returns a target specific FastISel object, or null if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="codeLine">  /// target does not support "fast" ISel.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4688</td>
    <td class="codeLine">  /// target does not support "fast" ISel.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="codeLine">  virtual FastISel *createFastISel(FunctionLoweringInfo &,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4689</td>
    <td class="codeLine">  virtual FastISel *createFastISel(FunctionLoweringInfo &,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="codeLine">                                   const TargetLibraryInfo *) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4690</td>
    <td class="codeLine">                                   const TargetLibraryInfo *) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4691</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4692</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="codeLine">  bool verifyReturnAddressArgumentIsConstant(SDValue Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4694</td>
    <td class="codeLine">  bool verifyReturnAddressArgumentIsConstant(SDValue Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="codeLine">                                             SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4695</td>
    <td class="codeLine">                                             SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4697</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="codeLine">  // Inline Asm Support hooks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4698</td>
    <td class="codeLine">  // Inline Asm Support hooks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4699</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="codeLine">  /// This hook allows the target to expand an inline asm call to be explicit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4701</td>
    <td class="codeLine">  /// This hook allows the target to expand an inline asm call to be explicit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="codeLine">  /// llvm code if it wants to.  This is useful for turning simple inline asms</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4702</td>
    <td class="codeLine">  /// llvm code if it wants to.  This is useful for turning simple inline asms</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="codeLine">  /// into LLVM intrinsics, which gives the compiler more information about the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4703</td>
    <td class="codeLine">  /// into LLVM intrinsics, which gives the compiler more information about the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="codeLine">  /// behavior of the code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4704</td>
    <td class="codeLine">  /// behavior of the code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="codeLine">  virtual bool ExpandInlineAsm(CallInst *) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4705</td>
    <td class="codeLine">  virtual bool ExpandInlineAsm(CallInst *) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4706</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="codeLine">  enum ConstraintType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4709</td>
    <td class="codeLine">  enum ConstraintType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="codeLine">    C_Register,            // Constraint represents specific register(s).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4710</td>
    <td class="codeLine">    C_Register,            // Constraint represents specific register(s).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="codeLine">    C_RegisterClass,       // Constraint represents any of register(s) in class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4711</td>
    <td class="codeLine">    C_RegisterClass,       // Constraint represents any of register(s) in class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="codeLine">    C_Memory,              // Memory constraint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4712</td>
    <td class="codeLine">    C_Memory,              // Memory constraint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="codeLine">    C_Address,             // Address constraint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4713</td>
    <td class="codeLine">    C_Address,             // Address constraint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="codeLine">    C_Immediate,           // Requires an immediate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4714</td>
    <td class="codeLine">    C_Immediate,           // Requires an immediate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="codeLine">    C_Other,               // Something else.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4715</td>
    <td class="codeLine">    C_Other,               // Something else.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="codeLine">    C_Unknown              // Unsupported constraint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4716</td>
    <td class="codeLine">    C_Unknown              // Unsupported constraint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4717</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="codeLine">  enum ConstraintWeight {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4719</td>
    <td class="codeLine">  enum ConstraintWeight {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="codeLine">    // Generic weights.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4720</td>
    <td class="codeLine">    // Generic weights.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="codeLine">    CW_Invalid  = -1,     // No match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4721</td>
    <td class="codeLine">    CW_Invalid  = -1,     // No match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="codeLine">    CW_Okay     = 0,      // Acceptable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4722</td>
    <td class="codeLine">    CW_Okay     = 0,      // Acceptable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="codeLine">    CW_Good     = 1,      // Good weight.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4723</td>
    <td class="codeLine">    CW_Good     = 1,      // Good weight.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="codeLine">    CW_Better   = 2,      // Better weight.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4724</td>
    <td class="codeLine">    CW_Better   = 2,      // Better weight.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="codeLine">    CW_Best     = 3,      // Best weight.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4725</td>
    <td class="codeLine">    CW_Best     = 3,      // Best weight.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="codeLine">    // Well-known weights.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4727</td>
    <td class="codeLine">    // Well-known weights.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="codeLine">    CW_SpecificReg  = CW_Okay,    // Specific register operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4728</td>
    <td class="codeLine">    CW_SpecificReg  = CW_Okay,    // Specific register operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="codeLine">    CW_Register     = CW_Good,    // Register operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4729</td>
    <td class="codeLine">    CW_Register     = CW_Good,    // Register operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="codeLine">    CW_Memory       = CW_Better,  // Memory operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4730</td>
    <td class="codeLine">    CW_Memory       = CW_Better,  // Memory operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="codeLine">    CW_Constant     = CW_Best,    // Constant operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4731</td>
    <td class="codeLine">    CW_Constant     = CW_Best,    // Constant operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="codeLine">    CW_Default      = CW_Okay     // Default or don't know type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4732</td>
    <td class="codeLine">    CW_Default      = CW_Okay     // Default or don't know type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4733</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="codeLine">  /// This contains information for each constraint that we are lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4735</td>
    <td class="codeLine">  /// This contains information for each constraint that we are lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="codeLine">  struct AsmOperandInfo : public InlineAsm::ConstraintInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4736</td>
    <td class="codeLine">  struct AsmOperandInfo : public InlineAsm::ConstraintInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="codeLine">    /// This contains the actual string for the code, like "m".  TargetLowering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4737</td>
    <td class="codeLine">    /// This contains the actual string for the code, like "m".  TargetLowering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="codeLine">    /// picks the 'best' code from ConstraintInfo::Codes that most closely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4738</td>
    <td class="codeLine">    /// picks the 'best' code from ConstraintInfo::Codes that most closely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="codeLine">    /// matches the operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4739</td>
    <td class="codeLine">    /// matches the operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="codeLine">    std::string ConstraintCode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4740</td>
    <td class="codeLine">    std::string ConstraintCode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class="codeLine">    /// Information about the constraint code, e.g. Register, RegisterClass,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4742</td>
    <td class="codeLine">    /// Information about the constraint code, e.g. Register, RegisterClass,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="codeLine">    /// Memory, Other, Unknown.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4743</td>
    <td class="codeLine">    /// Memory, Other, Unknown.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="codeLine">    TargetLowering::ConstraintType ConstraintType = TargetLowering::C_Unknown;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4744</td>
    <td class="codeLine">    TargetLowering::ConstraintType ConstraintType = TargetLowering::C_Unknown;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="codeLine">    /// If this is the result output operand or a clobber, this is null,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4746</td>
    <td class="codeLine">    /// If this is the result output operand or a clobber, this is null,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="codeLine">    /// otherwise it is the incoming operand to the CallInst.  This gets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4747</td>
    <td class="codeLine">    /// otherwise it is the incoming operand to the CallInst.  This gets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="codeLine">    /// modified as the asm is processed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4748</td>
    <td class="codeLine">    /// modified as the asm is processed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="codeLine">    Value *CallOperandVal = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4749</td>
    <td class="codeLine">    Value *CallOperandVal = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="codeLine">    /// The ValueType for the operand value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4751</td>
    <td class="codeLine">    /// The ValueType for the operand value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="codeLine">    MVT ConstraintVT = MVT::Other;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4752</td>
    <td class="codeLine">    MVT ConstraintVT = MVT::Other;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="codeLine">    /// Copy constructor for copying from a ConstraintInfo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4754</td>
    <td class="codeLine">    /// Copy constructor for copying from a ConstraintInfo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="codeLine">    AsmOperandInfo(InlineAsm::ConstraintInfo Info)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4755</td>
    <td class="codeLine">    AsmOperandInfo(InlineAsm::ConstraintInfo Info)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="codeLine">        : InlineAsm::ConstraintInfo(std::move(Info)) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4756</td>
    <td class="codeLine">        : InlineAsm::ConstraintInfo(std::move(Info)) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="codeLine">    /// Return true of this is an input operand that is a matching constraint</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4758</td>
    <td class="codeLine">    /// Return true of this is an input operand that is a matching constraint</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="codeLine">    /// like "4".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4759</td>
    <td class="codeLine">    /// like "4".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="codeLine">    bool isMatchingInputConstraint() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4760</td>
    <td class="codeLine">    bool isMatchingInputConstraint() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="codeLine">    /// If this is an input matching constraint, this method returns the output</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4762</td>
    <td class="codeLine">    /// If this is an input matching constraint, this method returns the output</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="codeLine">    /// operand it matches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4763</td>
    <td class="codeLine">    /// operand it matches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="codeLine">    unsigned getMatchedOperand() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4764</td>
    <td class="codeLine">    unsigned getMatchedOperand() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4765</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="codeLine">  using AsmOperandInfoVector = std::vector<AsmOperandInfo>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4767</td>
    <td class="codeLine">  using AsmOperandInfoVector = std::vector<AsmOperandInfo>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="codeLine">  /// Split up the constraint string from the inline assembly value into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4769</td>
    <td class="codeLine">  /// Split up the constraint string from the inline assembly value into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="codeLine">  /// specific constraints and their prefixes, and also tie in the associated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4770</td>
    <td class="codeLine">  /// specific constraints and their prefixes, and also tie in the associated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="codeLine">  /// operand values.  If this returns an empty vector, and if the constraint</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4771</td>
    <td class="codeLine">  /// operand values.  If this returns an empty vector, and if the constraint</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="codeLine">  /// string itself isn't empty, there was an error parsing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4772</td>
    <td class="codeLine">  /// string itself isn't empty, there was an error parsing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="codeLine">  virtual AsmOperandInfoVector ParseConstraints(const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4773</td>
    <td class="codeLine">  virtual AsmOperandInfoVector ParseConstraints(const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="codeLine">                                                const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4774</td>
    <td class="codeLine">                                                const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="codeLine">                                                const CallBase &Call) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4775</td>
    <td class="codeLine">                                                const CallBase &Call) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="codeLine">  /// Examine constraint type and operand type and determine a weight value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4777</td>
    <td class="codeLine">  /// Examine constraint type and operand type and determine a weight value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="codeLine">  /// The operand object must already have been set up with the operand type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4778</td>
    <td class="codeLine">  /// The operand object must already have been set up with the operand type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="codeLine">  virtual ConstraintWeight getMultipleConstraintMatchWeight(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4779</td>
    <td class="codeLine">  virtual ConstraintWeight getMultipleConstraintMatchWeight(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="codeLine">      AsmOperandInfo &info, int maIndex) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4780</td>
    <td class="codeLine">      AsmOperandInfo &info, int maIndex) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="codeLine">  /// Examine constraint string and operand type and determine a weight value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4782</td>
    <td class="codeLine">  /// Examine constraint string and operand type and determine a weight value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="codeLine">  /// The operand object must already have been set up with the operand type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4783</td>
    <td class="codeLine">  /// The operand object must already have been set up with the operand type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="codeLine">  virtual ConstraintWeight getSingleConstraintMatchWeight(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4784</td>
    <td class="codeLine">  virtual ConstraintWeight getSingleConstraintMatchWeight(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="codeLine">      AsmOperandInfo &info, const char *constraint) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4785</td>
    <td class="codeLine">      AsmOperandInfo &info, const char *constraint) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="codeLine">  /// Determines the constraint code and constraint type to use for the specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4787</td>
    <td class="codeLine">  /// Determines the constraint code and constraint type to use for the specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="codeLine">  /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4788</td>
    <td class="codeLine">  /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="codeLine">  /// If the actual operand being passed in is available, it can be passed in as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4789</td>
    <td class="codeLine">  /// If the actual operand being passed in is available, it can be passed in as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="codeLine">  /// Op, otherwise an empty SDValue can be passed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4790</td>
    <td class="codeLine">  /// Op, otherwise an empty SDValue can be passed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="codeLine">  virtual void ComputeConstraintToUse(AsmOperandInfo &OpInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4791</td>
    <td class="codeLine">  virtual void ComputeConstraintToUse(AsmOperandInfo &OpInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="codeLine">                                      SDValue Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4792</td>
    <td class="codeLine">                                      SDValue Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="codeLine">                                      SelectionDAG *DAG = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4793</td>
    <td class="codeLine">                                      SelectionDAG *DAG = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="codeLine">  /// Given a constraint, return the type of constraint it is for this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4795</td>
    <td class="codeLine">  /// Given a constraint, return the type of constraint it is for this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="codeLine">  virtual ConstraintType getConstraintType(StringRef Constraint) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4796</td>
    <td class="codeLine">  virtual ConstraintType getConstraintType(StringRef Constraint) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="codeLine">  /// Given a physical register constraint (e.g.  {edx}), return the register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4798</td>
    <td class="codeLine">  /// Given a physical register constraint (e.g.  {edx}), return the register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="codeLine">  /// number and the register class for the register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4799</td>
    <td class="codeLine">  /// number and the register class for the register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4800</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="codeLine">  /// Given a register class constraint, like 'r', if this corresponds directly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4801</td>
    <td class="codeLine">  /// Given a register class constraint, like 'r', if this corresponds directly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="codeLine">  /// to an LLVM register class, return a register of 0 and the register class</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4802</td>
    <td class="codeLine">  /// to an LLVM register class, return a register of 0 and the register class</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="codeLine">  /// pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4803</td>
    <td class="codeLine">  /// pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4804</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="codeLine">  /// This should only be used for C_Register constraints.  On error, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4805</td>
    <td class="codeLine">  /// This should only be used for C_Register constraints.  On error, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="codeLine">  /// returns a register number of 0 and a null register class pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4806</td>
    <td class="codeLine">  /// returns a register number of 0 and a null register class pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="codeLine">  virtual std::pair<unsigned, const TargetRegisterClass *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4807</td>
    <td class="codeLine">  virtual std::pair<unsigned, const TargetRegisterClass *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class="codeLine">  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4808</td>
    <td class="codeLine">  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="codeLine">                               StringRef Constraint, MVT VT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4809</td>
    <td class="codeLine">                               StringRef Constraint, MVT VT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="codeLine">  virtual unsigned getInlineAsmMemConstraint(StringRef ConstraintCode) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4811</td>
    <td class="codeLine">  virtual unsigned getInlineAsmMemConstraint(StringRef ConstraintCode) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="codeLine">    if (ConstraintCode == "m")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4812</td>
    <td class="codeLine">    if (ConstraintCode == "m")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="codeLine">      return InlineAsm::Constraint_m;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4813</td>
    <td class="codeLine">      return InlineAsm::Constraint_m;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="codeLine">    if (ConstraintCode == "o")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4814</td>
    <td class="codeLine">    if (ConstraintCode == "o")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="codeLine">      return InlineAsm::Constraint_o;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4815</td>
    <td class="codeLine">      return InlineAsm::Constraint_o;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="codeLine">    if (ConstraintCode == "X")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4816</td>
    <td class="codeLine">    if (ConstraintCode == "X")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="codeLine">      return InlineAsm::Constraint_X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4817</td>
    <td class="codeLine">      return InlineAsm::Constraint_X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="codeLine">    if (ConstraintCode == "p")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4818</td>
    <td class="codeLine">    if (ConstraintCode == "p")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="codeLine">      return InlineAsm::Constraint_p;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4819</td>
    <td class="codeLine">      return InlineAsm::Constraint_p;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="codeLine">    return InlineAsm::Constraint_Unknown;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4820</td>
    <td class="codeLine">    return InlineAsm::Constraint_Unknown;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4821</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="codeLine">  /// Try to replace an X constraint, which matches anything, with another that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4823</td>
    <td class="codeLine">  /// Try to replace an X constraint, which matches anything, with another that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="codeLine">  /// has more specific requirements based on the type of the corresponding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4824</td>
    <td class="codeLine">  /// has more specific requirements based on the type of the corresponding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="codeLine">  /// operand.  This returns null if there is no replacement to make.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4825</td>
    <td class="codeLine">  /// operand.  This returns null if there is no replacement to make.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="codeLine">  virtual const char *LowerXConstraint(EVT ConstraintVT) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4826</td>
    <td class="codeLine">  virtual const char *LowerXConstraint(EVT ConstraintVT) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="codeLine">  /// Lower the specified operand into the Ops vector.  If it is invalid, don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4828</td>
    <td class="codeLine">  /// Lower the specified operand into the Ops vector.  If it is invalid, don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="codeLine">  /// add anything to Ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4829</td>
    <td class="codeLine">  /// add anything to Ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="codeLine">  virtual void LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4830</td>
    <td class="codeLine">  virtual void LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="codeLine">                                            std::vector<SDValue> &Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4831</td>
    <td class="codeLine">                                            std::vector<SDValue> &Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="codeLine">                                            SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4832</td>
    <td class="codeLine">                                            SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="codeLine">  // Lower custom output constraints. If invalid, return SDValue().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4834</td>
    <td class="codeLine">  // Lower custom output constraints. If invalid, return SDValue().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="codeLine">  virtual SDValue LowerAsmOutputForConstraint(SDValue &Chain, SDValue &Glue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4835</td>
    <td class="codeLine">  virtual SDValue LowerAsmOutputForConstraint(SDValue &Chain, SDValue &Glue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="codeLine">                                              const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4836</td>
    <td class="codeLine">                                              const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="codeLine">                                              const AsmOperandInfo &OpInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4837</td>
    <td class="codeLine">                                              const AsmOperandInfo &OpInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4838</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="codeLine">  // Targets may override this function to collect operands from the CallInst</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4840</td>
    <td class="codeLine">  // Targets may override this function to collect operands from the CallInst</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="codeLine">  // and for example, lower them into the SelectionDAG operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4841</td>
    <td class="codeLine">  // and for example, lower them into the SelectionDAG operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="codeLine">  virtual void CollectTargetIntrinsicOperands(const CallInst &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4842</td>
    <td class="codeLine">  virtual void CollectTargetIntrinsicOperands(const CallInst &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="codeLine">                                              SmallVectorImpl<SDValue> &Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4843</td>
    <td class="codeLine">                                              SmallVectorImpl<SDValue> &Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4844</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4846</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class="codeLine">  // Div utility functions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4847</td>
    <td class="codeLine">  // Div utility functions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4848</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="codeLine">  SDValue BuildSDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4850</td>
    <td class="codeLine">  SDValue BuildSDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="codeLine">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4851</td>
    <td class="codeLine">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="codeLine">  SDValue BuildUDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4852</td>
    <td class="codeLine">  SDValue BuildUDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="codeLine">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4853</td>
    <td class="codeLine">                    SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="codeLine">  /// Targets may override this function to provide custom SDIV lowering for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4855</td>
    <td class="codeLine">  /// Targets may override this function to provide custom SDIV lowering for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="codeLine">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4856</td>
    <td class="codeLine">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="codeLine">  /// assumes SDIV is expensive and replaces it with a series of other integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4857</td>
    <td class="codeLine">  /// assumes SDIV is expensive and replaces it with a series of other integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4858</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="codeLine">  virtual SDValue BuildSDIVPow2(SDNode *N, const APInt &Divisor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4859</td>
    <td class="codeLine">  virtual SDValue BuildSDIVPow2(SDNode *N, const APInt &Divisor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="codeLine">                                SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4860</td>
    <td class="codeLine">                                SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="codeLine">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4861</td>
    <td class="codeLine">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="codeLine">  /// Targets may override this function to provide custom SREM lowering for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4863</td>
    <td class="codeLine">  /// Targets may override this function to provide custom SREM lowering for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="codeLine">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4864</td>
    <td class="codeLine">  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="codeLine">  /// assumes SREM is expensive and replaces it with a series of other integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4865</td>
    <td class="codeLine">  /// assumes SREM is expensive and replaces it with a series of other integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4866</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="codeLine">  virtual SDValue BuildSREMPow2(SDNode *N, const APInt &Divisor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4867</td>
    <td class="codeLine">  virtual SDValue BuildSREMPow2(SDNode *N, const APInt &Divisor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="codeLine">                                SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4868</td>
    <td class="codeLine">                                SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="codeLine">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4869</td>
    <td class="codeLine">                                SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="codeLine">  /// Indicate whether this target prefers to combine FDIVs with the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4871</td>
    <td class="codeLine">  /// Indicate whether this target prefers to combine FDIVs with the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="codeLine">  /// divisor. If the transform should never be done, return zero. If the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4872</td>
    <td class="codeLine">  /// divisor. If the transform should never be done, return zero. If the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="codeLine">  /// transform should be done, return the minimum number of divisor uses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4873</td>
    <td class="codeLine">  /// transform should be done, return the minimum number of divisor uses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="codeLine">  /// that must exist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4874</td>
    <td class="codeLine">  /// that must exist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="codeLine">  virtual unsigned combineRepeatedFPDivisors() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4875</td>
    <td class="codeLine">  virtual unsigned combineRepeatedFPDivisors() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4876</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4877</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4878</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="codeLine">  /// Hooks for building estimates in place of slower divisions and square</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4879</td>
    <td class="codeLine">  /// Hooks for building estimates in place of slower divisions and square</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="codeLine">  /// roots.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4880</td>
    <td class="codeLine">  /// roots.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="codeLine">  /// Return either a square root or its reciprocal estimate value for the input</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4882</td>
    <td class="codeLine">  /// Return either a square root or its reciprocal estimate value for the input</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="codeLine">  /// operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4883</td>
    <td class="codeLine">  /// operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="codeLine">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4884</td>
    <td class="codeLine">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="codeLine">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4885</td>
    <td class="codeLine">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="codeLine">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4886</td>
    <td class="codeLine">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="codeLine">  /// refinement iterations required to generate a sufficient (though not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4887</td>
    <td class="codeLine">  /// refinement iterations required to generate a sufficient (though not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="codeLine">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4888</td>
    <td class="codeLine">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="codeLine">  /// The boolean UseOneConstNR output is used to select a Newton-Raphson</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4889</td>
    <td class="codeLine">  /// The boolean UseOneConstNR output is used to select a Newton-Raphson</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="codeLine">  /// algorithm implementation that uses either one or two constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4890</td>
    <td class="codeLine">  /// algorithm implementation that uses either one or two constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="codeLine">  /// The boolean Reciprocal is used to select whether the estimate is for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4891</td>
    <td class="codeLine">  /// The boolean Reciprocal is used to select whether the estimate is for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="codeLine">  /// square root of the input operand or the reciprocal of its square root.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4892</td>
    <td class="codeLine">  /// square root of the input operand or the reciprocal of its square root.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="codeLine">  /// A target may choose to implement its own refinement within this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4893</td>
    <td class="codeLine">  /// A target may choose to implement its own refinement within this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="codeLine">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4894</td>
    <td class="codeLine">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="codeLine">  /// any further refinement of the estimate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4895</td>
    <td class="codeLine">  /// any further refinement of the estimate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="codeLine">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4896</td>
    <td class="codeLine">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="codeLine">  virtual SDValue getSqrtEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4897</td>
    <td class="codeLine">  virtual SDValue getSqrtEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="codeLine">                                  int Enabled, int &RefinementSteps,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4898</td>
    <td class="codeLine">                                  int Enabled, int &RefinementSteps,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="codeLine">                                  bool &UseOneConstNR, bool Reciprocal) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4899</td>
    <td class="codeLine">                                  bool &UseOneConstNR, bool Reciprocal) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="codeLine">    return SDValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4900</td>
    <td class="codeLine">    return SDValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4901</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="codeLine">  /// Try to convert the fminnum/fmaxnum to a compare/select sequence. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4903</td>
    <td class="codeLine">  /// Try to convert the fminnum/fmaxnum to a compare/select sequence. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="codeLine">  /// required for correctness since InstCombine might have canonicalized a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4904</td>
    <td class="codeLine">  /// required for correctness since InstCombine might have canonicalized a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="codeLine">  /// fcmp+select sequence to a FMINNUM/FMAXNUM intrinsic.  If we were to fall</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4905</td>
    <td class="codeLine">  /// fcmp+select sequence to a FMINNUM/FMAXNUM intrinsic.  If we were to fall</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="codeLine">  /// through to the default expansion/soften to libcall, we might introduce a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4906</td>
    <td class="codeLine">  /// through to the default expansion/soften to libcall, we might introduce a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="codeLine">  /// link-time dependency on libm into a file that originally did not have one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4907</td>
    <td class="codeLine">  /// link-time dependency on libm into a file that originally did not have one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="codeLine">  SDValue createSelectForFMINNUM_FMAXNUM(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4908</td>
    <td class="codeLine">  SDValue createSelectForFMINNUM_FMAXNUM(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="codeLine">  /// Return a reciprocal estimate value for the input operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4910</td>
    <td class="codeLine">  /// Return a reciprocal estimate value for the input operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="codeLine">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4911</td>
    <td class="codeLine">  /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="codeLine">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4912</td>
    <td class="codeLine">  /// 'Enabled' as set by a potential default override attribute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="codeLine">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4913</td>
    <td class="codeLine">  /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="codeLine">  /// refinement iterations required to generate a sufficient (though not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4914</td>
    <td class="codeLine">  /// refinement iterations required to generate a sufficient (though not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="codeLine">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4915</td>
    <td class="codeLine">  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="codeLine">  /// A target may choose to implement its own refinement within this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4916</td>
    <td class="codeLine">  /// A target may choose to implement its own refinement within this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="codeLine">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4917</td>
    <td class="codeLine">  /// If that's true, then return '0' as the number of RefinementSteps to avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="codeLine">  /// any further refinement of the estimate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4918</td>
    <td class="codeLine">  /// any further refinement of the estimate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="codeLine">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4919</td>
    <td class="codeLine">  /// An empty SDValue return means no estimate sequence can be created.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="codeLine">  virtual SDValue getRecipEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4920</td>
    <td class="codeLine">  virtual SDValue getRecipEstimate(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="codeLine">                                   int Enabled, int &RefinementSteps) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4921</td>
    <td class="codeLine">                                   int Enabled, int &RefinementSteps) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="codeLine">    return SDValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4922</td>
    <td class="codeLine">    return SDValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4923</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="codeLine">  /// Return a target-dependent comparison result if the input operand is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4925</td>
    <td class="codeLine">  /// Return a target-dependent comparison result if the input operand is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="codeLine">  /// suitable for use with a square root estimate calculation. For example, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4926</td>
    <td class="codeLine">  /// suitable for use with a square root estimate calculation. For example, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="codeLine">  /// comparison may check if the operand is NAN, INF, zero, normal, etc. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4927</td>
    <td class="codeLine">  /// comparison may check if the operand is NAN, INF, zero, normal, etc. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="codeLine">  /// result should be used as the condition operand for a select or branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4928</td>
    <td class="codeLine">  /// result should be used as the condition operand for a select or branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="codeLine">  virtual SDValue getSqrtInputTest(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4929</td>
    <td class="codeLine">  virtual SDValue getSqrtInputTest(SDValue Operand, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="codeLine">                                   const DenormalMode &Mode) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4930</td>
    <td class="codeLine">                                   const DenormalMode &Mode) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="codeLine">  /// Return a target-dependent result if the input operand is not suitable for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4932</td>
    <td class="codeLine">  /// Return a target-dependent result if the input operand is not suitable for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="codeLine">  /// use with a square root estimate calculation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4933</td>
    <td class="codeLine">  /// use with a square root estimate calculation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="codeLine">  virtual SDValue getSqrtResultForDenormInput(SDValue Operand,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4934</td>
    <td class="codeLine">  virtual SDValue getSqrtResultForDenormInput(SDValue Operand,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4935</td>
    <td class="codeLine">                                              SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="codeLine">    return DAG.getConstantFP(0.0, SDLoc(Operand), Operand.getValueType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4936</td>
    <td class="codeLine">    return DAG.getConstantFP(0.0, SDLoc(Operand), Operand.getValueType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4937</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4939</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="codeLine">  // Legalization utility functions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4940</td>
    <td class="codeLine">  // Legalization utility functions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4941</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="codeLine">  /// Expand a MUL or [US]MUL_LOHI of n-bit values into two or four nodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4943</td>
    <td class="codeLine">  /// Expand a MUL or [US]MUL_LOHI of n-bit values into two or four nodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="codeLine">  /// respectively, each computing an n/2-bit part of the result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4944</td>
    <td class="codeLine">  /// respectively, each computing an n/2-bit part of the result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="codeLine">  /// \param Result A vector that will be filled with the parts of the result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4945</td>
    <td class="codeLine">  /// \param Result A vector that will be filled with the parts of the result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="codeLine">  ///        in little-endian order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4946</td>
    <td class="codeLine">  ///        in little-endian order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="codeLine">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4947</td>
    <td class="codeLine">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="codeLine">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4948</td>
    <td class="codeLine">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="codeLine">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4949</td>
    <td class="codeLine">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class="codeLine">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4950</td>
    <td class="codeLine">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="codeLine">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4951</td>
    <td class="codeLine">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="codeLine">  /// \returns true if the node has been expanded, false if it has not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4952</td>
    <td class="codeLine">  /// \returns true if the node has been expanded, false if it has not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="codeLine">  bool expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl, SDValue LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4953</td>
    <td class="codeLine">  bool expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl, SDValue LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="codeLine">                      SDValue RHS, SmallVectorImpl<SDValue> &Result, EVT HiLoVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4954</td>
    <td class="codeLine">                      SDValue RHS, SmallVectorImpl<SDValue> &Result, EVT HiLoVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="codeLine">                      SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4955</td>
    <td class="codeLine">                      SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class="codeLine">                      SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4956</td>
    <td class="codeLine">                      SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="codeLine">                      SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4957</td>
    <td class="codeLine">                      SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="codeLine">  /// Expand a MUL into two nodes.  One that computes the high bits of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4959</td>
    <td class="codeLine">  /// Expand a MUL into two nodes.  One that computes the high bits of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="codeLine">  /// the result and one that computes the low bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4960</td>
    <td class="codeLine">  /// the result and one that computes the low bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="codeLine">  /// \param HiLoVT The value type to use for the Lo and Hi nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4961</td>
    <td class="codeLine">  /// \param HiLoVT The value type to use for the Lo and Hi nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="codeLine">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4962</td>
    <td class="codeLine">  /// \param LL Low bits of the LHS of the MUL.  You can use this parameter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="codeLine">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4963</td>
    <td class="codeLine">  ///        if you want to control how low bits are extracted from the LHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="codeLine">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4964</td>
    <td class="codeLine">  /// \param LH High bits of the LHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class="codeLine">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4965</td>
    <td class="codeLine">  /// \param RL Low bits of the RHS of the MUL.  See LL for meaning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="codeLine">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4966</td>
    <td class="codeLine">  /// \param RH High bits of the RHS of the MUL.  See LL for meaning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="codeLine">  /// \returns true if the node has been expanded. false if it has not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4967</td>
    <td class="codeLine">  /// \returns true if the node has been expanded. false if it has not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="codeLine">  bool expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4968</td>
    <td class="codeLine">  bool expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="codeLine">                 SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4969</td>
    <td class="codeLine">                 SelectionDAG &DAG, MulExpansionKind Kind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="codeLine">                 SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4970</td>
    <td class="codeLine">                 SDValue LL = SDValue(), SDValue LH = SDValue(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="codeLine">                 SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4971</td>
    <td class="codeLine">                 SDValue RL = SDValue(), SDValue RH = SDValue()) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="codeLine">  /// Attempt to expand an n-bit div/rem/divrem by constant using a n/2-bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4973</td>
    <td class="codeLine">  /// Attempt to expand an n-bit div/rem/divrem by constant using a n/2-bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class="codeLine">  /// urem by constant and other arithmetic ops. The n/2-bit urem by constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4974</td>
    <td class="codeLine">  /// urem by constant and other arithmetic ops. The n/2-bit urem by constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="codeLine">  /// will be expanded by DAGCombiner. This is not possible for all constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4975</td>
    <td class="codeLine">  /// will be expanded by DAGCombiner. This is not possible for all constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="codeLine">  /// divisors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4976</td>
    <td class="codeLine">  /// divisors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4977</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="codeLine">  /// \param Result A vector that will be filled with the lo and high parts of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4978</td>
    <td class="codeLine">  /// \param Result A vector that will be filled with the lo and high parts of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="codeLine">  ///        the results. For *DIVREM, this will be the quotient parts followed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4979</td>
    <td class="codeLine">  ///        the results. For *DIVREM, this will be the quotient parts followed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="codeLine">  ///        by the remainder parts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4980</td>
    <td class="codeLine">  ///        by the remainder parts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="codeLine">  /// \param HiLoVT The value type to use for the Lo and Hi parts. Should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4981</td>
    <td class="codeLine">  /// \param HiLoVT The value type to use for the Lo and Hi parts. Should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="codeLine">  ///        half of VT.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4982</td>
    <td class="codeLine">  ///        half of VT.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="codeLine">  /// \param LL Low bits of the LHS of the operation. You can use this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4983</td>
    <td class="codeLine">  /// \param LL Low bits of the LHS of the operation. You can use this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="codeLine">  ///        parameter if you want to control how low bits are extracted from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4984</td>
    <td class="codeLine">  ///        parameter if you want to control how low bits are extracted from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="codeLine">  ///        the LHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4985</td>
    <td class="codeLine">  ///        the LHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="codeLine">  /// \param LH High bits of the LHS of the operation. See LL for meaning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4986</td>
    <td class="codeLine">  /// \param LH High bits of the LHS of the operation. See LL for meaning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="codeLine">  /// \returns true if the node has been expanded, false if it has not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4987</td>
    <td class="codeLine">  /// \returns true if the node has been expanded, false if it has not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="codeLine">  bool expandDIVREMByConstant(SDNode *N, SmallVectorImpl<SDValue> &Result,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4988</td>
    <td class="codeLine">  bool expandDIVREMByConstant(SDNode *N, SmallVectorImpl<SDValue> &Result,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="codeLine">                              EVT HiLoVT, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4989</td>
    <td class="codeLine">                              EVT HiLoVT, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="codeLine">                              SDValue LL = SDValue(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4990</td>
    <td class="codeLine">                              SDValue LL = SDValue(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="codeLine">                              SDValue LH = SDValue()) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4991</td>
    <td class="codeLine">                              SDValue LH = SDValue()) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="codeLine">  /// Expand funnel shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4993</td>
    <td class="codeLine">  /// Expand funnel shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4994</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="codeLine">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4995</td>
    <td class="codeLine">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="codeLine">  SDValue expandFunnelShift(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4996</td>
    <td class="codeLine">  SDValue expandFunnelShift(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="codeLine">  /// Expand rotations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4998</td>
    <td class="codeLine">  /// Expand rotations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4999</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="codeLine">  /// \param AllowVectorOps expand vector rotate, this should only be performed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5000</td>
    <td class="codeLine">  /// \param AllowVectorOps expand vector rotate, this should only be performed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="codeLine">  ///        if the legalization is happening outside of LegalizeVectorOps</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5001</td>
    <td class="codeLine">  ///        if the legalization is happening outside of LegalizeVectorOps</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="codeLine">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5002</td>
    <td class="codeLine">  /// \returns The expansion if successful, SDValue() otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="codeLine">  SDValue expandROT(SDNode *N, bool AllowVectorOps, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5003</td>
    <td class="codeLine">  SDValue expandROT(SDNode *N, bool AllowVectorOps, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="codeLine">  /// Expand shift-by-parts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5005</td>
    <td class="codeLine">  /// Expand shift-by-parts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5006</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="codeLine">  /// \param Lo lower-output-part after conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5007</td>
    <td class="codeLine">  /// \param Lo lower-output-part after conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="codeLine">  /// \param Hi upper-output-part after conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5008</td>
    <td class="codeLine">  /// \param Hi upper-output-part after conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="codeLine">  void expandShiftParts(SDNode *N, SDValue &Lo, SDValue &Hi,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5009</td>
    <td class="codeLine">  void expandShiftParts(SDNode *N, SDValue &Lo, SDValue &Hi,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="codeLine">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5010</td>
    <td class="codeLine">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="codeLine">  /// Expand float(f32) to SINT(i64) conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5012</td>
    <td class="codeLine">  /// Expand float(f32) to SINT(i64) conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5013</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="codeLine">  /// \param Result output after conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5014</td>
    <td class="codeLine">  /// \param Result output after conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="codeLine">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5015</td>
    <td class="codeLine">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="codeLine">  bool expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5016</td>
    <td class="codeLine">  bool expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="codeLine">  /// Expand float to UINT conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5018</td>
    <td class="codeLine">  /// Expand float to UINT conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5019</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="codeLine">  /// \param Result output after conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5020</td>
    <td class="codeLine">  /// \param Result output after conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="codeLine">  /// \param Chain output chain after conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5021</td>
    <td class="codeLine">  /// \param Chain output chain after conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="codeLine">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5022</td>
    <td class="codeLine">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="codeLine">  bool expandFP_TO_UINT(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5023</td>
    <td class="codeLine">  bool expandFP_TO_UINT(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="codeLine">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5024</td>
    <td class="codeLine">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="codeLine">  /// Expand UINT(i64) to double(f64) conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5026</td>
    <td class="codeLine">  /// Expand UINT(i64) to double(f64) conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5027</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="codeLine">  /// \param Result output after conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5028</td>
    <td class="codeLine">  /// \param Result output after conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="codeLine">  /// \param Chain output chain after conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5029</td>
    <td class="codeLine">  /// \param Chain output chain after conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="codeLine">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5030</td>
    <td class="codeLine">  /// \returns True, if the expansion was successful, false otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="codeLine">  bool expandUINT_TO_FP(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5031</td>
    <td class="codeLine">  bool expandUINT_TO_FP(SDNode *N, SDValue &Result, SDValue &Chain,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="codeLine">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5032</td>
    <td class="codeLine">                        SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="codeLine">  /// Expand fminnum/fmaxnum into fminnum_ieee/fmaxnum_ieee with quieted inputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5034</td>
    <td class="codeLine">  /// Expand fminnum/fmaxnum into fminnum_ieee/fmaxnum_ieee with quieted inputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="codeLine">  SDValue expandFMINNUM_FMAXNUM(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5035</td>
    <td class="codeLine">  SDValue expandFMINNUM_FMAXNUM(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="codeLine">  /// Expand FP_TO_[US]INT_SAT into FP_TO_[US]INT and selects or min/max.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5037</td>
    <td class="codeLine">  /// Expand FP_TO_[US]INT_SAT into FP_TO_[US]INT and selects or min/max.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5038</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="codeLine">  /// \returns The expansion result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5039</td>
    <td class="codeLine">  /// \returns The expansion result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="codeLine">  SDValue expandFP_TO_INT_SAT(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5040</td>
    <td class="codeLine">  SDValue expandFP_TO_INT_SAT(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="codeLine">  /// Expand check for floating point class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5042</td>
    <td class="codeLine">  /// Expand check for floating point class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="codeLine">  /// \param ResultVT The type of intrinsic call result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5043</td>
    <td class="codeLine">  /// \param ResultVT The type of intrinsic call result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="codeLine">  /// \param Op The tested value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5044</td>
    <td class="codeLine">  /// \param Op The tested value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="codeLine">  /// \param Test The test to perform.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5045</td>
    <td class="codeLine">  /// \param Test The test to perform.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="codeLine">  /// \param Flags The optimization flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5046</td>
    <td class="codeLine">  /// \param Flags The optimization flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5047</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="codeLine">  SDValue expandIS_FPCLASS(EVT ResultVT, SDValue Op, FPClassTest Test,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5048</td>
    <td class="codeLine">  SDValue expandIS_FPCLASS(EVT ResultVT, SDValue Op, FPClassTest Test,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="codeLine">                           SDNodeFlags Flags, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5049</td>
    <td class="codeLine">                           SDNodeFlags Flags, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="codeLine">                           SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5050</td>
    <td class="codeLine">                           SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="codeLine">  /// Expand CTPOP nodes. Expands vector/scalar CTPOP nodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5052</td>
    <td class="codeLine">  /// Expand CTPOP nodes. Expands vector/scalar CTPOP nodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5053</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5054</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5055</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="codeLine">  SDValue expandCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5056</td>
    <td class="codeLine">  SDValue expandCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="codeLine">  /// Expand VP_CTPOP nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5058</td>
    <td class="codeLine">  /// Expand VP_CTPOP nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5059</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="codeLine">  SDValue expandVPCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5060</td>
    <td class="codeLine">  SDValue expandVPCTPOP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="codeLine">  /// Expand CTLZ/CTLZ_ZERO_UNDEF nodes. Expands vector/scalar CTLZ nodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5062</td>
    <td class="codeLine">  /// Expand CTLZ/CTLZ_ZERO_UNDEF nodes. Expands vector/scalar CTLZ nodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5063</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5064</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5065</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="codeLine">  SDValue expandCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5066</td>
    <td class="codeLine">  SDValue expandCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="codeLine">  /// Expand VP_CTLZ/VP_CTLZ_ZERO_UNDEF nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5068</td>
    <td class="codeLine">  /// Expand VP_CTLZ/VP_CTLZ_ZERO_UNDEF nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5069</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5070</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="codeLine">  SDValue expandVPCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5071</td>
    <td class="codeLine">  SDValue expandVPCTLZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="codeLine">  /// Expand CTTZ via Table Lookup.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5073</td>
    <td class="codeLine">  /// Expand CTTZ via Table Lookup.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5074</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5075</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="codeLine">  SDValue CTTZTableLookup(SDNode *N, SelectionDAG &DAG, const SDLoc &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5076</td>
    <td class="codeLine">  SDValue CTTZTableLookup(SDNode *N, SelectionDAG &DAG, const SDLoc &DL, EVT VT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="codeLine">                          SDValue Op, unsigned NumBitsPerElt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5077</td>
    <td class="codeLine">                          SDValue Op, unsigned NumBitsPerElt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="codeLine">  /// Expand CTTZ/CTTZ_ZERO_UNDEF nodes. Expands vector/scalar CTTZ nodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5079</td>
    <td class="codeLine">  /// Expand CTTZ/CTTZ_ZERO_UNDEF nodes. Expands vector/scalar CTTZ nodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5080</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5081</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5082</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="codeLine">  SDValue expandCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5083</td>
    <td class="codeLine">  SDValue expandCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="codeLine">  /// Expand VP_CTTZ/VP_CTTZ_ZERO_UNDEF nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5085</td>
    <td class="codeLine">  /// Expand VP_CTTZ/VP_CTTZ_ZERO_UNDEF nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5086</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5087</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="codeLine">  SDValue expandVPCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5088</td>
    <td class="codeLine">  SDValue expandVPCTTZ(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="codeLine">  /// Expand ABS nodes. Expands vector/scalar ABS nodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5090</td>
    <td class="codeLine">  /// Expand ABS nodes. Expands vector/scalar ABS nodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5091</td>
    <td class="codeLine">  /// vector nodes can only succeed if all operations are legal/custom.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="codeLine">  /// (ABS x) -> (XOR (ADD x, (SRA x, type_size)), (SRA x, type_size))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5092</td>
    <td class="codeLine">  /// (ABS x) -> (XOR (ADD x, (SRA x, type_size)), (SRA x, type_size))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5093</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="codeLine">  /// \param IsNegative indicate negated abs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5094</td>
    <td class="codeLine">  /// \param IsNegative indicate negated abs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5095</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="codeLine">  SDValue expandABS(SDNode *N, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5096</td>
    <td class="codeLine">  SDValue expandABS(SDNode *N, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="codeLine">                    bool IsNegative = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5097</td>
    <td class="codeLine">                    bool IsNegative = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="codeLine">  /// Expand ABDS/ABDU nodes. Expands vector/scalar ABDS/ABDU nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5099</td>
    <td class="codeLine">  /// Expand ABDS/ABDU nodes. Expands vector/scalar ABDS/ABDU nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5100</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5101</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="codeLine">  SDValue expandABD(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5102</td>
    <td class="codeLine">  SDValue expandABD(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="codeLine">  /// Expand BSWAP nodes. Expands scalar/vector BSWAP nodes with i16/i32/i64</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5104</td>
    <td class="codeLine">  /// Expand BSWAP nodes. Expands scalar/vector BSWAP nodes with i16/i32/i64</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="codeLine">  /// scalar types. Returns SDValue() if expand fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5105</td>
    <td class="codeLine">  /// scalar types. Returns SDValue() if expand fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5106</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5107</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class="codeLine">  SDValue expandBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5108</td>
    <td class="codeLine">  SDValue expandBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="codeLine">  /// Expand VP_BSWAP nodes. Expands VP_BSWAP nodes with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5110</td>
    <td class="codeLine">  /// Expand VP_BSWAP nodes. Expands VP_BSWAP nodes with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="codeLine">  /// i16/i32/i64 scalar types. Returns SDValue() if expand fails. \param N Node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5111</td>
    <td class="codeLine">  /// i16/i32/i64 scalar types. Returns SDValue() if expand fails. \param N Node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="codeLine">  /// to expand \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5112</td>
    <td class="codeLine">  /// to expand \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="codeLine">  SDValue expandVPBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5113</td>
    <td class="codeLine">  SDValue expandVPBSWAP(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="codeLine">  /// Expand BITREVERSE nodes. Expands scalar/vector BITREVERSE nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5115</td>
    <td class="codeLine">  /// Expand BITREVERSE nodes. Expands scalar/vector BITREVERSE nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="codeLine">  /// Returns SDValue() if expand fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5116</td>
    <td class="codeLine">  /// Returns SDValue() if expand fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5117</td>
    <td class="codeLine">  /// \param N Node to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5118</td>
    <td class="codeLine">  /// \returns The expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="codeLine">  SDValue expandBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5119</td>
    <td class="codeLine">  SDValue expandBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="codeLine">  /// Expand VP_BITREVERSE nodes. Expands VP_BITREVERSE nodes with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5121</td>
    <td class="codeLine">  /// Expand VP_BITREVERSE nodes. Expands VP_BITREVERSE nodes with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="codeLine">  /// i8/i16/i32/i64 scalar types. \param N Node to expand \returns The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5122</td>
    <td class="codeLine">  /// i8/i16/i32/i64 scalar types. \param N Node to expand \returns The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="codeLine">  /// expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5123</td>
    <td class="codeLine">  /// expansion result or SDValue() if it fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="codeLine">  SDValue expandVPBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5124</td>
    <td class="codeLine">  SDValue expandVPBITREVERSE(SDNode *N, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="codeLine">  /// Turn load of vector type into a load of the individual elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5126</td>
    <td class="codeLine">  /// Turn load of vector type into a load of the individual elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="codeLine">  /// \param LD load to expand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5127</td>
    <td class="codeLine">  /// \param LD load to expand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="codeLine">  /// \returns BUILD_VECTOR and TokenFactor nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5128</td>
    <td class="codeLine">  /// \returns BUILD_VECTOR and TokenFactor nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> scalarizeVectorLoad(LoadSDNode *LD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5129</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> scalarizeVectorLoad(LoadSDNode *LD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="codeLine">                                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5130</td>
    <td class="codeLine">                                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="codeLine">  // Turn a store of a vector type into stores of the individual elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5132</td>
    <td class="codeLine">  // Turn a store of a vector type into stores of the individual elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="codeLine">  /// \param ST Store with a vector value type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5133</td>
    <td class="codeLine">  /// \param ST Store with a vector value type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="codeLine">  /// \returns TokenFactor of the individual store chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5134</td>
    <td class="codeLine">  /// \returns TokenFactor of the individual store chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="codeLine">  SDValue scalarizeVectorStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5135</td>
    <td class="codeLine">  SDValue scalarizeVectorStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="codeLine">  /// Expands an unaligned load to 2 half-size loads for an integer, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5137</td>
    <td class="codeLine">  /// Expands an unaligned load to 2 half-size loads for an integer, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="codeLine">  /// possibly more for vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5138</td>
    <td class="codeLine">  /// possibly more for vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> expandUnalignedLoad(LoadSDNode *LD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5139</td>
    <td class="codeLine">  std::pair<SDValue, SDValue> expandUnalignedLoad(LoadSDNode *LD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="codeLine">                                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5140</td>
    <td class="codeLine">                                                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="codeLine">  /// Expands an unaligned store to 2 half-size stores for integer values, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5142</td>
    <td class="codeLine">  /// Expands an unaligned store to 2 half-size stores for integer values, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="codeLine">  /// possibly more for vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5143</td>
    <td class="codeLine">  /// possibly more for vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="codeLine">  SDValue expandUnalignedStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5144</td>
    <td class="codeLine">  SDValue expandUnalignedStore(StoreSDNode *ST, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="codeLine">  /// Increments memory address \p Addr according to the type of the value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5146</td>
    <td class="codeLine">  /// Increments memory address \p Addr according to the type of the value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="codeLine">  /// \p DataVT that should be stored. If the data is stored in compressed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5147</td>
    <td class="codeLine">  /// \p DataVT that should be stored. If the data is stored in compressed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="codeLine">  /// form, the memory address should be incremented according to the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5148</td>
    <td class="codeLine">  /// form, the memory address should be incremented according to the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="codeLine">  /// the stored elements. This number is equal to the number of '1's bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5149</td>
    <td class="codeLine">  /// the stored elements. This number is equal to the number of '1's bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="codeLine">  /// in the \p Mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5150</td>
    <td class="codeLine">  /// in the \p Mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="codeLine">  /// \p DataVT is a vector type. \p Mask is a vector value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5151</td>
    <td class="codeLine">  /// \p DataVT is a vector type. \p Mask is a vector value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="codeLine">  /// \p DataVT and \p Mask have the same number of vector elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5152</td>
    <td class="codeLine">  /// \p DataVT and \p Mask have the same number of vector elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="codeLine">  SDValue IncrementMemoryAddress(SDValue Addr, SDValue Mask, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5153</td>
    <td class="codeLine">  SDValue IncrementMemoryAddress(SDValue Addr, SDValue Mask, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="codeLine">                                 EVT DataVT, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5154</td>
    <td class="codeLine">                                 EVT DataVT, SelectionDAG &DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="codeLine">                                 bool IsCompressedMemory) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5155</td>
    <td class="codeLine">                                 bool IsCompressedMemory) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="codeLine">  /// Get a pointer to vector element \p Idx located in memory for a vector of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5157</td>
    <td class="codeLine">  /// Get a pointer to vector element \p Idx located in memory for a vector of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="codeLine">  /// type \p VecVT starting at a base address of \p VecPtr. If \p Idx is out of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5158</td>
    <td class="codeLine">  /// type \p VecVT starting at a base address of \p VecPtr. If \p Idx is out of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="codeLine">  /// bounds the returned pointer is unspecified, but will be within the vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5159</td>
    <td class="codeLine">  /// bounds the returned pointer is unspecified, but will be within the vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="codeLine">  /// bounds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5160</td>
    <td class="codeLine">  /// bounds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="codeLine">  SDValue getVectorElementPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5161</td>
    <td class="codeLine">  SDValue getVectorElementPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="codeLine">                                  SDValue Index) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5162</td>
    <td class="codeLine">                                  SDValue Index) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="codeLine">  /// Get a pointer to a sub-vector of type \p SubVecVT at index \p Idx located</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5164</td>
    <td class="codeLine">  /// Get a pointer to a sub-vector of type \p SubVecVT at index \p Idx located</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="codeLine">  /// in memory for a vector of type \p VecVT starting at a base address of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5165</td>
    <td class="codeLine">  /// in memory for a vector of type \p VecVT starting at a base address of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="codeLine">  /// \p VecPtr. If \p Idx plus the size of \p SubVecVT is out of bounds the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5166</td>
    <td class="codeLine">  /// \p VecPtr. If \p Idx plus the size of \p SubVecVT is out of bounds the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="codeLine">  /// returned pointer is unspecified, but the value returned will be such that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5167</td>
    <td class="codeLine">  /// returned pointer is unspecified, but the value returned will be such that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="codeLine">  /// the entire subvector would be within the vector bounds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5168</td>
    <td class="codeLine">  /// the entire subvector would be within the vector bounds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="codeLine">  SDValue getVectorSubVecPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5169</td>
    <td class="codeLine">  SDValue getVectorSubVecPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="codeLine">                                 EVT SubVecVT, SDValue Index) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5170</td>
    <td class="codeLine">                                 EVT SubVecVT, SDValue Index) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US][MIN|MAX]. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5172</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US][MIN|MAX]. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5173</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="codeLine">  SDValue expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5174</td>
    <td class="codeLine">  SDValue expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US][ADD|SUB]SAT. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5176</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US][ADD|SUB]SAT. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5177</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="codeLine">  SDValue expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5178</td>
    <td class="codeLine">  SDValue expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US]SHLSAT. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5180</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US]SHLSAT. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5181</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="codeLine">  SDValue expandShlSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5182</td>
    <td class="codeLine">  SDValue expandShlSat(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[U|S]MULFIX[SAT]. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5184</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[U|S]MULFIX[SAT]. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5185</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="codeLine">  SDValue expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5186</td>
    <td class="codeLine">  SDValue expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5188</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5189</td>
    <td class="codeLine">  /// method accepts integers as its arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="codeLine">  /// Note: This method may fail if the division could not be performed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5190</td>
    <td class="codeLine">  /// Note: This method may fail if the division could not be performed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class="codeLine">  /// within the type. Clients must retry with a wider type if this happens.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5191</td>
    <td class="codeLine">  /// within the type. Clients must retry with a wider type if this happens.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="codeLine">  SDValue expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5192</td>
    <td class="codeLine">  SDValue expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="codeLine">                              SDValue LHS, SDValue RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5193</td>
    <td class="codeLine">                              SDValue LHS, SDValue RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="codeLine">                              unsigned Scale, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5194</td>
    <td class="codeLine">                              unsigned Scale, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::U(ADD|SUB)O. Expansion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5196</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::U(ADD|SUB)O. Expansion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="codeLine">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5197</td>
    <td class="codeLine">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="codeLine">  void expandUADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5198</td>
    <td class="codeLine">  void expandUADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="codeLine">                      SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5199</td>
    <td class="codeLine">                      SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::S(ADD|SUB)O. Expansion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5201</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::S(ADD|SUB)O. Expansion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="codeLine">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5202</td>
    <td class="codeLine">  /// always suceeds and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="codeLine">  void expandSADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5203</td>
    <td class="codeLine">  void expandSADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="codeLine">                      SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5204</td>
    <td class="codeLine">                      SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5206</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US]MULO. Returns whether</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5206</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::[US]MULO. Returns whether</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5207</td>
    <td class="codeLine">  /// expansion was successful and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5207</td>
    <td class="codeLine">  /// expansion was successful and populates the Result and Overflow arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5208</td>
    <td class="codeLine">  bool expandMULO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5208</td>
    <td class="codeLine">  bool expandMULO(SDNode *Node, SDValue &Result, SDValue &Overflow,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5209</td>
    <td class="codeLine">                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5209</td>
    <td class="codeLine">                  SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5211</td>
    <td class="codeLine">  /// Expand a VECREDUCE_* into an explicit calculation. If Count is specified,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5211</td>
    <td class="codeLine">  /// Expand a VECREDUCE_* into an explicit calculation. If Count is specified,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5212</td>
    <td class="codeLine">  /// only the first Count elements of the vector are used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5212</td>
    <td class="codeLine">  /// only the first Count elements of the vector are used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5213</td>
    <td class="codeLine">  SDValue expandVecReduce(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5213</td>
    <td class="codeLine">  SDValue expandVecReduce(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5215</td>
    <td class="codeLine">  /// Expand a VECREDUCE_SEQ_* into an explicit ordered calculation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5215</td>
    <td class="codeLine">  /// Expand a VECREDUCE_SEQ_* into an explicit ordered calculation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5216</td>
    <td class="codeLine">  SDValue expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5216</td>
    <td class="codeLine">  SDValue expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5218</td>
    <td class="codeLine">  /// Expand an SREM or UREM using SDIV/UDIV or SDIVREM/UDIVREM, if legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5218</td>
    <td class="codeLine">  /// Expand an SREM or UREM using SDIV/UDIV or SDIVREM/UDIVREM, if legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5219</td>
    <td class="codeLine">  /// Returns true if the expansion was successful.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5219</td>
    <td class="codeLine">  /// Returns true if the expansion was successful.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5220</td>
    <td class="codeLine">  bool expandREM(SDNode *Node, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5220</td>
    <td class="codeLine">  bool expandREM(SDNode *Node, SDValue &Result, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5222</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::VECTOR_SPLICE. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5222</td>
    <td class="codeLine">  /// Method for building the DAG expansion of ISD::VECTOR_SPLICE. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5223</td>
    <td class="codeLine">  /// method accepts vectors as its arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5223</td>
    <td class="codeLine">  /// method accepts vectors as its arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5224</td>
    <td class="codeLine">  SDValue expandVectorSplice(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5224</td>
    <td class="codeLine">  SDValue expandVectorSplice(SDNode *Node, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5226</td>
    <td class="codeLine">  /// Legalize a SETCC or VP_SETCC with given LHS and RHS and condition code CC</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5226</td>
    <td class="codeLine">  /// Legalize a SETCC or VP_SETCC with given LHS and RHS and condition code CC</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5227</td>
    <td class="codeLine">  /// on the current target. A VP_SETCC will additionally be given a Mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5227</td>
    <td class="codeLine">  /// on the current target. A VP_SETCC will additionally be given a Mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5228</td>
    <td class="codeLine">  /// and/or EVL not equal to SDValue().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5228</td>
    <td class="codeLine">  /// and/or EVL not equal to SDValue().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5229</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5229</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5230</td>
    <td class="codeLine">  /// If the SETCC has been legalized using AND / OR, then the legalized node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5230</td>
    <td class="codeLine">  /// If the SETCC has been legalized using AND / OR, then the legalized node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5231</td>
    <td class="codeLine">  /// will be stored in LHS. RHS and CC will be set to SDValue(). NeedInvert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5231</td>
    <td class="codeLine">  /// will be stored in LHS. RHS and CC will be set to SDValue(). NeedInvert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5232</td>
    <td class="codeLine">  /// will be set to false. This will also hold if the VP_SETCC has been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5232</td>
    <td class="codeLine">  /// will be set to false. This will also hold if the VP_SETCC has been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5233</td>
    <td class="codeLine">  /// legalized using VP_AND / VP_OR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5233</td>
    <td class="codeLine">  /// legalized using VP_AND / VP_OR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5234</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5234</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5235</td>
    <td class="codeLine">  /// If the SETCC / VP_SETCC has been legalized by using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5235</td>
    <td class="codeLine">  /// If the SETCC / VP_SETCC has been legalized by using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5236</td>
    <td class="codeLine">  /// getSetCCSwappedOperands(), then the values of LHS and RHS will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5236</td>
    <td class="codeLine">  /// getSetCCSwappedOperands(), then the values of LHS and RHS will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5237</td>
    <td class="codeLine">  /// swapped, CC will be set to the new condition, and NeedInvert will be set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5237</td>
    <td class="codeLine">  /// swapped, CC will be set to the new condition, and NeedInvert will be set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5238</td>
    <td class="codeLine">  /// to false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5238</td>
    <td class="codeLine">  /// to false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5239</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5239</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5240</td>
    <td class="codeLine">  /// If the SETCC / VP_SETCC has been legalized using the inverse condcode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5240</td>
    <td class="codeLine">  /// If the SETCC / VP_SETCC has been legalized using the inverse condcode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5241</td>
    <td class="codeLine">  /// then LHS and RHS will be unchanged, CC will set to the inverted condcode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5241</td>
    <td class="codeLine">  /// then LHS and RHS will be unchanged, CC will set to the inverted condcode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5242</td>
    <td class="codeLine">  /// and NeedInvert will be set to true. The caller must invert the result of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5242</td>
    <td class="codeLine">  /// and NeedInvert will be set to true. The caller must invert the result of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5243</td>
    <td class="codeLine">  /// the SETCC with SelectionDAG::getLogicalNOT() or take equivalent action to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5243</td>
    <td class="codeLine">  /// the SETCC with SelectionDAG::getLogicalNOT() or take equivalent action to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5244</td>
    <td class="codeLine">  /// swap the effect of a true/false result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5244</td>
    <td class="codeLine">  /// swap the effect of a true/false result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5245</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5245</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5246</td>
    <td class="codeLine">  /// \returns true if the SETCC / VP_SETCC has been legalized, false if it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5246</td>
    <td class="codeLine">  /// \returns true if the SETCC / VP_SETCC has been legalized, false if it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5247</td>
    <td class="codeLine">  /// hasn't.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5247</td>
    <td class="codeLine">  /// hasn't.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5248</td>
    <td class="codeLine">  bool LegalizeSetCCCondCode(SelectionDAG &DAG, EVT VT, SDValue &LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5248</td>
    <td class="codeLine">  bool LegalizeSetCCCondCode(SelectionDAG &DAG, EVT VT, SDValue &LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5249</td>
    <td class="codeLine">                             SDValue &RHS, SDValue &CC, SDValue Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5249</td>
    <td class="codeLine">                             SDValue &RHS, SDValue &CC, SDValue Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5250</td>
    <td class="codeLine">                             SDValue EVL, bool &NeedInvert, const SDLoc &dl,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5250</td>
    <td class="codeLine">                             SDValue EVL, bool &NeedInvert, const SDLoc &dl,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5251</td>
    <td class="codeLine">                             SDValue &Chain, bool IsSignaling = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5251</td>
    <td class="codeLine">                             SDValue &Chain, bool IsSignaling = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5253</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5253</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5254</td>
    <td class="codeLine">  // Instruction Emitting Hooks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5254</td>
    <td class="codeLine">  // Instruction Emitting Hooks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5255</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5255</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5257</td>
    <td class="codeLine">  /// This method should be implemented by targets that mark instructions with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5257</td>
    <td class="codeLine">  /// This method should be implemented by targets that mark instructions with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5258</td>
    <td class="codeLine">  /// the 'usesCustomInserter' flag.  These instructions are special in various</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5258</td>
    <td class="codeLine">  /// the 'usesCustomInserter' flag.  These instructions are special in various</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5259</td>
    <td class="codeLine">  /// ways, which require special support to insert.  The specified MachineInstr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5259</td>
    <td class="codeLine">  /// ways, which require special support to insert.  The specified MachineInstr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5260</td>
    <td class="codeLine">  /// is created but not inserted into any basic blocks, and this method is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5260</td>
    <td class="codeLine">  /// is created but not inserted into any basic blocks, and this method is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5261</td>
    <td class="codeLine">  /// called to expand it into a sequence of instructions, potentially also</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5261</td>
    <td class="codeLine">  /// called to expand it into a sequence of instructions, potentially also</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5262</td>
    <td class="codeLine">  /// creating new basic blocks and control flow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5262</td>
    <td class="codeLine">  /// creating new basic blocks and control flow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5263</td>
    <td class="codeLine">  /// As long as the returned basic block is different (i.e., we created a new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5263</td>
    <td class="codeLine">  /// As long as the returned basic block is different (i.e., we created a new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5264</td>
    <td class="codeLine">  /// one), the custom inserter is free to modify the rest of \p MBB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5264</td>
    <td class="codeLine">  /// one), the custom inserter is free to modify the rest of \p MBB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5265</td>
    <td class="codeLine">  virtual MachineBasicBlock *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5265</td>
    <td class="codeLine">  virtual MachineBasicBlock *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5266</td>
    <td class="codeLine">  EmitInstrWithCustomInserter(MachineInstr &MI, MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5266</td>
    <td class="codeLine">  EmitInstrWithCustomInserter(MachineInstr &MI, MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5268</td>
    <td class="codeLine">  /// This method should be implemented by targets that mark instructions with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5268</td>
    <td class="codeLine">  /// This method should be implemented by targets that mark instructions with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5269</td>
    <td class="codeLine">  /// the 'hasPostISelHook' flag. These instructions must be adjusted after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5269</td>
    <td class="codeLine">  /// the 'hasPostISelHook' flag. These instructions must be adjusted after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5270</td>
    <td class="codeLine">  /// instruction selection by target hooks.  e.g. To fill in optional defs for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5270</td>
    <td class="codeLine">  /// instruction selection by target hooks.  e.g. To fill in optional defs for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5271</td>
    <td class="codeLine">  /// ARM 's' setting instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5271</td>
    <td class="codeLine">  /// ARM 's' setting instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5272</td>
    <td class="codeLine">  virtual void AdjustInstrPostInstrSelection(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5272</td>
    <td class="codeLine">  virtual void AdjustInstrPostInstrSelection(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5273</td>
    <td class="codeLine">                                             SDNode *Node) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5273</td>
    <td class="codeLine">                                             SDNode *Node) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5275</td>
    <td class="codeLine">  /// If this function returns true, SelectionDAGBuilder emits a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5275</td>
    <td class="codeLine">  /// If this function returns true, SelectionDAGBuilder emits a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5276</td>
    <td class="codeLine">  /// LOAD_STACK_GUARD node when it is lowering Intrinsic::stackprotector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5276</td>
    <td class="codeLine">  /// LOAD_STACK_GUARD node when it is lowering Intrinsic::stackprotector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5277</td>
    <td class="codeLine">  virtual bool useLoadStackGuardNode() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5277</td>
    <td class="codeLine">  virtual bool useLoadStackGuardNode() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5278</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5278</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5279</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5279</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5281</td>
    <td class="codeLine">  virtual SDValue emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5281</td>
    <td class="codeLine">  virtual SDValue emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5282</td>
    <td class="codeLine">                                      const SDLoc &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5282</td>
    <td class="codeLine">                                      const SDLoc &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5283</td>
    <td class="codeLine">    llvm_unreachable("not implemented for this target");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5283</td>
    <td class="codeLine">    llvm_unreachable("not implemented for this target");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5286</td>
    <td class="codeLine">  /// Lower TLS global address SDNode for target independent emulated TLS model.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5286</td>
    <td class="codeLine">  /// Lower TLS global address SDNode for target independent emulated TLS model.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5287</td>
    <td class="codeLine">  virtual SDValue LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5287</td>
    <td class="codeLine">  virtual SDValue LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5288</td>
    <td class="codeLine">                                          SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5288</td>
    <td class="codeLine">                                          SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5290</td>
    <td class="codeLine">  /// Expands target specific indirect branch for the case of JumpTable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5290</td>
    <td class="codeLine">  /// Expands target specific indirect branch for the case of JumpTable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5291</td>
    <td class="codeLine">  /// expanasion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5291</td>
    <td class="codeLine">  /// expanasion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5292</td>
    <td class="codeLine">  virtual SDValue expandIndirectJTBranch(const SDLoc& dl, SDValue Value, SDValue Addr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5292</td>
    <td class="codeLine">  virtual SDValue expandIndirectJTBranch(const SDLoc& dl, SDValue Value, SDValue Addr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5293</td>
    <td class="codeLine">                                         SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5293</td>
    <td class="codeLine">                                         SelectionDAG &DAG) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5294</td>
    <td class="codeLine">    return DAG.getNode(ISD::BRIND, dl, MVT::Other, Value, Addr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5294</td>
    <td class="codeLine">    return DAG.getNode(ISD::BRIND, dl, MVT::Other, Value, Addr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5295</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5295</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5297</td>
    <td class="codeLine">  // seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5297</td>
    <td class="codeLine">  // seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5298</td>
    <td class="codeLine">  // If we're comparing for equality to zero and isCtlzFast is true, expose the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5298</td>
    <td class="codeLine">  // If we're comparing for equality to zero and isCtlzFast is true, expose the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5299</td>
    <td class="codeLine">  // fact that this can be implemented as a ctlz/srl pair, so that the dag</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5299</td>
    <td class="codeLine">  // fact that this can be implemented as a ctlz/srl pair, so that the dag</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5300</td>
    <td class="codeLine">  // combiner can fold the new nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5300</td>
    <td class="codeLine">  // combiner can fold the new nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5301</td>
    <td class="codeLine">  SDValue lowerCmpEqZeroToCtlzSrl(SDValue Op, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5301</td>
    <td class="codeLine">  SDValue lowerCmpEqZeroToCtlzSrl(SDValue Op, SelectionDAG &DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5303</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5303</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5304</td>
    <td class="codeLine">  SDValue foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5304</td>
    <td class="codeLine">  SDValue foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5305</td>
    <td class="codeLine">                           const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5305</td>
    <td class="codeLine">                           const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5306</td>
    <td class="codeLine">  SDValue foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5306</td>
    <td class="codeLine">  SDValue foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5307</td>
    <td class="codeLine">                             const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5307</td>
    <td class="codeLine">                             const SDLoc &DL, DAGCombinerInfo &DCI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5309</td>
    <td class="codeLine">  SDValue optimizeSetCCOfSignedTruncationCheck(EVT SCCVT, SDValue N0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5309</td>
    <td class="codeLine">  SDValue optimizeSetCCOfSignedTruncationCheck(EVT SCCVT, SDValue N0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5310</td>
    <td class="codeLine">                                               SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5310</td>
    <td class="codeLine">                                               SDValue N1, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5311</td>
    <td class="codeLine">                                               DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5311</td>
    <td class="codeLine">                                               DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5312</td>
    <td class="codeLine">                                               const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5312</td>
    <td class="codeLine">                                               const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5314</td>
    <td class="codeLine">  // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5314</td>
    <td class="codeLine">  // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5315</td>
    <td class="codeLine">  SDValue optimizeSetCCByHoistingAndByConstFromLogicalShift(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5315</td>
    <td class="codeLine">  SDValue optimizeSetCCByHoistingAndByConstFromLogicalShift(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5316</td>
    <td class="codeLine">      EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5316</td>
    <td class="codeLine">      EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5317</td>
    <td class="codeLine">      DAGCombinerInfo &DCI, const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5317</td>
    <td class="codeLine">      DAGCombinerInfo &DCI, const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5319</td>
    <td class="codeLine">  SDValue prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5319</td>
    <td class="codeLine">  SDValue prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5320</td>
    <td class="codeLine">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5320</td>
    <td class="codeLine">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5321</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5321</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5322</td>
    <td class="codeLine">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5322</td>
    <td class="codeLine">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5323</td>
    <td class="codeLine">  SDValue buildUREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5323</td>
    <td class="codeLine">  SDValue buildUREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5324</td>
    <td class="codeLine">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5324</td>
    <td class="codeLine">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5325</td>
    <td class="codeLine">                          const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5325</td>
    <td class="codeLine">                          const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5327</td>
    <td class="codeLine">  SDValue prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5327</td>
    <td class="codeLine">  SDValue prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5328</td>
    <td class="codeLine">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5328</td>
    <td class="codeLine">                            SDValue CompTargetNode, ISD::CondCode Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5329</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5329</td>
    <td class="codeLine">                            DAGCombinerInfo &DCI, const SDLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5330</td>
    <td class="codeLine">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5330</td>
    <td class="codeLine">                            SmallVectorImpl<SDNode *> &Created) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5331</td>
    <td class="codeLine">  SDValue buildSREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5331</td>
    <td class="codeLine">  SDValue buildSREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5332</td>
    <td class="codeLine">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5332</td>
    <td class="codeLine">                          ISD::CondCode Cond, DAGCombinerInfo &DCI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5333</td>
    <td class="codeLine">                          const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5333</td>
    <td class="codeLine">                          const SDLoc &DL) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5334</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5334</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5336</td>
    <td class="codeLine">/// Given an LLVM IR type and return type attributes, compute the return value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5336</td>
    <td class="codeLine">/// Given an LLVM IR type and return type attributes, compute the return value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5337</td>
    <td class="codeLine">/// EVTs and flags, and optionally also the offsets, if the return value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5337</td>
    <td class="codeLine">/// EVTs and flags, and optionally also the offsets, if the return value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5338</td>
    <td class="codeLine">/// being lowered to memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5338</td>
    <td class="codeLine">/// being lowered to memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5339</td>
    <td class="codeLine">void GetReturnInfo(CallingConv::ID CC, Type *ReturnType, AttributeList attr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5339</td>
    <td class="codeLine">void GetReturnInfo(CallingConv::ID CC, Type *ReturnType, AttributeList attr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5340</td>
    <td class="codeLine">                   SmallVectorImpl<ISD::OutputArg> &Outs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5340</td>
    <td class="codeLine">                   SmallVectorImpl<ISD::OutputArg> &Outs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5341</td>
    <td class="codeLine">                   const TargetLowering &TLI, const DataLayout &DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5341</td>
    <td class="codeLine">                   const TargetLowering &TLI, const DataLayout &DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5343</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5343</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5345</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5345</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_TARGETLOWERING_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>